<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术空间</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2025-08-09T13:15:32.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Youtube 视频下载工具使用</title>
    <link href="https://www.techgrow.cn/posts/3f99e39.html"/>
    <id>https://www.techgrow.cn/posts/3f99e39.html</id>
    <published>2025-08-09T13:16:21.000Z</published>
    <updated>2025-08-09T13:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li><a href="https://github.com/yt-dlp/yt-dlp">yt-dlp</a></li><li><a href="https://github.com/ytdl-org/youtube-dl">youtube-dl</a></li></ul><span id="more"></span><h2 id="yt-dlp"><a href="#yt-dlp" class="headerlink" title="yt-dlp"></a>yt-dlp</h2><p><a href="https://github.com/yt-dlp/yt-dlp">yt-dlp</a> 是一个功能丰富的命令行音频 / 视频下载器，支持数千个站点，支持断点续传和网络代理。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ul><li>Pip 安装（依赖 Python）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Linux</span> / Mac</span><br><span class="line">pip install<span class="params"> -U</span> yt-dlp</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 安装（二进制方式）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Linux</span> (可直接下载可执行文件)</span><br><span class="line"><span class="keyword"># https</span>://github.com/yt-dlp/yt-dlp/releases</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">wget<span class="params"> -O</span> yt-dlp https://github.com/yt-dlp/yt-dlp/releases/download/2025.07.21/yt-dlp_linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line">sudo mv yt-dlp /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件授权</span></span><br><span class="line">sudo chmod +x /usr/bin/yt-dlp</span><br></pre></td></tr></tbody></table></figure><ul><li>Windows 安装（二进制方式）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Windows</span> (可直接下载 Exe 可执行文件)</span><br><span class="line"><span class="keyword"># https</span>://github.com/yt-dlp/yt-dlp/releases</span><br></pre></td></tr></tbody></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>下载命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span> <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理 + 多线程加速）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> -N</span> 4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理 + 多线程加速 + 安全文件名）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> --restrict</span>-filenames<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> -N</span> 4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>参数说明</li></ul><table><thead><tr><th>参数</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td><code>-N</code></td><td>指定线程数量</td><td>使用多个线程进行下载，可以加快下载速度</td></tr><tr><td><code>-c</code></td><td>支持断点续传</td><td>从已下载部分直接接着下载，不会重头开始下载</td></tr><tr><td><code>--restrict-filenames</code></td><td>使用安全文件名</td><td>文件名最终会变成类似 <code>2_HOUR_STUDY_WITH_ME.mp4</code></td></tr><tr><td><code>--proxy "http://127.0.0.1:7890"</code></td><td>指定代理</td><td>支持 <code>http://</code>、<code>https://</code>、<code>socks5://</code> 等代理格式</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>YouTube 视频通常分成音频 + 视频两个流下载，<code>yt-dlp</code> 会自动合并处理。</li><li>如果是长视频，建议 <code>yt-dlp</code> 配合 <code>-c</code> 断点续传和 <code>-N</code> 多线程加速，这样即使下载中途断了，也能很快恢复。</li><li><code>-N</code> 参数对大部分 HTTP 分片流（DASH、HLS）有效，对单个 MP4 文件直链无效。有些代理或网络环境下，如果线程数太高，可能触发 YouTube 限制。</li></ul></div><h3 id="使用问题"><a href="#使用问题" class="headerlink" title="使用问题"></a>使用问题</h3><h4 id="缺少-Cookie-信息"><a href="#缺少-Cookie-信息" class="headerlink" title="缺少 Cookie 信息"></a>缺少 Cookie 信息</h4><blockquote><p>问题描述：下载 YouTube 视频时，触发了人机验证 / 登录验证（如下所示），<code>yt-dlp</code> 没法直接绕过，所以它提示要用浏览器 Cookie 来模拟已登录的状态。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: [youtube] 5Q2Pc-e-8Qc: Sign in to confirm you’re not a bot. Use --cookies-from-browser or --cookies for the authentication. See  https://github.com/yt-dlp/yt-dlp/wiki/FAQ#how-do-i-pass-cookies-to-yt-dlp  for how to manually pass cookies. Also see  https://github.com/yt-dlp/yt-dlp/wiki/Extractors#exporting-youtube-cookies  for tips on effectively exporting YouTube cookies</span><br></pre></td></tr></tbody></table></figure><blockquote><p>解决方法一：使用浏览器插件</p></blockquote><ul><li><p>(1) 安装浏览器插件</p><ul><li>推荐用 <code>Get cookies.txt</code>（Chrome）或 Firefox 的同类扩展插件。</li></ul></li><li><p>(2) 导出 Cookie 文件</p><ul><li>浏览器打开 <code>https://www.youtube.com</code></li><li>确保已经登录 Youtube</li><li> 点击扩展插件 → 导出 Cookies → 保存成 <code>cookies.txt</code> 文件</li></ul></li><li><p> (3) 让 <code>yt-dlp</code> 用 Cookie 文件下载</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> --cookies</span> cookies.txt <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>解决方法二：从浏览器自动读取 Cookie</p></blockquote><ul><li><p>(1) <code>yt-dlp</code> 支持直接读取浏览器的 Cookie（需要本地环境支持）</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> --cookies</span>-from-browser chrome<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span> <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>(2) 参数说明</p><ul><li><code>--cookies-from-browser chrome</code> 表示从 Chrome 读取 Cookie，也支持用 <code>firefox</code>、<code>edge</code> 等。</li><li>要求本地浏览器已经登录了 YouTube，并且浏览器没有关掉 Cookie 保存功能。</li></ul></li></ul><h4 id="音频和视频合并失败"><a href="#音频和视频合并失败" class="headerlink" title="音频和视频合并失败"></a>音频和视频合并失败</h4><p>YouTube 视频通常分成音频 + 视频两个流下载，<code>yt-dlp</code> 会在两者下载完成后自动合并处理。但是，如果 <code>.webm</code> 音频是 Opus 编码，直接合并进 <code>.mp4</code> 会报错，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading webpage</span><br><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading tv client config</span><br><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading tv player API JSON</span><br><span class="line">[info] 5Q2Pc-e-8Qc: Downloading 1 format(s): 401+251</span><br><span class="line">[download] 2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].f401.mp4 has already been downloaded</span><br><span class="line">[download] 100% of    3.27GiB</span><br><span class="line">[download] 2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].f251.webm has already been downloaded</span><br><span class="line">[download] 100% of  111.71MiB</span><br><span class="line">[Merger] Merging formats into "2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].webm"</span><br><span class="line">ERROR: Postprocessing: Conversion failed!  </span><br></pre></td></tr></tbody></table></figure><p>这种情况需要使用 Ffmpeg 先将音频转成 AAC 编码，然后再进行合并（前提是 <code>yt-dlp</code> 已经将 <code>.webm</code> 和 <code>.mp4</code> 文件都完整地下载到本地）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg<span class="params"> -i</span> video.mp4<span class="params"> -i</span> audio.webm<span class="params"> -c</span>:v copy<span class="params"> -c</span>:a aac<span class="params"> -b</span>:a 192k output.mp4</span><br></pre></td></tr></tbody></table></figure><h4 id="下载时直接合并音频和视频"><a href="#下载时直接合并音频和视频" class="headerlink" title="下载时直接合并音频和视频"></a>下载时直接合并音频和视频</h4><p>YouTube 视频通常分成音频 + 视频两个流下载，若希望 <code>yt-dlp</code> 在下载两者的时候直接合并，可以参考以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> <span class="string">"bv*+ba"</span><span class="params"> --merge</span>-output-format mp4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数 <code>-f "bv*+ba"</code> 是 <code>yt-dlp</code> 里的格式选择表达式，意思是：</p><ul><li><code>bv*</code> = best video stream（最好画质的视频流），<code>*</code> 表示不限编码类型（AV1、VP9、H.264 都可以）</li><li><code>ba</code> = best audio stream（最好音质的音频流）</li><li><code>+</code> = 选择视频流和音频流，并在下载后合并成一个文件</li></ul><h4 id="下载时指定视频编码为-H-264"><a href="#下载时指定视频编码为-H-264" class="headerlink" title="下载时指定视频编码为 H.264"></a>下载时指定视频编码为 H.264</h4><p>若希望指定 <code>yt-dlp</code> 下载视频的编码格式为 H.264（在 YouTube 格式代码中，H.264 编码视频通常带有 <code>avc1</code> 标签），可以参考以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> <span class="string">"bv[codec^=avc1]+ba"</span><span class="params"> --merge</span>-output-format mp4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><code>-f "bv[codec^=avc1]+ba"</code><ul><li><code>bv</code> = best video stream（最好画质的视频流）</li><li><code>[codec^=avc1]</code> = <code>codec</code> 字段以 <code>avc1</code> 开头（H.264 的标识）</li><li><code>ba</code> = best audio stream（最好音质的音频流）</li><li><code>+</code> = 选择视频流和音频流，并在下载后合并成一个文件</li></ul></li><li><code>--merge-output-format mp4</code><ul><li>限制输出容器是 MP4（和 H.264 配合更好）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Youtube 视频下载工具的使用。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Redis 哨兵机制详解</title>
    <link href="https://www.techgrow.cn/posts/660eca58.html"/>
    <id>https://www.techgrow.cn/posts/660eca58.html</id>
    <published>2025-07-27T13:15:32.000Z</published>
    <updated>2025-07-27T13:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="哨兵机制的概念"><a href="#哨兵机制的概念" class="headerlink" title="哨兵机制的概念"></a>哨兵机制的概念</h2><p>Redis 有三种模式：分别是主从复制、哨兵模式、集群模式，后两者可以保证高可用。</p><ul><li><strong>哨兵（Sentinel）机制是什么</strong><ul><li>哨兵机制主要用于 Redis 主从架构下的故障检测与自动主从切换。</li><li>哨兵一个专门用于高可用的 Redis 组件（节点），不是用于存储数据的。</li><li>哨兵不参与数据同步和读写，而是专门负责监控、故障切换和通知客户端谁是主节点。</li><li>哨兵进程通常和 Redis 节点分开部署（也可以部署在同一台机器上，但进程独立）。</li><li>通常运行多个哨兵实例（即哨兵集群），实现冗余和仲裁。每个哨兵都会连接至 Master 节点和所有 Slave 节点，监控它们的状态信息。</li></ul></li></ul><span id="more"></span><ul><li><p><strong>哨兵（Sentinel）节点的作用是什么</strong></p><ul><li>监控（Monitor）：持续检查主节点和从节点是否存活（通过 PING 等）。</li><li>通知（Notification）：检测到故障后通知系统管理员或其他服务。</li><li>自动故障转移（Failover）：如果主节点不可用，选举一个从节点提升为新主节点。</li><li>服务发现（Discovery）：提供主节点的地址信息给客户端（可供自动重连）；如果发生了故障转移，会通知客户端新的主节点地址。</li></ul></li><li><p><strong>哨兵（Sentinel）节点不是从节点（Slave）</strong></p><ul><li>哨兵节点不负责同步数据，也不参与数据读写。</li><li>它只是通过 Redis 协议连接 Redis 实例，执行命令如 INFO、PING 来感知状态。</li><li>哨兵节点不保存业务数据，最多保存一些监控状态（内存中）。</li></ul></li><li><p><strong>为什么需要哨兵（Sentinel）机制</strong></p><ul><li>Redis 的主从复制机制主要用于实现数据备份和读请求的负载分担，但它本身并不具备自动容错和主节点自动切换的能力。因此，单纯依赖主从复制并不能保证系统的高可用性。具体表现如下：<ul><li>需要人工介入：当主节点发生故障时，Redis 本身无法自动完成故障切换，需要运维人员手动将某个从节点提升为新的主节点，并重新配置其他从节点同步新的主节点。</li><li>单点故障风险：主节点作为写操作的唯一入口，一旦宕机，系统的写操作将完全中断，严重影响服务可用性。</li><li>主节点写入能力受限：Redis 是单线程模型，主节点的写入吞吐受限于单机性能，无法横向扩展。</li><li>单机节点存储容量有限：Redis 通常运行在内存中，主节点的物理内存限制了存储能力。</li></ul></li><li>Redis 哨兵机制应运而生，用于增强 Redis 在主从架构下的高可用性。它具备以下能力：<ul><li>哨兵节点自动监控 Redis 实例状态（包括主节点和从节点）。</li><li>主节点宕机时，自动完成主从切换（Failover）。</li><li>通知支持 Sentinel 机制的客户端连接新的主节点。</li><li>协助管理 Redis 主从结构并确保一致性。</li></ul></li><li>若需要进一步提高 Redis 的可用性与扩展性，还可以使用 Redis Cluster（集群），它支持数据分片（水平扩展），具备原生的多主多从架构、高可用、以及容错能力。</li></ul></li></ul><h2 id="哨兵机制的原理"><a href="#哨兵机制的原理" class="headerlink" title="哨兵机制的原理"></a>哨兵机制的原理</h2><p>Redis 哨兵机制是通过在独立的哨兵节点上运行特定的哨兵进程来实现的。这些哨兵进程监控主从节点的状态，并在出现故障时自动完成故障转移，并通知应用方，实现高可用性。</p><ul><li><p><strong>(1) 哨兵选举：</strong></p><ul><li>在启动时，每个哨兵节点都会参与选举，其中一个哨兵节点会被选为领导者（Leader），负责协调其他哨兵节点执行故障转移。选举过程如下：<ul><li>每个在线的哨兵节点都有资格成为领导者。当某个哨兵判断主节点不可用后，会向其他哨兵节点发送 <code>is-master-down-by-addr</code> 命令，请求判断主节点状态并征求选票，希望被选为本轮的领导者。</li><li>其他哨兵节点在收到该命令后，会根据自身判断和是否已经投票的情况，决定是否同意对方成为领导者（每个哨兵在同一轮选举中只能投票一次）。</li><li>如果某个哨兵节点获得的选票数达到或超过 <code>总哨兵节点数 / 2 + 1</code>（即超过半数），则该哨兵节点将成为本轮选举的领导者；如果未能获得足够票数，则会进入下一轮选举，直到选出领导者为止。</li></ul></li></ul></li><li><p><strong>(2) 哨兵监控主从节点:</strong></p><ul><li>哨兵节点通过发送命令周期性地检查主从节点的健康状态，包括主节点是否在线、从节点是否同步等。</li><li>如果哨兵节点发现主节点不可用，它会触发一次故障转移操作，而且是由哨兵领导者负责处理主节点的故障转移。</li></ul></li><li><p><strong>(3) 哨兵执行故障转移：</strong></p><ul><li>一旦主节点被判定为不可用，哨兵节点会执行故障转移操作。它会从当前的从节点中选出一个新的主节点，并将其他从节点切换到新的主节点。这样，缓存系统可以继续提供服务，而无需人工介入。</li><li>故障转移过程：<ul><li>由哨兵节点定期监控主节点是否出现故障，哨兵节点会定期向主节点发送心跳 PING 来确认主节点是否存活。</li><li>如果主节点在 “一定时间范围” 内不响应 PONG 或者是回复了一个错误消息，那么这个哨兵节点会主观地（单方面地）认为这个主节点已经不可用了。</li></ul></li><li>确认新主节点：<ul><li>过滤掉不健康的从节点（如已下线、网络断连、长时间未响应哨兵 PING 命令的节点）。</li><li>在剩余的健康从节点中，优先选择优先级（Priority）最高的节点。</li><li>如果有多个从节点优先级相同，则选择复制偏移量（Replication Offset）最大的节点，即数据最接近原主节点的从节点。</li><li>若优先级和复制偏移量都相等，则选择节点 ID 字典序最小的节点作为新主节点。</li></ul></li></ul></li><li><p><strong>(4) 客户端重定向：</strong></p><ul><li>当主节点出现故障时，哨兵节点会自动发起主从切换（故障转移），选举一个新的从节点作为新的主节点。</li><li>哨兵节点不会直接通知客户端新的主节点地址，而是提供一个服务发现机制。客户端需要通过支持哨兵机制的客户端，从哨兵节点动态获取当前的主节点地址。</li><li>这样一来，客户端可以在主节点切换后，通过哨兵节点重新获取主节点信息，从而无感知地完成主节点重连，保证业务连续性。</li><li>此外，哨兵节点还会持续监控所有主节点和所有从节点的运行状态，如果某个从节点出现故障，哨兵节点会将其标记为下线；一旦从节点恢复，哨兵节点会自动将其重新加入主从复制架构，并使其同步当前主节点的数据，以维持整个架构的完整性。</li></ul></li></ul><h2 id="哨兵的部署架构"><a href="#哨兵的部署架构" class="headerlink" title="哨兵的部署架构"></a>哨兵的部署架构</h2><p>Redis Sentinel（哨兵）本身是一个分布式系统，通常以哨兵集群的形式部署，多个哨兵节点之间可以协同工作，保障系统的高可用性（如下图所示）。</p><p><img data-src="../../../asset/2025/07/redis-sentinel-3.png"></p><ul><li><strong>哨兵（Sentinel）故障转移的核心概念</strong></li></ul><table><thead><tr><th>概念</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td><code>quorum</code>（法定票数）</td><td>Master 节点从主观下线（sdown）到客观下线（odown）所需的同意哨兵数（即最少 N 个哨兵同时判断 Master 为宕机）</td><td>确保哨兵对 Master 宕机的判断具有一定共识，避免误判</td></tr><tr><td><code>majority</code>（多数哨兵）</td><td>执行故障转移操作时，要求同意执行故障转移的哨兵数量必须达到总数的一半以上，否则不会执行故障转移</td><td>为了避免「脑裂」现象，即多个哨兵在不同网络分区中同时尝试进行故障转移，导致系统不一致或混乱</td></tr></tbody></table><ul><li><p><strong>哨兵（Sentinel）的部署架构是什么</strong></p><ul><li>Redis Sentinel（哨兵）本身是一个分布式系统，通常以哨兵集群的形式部署，多个哨兵节点之间可以协同工作，保障系统的高可用性。<ul><li>哨兵通常以集群的形式部署，这样是为了保证哨兵的高可用性<ul><li><strong>哨兵集群要求至少需要部署 3 个哨兵实例，否则可能无法保证故障转移的正常执行，同时也为了实现多数投票机制，并提高容错能力。</strong></li><li><strong>哨兵集群 + Redis 主从架构能够提供高可用性，但无法做到数据零丢失。故障转移过程中可能存在数据未完整同步到从节点的风险，因此仅适用于对可用性要求高、但允许少量数据丢失的场景。</strong></li><li>由于哨兵 + Redis 主从是一种相对复杂的部署架构，建议在测试环境和生产环境中都进行充分的测试与故障演练，确保系统在各种异常情况下都能稳定运行。</li></ul></li><li>在发生故障转移时，是否将一个主节点判定为宕机，必须经过多数哨兵节点（Quorum）的同意。这涉及到分布式选举机制，用于确保故障转移的判断和执行具备一致性和可靠性。</li><li>即使部分哨兵节点发生故障，哨兵集群仍然能够正常工作。这是因为哨兵本身作为高可用机制的一部分，必须具备容错能力，若其自身是单点的，那就违背了其设计初衷。</li><li>目前使用的是 Sentinel <code>2.x 版本</code>。与 Sentinel <code>1.x</code> 相比，Sentinel <code>2.x</code> 重写了大量核心代码，主要目的是简化故障转移流程、提升算法健壮性和系统稳定性，使其更适用于生产环境中的高可用场景。</li></ul></li></ul></li><li><p><strong>为什么 Redis 哨兵集群只有 2 个节点会无法正常工作</strong></p><ul><li>以部署了 2 个哨兵实例的场景为例（配置：<code>quorum = 1</code>）：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></tbody></table></figure></li><li>当主节点 M1 宕机时，只要 S1 和 S2 中任意一个哨兵认为 M1 宕机，就可以发起主观下线（Subjective Down，简称 sdown）判断。接着，两个哨兵会通过选举机制，选举出其中一个哨兵来执行故障转移操作。</li><li>但是，哨兵系统执行真正的故障转移时，还需要满足 <code>majority</code> 要求，也就是多数哨兵节点同意执行故障转移。例如：<ul><li>2 个哨兵时，要求 <code>majority = 2</code></li><li>3 个哨兵时，要求 <code>majority = 2</code></li><li>4 个哨兵时，要求 <code>majority = 3</code></li><li>5 个哨兵时，要求 <code>majority = 3</code></li></ul></li><li>因此在 2 个哨兵节点的场景中，只有当两个哨兵都正常运行时，才满足 <code>majority</code> 的要求，才允许执行故障转移操作。</li><li>如果运行主节点 M1 和哨兵 S1 的那台机器宕机了，意味着主节点 M1 和哨兵 S1 同时失效，只剩下从节点 R1 和哨兵 S2 仍在运行。此时虽然还有一个哨兵存在（S2），但由于无法满足 <code>majority</code> 要求，故障转移将不会被执行，导致缓存系统始终处于不可用状态。</li></ul></li><li><p><strong>Redis 经典的 3 节点哨兵集群架构</strong></p><ul><li>以部署了 3 个哨兵实例的场景为例（配置：<code>quorum = 2</code>）：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       +----+</span><br><span class="line">       | M1 |</span><br><span class="line">       | S1 |</span><br><span class="line">       +----+</span><br><span class="line">          |</span><br><span class="line">+----+    |    +----+</span><br><span class="line">| R2 |----+----| R3 |</span><br><span class="line">| S2 |         | S3 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></tbody></table></figure></li><li>如果主节点 M1 所在的机器宕机，意味着主节点 M1 和哨兵 S1 同时失效，剩下的两个哨兵 S2 和 S3 仍在运行。此时：<ul><li>哨兵 S2 和 S3 可以一致地判断主节点 M1 宕机了（满足 <code>quorum = 2</code>），从而形成客观下线（odown）判断；</li><li>接着，S2 和 S3 两个哨兵会通过选举机制，选举出其中一个哨兵负责执行故障转移操作；</li><li>因为 3 个哨兵的 <code>majority</code> 要求为 2，而当前恰好有 2 个哨兵仍然存活，所以满足故障转移所需的条件。</li></ul></li><li>因此，在这种经典的 3 节点哨兵集群架构下，即使一台机器宕机，只要剩余的 2 个哨兵还在正常运行，依然可以完成故障转移，从而保证整个哨兵集群的高可用性。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>无论 Redis 是一主一从、一主多从的复制架构，都可以使用 Redis 的哨兵机制，官方更推荐使用一主多从的复制架构，这样可用性更高。</li></ul></div><h2 id="哨兵机制的使用"><a href="#哨兵机制的使用" class="headerlink" title="哨兵机制的使用"></a>哨兵机制的使用</h2><p>在 SpringBoot 项目中，使用 Lettuce 客户端连接 Redis 的一主多从 + 哨兵模式时，只需要在 <code>application.yml</code> 正确配置哨兵信息，SpringBoot 就会自动识别并创建 Lettuce 连接。</p><ul><li>SpringBoot 配置文件示例（<code>application.yml</code>）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span>             <span class="comment"># 主节点名称，对应哨兵配置中的 sentinel monitor 的名称</span></span><br><span class="line">      <span class="attr">nodes:</span>                       <span class="comment"># 哨兵节点列表（ip:port）</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourRedisPassword</span>    <span class="comment"># Redis 认证密码（如果开启了）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><ul><li>若希望使用从节点读取数据（主节点默认可以读写，但从节点只读不可写），可以使用以下 SpringBoot 配置信息 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span>             <span class="comment"># 主节点名称，对应哨兵配置中的 sentinel monitor 的名称</span></span><br><span class="line">      <span class="attr">nodes:</span>                       <span class="comment"># 哨兵节点列表（ip:port）</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourRedisPassword</span>    <span class="comment"># Redis 认证密码（如果开启了）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">read-from:</span> <span class="string">REPLICA_PREFERRED</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>Lettuce 的配置值</th><th>含义</th></tr></thead><tbody><tr><td><code>MASTER</code></td><td>所有请求都从主节点读取（默认）</td></tr><tr><td><code>MASTER_PREFERRED</code></td><td>优先主节点，主节点不可用时才从从节点读取</td></tr><tr><td><code>REPLICA</code>（或 <code>SLAVE</code>）</td><td>所有请求都从从节点读取</td></tr><tr><td><code>REPLICA_PREFERRED</code></td><td>优先从从节点读取，从节点不可用时回退到主节点</td></tr><tr><td><code>NEAREST</code></td><td>从网络延迟最小的节点读取（需要集群拓扑支持）</td></tr></tbody></table><ul><li>Redis 哨兵配置文件示例（<code>redis-sentinel.conf</code>）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控名为 mymaster 的主节点，IP 是 192.168.1.100，端口 6379，</span></span><br><span class="line"><span class="comment"># 至少有 2 个哨兵同时判断该主节点不可达时，才会被判定为主观下线（sdown）</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span> <span class="number">6379 </span><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 5000 毫秒（5 秒）内没有收到主节点的响应，哨兵就认为主节点已主观下线</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个故障转移（Failover）过程的超时时间：10 秒</span></span><br><span class="line"><span class="comment"># 包括选举新主节点、通知其他从节点进行复制、通知客户端更新配置等</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移时，最多同时有 1 个从节点并行地从新的主节点复制数据（同步）</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><ul><li>引入 Lettuce 依赖，使用 Lettuce 的默认连接工厂 </li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot 默认使用 Lettuce 作为 Redis 客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Redis 连接验证代码 </li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"testKey"</span>, <span class="string">"hello from sentinel"</span>);</span><br><span class="line">    String value = stringRedisTemplate.opsForValue().get(<span class="string">"testKey"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Redis 返回: "</span> + value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>SpringBoot 配置（<code>application.yml</code>）的注意事项<ul><li>主从节点的 IP 和端口不需要配置，哨兵模式下 Lettuce 客户端能自动发现主从拓扑结构。</li><li><code>mymaster</code> 一定要和哨兵配置文件（<code>redis-sentinel.conf</code>）里设置的一致。</li><li>Lettuce 默认支持哨兵模式，一般不需要额外配置；但是，如果哨兵模式使用 SSL，则需要显式配置连接工厂。</li><li>SpringBoot 的默认连接池支持读写分离，只需要配置 Lettuce 的 <code>read-from</code> 属性即可生效。</li><li>在 Redis 的主从复制或者集群架构中，主节点可以读写，但从节点默认是只读的，即可以响应读请求（如 <code>GET</code>、<code>MGET</code> 等），但不能写入数据。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>无论 Redis 是一主一从、一主多从还是集群架构，Redis 的主节点都可以读写，从节点默认是可以读（只读，不能写入）；但如果想实现真正的读写分离或者读负载均衡，还需要在客户端进行配置或开发支持（比如 Jedis、Lettuce 都支持手动配置是否访问从节点），因为 Redis 本身不会自动将读请求发送给从节点。由于 Redis 的主从同步可能存在延迟，如果业务对读取一致性要求较高（如读取后马上更新），那么就不要使用从节点读取数据。</p></div><h2 id="哨兵机制的问题"><a href="#哨兵机制的问题" class="headerlink" title="哨兵机制的问题"></a>哨兵机制的问题</h2><h3 id="如何避免脑裂现象"><a href="#如何避免脑裂现象" class="headerlink" title="如何避免脑裂现象"></a>如何避免脑裂现象</h3><ul><li><p><strong>Redis 哨兵集群的脑裂现象是指什么</strong></p><ul><li>指在出现网络分区或者部分哨兵节点失联的情况下，多个哨兵节点在没有达到 <code>majority</code>（多数哨兵）共识的前提下，分别认为 Master 节点宕机并发起故障转移，导致出现两个或多个 Master 节点，从而造成数据不一致或系统混乱。</li><li>值得一提的是，除了主从同步延迟外，脑裂现象也会导致 Redis 集群丢失部分缓存数据。</li></ul></li><li><p><strong>Redis 哨兵集群如何避免脑裂现象</strong></p><ul><li>设置合适的 <code>quorum</code>（法定票数），即某个哨兵要认为主节点下线，必须要有至少 <code>quorum</code> 个哨兵达成共识。</li><li>真正的故障转移必须经过 <code>majority</code> 个哨兵（多数哨兵）投票通过，避免少数哨兵单方面误判。</li><li>因此，只要哨兵总数为奇数（如 3 个或 5 个），且大多数哨兵能互通，就不会发生脑裂现象。<ul><li>举个例子，假设集群中有 3 个哨兵，并配置 <code>quorum = 2</code>，那么：<ul><li>只有至少 2 个哨兵都判断主节点不可用，才会触发故障转移；</li><li>此时，还需要过半（即至少 2 个）的哨兵同意发起故障转移，才能选出新的主节点；</li><li>如果由于网络问题分区成 <code>1 + 2</code> 的两组哨兵，单独的哨兵将无法满足 <code>quorum</code> 和 <code>majority</code> 条件，这样就不会误判，从而避免脑裂。</li></ul></li></ul></li></ul></li></ul><table><thead><tr><th>概念</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td><code>quorum</code>（法定票数）</td><td>Master 节点从主观下线（SDOWN）到客观下线（ODOWN）所需的同意哨兵数（即最少 N 个哨兵同时判断 Master 为宕机）</td><td>确保哨兵对 Master 宕机的判断具有一定共识，避免误判</td></tr><tr><td><code>majority</code>（多数哨兵）</td><td>执行故障转移操作时，要求同意执行故障转移的哨兵数量必须达到总数的一半以上，否则不会执行故障转移</td><td>为了避免「脑裂」现象，即多个哨兵在不同网络分区中同时尝试进行故障转移，导致系统不一致或混乱</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">网络分区是指什么</p><p>网络分区（Network Partition）是指由于网络故障，集群中的一部分节点之间无法正常通信，被分隔成了两个或多个 "孤岛"，每个孤岛只能看到自身可达的节点，看不到其他节点。在 Redis 的哨兵集群架构中，网络分区通常指的是：部分哨兵与主节点失去连接、部分哨兵之间失去通信、主从节点之间断联。这些都可能导致：误判主节点下线、多个哨兵同时发起故障转移、出现多个主节点（脑裂）。</p></div><h3 id="如何避免数据丢失"><a href="#如何避免数据丢失" class="headerlink" title="如何避免数据丢失"></a>如何避免数据丢失</h3><p>Redis 的哨兵机制主要用于主从架构下的故障检测与自动主备切换，但在某些特殊场景下，哨兵机制可能会导致数据丢失，主要包括以下两种情况：</p><ul><li><p><strong>(1) 异步复制导致的数据丢失</strong></p><ul><li>Redis 主从节点之间的数据同步是异步复制，这意味着主节点写入的数据不会立即同步到从节点。<ul><li>当主节点（Master）宕机时，可能仍有部分数据尚未同步写入到从节点（Slave）。</li><li>此时，如果哨兵进行故障转移，从节点被提升为新的主节点，那么这些未同步的数据将永久丢失。</li></ul></li><li>这种情况的本质是主从延迟造成的数据不一致，属于设计上的权衡（异步复制换取更高性能和低延迟）。</li></ul></li><li><p><strong>(2) 脑裂（Split-Brain）导致的数据丢失</strong></p><ul><li>脑裂指的是：主节点与其他哨兵和从节点之间发生网络分区，导致其在局部网络中 “孤岛运行”，而在整体视角下却被认为已宕机。<ul><li>在发生网络分区期间，哨兵可能判定主节点不可用（ODOWN - 客观不可用），并发起故障转移，将某个从节点提升为新的主节点。</li><li>但由于旧主节点实际上仍在运行，客户端可能仍将数据写入旧主节点，形成了两个 “主节点”（双主）。</li><li>当网络恢复时，旧主节点会被哨兵强制转为从节点，并从新主节点复制数据，这会导致旧主节点上的数据被清空。</li></ul></li><li>因此，在发生网络分区的这段时间内，写入旧主节点的数据会丢失，因为它从未被同步到新主节点上，并且在旧主节点恢复后被覆盖掉。</li></ul></li></ul><hr><p>Redis 提供以下两个配置项用于控制写请求行为，从而减少异步复制和脑裂导致的数据丢失。</p><ul><li><code>min-slaves-to-write 1</code>：要求至少有 1 个从节点处于正常连接状态，主节点才允许写入数据。</li><li><code>min-slaves-max-lag 10</code>：要求从节点的复制延迟（ACK 返回的时间）不能超过 10 秒，主节点才允许写入数据。</li></ul><p>当主节点检测到可以正常连接的从节点数量不足，或者所有从节点的复制延迟都超过 10 秒，那么主节点将拒绝客户端的写请求。</p><ul><li><p><strong>(1) 减少异步复制导致的数据丢失</strong></p><ul><li>Redis 的主从复制是异步的。如果主节点宕机，而有些数据尚未同步到从节点，那么这些数据将永久丢失。</li><li>通过设置 <code>min-slaves-max-lag</code>，主节点可以感知从节点复制数据的延迟。如果从节点响应太慢（比如都超过了 10 秒），主节点会拒绝客户端的写入请求，防止继续写入大量数据而无法同步，从而将主节点宕机时可能丢失的数据限制在一个可控的范围（如 10 秒）内。</li></ul></li><li><p><strong>(2) 减少脑裂导致的数据丢失</strong></p><ul><li>在出现脑裂的情况下，客户端可能仍向旧主节点写入数据，形成两个主节点（双主），导致数据不一致和丢失。</li><li>通过 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 这两个配置项，可以防止脑裂主节点继续接受写请求：<ul><li>如果旧主节点失去了所有从节点的连接；</li><li>且在 <code>min-slaves-max-lag</code> 时间（如 10 秒）内未收到任何从节点的 ACK 消息；</li><li>那么主节点将自动停止接受写请求。</li></ul></li><li>这样，即使发生脑裂，旧主节点也会在 10 秒内拒绝写入数据，最多只会丢失 10 秒的数据，大大降低了数据丢失的风险。</li></ul></li></ul><p>当 Redis 主节点拒绝写请求时，客户端可以采取如下策略进行容灾处理：</p><ul><li><strong>(1) 客户限流处理</strong><ul><li>对接口请求进行限流处理，减慢请求涌入的速度，防止请求堆积或爆发式增长。</li></ul></li><li><strong>(2) 异步重试机制</strong><ul><li>将待写入的数据缓存在本地磁盘或者 Kafka 消息队列中。</li><li>客户端定时从本地磁盘或者 Kafka 队列中获取数据（例如每隔 10 分钟），然后尝试将数据重新写回 Redis 主节点。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Redis 的哨兵机制，包括 SpringBoot 项目使用哨兵机制。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="缓存" scheme="https://www.techgrow.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Higress 入门教程 - 基础篇（2025 年）</title>
    <link href="https://www.techgrow.cn/posts/63cc9919.html"/>
    <id>https://www.techgrow.cn/posts/63cc9919.html</id>
    <published>2025-07-22T13:12:19.000Z</published>
    <updated>2025-07-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Higress 是基于阿里内部的 Envoy Gateway 实践沉淀、以开源 Istio + Envoy 为核心构建的下一代云原生网关，实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力，深度集成 Dubbo、Nacos、Sentinel 等微服务技术栈，能够帮助用户极大的降低网关的部署及运维成本。在标准上全面支持 Ingress 与 Gateway API，积极拥抱云原生下的标准 API 规范；同时，Higress Controller 也支持 Nginx Ingress 平滑迁移，可以帮助用户零成本快速迁移到 Higress。</p><span id="more"></span><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li><a href="https://github.com/alibaba/higress">Higress 官方项目</a></li><li><a href="https://higress.cn/docs/latest/overview/what-is-higress/">Higress 官方文档</a></li><li><a href="https://higress.cn/">Higress 官方网站</a></li></ul><h3 id="网关的分类"><a href="#网关的分类" class="headerlink" title="网关的分类"></a>网关的分类</h3><p>行业中通常把网关分为两个大类：流量网关与业务网关，流量网关主要提供全局性的、与后端业务无关的策略配置，例如阿里内部的的统一接入网关 Tengine 就是典型的流量网关；业务网关顾名思义主要提供独立业务域级别的、与后端业务紧耦合策略配置，随着应用架构模式从单体演进到现在的微服务，业务网关也有了新的叫法 - 微服务网关。</p><p><img data-src="../../../asset/2025/07/higress-7.png"></p><p>在虚拟化时期的微服务架构下，业务通常采用流量网关 + 微服务网关的两层架构，流量网关负责南北向流量调度和安全防护，微服务网关负责东西向流量调度和服务治理，而在容器和 K8s 主导的云原生时代，Ingress 成为 K8s 生态的网关标准，赋予了网关新的使命，使得流量网关 + 微服务网关合二为一成为可能。作为面向南北向的公网网关，使用 Waf 防护异常流量是很常规的需求，而且随着互联网环境变得越来越复杂，用户对防护的诉求是持续增强的，常规做法是将流量先接入 Waf 安全网关，过滤后再将流量转发给流量网关，最后到达微服务网关；Higress 希望通过内置 Waf 模块，使得用户的请求链接只经过 Higress 就可以同时完成 Waf 防护、流量分发、微服务治理，既可以降低链路 RT，也可以降低网关的运维复杂度。因此 Higress 实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力。</p><p><img data-src="../../../asset/2025/07/higress-8.png"></p><h2 id="Higress-简介"><a href="#Higress-简介" class="headerlink" title="Higress 简介"></a>Higress 简介</h2><h3 id="Higress-是什么"><a href="#Higress-是什么" class="headerlink" title="Higress 是什么"></a>Higress 是什么</h3><ul><li>Higress 是一款云原生 API 网关，内核基于 Istio 和 Envoy，可以用 Go/Rust/JS 等编写 Wasm 插件，提供了数十个现成的通用插件，以及开箱即用的控制台。</li><li>Higress 在阿里内部为解决 Tengine Reload 对长连接业务有损，以及 gRPC/Dubbo 负载均衡能力不足而诞生。</li><li>阿里云基于 Higress 构建了云原生 API 网关产品，为大量企业客户提供 99.99% 的网关高可用保障服务能力。</li><li>Higress 基于 AI 网关能力，支撑了通义千问 APP、百炼大模型 API、机器学习 PAI 平台等 AI 业务。同时服务国内头部的 AIGC 企业（如零一万物），以及 AI 产品（如 FastGPT）。</li></ul><p><img data-src="../../../asset/2025/07/higress-1.png"></p><h3 id="什么是-AI-网关"><a href="#什么是-AI-网关" class="headerlink" title="什么是 AI 网关"></a>什么是 AI 网关</h3><p>AI Gateway = AI Native API GatewayAI，网关的本质依然是 API 网关，AI 原生的意义在于，在这样的 API 网关里，AI 是一等公民。API 研发、API 供应、API 消费、以及 API 观测都基于 AI 场景下的需求，演进出全新的能力。</p><blockquote><p>这是传统 API 网关的功能范畴，AI 场景下仍然有其通用价值：</p></blockquote><p><img data-src="../../../asset/2025/07/higress-2.png"></p><blockquote><p>在 AI 场景下，基于 Higress 可以将 API 网关的功能范畴进一步扩展：</p></blockquote><p><img data-src="../../../asset/2025/07/higress-3.png"></p><h3 id="Higress-核心优势"><a href="#Higress-核心优势" class="headerlink" title="Higress 核心优势"></a>Higress 核心优势</h3><ul><li><p>生产等级</p><ul><li>脱胎于阿里巴巴多年生产验证的内部产品，支持每秒请求量达数十万级的大规模场景。</li><li>彻底摆脱 Nginx Reload 引起的流量抖动，配置变更毫秒级生效且业务无感。对 AI 业务等长连接场景特别友好。</li></ul></li><li><p>便于扩展</p><ul><li>提供丰富的官方插件库，涵盖 AI、流量管理、安全防护等常用功能，满足 90% 以上的业务场景需求。</li><li>主打 Wasm 插件扩展，通过沙箱隔离确保内存安全，支持多种编程语言，允许插件版本独立升级，实现流量无损热更新网关逻辑。</li></ul></li><li><p>安全易用</p><ul><li>基于 Ingress API 和 Gateway API 标准，提供开箱即用的 UI 控制台，WAF 防护插件、IP/Cookie CC 防护插件开箱即用。</li><li>支持对接 Let’s Encrypt 自动签发和续签免费证书，并且可以脱离 K8s 部署，一行 Docker 命令即可启动，方便个人开发者使用。</li></ul></li><li><p>流式处理</p><ul><li>支持真正的完全流式处理请求 / 响应 Body，Wasm 插件很方便地自定义处理 SSE（Server-Sent Events）等流式协议的报文。</li><li>在 AI 业务等大带宽场景下，可以显著降低内存开销。</li></ul></li></ul><h3 id="Higress-使用场景"><a href="#Higress-使用场景" class="headerlink" title="Higress 使用场景"></a>Higress 使用场景</h3><h4 id="AI-网关"><a href="#AI-网关" class="headerlink" title="AI 网关"></a>AI 网关</h4><p>Higress 能够用统一的协议对接国内外所有 LLM 模型厂商，同时具备丰富的 AI 可观测、多模型负载均衡 / Fallback、AI Token 流控、AI 缓存等能力：</p><p><img data-src="../../../asset/2025/07/higress-4.png"></p><h4 id="K8s-Ingress-网关"><a href="#K8s-Ingress-网关" class="headerlink" title="K8s Ingress 网关"></a>K8s Ingress 网关</h4><p>Higress 可以作为 K8s 集群的 Ingress 入口网关，并且兼容了大量 K8s Nginx Ingress 的注解，可以从 K8s Nginx Ingress 快速平滑迁移到 Higress。支持 Gateway API 标准，支持用户从 Ingress API 平滑迁移到 Gateway API。相比 ingress-nginx，资源开销大幅下降，路由变更生效速度有十倍提升。</p><p><img data-src="../../../asset/2025/07/higress-5.png"></p><h4 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h4><p>Higress 可以作为微服务网关，能够对接多种类型的注册中心发现服务配置路由，例如 Nacos、ZooKeeper、Consul、Eureka 等。并且深度集成了 Dubbo、Nacos、Sentinel 等微服务技术栈，基于 Envoy C++ 网关内核的出色性能，相比传统 Java 类微服务网关，可以显著降低资源使用率，减少成本。</p><p><img data-src="../../../asset/2025/07/higress-6.png"></p><h4 id="安全防护网关"><a href="#安全防护网关" class="headerlink" title="安全防护网关"></a>安全防护网关</h4><p>Higress 可以作为安全防护网关，提供 WAF 的能力，并且支持多种认证鉴权策略，例如 key-auth、hmac-auth、jwt-auth、basic-auth、oidc 等。</p><h3 id="Higress-整体架构"><a href="#Higress-整体架构" class="headerlink" title="Higress 整体架构"></a>Higress 整体架构</h3><ul><li>整体上 Higress 网关由控制面组件 Higress-Controller 和数据面组件 Higress-Gateway 组成。Higress-Gateway 负责承载数据流量，Higress-Controller 负责管理配置下发。</li><li>数据面组件 Higress-Gateway 是基于 Envoy 开发的网关组件，负责接收和处理流量，支持 HTTP/1.1、HTTP/2、gRPC 等协议，支持 TLS、mTLS、WAF、限流、熔断、重试、负载均衡、路由、转发、重定向、跨域等功能，也就是说真正的流量处理都是在 Higress-Gateway 中完成的。</li><li>控制面组件 Higress-Controller 负责管理配置下发，支持 Ingress API、Gateway API、Istio API，支持多种注册中心，支持多种认证鉴权策略，支持多种插件扩展机制，支持多种 CRD 实现流量精细化管理，也就是说所有的配置都是通过 Higress-Controller 下发到 Higress-Gateway 中的。</li></ul><p><img data-src="../../../asset/2025/07/higress-9.png"></p><h3 id="Higress-开发语言"><a href="#Higress-开发语言" class="headerlink" title="Higress 开发语言"></a>Higress 开发语言</h3><p>Higress 主要是基于 Envoy Proxy 开发的，核心是用 C++（Envoy 内核）和 Go（控制面、插件、扩展部分）组合实现的。</p><table><thead><tr><th>组件</th><th>语言</th><th>作用</th></tr></thead><tbody><tr><td> Envoy Proxy（数据面）</td><td>C++</td><td>Higress 的流量转发核心，负责 HTTP/TCP 代理、路由、负载均衡，使用 Envoy 做高性能转发。</td></tr><tr><td>控制面 / 插件 / 扩展逻辑</td><td> Go</td><td>Higress 提供了 Ingress、Gateway API 的控制逻辑、配置管理、Wasm 插件管理等，这部分主要用 Go 实现。</td></tr><tr><td>Wasm 插件（可选）</td><td>WebAssembly（多语言）</td><td>Higress 支持流量治理的 Wasm 扩展，用户可以用 Rust、C++、AssemblyScript 编写。</td></tr></tbody></table><p>为什么采用这种语言组合？</p><ul><li>C++（Envoy 内核）：高性能、云原生友好，成熟的代理框架。</li><li>Go（控制面、插件）：易于集成 Kubernetes，开发效率高，社区有大量的 Ingress/Gateway 生态。</li><li>Wasm（扩展能力）：支持动态扩展，不用重启服务。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/qq_45038038/article/details/136005591">下一代云原生网关 Higress</a></li><li><a href="https://www.51cto.com/article/786706.html">Higress 或许是目前最好的云原生网关</a></li><li><a href="https://zhuanlan.zhihu.com/p/21624794301">使用 Higress 统一替代 APISIX/Kong/Istio Ingress</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Higress 的基础使用。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门基础教程之一</title>
    <link href="https://www.techgrow.cn/posts/99bf51b3.html"/>
    <id>https://www.techgrow.cn/posts/99bf51b3.html</id>
    <published>2025-07-22T13:12:19.000Z</published>
    <updated>2025-07-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Kubernetes-概述"><a href="#Kubernetes-概述" class="headerlink" title="Kubernetes 概述"></a>Kubernetes 概述</h2><h3 id="各种部署方式的区别"><a href="#各种部署方式的区别" class="headerlink" title="各种部署方式的区别"></a>各种部署方式的区别</h3><p>传统的应用部署方式是通过插件或脚本来安装应用，这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新、回滚等操作；当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能够快速部署，由于容器与底层设施、机器文件系统解耦的，所以它能在不同云、不同版本操作系统间进行迁移。容器占用资源少、部署快，每个应用可以被打包成一个容器镜像，每个应用与容器间成一对一关系也使容器有更大优势，使用容器可以在 <code>build</code> 或 <code>release</code> 的阶段，为应用创建容器镜像，因为每个应用不需要与其余的应用堆栈组合，也不依赖于生产环境基础结构，这使得从研发到测试、生产能提供一致环境。类似地，容器比虚拟机轻量、更 “透明”，这更便于监控和管理。</p><span id="more"></span><h3 id="Kubernetes-基本介绍"><a href="#Kubernetes-基本介绍" class="headerlink" title="Kubernetes 基本介绍"></a>Kubernetes 基本介绍</h3><p>Kubernetes 是 Google 于 2014 年 6 月正式开源的一个容器编排引擎，简称 K8s，是用 8 代替 8 个字符 <code>ubernete</code> 而成的缩写。Kubernetes 可用于管理云平台中多个主机上的容器化的应用，支持自动化部署、大规模扩缩容、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。Kubernetes 提供了应用部署、规划、更新、维护的一种机制。在 Kubernetes 中，可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p><h3 id="Kubernetes-功能介绍"><a href="#Kubernetes-功能介绍" class="headerlink" title="Kubernetes 功能介绍"></a>Kubernetes 功能介绍</h3><p>Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过 Kubernetes 能够进行应用的自动化部署和扩缩容。在 Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes 积累了作为 Google 生产环境运行工作负载 15 年的经验，并吸收了来自于社区的最佳想法和实践。Kubernetes 的核心功能如下：</p><ul><li>自动装箱：基于容器对应用运行环境的资源配置要求自动部署应用容器</li><li>自我修复：当容器运行失败时，会对容器进行重启；当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度；当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</li><li>水平扩展：通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</li><li>服务发现：用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡</li><li>滚动更新：可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</li><li>版本回退：可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</li><li>密钥和配置管理：在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署</li><li>存储编排：自动实现存储系统挂载及应用，这特别对有状态应用实现数据持久化非常重要；存储系统可以来自于本地目录、网络存储（NFS、Gluster、Ceph 等）、公共云存储服务</li><li>批处理：提供一次性任务，定时任务，满足批量数据处理和分析的场景</li></ul><h3 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h3><table><thead><tr><th>技术名称</th><th>技术描述</th></tr></thead><tbody><tr><td> YAML 配置文件</td><td>使用 YAML 文件定义 Kubernetes 资源，如 Pod、Service、Deployment 等，是声明式管理的基础。</td></tr><tr><td>kubectl 命令工具</td><td> Kubernetes 的命令行客户端工具，用于操作集群、部署资源、排查故障等。</td></tr><tr><td>Pod</td><td>Kubernetes 中最小的可调度单元，通常封装一个或多个容器，容器共享网络和存储。</td></tr><tr><td>Controller（控制器）</td><td>自动化资源管理的核心组件，如 Deployment、ReplicaSet、StatefulSet、DaemonSet 等控制器。</td></tr><tr><td>Service</td><td> 定义一组 Pod 的统一访问入口，支持负载均衡和服务发现。</td></tr><tr><td>Label</td><td> 给资源打标签的机制，支持资源的分类、选择、分组管理等，用于调度和服务发现。</td></tr><tr><td>Volume</td><td> 提供容器持久化或共享数据的机制，支持本地存储、NFS、云存储等。</td></tr><tr><td>PVC 和 PV</td><td>PVC（Persistent Volume Claim）是用户请求的存储资源，PV（Persistent Volume）是实际存储资源，解耦用户和存储实现。</td></tr><tr><td>Secret 和 ConfigMap</td><td>Secret 用于管理敏感数据，ConfigMap 用于存储配置数据，都可挂载进容器或作为环境变量使用。</td></tr><tr><td>Namespace</td><td> 提供资源隔离的逻辑空间，用于多租户环境或资源分类管理。</td></tr><tr><td>Probes（探针）</td><td>包括存活探针（liveness）和就绪探针（readiness），用于健康检查和控制流量转发。</td></tr><tr><td>API Server</td><td>Kubernetes 控制平面的核心组件，负责处理来自 kubectl 或其他客户端的请求，并与 Etcd、Controller（控制器）、Scheduler（调度器）等交互。</td></tr><tr><td>Scheduler（调度器）</td><td>根据资源需求、约束条件和策略将 Pod 分配到合适的节点。</td></tr><tr><td>集群安装机制与 RBAC</td><td> 安装机制包括 kubeadm、Kops、RKE 等，RBAC（基于角色的访问控制）用于权限管理和安全控制。</td></tr><tr><td>Helm</td><td>Kubernetes 的包管理工具，用于简化应用部署，支持版本管理、参数化配置等。</td></tr></tbody></table><h3 id="Kubernetes-核心概念"><a href="#Kubernetes-核心概念" class="headerlink" title="Kubernetes 核心概念"></a>Kubernetes 核心概念</h3><p>Kubernetes 三个核心概念（Pod、Controller、Service）的介绍如下：</p><ul><li><p>Pod（最小部署单元）</p><ul><li>Pod 是 Kubernetes 中最小的调度和运行单元。</li><li>本质上是一组容器的集合（通常是一个容器）。</li><li>容器之间共享网络（IP、端口）和存储卷。</li><li>Pod 的生命周期通常是短暂的，用于运行临时任务或被控制器自动重建。</li></ul></li><li><p>Controller（控制器）</p><ul><li>用于管理和自动化 Pod 的部署与副本数量。</li><li>支持无状态应用部署（如 Deployment）。</li><li>支持有状态应用部署（如 StatefulSet）。</li><li>可实现以下功能：<ul><li>保证指定数量的 Pod 实例持续运行。</li><li>在多个节点上部署同一类 Pod（如 DaemonSet）。</li><li>支持一次性任务（Job）和定时任务（CronJob）。</li></ul></li></ul></li><li><p>Service（服务）</p><ul><li>负责定义一组 Pod 的访问规则。</li><li>提供统一的访问入口（Cluster IP、NodePort、LoadBalancer 等），实现服务发现与负载均衡。</li><li>解决 Pod 动态 IP 和短生命周期带来的访问不稳定问题。</li></ul></li></ul><p>这三个核心概念的关系：</p><ul><li>Pod 是具体运行的实例。</li><li>Controller 管理 Pod 的创建、副本和调度。</li><li>Service 让外部或内部服务可以稳定地访问 Pod。</li></ul><h2 id="Kubernetes-集群搭建"><a href="#Kubernetes-集群搭建" class="headerlink" title="Kubernetes 集群搭建"></a>Kubernetes 集群搭建</h2><h3 id="集群架构组件"><a href="#集群架构组件" class="headerlink" title="集群架构组件"></a>集群架构组件</h3><p><img data-src="../../../asset/2025/07/k8s-1.png"></p><ul><li><p><code>Master（主控节点）</code>：Kubernetes 集群控制节点，负责对集群进行调度管理，接受集群外的用户去集群操作请求。Master 由 API Server、Scheduler、Controller Manager、Etcd 存储系统组成</p><ul><li>Scheduler：节点调度，选择 Node 节点来应用部署</li><li> API Server：集群统一入口，以 RESTful 接口将数据交给 Etcd 进行存储</li><li> Controller Manager：处理集群中的常规后台任务，一个资源对应一个控制器</li><li> Etcd 存储系统：用于存储集群相关的数据</li></ul></li><li><p><code>Node（工作节点）</code>：Kubernetes 集群工作节点，负责运行用户业务应用容器，Node 由 Kubelet、Kube-Proxy 和 Container Runtime 组成</p><ul><li>Kubelet：负责 Pod 对应的容器的创建、启停管理，与 Master 节点协作，实现集群管理的基本功能</li><li> Kube-Proxy：提供 Kubernetes 的通信与负载均衡功能的重要组件</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Etcd 是什么</p><ul><li>在分布式系统中，Etcd 是一个高可用、强一致性的分布式键值存储系统，在 Kubernetes 等系统中扮演着核心元数据存储和协调中心的角色。</li><li>Etcd 属于更底层的基础组件，使用 Raft 算法实现强一致性（满足 CAP 中的 C 和 P），提供了一致性的 KV 存储、watch、lease、事务等机制。</li></ul></div><h3 id="集群搭建规划"><a href="#集群搭建规划" class="headerlink" title="集群搭建规划"></a>集群搭建规划</h3><p>Kubernetes 集群有两种类型，包括单 Master 集群和多 Master 集群，为了提高集群的高可用性，生产环境一般采用多 Master 集群方案，如下图所示：</p><p><img data-src="../../../asset/2021/03/kubernetes-cluster-plan.png"></p><h3 id="集群搭建要求"><a href="#集群搭建要求" class="headerlink" title="集群搭建要求"></a>集群搭建要求</h3><p>搭建 Kubernetes 集群需要满足以下几个条件：</p><ul><li>一台或多台机器，建议操作系统 CentOS 7（64 位）</li><li>Master 节点的硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 20GB 或更多</li><li> Node 节点的硬件配置：4GB 或更多 RAM，4 个 CPU 或更多 CPU，硬盘 40GB 或更多</li><li>集群中所有机器之间的网络可以互通</li><li>系统内可以访问外网，需要拉取镜像</li><li>禁用 Swap 分区（必须）</li></ul><h3 id="集群搭建方式"><a href="#集群搭建方式" class="headerlink" title="集群搭建方式"></a>集群搭建方式</h3><p>目前生产环境搭建 Kubernetes 集群主要有以下两种方式：</p><ul><li><p><strong>Kubeadm</strong></p><ul><li><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">Kubeadm</a> 是一个 Kubernetes 部署工具，提供 <code>kubeadm init</code> 和 <code>kubeadm join</code> 命令，可用于快速搭建 Kubernetes 集群。</li></ul></li><li><p><strong>二进制包</strong></p><ul><li>从 Github 下载发行版的二进制包，手动部署每个组件，组成 Kubernetes 集群。Kubeadm 虽然降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。</li><li>如果想集群整体更可控，生产环境推荐使用二进制包搭建 Kubernetes 集群，虽然手动部署比较麻烦，但期间可以学习很多工作原理，也利于后期维护。</li></ul></li></ul><h3 id="集群搭建步骤"><a href="#集群搭建步骤" class="headerlink" title="集群搭建步骤"></a>集群搭建步骤</h3><h4 id="二进制包方式搭建集群"><a href="#二进制包方式搭建集群" class="headerlink" title="二进制包方式搭建集群"></a>二进制包方式搭建集群</h4><ul><li><a href="/posts/ccd6f2d4.html">基于二进制包方式搭建 Kubernetes 集群</a></li></ul><h4 id="Kubeadm-方式搭建集群"><a href="#Kubeadm-方式搭建集群" class="headerlink" title="Kubeadm 方式搭建集群"></a>Kubeadm 方式搭建集群</h4><ul><li><a href="/posts/b728042a.html">基于 Kubeadm 方式搭建 Kubernetes 集群</a></li></ul><h2 id="Kubernetes-核心技术-1"><a href="#Kubernetes-核心技术-1" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="kubectl-命令行工具"><a href="#kubectl-命令行工具" class="headerlink" title="kubectl 命令行工具"></a>kubectl 命令行工具</h3><p>kubectl 是 Kubernetes 集群的命令行工具，通过 kubectl 能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。</p><h4 id="kubectl-的语法"><a href="#kubectl-的语法" class="headerlink" title="kubectl 的语法"></a>kubectl 的语法</h4><ul><li><p>命令语法：<code>kubectl [command] [type] [name] [flags]</code></p></li><li><p><code>command</code>：</p><ul><li>指定要对资源执行的操作</li><li>例如：<code>create</code>、<code>get</code>、<code>describe</code> 和 <code>delete</code></li></ul></li><li><p><code>type</code>：</p><ul><li>指定资源类型，资源类型是大小写敏感的，开发者能够以单数、复数和缩略的形式。例如:</li><li><code>kubectl get pod pod1</code></li><li><code>kubectl get pods pod1</code></li><li><code>kubectl get po pod1</code></li><li><code>kubectl get nodes K8s-node1</code></li></ul></li><li><p><code>name</code>：</p><ul><li>指定资源的名称，名称大小写敏感。如果省略资源名称，则会显示所有的资源。例如：</li><li><code>kubectl get pods</code></li><li><code>kubectl get nodes</code></li><li><code>kubectl get nodes K8s-node1</code></li></ul></li><li><p><code>flags</code>：</p><ul><li>指定可选的参数。例如，可以使用 <code>-s</code> 或者 <code>-server</code> 参数指定 Kubernetes API Server 的地址和端口。</li></ul></li></ul><h4 id="kubectl-的使用帮助手册"><a href="#kubectl-的使用帮助手册" class="headerlink" title="kubectl 的使用帮助手册"></a>kubectl 的使用帮助手册</h4><p>可以使用 <code>kubectl --help</code> 命令查看 kubectl 命令的整体使用帮助，包括所有可用的主命令及其简要说明；还可以通过 <code>kubectl &lt;command&gt; --help</code> 获取某个具体子命令的详细使用手册和参数说明。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 kubectl 的所有主命令和帮助信息</span></span><br><span class="line"><span class="keyword"># kubectl</span><span class="params"> --help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kubectl get 子命令的详细用法和参数说明</span></span><br><span class="line"><span class="keyword"># kubectl</span> get<span class="params"> --help</span></span><br></pre></td></tr></tbody></table></figure><p>比如，<code>kubectl help</code> 命令输出的帮助内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">kubectl controls the Kubernetes cluster manager.</span><br><span class="line"></span><br><span class="line"> Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/</span><br><span class="line"></span><br><span class="line">Basic Commands (Beginner):</span><br><span class="line">  create        Create a resource from a file or from stdin.</span><br><span class="line">  expose        使用 replication controller, service, deployment 或者 pod 并暴露它作为一个 新的 Kubernetes</span><br><span class="line">Service</span><br><span class="line">  run           在集群中运行一个指定的镜像</span><br><span class="line">  set           为 objects 设置一个指定的特征</span><br><span class="line"></span><br><span class="line">Basic Commands (Intermediate):</span><br><span class="line">  explain       查看资源的文档</span><br><span class="line">  get           显示一个或更多 resources</span><br><span class="line">  edit          在服务器上编辑一个资源</span><br><span class="line">  delete        Delete resources by filenames, stdin, resources and names, or by resources and label selector</span><br><span class="line"></span><br><span class="line">Deploy Commands:</span><br><span class="line">  rollout       Manage the rollout of a resource</span><br><span class="line">  scale         Set a new size for a Deployment, ReplicaSet or Replication Controller</span><br><span class="line">  autoscale     自动调整一个 Deployment, ReplicaSet, 或者 ReplicationController 的副本数量</span><br><span class="line"></span><br><span class="line">Cluster Management Commands:</span><br><span class="line">  certificate   修改 certificate 资源.</span><br><span class="line">  cluster-info  显示集群信息</span><br><span class="line">  top           Display Resource (CPU/Memory/Storage) usage.</span><br><span class="line">  cordon        标记 node 为 unschedulable</span><br><span class="line">  uncordon      标记 node 为 schedulable</span><br><span class="line">  drain         Drain node in preparation for maintenance</span><br><span class="line">  taint         更新一个或者多个 node 上的 taints</span><br><span class="line"></span><br><span class="line">Troubleshooting and Debugging Commands:</span><br><span class="line">  describe      显示一个指定 resource 或者 group 的 resources 详情</span><br><span class="line">  logs          输出容器在 pod 中的日志</span><br><span class="line">  attach        Attach 到一个运行中的 container</span><br><span class="line">  exec          在一个 container 中执行一个命令</span><br><span class="line">  port-forward  Forward one or more local ports to a pod</span><br><span class="line">  proxy         运行一个 proxy 到 Kubernetes API server</span><br><span class="line">  cp            复制 files 和 directories 到 containers 和从容器中复制 files 和 directories.</span><br><span class="line">  auth          Inspect authorization</span><br><span class="line"></span><br><span class="line">Advanced Commands:</span><br><span class="line">  diff          Diff live version against would-be applied version</span><br><span class="line">  apply         通过文件名或标准输入流(stdin)对资源进行配置</span><br><span class="line">  patch         使用 strategic merge patch 更新一个资源的 field(s)</span><br><span class="line">  replace       通过 filename 或者 stdin替换一个资源</span><br><span class="line">  wait          Experimental: Wait for a specific condition on one or many resources.</span><br><span class="line">  convert       在不同的 API versions 转换配置文件</span><br><span class="line">  kustomize     Build a kustomization target from a directory or a remote url.</span><br><span class="line"></span><br><span class="line">Settings Commands:</span><br><span class="line">  label         更新在这个资源上的 labels</span><br><span class="line">  annotate      更新一个资源的注解</span><br><span class="line">  completion    Output shell completion code for the specified shell (bash or zsh)</span><br><span class="line"></span><br><span class="line">Other Commands:</span><br><span class="line">  alpha         Commands for features in alpha</span><br><span class="line">  api-resources Print the supported API resources on the server</span><br><span class="line">  api-versions  Print the supported API versions on the server, in the form of "group/version"</span><br><span class="line">  config        修改 kubeconfig 文件</span><br><span class="line">  plugin        Provides utilities for interacting with plugins.</span><br><span class="line">  version       输出 client 和 server 的版本信息</span><br><span class="line"></span><br><span class="line">Use "kubectl &lt;command&gt; --help" for more information about a given command.</span><br><span class="line">Use "kubectl options" for a list of global command-line options (applies to all commands).</span><br></pre></td></tr></tbody></table></figure><h4 id="kubectl-的子命令使用分类"><a href="#kubectl-的子命令使用分类" class="headerlink" title="kubectl 的子命令使用分类"></a>kubectl 的子命令使用分类</h4><ul><li>基础命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>create</code></td><td>通过文件名或标注输入创建资源</td></tr><tr><td><code>expose</code></td><td>将一个资源公开为一个新的 Service</td></tr><tr><td><code>run</code></td><td>在集群中运行一个特定的镜像</td></tr><tr><td><code>set</code></td><td>在对象上设置特定的功能</td></tr><tr><td><code>get</code></td><td>显示一个或多个资源</td></tr><tr><td><code>explain</code></td><td>文档参考资料</td></tr><tr><td><code>edit</code></td><td>使用默认的编辑器编辑一个资源</td></tr><tr><td><code>delete</code></td><td>通过文件名、标注输入、资源名或标注选择来删除资源</td></tr></tbody></table><ul><li> 部署命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>rollout</code></td><td>管理资源的发布</td></tr><tr><td><code>rolling-update</code></td><td>对某些类型的副本控制器滚动更新</td></tr><tr><td><code>scale</code></td><td>扩容或缩容 Pod 数量，Deployment、ReplicaSet、RC 或 Job</td></tr><tr><td><code>autoscale</code></td><td>创建一个自动选择扩容或缩容容器并设置 Pod 数量</td></tr></tbody></table><ul><li> 集群管理命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>certificate</code></td><td>修改证书资源</td></tr><tr><td><code>cluster-info</code></td><td>显示集群信息</td></tr><tr><td><code>top</code></td><td>显示资源（CPU/Memory/Storage）使用情况，需要 Heapster 运行</td></tr><tr><td><code>cordon</code></td><td>标记节点不可调度</td></tr><tr><td><code>uncordon</code></td><td>标记节点可调度</td></tr><tr><td><code>drain</code></td><td>驱逐节点上的应用，准备下线维护</td></tr><tr><td><code>taint</code></td><td>修改节点 Taint 标记</td></tr></tbody></table><ul><li>故障和调试命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>describe</code></td><td>显示特定资源或资源组的详细信息</td></tr><tr><td><code>logs</code></td><td>在一个 Pod 中打印一个容器日志。如 Pod 只有一个容器，容器名称是可选的</td></tr><tr><td><code>attach</code></td><td>附加到一个运行的容器</td></tr><tr><td><code>exec</code></td><td>执行命令到容器</td></tr><tr><td><code>port-forward</code></td><td>转发一个或多个本地端口到一个 Pod</td></tr><tr><td><code>proxy</code></td><td>运行一个 Proxy 到 Kubernetes API server</td></tr><tr><td><code>cp</code></td><td>拷贝文件和目录到容器中或从容器中拷贝出来</td></tr><tr><td><code>auth</code></td><td>检查授权</td></tr></tbody></table><ul><li>其他高级命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>apply</code></td><td>通过文件名或标准输入对资源应用配置</td></tr><tr><td><code>patch</code></td><td>使用补丁修改、更新资源的字段</td></tr><tr><td><code>replace</code></td><td>通过文件名或标准输入替换一个资源</td></tr><tr><td><code>convert</code></td><td>不同的 API 版本之间转换配置文件</td></tr></tbody></table><ul><li>其他设置命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>label</code></td><td>更新资源上的标签</td></tr><tr><td><code>annotate</code></td><td>更新资源上的注释</td></tr></tbody></table><ul><li>其他常用命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>completion</code></td><td>用于实现 kubectl 工具自动补全</td></tr><tr><td><code>api-versions</code></td><td>打印可用的 API 版本</td></tr><tr><td><code>config</code></td><td>修改 kubeconfig 文件（用于访问 API，比如凭证信息配置）</td></tr><tr><td><code>help</code></td><td>所有命令帮助</td></tr><tr><td><code>plugin</code></td><td>运行一个可执行插件</td></tr><tr><td><code>version</code></td><td>打印客户端和服务端的版本信息</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">最常用的命令</p><ul><li><code>kubectl get pods</code>：查看当前命名空间下所有 Pod 的状态信息。</li><li><code>kubectl get nodes</code>：查看集群中所有节点（Node）的状态信息。</li><li><code>kubectl get svc</code>： 查看当前命名空间下所有 Service（服务）资源的配置信息。</li><li><code>kubectl get cs</code>： 查看集群核心组件（ComponentStatus，如 Scheduler、Controller Manager 等）的运行状态，已过时不推荐使用。</li></ul></div><h3 id="YAML-资源编排"><a href="#YAML-资源编排" class="headerlink" title="YAML 资源编排"></a>YAML 资源编排</h3><p>在 Kubernetes 集群中，资源管理和资源对象的编排部署可以通过声明式的 YAML 文件来实现。用户可以将对资源对象的操作需求编写到 YAML 格式的配置文件中，这种文件称为资源清单文件。通过 kubectl 命令直接调用这些资源清单文件，就能够高效地完成大量资源对象的编排和部署工作。</p><h4 id="YAML-的概述"><a href="#YAML-的概述" class="headerlink" title="YAML 的概述"></a>YAML 的概述</h4><ul><li>YAML 是一个可读性高，用来表达数据序列的格式。</li><li>YAML 仍是一种标记语言，为了强调这种语言以数据作为中心，而不是以标记语言为重点。</li></ul><h4 id="YAML-的基本语法"><a href="#YAML-的基本语法" class="headerlink" title="YAML 的基本语法"></a>YAML 的基本语法</h4><ul><li>使用空格作为缩进；</li><li>缩进的空格数量不重要，只要相同层级的元素左侧对齐即可；</li><li>低版本缩进时，不允许使用 Tab 键，只允许使用空格；</li><li>使用 <code>---</code> 作为文档分隔符，表示一个 YAML 文件中的多文档边界；</li><li>使用 <code>#</code> 标识注释，从这个字符一直到行尾，都会被 YAML 解释器忽略。</li></ul><h4 id="YAML-支持的数据结构"><a href="#YAML-支持的数据结构" class="headerlink" title="YAML 支持的数据结构"></a>YAML 支持的数据结构</h4><ul><li>对象：键值对的集合，又称为映射 (Mapping) / 哈希 (Hash) / 字典 (Dictionary)</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对象类型：对象的一组键值对，使用冒号结构表示</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yaml 也允许另一种写法，将所有键值对写成一个行内对象</span></span><br><span class="line"><span class="attr">hash:</span> {<span class="attr">name:</span> <span class="string">Tom</span>, <span class="attr">age:</span> <span class="number">18</span>}</span><br></pre></td></tr></tbody></table></figure><ul><li>数组：一组按次序排列的值，又称为序列 (Sequence) / 列表 (List)</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 横向写法（行内数组）</span></span><br><span class="line"><span class="attr">fruits:</span> [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 纵向写法（可读性更好，推荐）</span></span><br><span class="line"><span class="attr">fruits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cherry</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合对象的数组（数组中每个元素都是一个对象）</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Alice</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">25</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Peter</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">30</span></span><br></pre></td></tr></tbody></table></figure><ul><li>多行字符串可以使用 <code>|</code> 保留换行符，也可以使用 <code>&gt;</code> 折叠换行 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 `|` 保留换行符</span></span><br><span class="line"><span class="attr">this:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br></pre></td></tr></tbody></table></figure><ul><li>多个 YAML 文档之间可以使用 <code>---</code> 文档分隔符分隔 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个文档（例如定义一个 ConfigMap）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">config1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 第二个文档（例如定义一个 Secret）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret1</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">BASE64_ENCODED_DATA</span></span><br></pre></td></tr></tbody></table></figure><h4 id="YAML-资源清单的描述方法"><a href="#YAML-资源清单的描述方法" class="headerlink" title="YAML 资源清单的描述方法"></a>YAML 资源清单的描述方法</h4><p>在 Kubernetes 中，用户通常使用 YAML 格式的配置文件来定义和创建符合预期状态的集群资源（如 Pod、Deployment 等）。这类遵循 Kubernetes API 规范、用于描述资源对象及其期望状态的 YAML 文件，被称为资源清单（Manifest）。</p><ul><li>常用字段（<strong>必须存在的属性</strong>）</li></ul><table><thead><tr><th>参数名</th><th>字段类型</th><th>说明</th></tr></thead><tbody><tr><td><code>version</code></td><td>String</td><td>K8s API 的版本，目前基本是 <code>v1</code>，可以用 <code>kubectl api-versions</code> 命令查询</td></tr><tr><td><code>kind</code></td><td>String</td><td>YAML 文件定义的资源类型和角色，例如：<code>Pod</code></td></tr><tr><td><code>metadata</code></td><td>Object</td><td> 元数据对象，固定值写 <code>metadata</code></td></tr><tr><td><code>metadata.name</code></td><td>String</td><td> 元数据对象的名字，由用户定义，例如命名 Pod 的名字</td></tr><tr><td><code>metadata.namespace</code></td><td>String</td><td> 元数据对象的命名空间，由用户定义</td></tr><tr><td><code>spec</code></td><td>Object</td><td> 详细定义对象，固定值写 <code>spec</code></td></tr><tr><td><code>spec.containers[]</code></td><td>list</td><td>spec 对象的容器列表定义，是一个列表</td></tr><tr><td><code>spec.containers[].name</code></td><td>String</td><td> 定义容器的名称</td></tr><tr><td><code>spec.containers[].image</code></td><td>String</td><td> 定义容器使用的镜像名称</td></tr></tbody></table><ul><li>资源清单的定义示例（创建一个 Nginx 的 Pod）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>更完整的资源清单定义示例（创建一个 Nginx 的 Deployment）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>最后可以使用 <code>kubectl apply -f xxxx.yaml</code> 命令来执行这个资源清单</li></ul><h4 id="快速生成-YAML-资源清单"><a href="#快速生成-YAML-资源清单" class="headerlink" title="快速生成 YAML 资源清单"></a>快速生成 YAML 资源清单</h4><ul><li>(1) 第一种方式：使用 <code>kubectl create</code> 命令快速生成 YAML 的配置模板内容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速生成 YAML 配置模板内容，--dry-run=client 表示只在客户端进行验证和生成请求，而不把资源真正提交到 API Server</span></span><br><span class="line"><span class="keyword"># kubectl</span> create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者将生成 YAML 配置模板内容输出到文件中</span></span><br><span class="line"><span class="keyword"># kubectl</span> create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> {}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line"><span class="attr">status:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 第二种方式：使用 <code>kubectl get</code> 命令导出正在运行的资源对象的 YAML 配置内容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前正在运行的 Deployment</span></span><br><span class="line"><span class="keyword"># kubectl</span> get deployments</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   1/1     1            1           2d12h</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出当前正在运行的 Deployment 的 YAML 配置内容</span></span><br><span class="line"><span class="keyword"># kubectl</span> get deployment nginx<span class="params"> -o</span> yaml &gt; nginx.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">deployment.kubernetes.io/revision:</span> <span class="string">"1"</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">  <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:labels:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:app:</span> {}</span><br><span class="line">      <span class="attr">f:spec:</span></span><br><span class="line">        <span class="attr">f:progressDeadlineSeconds:</span> {}</span><br><span class="line">        <span class="attr">f:replicas:</span> {}</span><br><span class="line">        <span class="attr">f:revisionHistoryLimit:</span> {}</span><br><span class="line">        <span class="attr">f:selector:</span></span><br><span class="line">          <span class="attr">f:matchLabels:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:app:</span> {}</span><br><span class="line">        <span class="attr">f:strategy:</span></span><br><span class="line">          <span class="attr">f:rollingUpdate:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:maxSurge:</span> {}</span><br><span class="line">            <span class="attr">f:maxUnavailable:</span> {}</span><br><span class="line">          <span class="attr">f:type:</span> {}</span><br><span class="line">        <span class="attr">f:template:</span></span><br><span class="line">          <span class="attr">f:metadata:</span></span><br><span class="line">            <span class="attr">f:labels:</span></span><br><span class="line">              <span class="string">.:</span> {}</span><br><span class="line">              <span class="attr">f:app:</span> {}</span><br><span class="line">          <span class="attr">f:spec:</span></span><br><span class="line">            <span class="attr">f:containers:</span></span><br><span class="line">              <span class="string">k:{"name":"nginx"}:</span></span><br><span class="line">                <span class="string">.:</span> {}</span><br><span class="line">                <span class="attr">f:image:</span> {}</span><br><span class="line">                <span class="attr">f:imagePullPolicy:</span> {}</span><br><span class="line">                <span class="attr">f:name:</span> {}</span><br><span class="line">                <span class="attr">f:resources:</span> {}</span><br><span class="line">                <span class="attr">f:terminationMessagePath:</span> {}</span><br><span class="line">                <span class="attr">f:terminationMessagePolicy:</span> {}</span><br><span class="line">            <span class="attr">f:dnsPolicy:</span> {}</span><br><span class="line">            <span class="attr">f:restartPolicy:</span> {}</span><br><span class="line">            <span class="attr">f:schedulerName:</span> {}</span><br><span class="line">            <span class="attr">f:securityContext:</span> {}</span><br><span class="line">            <span class="attr">f:terminationGracePeriodSeconds:</span> {}</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubectl-create</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:annotations:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:deployment.kubernetes.io/revision:</span> {}</span><br><span class="line">      <span class="attr">f:status:</span></span><br><span class="line">        <span class="attr">f:availableReplicas:</span> {}</span><br><span class="line">        <span class="attr">f:conditions:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="string">k:{"type":"Available"}:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> {}</span><br><span class="line">            <span class="attr">f:lastUpdateTime:</span> {}</span><br><span class="line">            <span class="attr">f:message:</span> {}</span><br><span class="line">            <span class="attr">f:reason:</span> {}</span><br><span class="line">            <span class="attr">f:status:</span> {}</span><br><span class="line">            <span class="attr">f:type:</span> {}</span><br><span class="line">          <span class="string">k:{"type":"Progressing"}:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> {}</span><br><span class="line">            <span class="attr">f:lastUpdateTime:</span> {}</span><br><span class="line">            <span class="attr">f:message:</span> {}</span><br><span class="line">            <span class="attr">f:reason:</span> {}</span><br><span class="line">            <span class="attr">f:status:</span> {}</span><br><span class="line">            <span class="attr">f:type:</span> {}</span><br><span class="line">        <span class="attr">f:observedGeneration:</span> {}</span><br><span class="line">        <span class="attr">f:readyReplicas:</span> {}</span><br><span class="line">        <span class="attr">f:replicas:</span> {}</span><br><span class="line">        <span class="attr">f:updatedReplicas:</span> {}</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kube-controller-manager</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"300851"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/apis/apps/v1/namespaces/default/deployments/nginx</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">f8edd19f-3292-45ac-ad16-932611f528a8</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line">        <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">        <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">      <span class="attr">securityContext:</span> {}</span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">availableReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">    <span class="attr">lastUpdateTime:</span> <span class="string">"2025-07-22T14:10:24Z"</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">ReplicaSet</span> <span class="string">"nginx-6799fc88d8"</span> <span class="string">has</span> <span class="string">successfully</span> <span class="string">progressed.</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">NewReplicaSetAvailable</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">"True"</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Progressing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">    <span class="attr">lastUpdateTime:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">Deployment</span> <span class="string">has</span> <span class="string">minimum</span> <span class="string">availability.</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">"True"</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Available</span></span><br><span class="line">  <span class="attr">observedGeneration:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">readyReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">updatedReplicas:</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><h4 id="Pod-的概述"><a href="#Pod-的概述" class="headerlink" title="Pod 的概述"></a>Pod 的概述</h4><p>Pod 是 Kubernetes 中可以创建和管理的最小资源单元，是用户在资源对象模型中创建或部署的基本单位，也是 Kubernetes 上运行容器化应用的直接载体。Kubernetes 并不会直接管理容器，而是通过管理 Pod 来间接管理容器。一个 Pod 通常由一个或多个容器组成，这些容器共享网络、存储等资源，并作为一个整体被调度和管理。在 Kubernetes 中，其他资源对象主要用于支撑或扩展 Pod 的功能，例如：Controller 资源用于管理和控制 Pod 的生命周期；Service 或 Ingress 资源用于暴露和访问 Pod；而 PersistentVolume (PV) 等存储资源用于为 Pod 提供持久化存储支持。此外，每个 Pod 都包含一个特殊的系统容器，称为 Pause 容器，它作为 Pod 的 “根容器” 存在，用于占据 Pod 的网络命名空间等资源。除了 Pause 容器，Pod 中还包含一个或多个紧密相关的用户业务容器，这些容器协同工作，共同完成某项具体的业务功能。</p><h4 id="Pod-的特性"><a href="#Pod-的特性" class="headerlink" title="Pod 的特性"></a>Pod 的特性</h4><ul><li><p><strong>资源共享</strong></p><ul><li>一个 Pod 里的多个容器可以共享存储和网络，可以看作一个逻辑的主机（服务器），共享 Namespace（命名空间）、Cgroups（控制组）或者其他的隔离资源。</li><li>同一个 Pod 中的多个容器共享同一个 Network Namespace，因此它们共享同一个 IP 地址和端口空间。也就是说，Pod 内的容器可以通过 <code>localhost</code> 进行通信。需要注意的是，多个容器在同一个 Pod 中运行时，应避免端口冲突。不同的 Pod 之间具有各自独立的 IP 地址，默认情况下，不同 Pod 中的容器之间不能通过 IPC 机制通信（除非做了特殊配置），通常使用 Pod 的 IP 地址进行网络通信。</li><li>一个 Pod 中的多个容器可以共享同一个存储卷，该存储卷作为 Pod 的一部分被定义，并可以挂载到该 Pod 内所有容器的文件系统中，从而实现数据共享和持久化存储。</li></ul></li><li><p><strong>生命周期短暂</strong></p><ul><li>Pod 是生命周期相对短暂的组件，例如当 Pod 所在的节点发生故障时，该节点上的 Pod 会被重新调度到其他节点上运行。但需要注意的是，重新调度后创建的是一个全新的 Pod，与原来的 Pod 没有任何关联，原有的状态、数据和标识都会丢失，二者之间没有任何直接关系。</li></ul></li><li><p><strong>平坦的网络</strong></p><ul><li>Kubernetes 集群中的所有 Pod 都处于同一个共享的网络地址空间中，这意味着每个 Pod 都可以通过其他 Pod 的 IP 地址直接进行访问和通信，无需进行额外的网络配置。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Docker 容器与宿主机进程的关系</p><ul><li>Docker 容器里的进程没有独立 Linux 内核，使用的是宿主机内核，它本质就是宿主机进程。</li><li>Docker 容器只是由 Linux 内核提供的隔离（Namespace） + 资源限制（Cgroups）环境。</li><li>当宿主机关掉 Docker 容器主进程，容器就会退出运行（容器生命周期依赖主进程）。换言之，Docker 容器主进程如果挂掉，容器就会停止运行。</li><li>Docker 容器的 Linux 内核版本永远等于宿主机的内核版本，更换镜像也换不掉内核。比如，当宿主机内核版本低（例如 <code>3.3</code>），容器里即使是最新版本的 Ubuntu，也无法使用高版本内核才有的特性（比如一些新 Cgroup 特性、eBPF）。</li></ul></div><h4 id="Pod-的定义"><a href="#Pod-的定义" class="headerlink" title="Pod 的定义"></a>Pod 的定义</h4><p>下面是 YAML 文件定义的 Pod 的完整内容（<code>&lt;string&gt;</code> 是占位符，需要根据实际情况填写）：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="comment"># 元数据</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="comment"># 时间配置</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">0</span>            <span class="comment"># 检查间隔时间</span></span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 安全配置</span></span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span>       <span class="comment"># 重启策略，可选值: Always、Never、OnFailure，默认 Always</span></span><br><span class="line">  <span class="attr">nodeSelector:</span>               <span class="comment"># 节点选择，将 Pod 调度到包含这些 Label 的 Node 上</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">value</span>                <span class="comment"># 以 key:value 格式指定</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span>          <span class="comment"># 是否使用主机网络模式，默认 false（不使用）</span></span><br><span class="line">  <span class="comment"># 共享存储卷列表</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">      <span class="attr">emptyDir:</span> {}</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">host-volume</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/path/on/host</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">configmap-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&lt;string&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Pod-的使用"><a href="#Pod-的使用" class="headerlink" title="Pod 的使用"></a>Pod 的使用</h4><p><strong>在 Kubernetes 中，运行的容器要求其主程序必须始终在前台运行，而不能以后台方式执行。如果应用默认是以后台运行的方式启动，就需要进行修改，使其在前台运行。否则，当 kubelet 创建包含该容器的 Pod 并执行启动命令后，会因为容器立即退出而认为该 Pod 已经结束，从而立刻销毁该 Pod。</strong>如果该 Pod 是由控制器（如 ReplicationController）管理的，那么就会不断尝试重新创建和销毁 Pod，陷入无限循环。需要注意的是，一个 Pod 可以由一个或多个容器组成。</p><ul><li>下面的 YAML 配置内容定义了一个包含单个容器的 Pod，容器使用的是官方 Tomcat 镜像，并包含基本的端口和挂载配置 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mytomcat</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">tomcat:9.0</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/local/tomcat/webapps</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-data</span></span><br><span class="line">      <span class="attr">emptyDir:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>YAML 配置内容的详细说明</li></ul><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td><code>metadata.name</code></td><td>Pod 的名称，必须唯一</td></tr><tr><td><code>metadata.labels</code></td><td>标签，用于标识和选择 Pod</td></tr><tr><td><code>spec.containers</code></td><td>容器列表，一个 Pod 可包含一个或多个容器</td></tr><tr><td><code>spec.containers[].name</code></td><td>容器的名称，在 Pod 内部唯一</td></tr><tr><td><code>spec.containers[].image</code></td><td>容器使用的镜像，这里是 <code>tomcat:9.0</code></td></tr><tr><td><code>spec.containers[].ports</code></td><td>容器开放的端口列表</td></tr><tr><td><code>spec.containers[].ports[].containerPort</code></td><td>容器内部监听的端口号（如 Tomcat 默认 8080）</td></tr><tr><td><code>spec.containers[].volumeMounts</code></td><td>容器内挂载的卷配置</td></tr><tr><td><code>spec.containers[].volumeMounts[].name</code></td><td>要挂载的卷名称，对应 <code>spec.volumes</code> 中定义的名称</td></tr><tr><td><code>spec.containers[].volumeMounts[].mountPath</code></td><td>挂载点路径，如 <code>/usr/local/tomcat/webapps</code></td></tr><tr><td><code>spec.volumes</code></td><td>定义 Pod 中使用的卷</td></tr><tr><td><code>spec.volumes[].name</code></td><td>卷的名称，与 <code>volumeMounts</code> 中的名称对应</td></tr><tr><td><code>spec.volumes[].emptyDir</code></td><td>使用一个空目录卷，Pod 删除时数据也会被清除</td></tr></tbody></table><h4 id="Pod-的分类"><a href="#Pod-的分类" class="headerlink" title="Pod 的分类"></a>Pod 的分类</h4><p>Pod 有两种类型：</p><ul><li><p><strong>普通 Pod</strong>  </p><ul><li> 普通 Pod 被创建后会被存储到 Etcd 中，随后由 Kubernetes Master 调度到某个特定的 Node 上并与之绑定。该 Node 上的 kubelet 进程会负责将 Pod 实例化为一组相关的容器（如 Docker 容器）并启动它们。默认情况下，如果 Pod 中的某个容器停止运行，Kubernetes 会自动检测并重启该 Pod 内的所有容器。如果 Pod 所在的 Node 发生宕机，Kubernetes 会将该 Node 上的所有 Pod 重新调度到其他可用节点上。</li></ul></li><li><p><strong>静态 Pod</strong>  </p><ul><li> 静态 Pod 是由 kubelet 直接管理的特殊 Pod，仅存在于特定的 Node 上。它们不受 API Server 管理，也无法与 ReplicationController、Deployment 或 DaemonSet 等控制器关联。此外，kubelet 对静态 Pod 的健康检查能力有限，通常仅能监控其运行状态，而不会像普通 Pod 那样提供完整的健康检查机制。</li></ul></li></ul><h4 id="Pod-的状态"><a href="#Pod-的状态" class="headerlink" title="Pod 的状态"></a>Pod 的状态</h4><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td> Pending</td><td>API Server 已创建该 Pod，但 Pod 中的一个或多个容器的镜像尚未创建（包括镜像下载过程）。</td></tr><tr><td>Running</td><td>Pod 内所有容器已创建，且至少有一个容器处于运行状态（包括正在启动或重启的状态）。</td></tr><tr><td>Completed</td><td>Pod 内所有容器均已成功执行并退出，且不会再重启。</td></tr><tr><td>Failed</td><td>Pod 内所有容器均已退出，但至少有一个容器退出失败。</td></tr><tr><td>Unknown</td><td> 由于某些原因（如网络通信不畅）无法获取 Pod 的状态。</td></tr></tbody></table><h4 id="Pod-的重启策略"><a href="#Pod-的重启策略" class="headerlink" title="Pod 的重启策略"></a>Pod 的重启策略</h4><p>Pod 的重启策略包括 Always、OnFailure 和 Never，默认值是 Always。</p><table><thead><tr><th>重启策略</th><th>说明</th></tr></thead><tbody><tr><td> Always</td><td> 当容器失效时，由 kubelet 自动重启该容器。</td></tr><tr><td>OnFailure</td><td> 当容器终止运行且退出码不为 0 时，由 kubelet 自动重启该容器。</td></tr><tr><td>Never</td><td> 不论容器运行状态如何，kubelet 都不会重启该容器。</td></tr></tbody></table><h4 id="Pod-的状态转换"><a href="#Pod-的状态转换" class="headerlink" title="Pod 的状态转换"></a>Pod 的状态转换</h4><p>Pod 状态转换表（基于容器事件和重启策略）如下：</p><table><thead><tr><th>Pod 包含的容器数</th><th> Pod 当前的状态</th><th>发生事件</th><th> Pod 的结果状态（RestartPolicy=Always）</th><th>Pod 的结果状态（RestartPolicy=OnFailure）</th><th>Pod 的结果状态（RestartPolicy=Never）</th></tr></thead><tbody><tr><td>1 个容器</td><td> Running</td><td> 容器成功退出</td><td> Running</td><td>Succeeded</td><td>Succeeded</td></tr><tr><td>1 个容器</td><td> Running</td><td> 容器失败退出</td><td> Running</td><td>Running</td><td>Failed</td></tr><tr><td>2 个容器</td><td> Running</td><td>1 个容器失败退出</td><td> Running</td><td>Running</td><td>Running</td></tr><tr><td>2 个容器</td><td> Running</td><td> 容器被 OOM 终止</td><td> Running</td><td>Running</td><td>Failed</td></tr></tbody></table><ul><li> 关键说明：<ul><li><strong>OOM</strong>：表示容器因内存不足（Out Of Memory）被系统终止</li><li>状态转换规则：<ul><li><code>Always</code>：任何容器终止都会触发重启（保持 Running 状态）</li><li><code>OnFailure</code>：仅当容器异常退出（非 0 状态码 / OOM）时重启</li><li><code>Never</code>：容器终止后直接反映最终状态（Succeeded/Failed）</li></ul></li><li>多容器 Pod 的状态由所有容器的综合状态决定</li></ul></li></ul><h4 id="Pod-的资源配置"><a href="#Pod-的资源配置" class="headerlink" title="Pod 的资源配置"></a>Pod 的资源配置</h4><p>每个 Pod 都可以对其可使用的 Node（节点）计算资源设置限额。Kubernetes 支持对以下两种计算资源进行配额限制：</p><ul><li><p>资源类型  </p><ul><li>CPU 资源：以绝对值的 CPU 数量为单位（比如 <code>500m</code> 表示 0.5 个 CPU 核心）。</li><li>Memory 资源：内存大小以字节数为单位（比如 <code>512Mi</code> 表示 512 MiB 内存）。</li></ul></li><li><p>配额参数  </p><ul><li>每种资源需要定义两个关键参数：  </li><li>Requests<ul><li> 表示该资源的最小申请量。</li><li>Kubernetes 调度器会确保 Node（节点）剩余资源大于等于 Requests 值，否则 Pod 无法被调度。</li></ul></li><li>Limits<ul><li> 表示该资源的最大允许使用量。若容器尝试使用超过 Limits 的资源：<ul><li>对于 CPU 资源，容器会被限制（Throttled）。</li><li>对于 Memory 资源，容器可能被 Kubernetes 终止（OOM Kill）并重启。</li></ul></li></ul></li></ul></li></ul><p>下述 YAML 配置内容表示 MySQL 容器申请最少 <code>0.25</code> 个 CPU 以及 <code>64MiB</code> 内存，在运行过程中容器所能使用的最大资源配额为 <code>0.5</code> 个 CPU 以及 <code>128MiB</code> 内存。</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"128Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"500m"</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AI 应用（AI-Agent）开发新范式</title>
    <link href="https://www.techgrow.cn/posts/a7fade9c.html"/>
    <id>https://www.techgrow.cn/posts/a7fade9c.html</id>
    <published>2025-07-22T11:41:00.000Z</published>
    <updated>2025-07-22T11:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><div class="row"><embed src="/pdf/AI应用（AI-Agent）开发新范式.pdf" width="100%" height="1024px" isolation="isolate" type="application/pdf"></div>]]></content>
    
    
    <summary type="html">AI 应用 与 AI Agent 开发新范式。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="AI" scheme="https://www.techgrow.cn/tags/AI/"/>
    
    <category term="在线电子书" scheme="https://www.techgrow.cn/tags/%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 手写高性能网络库（Muduo）</title>
    <link href="https://www.techgrow.cn/posts/dbb10768.html"/>
    <id>https://www.techgrow.cn/posts/dbb10768.html</id>
    <published>2025-07-15T13:55:33.000Z</published>
    <updated>2025-07-15T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写高性能网络库（Muduo）</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 实现类似于 Muduo 这样的高性能网路库。</p>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 开发一款高性能网络库（Muduo）。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMake 开发随笔</title>
    <link href="https://www.techgrow.cn/posts/5e16ffff.html"/>
    <id>https://www.techgrow.cn/posts/5e16ffff.html</id>
    <published>2025-06-25T15:36:32.000Z</published>
    <updated>2025-06-25T15:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="源文件路径"><a href="#源文件路径" class="headerlink" title="源文件路径"></a>源文件路径</h2><table><thead><tr><th>变量名</th><th>含义</th><th>会因 <code>add_subdirectory()</code> 变化</th><th>会因 <code>project()</code> 变化</th><th>用途</th><th>推荐使用场景</th></tr></thead><tbody><tr><td><code>CMAKE_SOURCE_DIR</code></td><td>顶层 CMake 项目的源代码目录（CMake 最初运行的目录）</td><td>❌ 否</td><td>❌ 否</td><td>全局设置、根路径引用</td><td>获取整个 CMake 项目的根目录</td></tr><tr><td><code>PROJECT_SOURCE_DIR</code></td><td>当前 <code>project()</code> 指令所在目录</td><td>✅ 是</td><td>✅ 是</td><td>模块级路径引用（推荐）</td><td>获取当前模块（Project）目录</td></tr><tr><td><code>CMAKE_CURRENT_SOURCE_DIR</code></td><td>当前 <code>CMakeLists.txt</code> 文件所在目录</td><td>✅ 是</td><td>❌ 否</td><td>当前目录相关文件引用（强烈推荐）</td><td>获取当前 CMakeLists 所在目录</td></tr></tbody></table><span id="more"></span>]]></content>
    
    
    <summary type="html">本文主要介绍记录 CMake 日常开发中的使用技巧和踩坑经历。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发随笔" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 实现 RPC 分布式网络通信框架</title>
    <link href="https://www.techgrow.cn/posts/5e6aa28a.html"/>
    <id>https://www.techgrow.cn/posts/5e6aa28a.html</id>
    <published>2025-06-08T13:55:33.000Z</published>
    <updated>2025-06-21T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写高性能网络库（Muduo）</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 Muduo 高性能网络库 + Protobuf 开发 RPC 框架，并使用中间件 ZooKeeper。</p><span id="more"></span><h3 id="开发工具列表"><a href="#开发工具列表" class="headerlink" title="开发工具列表"></a>开发工具列表</h3><table><thead><tr><th>软件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>17</code></td><td>高版本的 Protobuf 库依赖 C++ 17</td></tr><tr><td>Boost</td><td><code>1.74.0.3</code></td><td>Muduo 库依赖 Boost 库</td></tr><tr><td> Muduo</td><td><code>2.0.3</code></td><td><a href="https://github.com/chenshuo/muduo">Muduo 库</a>，基于 C++ 开发，用于网络编程</td></tr><tr><td> Protobuf</td><td><code>31.1</code></td><td><a href="https://github.com/protocolbuffers/protobuf">Protobuf 库</a>，核心代码主要是用 C++ 开发</td></tr><tr><td> ZooKeeper C API</td><td><code>3.8.0</code></td><td>ZooKeeper 提供的原生 C API，基于 C 语言开发</td></tr><tr><td> G++（GCC）</td><td><code>12.2.0</code></td><td>建议使用 <code>9</code> 版本的 G++（GCC） 编译器</td></tr><tr><td> CMake</td><td><code>3.25.1</code></td><td>C/C++ 项目构建工具</td></tr><tr><td> ZooKeeper</td><td><code>3.8.0</code></td><td>ZooKeeper 服务器</td></tr><tr><td> Linux</td><td><code>Debian 12</code></td><td>Muduo 库不支持 Windows 平台</td></tr><tr><td> Visual Studio Code</td><td><code>1.100.2</code></td><td>使用 VSCode 远程开发特性</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">平台兼容性说明</p><p>由于使用了 Muduo 库，且 Muduo 库仅支持 Linux 平台；因此本文提供的所有 RPC 框架代码支持在 Linux 平台运行，不支持 Windows 平台，默认是基于 Debian 12 进行远程开发。</p></div><h3 id="开源-RPC-框架"><a href="#开源-RPC-框架" class="headerlink" title="开源 RPC 框架"></a>开源 RPC 框架</h3><h4 id="大厂开源框架"><a href="#大厂开源框架" class="headerlink" title="大厂开源框架"></a>大厂开源框架</h4><ul><li><a href="https://github.com/grpc/grpc">gRPC</a> 是一个由 Google 开源、基于 HTTP/2 和 Protocol Buffers 的高性能 RPC 框架，使用 C++ 开发，支持多种语言（如 Go、Java、Python 等）。</li><li><a href="https://github.com/apache/brpc">bRPC</a> 是百度开源的高性能、可扩展的 RPC 框架，主要用于服务器间通信，采用 C++ 编写，广泛应用于百度内部大规模分布式系统中。</li><li><a href="https://github.com/Tencent/phxrpc">phxrpc</a> 是腾讯微信后台团队推出的一个非常简洁小巧的 RPC 框架，编译生成的库只有 450K。</li></ul><h4 id="个人开源框架"><a href="#个人开源框架" class="headerlink" title="个人开源框架"></a>个人开源框架</h4><ul><li><a href="https://github.com/Gooddbird/tinyrpc">tinyrpc</a> - c++ async rpc framework. 14w+ qps.</li><li><a href="https://github.com/Gooddbird/rocket">rocket</a> - c++ rpc framework, simplified version of tinyrpc.</li><li><a href="https://github.com/qicosmos/rest_rpc">rest_rpc</a>  - modern c++, simple, easy to use rpc framework.</li><li><a href="https://github.com/rpclib/rpclib">rpclib</a> - a modern c++ msgpack-RPC server and client library.</li><li><a href="https://github.com/TarsCloud/TarsCpp?tab=readme-ov-file">TarsCpp</a> - c++ language framework rpc source code implementation.</li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="集群和分布式"><a href="#集群和分布式" class="headerlink" title="集群和分布式"></a>集群和分布式</h3><ul><li><p><strong>集群</strong></p><ul><li>概念<ul><li>每一台服务器独立运行一个工程的所有模块。</li></ul></li><li>优点<ul><li>部署简单：每台机器部署一样的工程，维护相对简单。</li><li>容错性强：某台机器宕机，其它机器可以顶上，保证服务连续。</li><li>扩展方便：增加机器即可横向扩展，提高并发处理能力。</li><li>负载均衡容易：前端加个负载均衡器即可实现请求均衡分发。</li></ul></li><li>缺点<ul><li>资源浪费：每台机器都部署所有模块，某些模块可能资源使用率低。</li><li>维护更新不灵活：改动一个模块需要重新部署整个工程。</li><li>扩展粒度粗：不能单独扩展某个压力大的模块（有些模块是 CPU 密集型，有些模块是 I/O 密集型），只能整体扩容。</li></ul></li></ul></li><li><p><strong>分布式</strong></p><ul><li>概念<ul><li>一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务。</li><li>每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</li></ul></li><li>优点<ul><li>资源利用率高：按模块实际资源需求进行部署，提高系统整体资源使用效率。</li><li>扩展灵活：哪个模块压力大就单独扩展它，不影响其它模块。</li><li>服务解耦：模块之间独立部署、独立维护，开发和运维更灵活。</li><li>技术异构性好：不同模块可以使用不同的技术栈，更自由地选择工具。</li></ul></li><li>缺点<ul><li>系统复杂度高：涉及服务间通信、分布式事务、网络延迟等问题。</li><li>开发运维成本高：部署、调试、监控、容错等方面的技术要求更高。</li><li>依赖网络稳定性：模块之间通过网络通信，一旦网络出问题可能会引发级联故障。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">详细图解说明</p><ul><li><a href="../../../asset/2025/01/cluster-distribute-1.png">集群和分布式的理解</a></li><li><a href="../../../asset/2024/12/dubbo-16.png">单体架构的部署拓扑图</a></li><li><a href="../../../asset/2024/12/dubbo-15.png">集群架构的部署拓扑图</a></li><li><a href="../../../asset/2024/12/dubbo-14.png">分布式架构的部署拓扑图</a></li></ul></div><div class="admonition warning"><p class="admonition-title">特别注意</p><p><strong>在企业的生产环境中，集群和分布式是并存的，两者并不是分开的。</strong></p></div><h3 id="RPC-通信原理"><a href="#RPC-通信原理" class="headerlink" title="RPC 通信原理"></a>RPC 通信原理</h3><p>RPC（Remote Procedure Call）远程过程调用的工作流程如下图所示：</p><p><img data-src="../../../asset/2025/06/cxx-rpc-1.png"></p><ul><li><strong>黄色部分</strong>：设计 RPC 方法参数的打包和解析，也就是数据的序列化和反序列化，可以使用 Protobuf 实现。</li><li><strong>绿色部分</strong>：网络通信部分，包括寻找 RPC 服务主机、发起 RPC 调用请求和响应 RPC 调用结果，可以使用 Muduo 网络库和 ZooKeeper（用于服务注册与发现）实现 。</li></ul><h3 id="网络-I-O-模型"><a href="#网络-I-O-模型" class="headerlink" title="网络 I/O 模型"></a>网络 I/O 模型</h3><p>主流的网络 I/O 模型有以下几种，Muduo 采用的是第四种（<code>reactors in threads - one loop per thread</code>）。</p><ul><li><p>(1) <code>accept + read/write</code></p><ul><li>不适用于并发服务器</li></ul></li><li><p> (2) <code>accept + fork - process-pre-connection</code></p><ul><li>适合并发连接数不大，计算任务工作量大于 Fork 的开销。</li></ul></li><li><p>(3) <code>accept + thread - thread-pre-connection</code></p><ul><li>比第二种网络 I/O 模型的开销小了一点，但是并发造成的线程堆积过多。</li></ul></li><li><p>(4) <code>reactors in threads - one loop per thread</code></p><ul><li>这是 Muduo 库的网络设计方案，底层实质上是基于 Linux 的 <code>epoll</code> + <code>pthread</code> 线程池实现，且依赖了 Boost 库，适用于并发连接数较大的场景。</li><li>有一个 Main Reactor 负载 Accept 连接，然后将连接分发给某个 SubReactor（采用轮询的方式来选择 SubReactor），该连接的所用操作都在那个 SubReactor 所处的线程中完成。多个连接可能被分派到多个线程中被处理，以充分利用 CPU。</li><li>有一个 Base I/O Thread 负责 Accept 新的连接，接收到新的连接以后，使用轮询的方式在 Reactor Pool 中找到合适的 SubReactor 将这个连接挂载上去，这个连接上的所有任务都在这个 SubReactor  所处的线程中完成。</li><li>Reactor Poll 的大小是固定的，根据 CPU 的核心数量来确定。如果有过多的耗费 CPU 资源的计算任务，可以提交到 ThreadPool 线程池中专门处理耗时的计算任务。</li></ul></li><li><p>(5) <code>reactors in process - one loop pre process</code></p><ul><li>这是 Nginx 服务器的网络设计方案，基于进程设计，采用多个 Reactors 充当 I/O 进程和工作进程，通过一个 <code>accept</code> 锁，完美解决多个 Reactors 之间的 “惊群现象”。</li></ul></li></ul><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p>本文基于 C++ 实现 RPC 框架时，使用到以下框架，主要包括 Muduo、Protobuf、ZooKeeper C API。</p><h3 id="Muduo-的简介"><a href="#Muduo-的简介" class="headerlink" title="Muduo 的简介"></a>Muduo 的简介</h3><p>Muduo 是一个用 C++ 编写的高性能、基于事件驱动的网络库，专门设计用于构建 Linux 下高并发、低延迟的网络服务，特别适合开发分布式系统、微服务、消息中间件、网络游戏服务器等后端程序。</p><ul><li><p>核心特性</p><ul><li>基于事件驱动模型：使用 Reactor 模式，即单线程 I/O + 多线程计算。</li><li>高性能：使用 <code>epoll</code> I/O 多路复用技术、非阻塞 I/O、零内存拷贝技术。</li><li>线程安全：网络部分是线程安全的，使用线程池和回调。</li><li>C++ 11 标准：需要使用支持 C++ 11 的编译器。</li><li>仅支持 Linux 平台：利用 Linux 特性优化性能，不支持跨平台。</li><li>可组合性强：解耦的模块设计，便于扩展和组合。</li></ul></li><li><p>核心模块</p><ul><li><code>base</code>（基础模块）<ul><li>非网络相关的通用工具</li><li>如线程池、时间戳、日志系统、原子操作等</li></ul></li><li><code>net</code>（网络模块）<ul><li>TCP 服务器 / 客户端模型</li><li> Reactor 事件分发器</li><li> Buffer、Channel、EventLoop、TcpConnection 等核心组件</li></ul></li></ul></li><li><p>核心组件</p><ul><li>EventLoop<ul><li> 事件循环，是每个线程的核心对象</li><li>封装了 <code>epoll</code> 库，处理文件描述符的读写事件</li></ul></li><li> Channel<ul><li> 表示一个 <code>fd</code>（文件描述符）及其感兴趣的事件（如读写）</li><li>是 EventLoop 与具体 I/O 事件之间的桥梁</li></ul></li><li> Poller<ul><li> 封装 <code>epoll</code> 或 <code>poll</code> 的接口（Muduo 默认用 <code>epoll</code>）</li></ul></li><li>TcpServer / TcpClient<ul><li> 高层封装，简化服务端和客户端的使用</li><li>支持多线程连接处理</li></ul></li><li> Callback 机制<ul><li>所有 I/O 事件都通过用户注册的回调函数处理（高扩展性）</li></ul></li></ul></li><li><p>性能优势</p><ul><li>完全采用非阻塞、异步 I/O 模型</li><li>使用智能指针管理资源（如 <code>std::shared_ptr&lt;TcpConnection&gt;</code>）</li><li>零内存拷贝的数据缓冲机制（Buffer）</li><li>合理利用多线程资源（EventLoopThreadPool）</li></ul></li><li><p>适用场景</p><ul><li>高并发 TCP 服务器（如 Redis、MQTT、游戏网关）</li><li>微服务通信框架（可自定义通信协议）</li><li>高性能 HTTP 服务（支持 HTTP 1.0/1.1）</li><li>自研 RPC 系统</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">平台兼容性</p><ul><li>Muduo 库只支持 Linux 平台，不兼容 Windows 平台，因为其底层使用了 Linux 平台的 <code>pthread</code> 和 <code>epoll</code>。</li></ul></div><h3 id="Protobuf-的简介"><a href="#Protobuf-的简介" class="headerlink" title="Protobuf 的简介"></a>Protobuf 的简介</h3><ul><li><p>Protocol Buffers（简称 Protobuf）是 Google 提出的一种高效、可扩展的结构化数据序列化格式，用于数据交换。它独立于平台和编程语言，具有良好的跨平台兼容性和扩展性。</p></li><li><p>Google 为多种主流编程语言提供了 Protobuf 的官方实现，包括 Java、C#、C++、Go 和 Python 等。每种语言的实现都包含相应的编译器插件（<code>protoc</code>）和运行时库，使得开发者可以在不同语言间无缝进行数据通信。</p></li><li><p>由于 Protobuf 采用紧凑的二进制编码格式，其序列化和反序列化效率远高于基于文本的格式。相比 XML，Protobuf 的传输效率可提高约 20 倍；相比 JSON，也有近 10 倍的性能提升。这使得它特别适用于对性能要求高的场景。</p></li><li><p>Protobuf 广泛应用于分布式系统间的数据通信、异构平台的数据交换，也适合用作网络传输协议的数据格式、高效配置文件的载体、或用于数据持久化存储。作为一种兼具效率与可维护性的序列化方案，Protobuf 在大规模系统设计中具有极高的实用价值。</p></li></ul><h3 id="ZooKeeper-C-API-的简介"><a href="#ZooKeeper-C-API-的简介" class="headerlink" title="ZooKeeper C API 的简介"></a>ZooKeeper C API 的简介</h3><p>ZooKeeper C API 是 ZooKeeper 提供的一套原生 C 语言接口，它提供两个版本，包括 <code>libzookeeper_mt</code>（多线程版）和 <code>libzookeeper_st</code>（单线程版），可以用于 C/C++ 编写客户端程序，通常使用的是 <code>libzookeeper_mt</code>（多线程版）。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-Boost-库"><a href="#安装-Boost-库" class="headerlink" title="安装 Boost 库"></a>安装 Boost 库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Boost 的所有组件和头文件</span></span><br><span class="line">sudo apt-get install -y libboost-all-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Bootst 版本</span></span><br><span class="line">sudo dpkg -s libboost-all-dev | grep Version</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>由于 Muduo 使用了 Boost 库（如 <code>boost::any</code>），因此需要安装 Boost 库。</p></div><h3 id="安裝-Muduo-库"><a href="#安裝-Muduo-库" class="headerlink" title="安裝 Muduo 库"></a>安裝 Muduo 库</h3><ul><li>编译安装 Muduo 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chenshuo/muduo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入代码目录</span></span><br><span class="line"><span class="built_in">cd</span> muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Muduo 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Muduo 库的静态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep muduo</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Muduo 的编译依赖 CMake 和 Boost 库，默认编译生成的是静态库（<code>.a</code>），如果需要编译生成共享库（<code>.so</code>），可以自行修改 <code>CMakeLists.txt</code> 中的配置。</li><li>Muduo 支持 C++ 11，仅支持 Linux 平台，不支持 Windows 平台，建议使用 <code>7.x</code> 及以后版本的 <code>g++</code> 编译器。</li></ul></div><h3 id="安装-Protobuf-库"><a href="#安装-Protobuf-库" class="headerlink" title="安装 Protobuf 库"></a>安装 Protobuf 库</h3><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Protobuf 各个版本的源码包可以从 <a href="https://github.com/protocolbuffers/protobuf/releases">GitHub Release</a> 下载得到。</li><li>Protobuf 从 <code>3.21</code> 版本开始，Google 官方已经弃用了 <code>autogen.sh</code> 和 <code>configure</code> 构建系统，转而使用 CMake 作为主要构建系统。</li><li>Protobuf 从源码编译后，默认只会生成 <code>.a</code> 静态库文件，若希望生成 <code>.so</code> 动态库文件，需要在编译时添加 CMake 参数 <code>-DBUILD_SHARED_LIBS=ON</code>，加上参数后只会生成 <code>.so</code> 动态库文件。</li></ul></div><ul><li>安装依赖包 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install cmake g++ make git wget</span><br></pre></td></tr></tbody></table></figure><ul><li>编译安装 Protobuf 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://github.com/protocolbuffers/protobuf/archive/refs/tags/v31.1.tar.gz -O protobuf-v31.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf protobuf-v31.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cd</span> protobuf-31.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化子模块</span></span><br><span class="line">git init &amp;&amp; git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件（Makefile）</span></span><br><span class="line">cmake .. -DBUILD_SHARED_LIBS=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码（耗时较长）</span></span><br><span class="line">make -j2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装（包括可执行文件、头文件和库）</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 Protobuf 库安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Protobuf 库的版本</span></span><br><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Protobuf 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/google/protobuf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Protobuf 库的动态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib/libproto*</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-ZooKeeper-中间件"><a href="#安装-ZooKeeper-中间件" class="headerlink" title="安装 ZooKeeper 中间件"></a>安装 ZooKeeper 中间件</h3><h4 id="安装-ZooKeeper-服务器"><a href="#安装-ZooKeeper-服务器" class="headerlink" title="安装 ZooKeeper 服务器"></a>安装 ZooKeeper 服务器</h4><ul><li>安装 ZooKeeper 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ZooKeeper 客户端和服务器</span></span><br><span class="line">sudo apt install -y zookeeper zookeeperd</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 ZooKeeper 客户端的软链接 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 客户端的安装位置</span></span><br><span class="line">sudo dpkg -L zookeeper | grep -E <span class="string">'zkCli.sh|zkEnv.sh'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 ZooKeeper 客户端的软链接（方便以后直接运行客户端）</span></span><br><span class="line">sudo ln -s /usr/share/zookeeper/bin/zkCli.sh /usr/<span class="built_in">local</span>/bin/zkCli.sh</span><br><span class="line">sudo ln -s /usr/share/zookeeper/bin/zkEnv.sh /usr/<span class="built_in">local</span>/bin/zkEnv.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 ZooKeeper 服务器安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 服务器的运行状态</span></span><br><span class="line">sudo systemctl status zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 ZooKeeper 客户端连接 ZooKeeper 服务器</span></span><br><span class="line">zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></tbody></table></figure><ul><li>ZooKeeper 服务器的安装信息</li></ul><table><thead><tr><th>安装信息</th><th>说明</th></tr></thead><tbody><tr><td>默认的监听端口</td><td><code>2181</code></td></tr><tr><td>默认的数据目录</td><td><code>/tmp/zookeeper</code></td></tr><tr><td>默认配置文件的路径</td><td><code>/etc/zookeeper/conf/zoo.cfg</code></td></tr></tbody></table><h4 id="安装-ZooKeeper-C-API-库"><a href="#安装-ZooKeeper-C-API-库" class="headerlink" title="安装 ZooKeeper C API 库"></a>安装 ZooKeeper C API 库</h4><p>由于本文的 RPC 项目使用 ZooKeeper C API 库来实现 RPC 服务动态注册和发现，因此需要安装 ZooKeeper C API 库。值得一提的是，ZooKeeper 提供了一个 <code>libzookeeper_mt</code>（多线程版）或 <code>libzookeeper_st</code>（单线程版）原生 C API，可以用于 C/C++ 编写客户端程序，通常使用的是 <code>libzookeeper_mt</code>（多线程版）。在 Linux 系统上，除了可以通过 APT / YUM 包管理工具直接安装 ZooKeeper C API 库，还可以手动编译 ZooKeeper 的源码来安装 ZooKeeper C API 库，具体编译步骤为 <code>.configure</code> + <code>make</code> + <code>makeinstall</code>，默认会编译生成多线程版本的库（<code>libzookeeper_mt.so</code>）和单线程版的库（如 <code>libzookeeper_st.so</code>）。</p><ul><li>安装 ZooKeeper C API 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ZooKeeper 多线程版的开发包（单线程版本是：libzookeeper-st-dev）</span></span><br><span class="line">sudo apt install -y libzookeeper-mt-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 ZooKeeper C API 库安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 的头文件</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep zookeeper.h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 的静态库</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep <span class="string">'\.a$'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 的动态库</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep <span class="string">'\.so'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>ZooKeeper C API 库的安装信息</li></ul><table><thead><tr><th>安装信息</th><th>说明</th></tr></thead><tbody><tr><td>头文件的路径</td><td><code>/usr/include/zookeeper/zookeeper.h</code></td></tr><tr><td>静态库的路径</td><td><code>/usr/lib/x86_64-linux-gnu/libzookeeper_mt.a</code></td></tr><tr><td>动态库的路径</td><td><code>/usr/lib/x86_64-linux-gnu/libzookeeper_mt.so</code></td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">使用原生 ZooKeeper C API 库的注意事项</p><ul><li>(1) 设置监听 Watcher 是一次性的，监听事件触发后 Watch 会立即失效，ZooKeeper 不会自动重新注册。若希望持续监听同一个节点变化，需要在回调中手动再次注册 Watch。</li><li>(2) ZNode 节点仅支持存储简单的 <code>byte</code> 字节数组（最大 1MB），不具备结构化存储能力。如果需要存储结构体或对象，需要自行将其转换为字节数组，例如使用 JSON、Protobuf 等序列化方式进行编码与解码。</li></ul></div><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">c++-project-mprpc</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── conf</span><br><span class="line">│   └── rpc.conf</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── consumer</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── rpcconsumer.cc</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   ├── friend.pb.cc</span><br><span class="line">│   │   ├── friend.pb.h</span><br><span class="line">│   │   ├── user.pb.cc</span><br><span class="line">│   │   └── user.pb.h</span><br><span class="line">│   ├── proto</span><br><span class="line">│   │   ├── friend.proto</span><br><span class="line">│   │   └── user.proto</span><br><span class="line">│   └── provider</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">│       └── rpcprovider.cc</span><br><span class="line">├── lib</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   ├── rpcheader.pb.cc</span><br><span class="line">│   │   └── rpcheader.pb.h</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   ├── lockqueue.h</span><br><span class="line">│   │   ├── logger.h</span><br><span class="line">│   │   ├── mprpccontext.h</span><br><span class="line">│   │   ├── mprpcchannel.h</span><br><span class="line">│   │   ├── mprpcconfig.h</span><br><span class="line">│   │   ├── mprpccontroller.h</span><br><span class="line">│   │   ├── mprpcprovider.h</span><br><span class="line">│   │   ├── networkutil.h</span><br><span class="line">│   │   └── zookeeperclient.h</span><br><span class="line">│   ├── logger.cc</span><br><span class="line">│   ├── mprpccontext.cc</span><br><span class="line">│   ├── mprpcchannel.cc</span><br><span class="line">│   ├── mprpcconfig.cc</span><br><span class="line">│   ├── mprpccontroller.cc</span><br><span class="line">│   ├── mprpcprovider.cc</span><br><span class="line">│   ├── networkutil.cc</span><br><span class="line">│   ├── proto</span><br><span class="line">│   │   └── rpcheader.proto</span><br><span class="line">│   └── zookeeperclient.cc</span><br><span class="line">└── test</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── protobuf</span><br><span class="line">    │   ├── CMakeLists.txt</span><br><span class="line">    │   ├── generated</span><br><span class="line">    │   │   ├── addressbook.pb.cc</span><br><span class="line">    │   │   ├── addressbook.pb.h</span><br><span class="line">    │   │   ├── friendservice.pb.cc</span><br><span class="line">    │   │   ├── friendservice.pb.h</span><br><span class="line">    │   │   ├── groupservice.pb.cc</span><br><span class="line">    │   │   ├── groupservice.pb.h</span><br><span class="line">    │   │   ├── userservice.pb.cc</span><br><span class="line">    │   │   └── userservice.pb.h</span><br><span class="line">    │   ├── main.cc</span><br><span class="line">    │   └── proto</span><br><span class="line">    │       ├── addressbook.proto</span><br><span class="line">    │       ├── friendservice.proto</span><br><span class="line">    │       ├── groupservice.proto</span><br><span class="line">    │       └── userservice.proto</span><br><span class="line">    └── zookeeper</span><br><span class="line">        ├── CMakeLists.txt</span><br><span class="line">        └── main.cc</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>目录名称</th><th>目录说明</th></tr></thead><tbody><tr><td><code>build</code></td><td>CMake 编译构建项目的目录（项目首次编译后才会有）</td></tr><tr><td><code>bin</code></td><td>存放项目编译生成的可执行文件的目录（项目首次编译后才会有）</td></tr><tr><td><code>lib</code></td><td>存放项目编译生成的 RPC 框架头文件和静态库的目录（项目首次编译后才会有）</td></tr><tr><td><code>conf</code></td><td>存放 RPC 框架的配置文件</td></tr><tr><td><code>proto</code></td><td>存放 Protobuf 的 <code>.proto</code> 协议文件</td></tr><tr><td><code>generated</code></td><td>存放根据 <code>.proto</code> 协议文件生成的 C++ 头文件和源文件</td></tr><tr><td><code>src</code></td><td>RPC 框架源码</td></tr><tr><td><code>test</code></td><td>第三方库的测试代码</td></tr><tr><td><code>test/protobuf/</code></td><td>Protobuf 的测试代码</td></tr><tr><td><code>test/zookeeper/</code></td><td>ZooKeeper 的测试代码</td></tr><tr><td><code>example</code></td><td>RPC 框架的使用案例代码</td></tr><tr><td><code>example/provider</code></td><td>RPC 框架（服务提供者）的使用案例代码</td></tr><tr><td><code>example/consumer</code></td><td>RPC 框架（服务调用者）的使用案例代码</td></tr><tr><td><code>autobuild.sh</code></td><td>项目一键编译构建的脚本文件</td></tr></tbody></table><h3 id="项目原理"><a href="#项目原理" class="headerlink" title="项目原理"></a>项目原理</h3><p><img data-src="../../../asset/2025/06/cxx-rpc-2.png"></p><h3 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h3><p>基于 C++ 开发 RPC 框架时，使用到以下技术：</p><ul><li>单例模式</li><li> Conf 配置文件读取</li><li> Muduo 网络库编程</li><li> CMake 构建项目集成编译环境</li><li>异步日志记录（线程同步通信实现）</li><li>Protobuf 数据序列化和反序列化协议</li><li> ZooKeeper 分布式一致性协调服务应用以及编程</li></ul><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><h3 id="RPC-框架核心代码"><a href="#RPC-框架核心代码" class="headerlink" title="RPC 框架核心代码"></a>RPC 框架核心代码</h3><p>由于篇幅有限，下面只给出 RPC 框架项目的核心代码，完整的项目代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-mprpc">这里</a> 获取得到。</p><h4 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h4><ul><li><code>networkutil.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ifaddrs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络工具类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkUtil</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkUtil&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地的 IP 地址，可指定网络接口名称（比如 eth0）</span></span><br><span class="line">    <span class="function">std::string <span class="title">FindLocalIp</span><span class="params">(<span class="keyword">const</span> std::string&amp; network_interface = <span class="string">""</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个未被占用的端口，可指定端口区间（比如 [7000, 9000]）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindAvailablePort</span><span class="params">(<span class="keyword">int</span> low = <span class="number">7000</span>, <span class="keyword">int</span> high = <span class="number">9000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">NetworkUtil</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">NetworkUtil</span>(<span class="keyword">const</span> NetworkUtil&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    NetworkUtil&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NetworkUtil&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>networkutil.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"networkutil.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">NetworkUtil&amp; <span class="title">NetworkUtil::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> NetworkUtil instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本地的 IP 地址，可指定网络接口名称（比如 eth0）</span></span><br><span class="line"><span class="function">std::string <span class="title">NetworkUtil::FindLocalIp</span><span class="params">(<span class="keyword">const</span> std::string&amp; network_interface)</span> </span>{</span><br><span class="line">    std::string result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地网络接口的信息链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span>* <span class="title">ifaddr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getifaddrs</span>(&amp;ifaddr) == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// Fallback 处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历本地网络接口的信息链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* ifa = ifaddr; ifa; ifa = ifa-&gt;ifa_next) {</span><br><span class="line">        <span class="keyword">if</span> (!ifa-&gt;ifa_addr || ifa-&gt;ifa_addr-&gt;sa_family != AF_INET) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取网络接口的名称</span></span><br><span class="line">        <span class="function">std::string <span class="title">name</span><span class="params">(ifa-&gt;ifa_name)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过 lo 接口（回环接口）</span></span><br><span class="line">        <span class="keyword">if</span> (ifa-&gt;ifa_flags &amp; IFF_LOOPBACK) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指定了网络接口（如 eth0），且匹配上了，就直接使用</span></span><br><span class="line">        <span class="keyword">if</span> (!network_interface.<span class="built_in">empty</span>() &amp;&amp; name == network_interface) {</span><br><span class="line">            <span class="keyword">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;((struct sockaddr_in*)ifa-&gt;ifa_addr)-&gt;sin_addr, ip, <span class="built_in"><span class="keyword">sizeof</span></span>(ip));</span><br><span class="line">            result = ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认选择 eth0、ens33、enp0s3 等常见有线网卡</span></span><br><span class="line">        <span class="keyword">if</span> (network_interface.<span class="built_in">empty</span>() &amp;&amp; (name.<span class="built_in">find</span>(<span class="string">"eth"</span>) == <span class="number">0</span> || name.<span class="built_in">find</span>(<span class="string">"en"</span>) == <span class="number">0</span>)) {</span><br><span class="line">            <span class="keyword">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;((struct sockaddr_in*)ifa-&gt;ifa_addr)-&gt;sin_addr, ip, <span class="built_in"><span class="keyword">sizeof</span></span>(ip));</span><br><span class="line">            result = ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">freeifaddrs</span>(ifaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">empty</span>() ? <span class="string">"127.0.0.1"</span> : result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个未被占用的端口，可指定端口区间（比如 [7000, 9000]）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NetworkUtil::FindAvailablePort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历指定区间内的所有端口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> port = low; port &lt;= high; ++port) {</span><br><span class="line">        <span class="comment">// 创建一个 IPv4 TCP Socket</span></span><br><span class="line">        <span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 创建 Socket 失败，尝试下一个端口</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 Socket 地址，绑定到任意本地地址（0.0.0.0）和当前端口</span></span><br><span class="line">        sockaddr_in addr{};</span><br><span class="line">        addr.sin_family = AF_INET;</span><br><span class="line">        addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Socket 选项：SO_REUSEADDR 允许端口重复绑定（避免 TIME_WAIT 问题）</span></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in"><span class="keyword">sizeof</span></span>(opt));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试将 Socket 绑定到指定端口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (sockaddr*)&amp;addr, <span class="built_in"><span class="keyword">sizeof</span></span>(addr)) == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 绑定成功，释放资源（因为这里只是探测端口是否可用）</span></span><br><span class="line">            <span class="built_in">close</span>(sockfd);</span><br><span class="line">            <span class="comment">// 返回找到的可用端口</span></span><br><span class="line">            <span class="keyword">return</span> port;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 端口绑定失败，说明端口已被占用或其他错误，释放资源</span></span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历完指定的端口区间，没有找到可用端口，返回 -1 表示失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="异步日志记录"><a href="#异步日志记录" class="headerlink" title="异步日志记录"></a>异步日志记录</h4><ul><li><code>lockqueue.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步写日志的日志队列（线程安全）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 往队尾插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入数据</span></span><br><span class="line">        m_queue.<span class="built_in">push</span>(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒日志写入线程去消费队列中的数据</span></span><br><span class="line">        m_condvariable.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往队头弹出数据</span></span><br><span class="line">    <span class="function">T <span class="title">Pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到队列不为空或者已退出</span></span><br><span class="line">        m_condvariable.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>() || m_exit; });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视业务逻辑而定，可以返回空数据或者抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (m_exit &amp;&amp; m_queue.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">return</span> {};</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取队头元素</span></span><br><span class="line">        T data = m_queue.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出队头元素</span></span><br><span class="line">        m_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭队列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 设置退出标志</span></span><br><span class="line">        m_exit = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 唤醒正在等待的日志写入线程</span></span><br><span class="line">        m_condvariable.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取退出标志</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isExit</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> m_exit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex m_mutex;                      <span class="comment">// 互斥锁</span></span><br><span class="line">    std::queue&lt;T&gt; m_queue;                   <span class="comment">// 队列</span></span><br><span class="line">    std::condition_variable m_condvariable;  <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="keyword">bool</span> m_exit = <span class="literal">false</span>;                     <span class="comment">// 退出标志，用于避免发生线程死锁</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>logger.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lockqueue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG(logmsgformat, ...)                                \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= DEBUG) {                        \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {DEBUG, c, thread_id};                 \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO(logmsgformat, ...)                                 \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= INFO) {                         \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {INFO, c, thread_id};                  \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_WARN(logmsgformat, ...)                                 \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= WARN) {                         \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {WARN, c, thread_id};                  \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERROR(logmsgformat, ...)                                \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= ERROR) {                        \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {ERROR, c, thread_id};                 \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别（DEBUG &lt; INFO &lt; WARN &lt; ERROR）</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LogLevel</span> {</span></span><br><span class="line">    DEBUG,  <span class="comment">// 调试日志信息</span></span><br><span class="line">    INFO,   <span class="comment">// 普通日志信息</span></span><br><span class="line">    WARN,   <span class="comment">// 警告日志信息</span></span><br><span class="line">    ERROR,  <span class="comment">// 错误日志信息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LogMessage</span> {</span></span><br><span class="line">    LogLevel m_loglevel;         <span class="comment">// 日志级别</span></span><br><span class="line">    std::string m_logcontent;    <span class="comment">// 日志内容</span></span><br><span class="line">    std::thread::id m_threadid;  <span class="comment">// 打印日志的线程的 ID</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mprpc 框架提供的日志系统（单例对象，异步写入日志文件）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Logger&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入日志信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Log</span><span class="params">(<span class="keyword">const</span> LogMessage&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取日志级别</span></span><br><span class="line">    <span class="function">LogLevel <span class="title">GetLogLevel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetLogLevel</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LogLevel m_loglevel;             <span class="comment">// 记录日志级别</span></span><br><span class="line">    std::thread m_writeThread;       <span class="comment">// 日志写入线程</span></span><br><span class="line">    LockQueue&lt;LogMessage&gt; m_lckQue;  <span class="comment">// 日志缓冲队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="keyword">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算操作符</span></span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取日志级别的名称</span></span><br><span class="line">    <span class="function">std::string <span class="title">LogLevelToString</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>logger.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Logger::<span class="built_in">Logger</span>() {</span><br><span class="line">    <span class="comment">// 设置默认的日志级别</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_loglevel = INFO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动专门写日志文件的线程</span></span><br><span class="line">    m_writeThread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 获取当前日期</span></span><br><span class="line">            <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            tm* now_tm = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取日志文件的名称</span></span><br><span class="line">            <span class="keyword">char</span> file_name[<span class="number">128</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(file_name, <span class="string">"%d-%d-%d-log.txt"</span>, now_tm-&gt;tm_year + <span class="number">1900</span>, now_tm-&gt;tm_mon + <span class="number">1</span>, now_tm-&gt;tm_mday);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开日志文件</span></span><br><span class="line">            FILE* pf = <span class="built_in">fopen</span>(file_name, <span class="string">"a+"</span>);</span><br><span class="line">            <span class="keyword">if</span> (pf == <span class="literal">nullptr</span>) {</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"logger file "</span> &lt;&lt; file_name &lt;&lt; <span class="string">" open failed!"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从日志缓冲队列获取日志信息（会阻塞当前线程，直到日志队列不为空）</span></span><br><span class="line">            LogMessage message = m_lckQue.<span class="built_in">Pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查退出标志</span></span><br><span class="line">            <span class="keyword">if</span> (m_lckQue.<span class="built_in">isExit</span>()) {</span><br><span class="line">                <span class="comment">// 关闭日志文件</span></span><br><span class="line">                <span class="built_in">fclose</span>(pf);</span><br><span class="line">                <span class="comment">// 跳出外层 For 循环，结束日志写入线程的运行（会丢失未被写入的日志信息）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取打印日志信息的线程的 ID（可能为负数）</span></span><br><span class="line">            std::thread::id real_thread_id = message.m_threadid;</span><br><span class="line">            std::ostringstream oss;</span><br><span class="line">            oss &lt;&lt; real_thread_id;</span><br><span class="line">            std::string log_thread_id = oss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取日志内容和日志级别的名称</span></span><br><span class="line">            std::string&amp; log_content = message.m_logcontent;</span><br><span class="line">            std::string log_level_name = <span class="built_in">LogLevelToString</span>(message.m_loglevel);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前时间</span></span><br><span class="line">            <span class="keyword">char</span> time_buf[<span class="number">128</span>] = {<span class="number">0</span>};</span><br><span class="line">            <span class="built_in">sprintf</span>(time_buf, <span class="string">"%d-%d-%d %d:%d:%d =&gt; %d [%s] "</span>, now_tm-&gt;tm_year + <span class="number">1900</span>, now_tm-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                    now_tm-&gt;tm_mday, now_tm-&gt;tm_hour, now_tm-&gt;tm_min, now_tm-&gt;tm_sec, log_thread_id.<span class="built_in">c_str</span>(),</span><br><span class="line">                    log_level_name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加当前时间到日志内容的最前面</span></span><br><span class="line">            log_content.<span class="built_in">insert</span>(<span class="number">0</span>, time_buf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加换行符到日志内容的最后面</span></span><br><span class="line">            log_content.<span class="built_in">append</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志内容到控制台</span></span><br><span class="line">            std::cout &lt;&lt; log_content;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将日志内容写入日志文件</span></span><br><span class="line">            <span class="built_in">fputs</span>(log_content.<span class="built_in">c_str</span>(), pf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭日志文件</span></span><br><span class="line">            <span class="built_in">fclose</span>(pf);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Logger::~<span class="built_in">Logger</span>() {</span><br><span class="line">    <span class="comment">// 关闭队列，通知日志写入线程停止运行，避免发生线程死锁</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_lckQue.<span class="built_in">Stop</span>();</span><br><span class="line">    <span class="comment">// 等待日志线程安全退出</span></span><br><span class="line">    <span class="keyword">if</span> (m_writeThread.<span class="built_in">joinable</span>()) {</span><br><span class="line">        m_writeThread.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入日志信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::Log</span><span class="params">(<span class="keyword">const</span> LogMessage&amp; message)</span> </span>{</span><br><span class="line">    <span class="comment">// 将日志信息写入缓冲队列中</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_lckQue.<span class="built_in">Push</span>(message);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::SetLogLevel</span><span class="params">(LogLevel level)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_loglevel = level;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别</span></span><br><span class="line"><span class="function">LogLevel <span class="title">Logger::GetLogLevel</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_loglevel;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别的名称</span></span><br><span class="line"><span class="function">std::string <span class="title">Logger::LogLevelToString</span><span class="params">(LogLevel level)</span> </span>{</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (level) {</span><br><span class="line">        <span class="keyword">case</span> DEBUG:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DEBUG"</span>;</span><br><span class="line">        <span class="keyword">case</span> INFO:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"INFO"</span>;</span><br><span class="line">        <span class="keyword">case</span> WARN:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"WARN"</span>;</span><br><span class="line">        <span class="keyword">case</span> ERROR:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"UNKNOWN"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h4><ul><li><code>rpc.conf</code> 配置文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ZooKeeper的IP地址（必填）</span><br><span class="line">zk_server_host=127.0.0.1</span><br><span class="line"># ZooKeeper的端口号（必填）</span><br><span class="line">zk_server_port=2181</span><br><span class="line"># RPC服务提供者优先使用的网卡接口（可选）</span><br><span class="line">rpc_network_interface=eth1</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcconfig.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string ZK_SERVER_HOST_KEY = <span class="string">"zk_server_host"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string ZK_SERVER_PORT_KEY = <span class="string">"zk_server_port"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string RPC_NETWORK_INTERFACE_KEY = <span class="string">"rpc_network_interface"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 框架读取配置文件的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcConfig</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* config_file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">Load</span><span class="params">(<span class="keyword">const</span> std::string&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置信息（无需考虑线程安全问题）</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Trim</span><span class="params">(std::string&amp; str)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcconfig.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcconfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcConfig::LoadConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* config_file)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断是否已经加载过配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (!m_configMap.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开配置文件</span></span><br><span class="line">    FILE* pf = <span class="built_in">fopen</span>(config_file, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == pf) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"config file "</span> &lt;&lt; config_file &lt;&lt; <span class="string">" is not exist!"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析配置文件</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), pf)) {</span><br><span class="line">        <span class="function">std::string <span class="title">src_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line">        <span class="built_in">Trim</span>(src_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断注释内容</span></span><br><span class="line">        <span class="keyword">if</span> (src_buf.<span class="built_in">empty</span>() || src_buf[<span class="number">0</span>] == <span class="string">'#'</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        <span class="keyword">int</span> idx = src_buf.<span class="built_in">find_first_of</span>(<span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">-1</span>) {</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置项的 Key</span></span><br><span class="line">        std::string key = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置项的 Value</span></span><br><span class="line">        std::string value = src_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查配置项的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (key.<span class="built_in">empty</span>() || value.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储配置项</span></span><br><span class="line">        m_configMap.<span class="built_in">insert</span>({key, value});</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s=%s"</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(pf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::Load</span><span class="params">(<span class="keyword">const</span> std::string&amp; key)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">return</span> it != m_configMap.<span class="built_in">end</span>() ? it-&gt;second : <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcConfig::Trim</span><span class="params">(std::string&amp; str)</span> </span>{</span><br><span class="line">    <span class="comment">// 定义空白字符</span></span><br><span class="line">    <span class="keyword">const</span> std::string whitespace = <span class="string">" \n\r\t"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除字符串前面多余的空白字符</span></span><br><span class="line">    <span class="keyword">size_t</span> start = str.<span class="built_in">find_first_not_of</span>(whitespace);</span><br><span class="line">    <span class="keyword">if</span> (start != std::string::npos) {</span><br><span class="line">        str = str.<span class="built_in">substr</span>(start);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 字符串全是空白字符</span></span><br><span class="line">        str.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除字符串后面多余的空白字符</span></span><br><span class="line">    <span class="keyword">size_t</span> end = str.<span class="built_in">find_last_not_of</span>(whitespace);</span><br><span class="line">    <span class="keyword">if</span> (end != std::string::npos) {</span><br><span class="line">        str = str.<span class="built_in">substr</span>(<span class="number">0</span>, end + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Protobuf-协议文件"><a href="#Protobuf-协议文件" class="headerlink" title="Protobuf 协议文件"></a>Protobuf 协议文件</h4><ul><li><code>rpcheader.proto</code> 协议文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package mprpc;</span><br><span class="line"></span><br><span class="line">message RpcHeader {</span><br><span class="line">    // RPC 调用的服务名称</span><br><span class="line">    bytes service_name = 1;</span><br><span class="line"></span><br><span class="line">    // RPC 调用的方法名称</span><br><span class="line">    bytes method_name = 2;</span><br><span class="line"></span><br><span class="line">    // RPC 调用的参数长度（参数的序列化字符串的长度）</span><br><span class="line">    uint32 args_size = 3;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的初始化"><a href="#RPC-框架的初始化" class="headerlink" title="RPC 框架的初始化"></a>RPC 框架的初始化</h4><ul><li><code>mprpccontext.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcchannel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcconfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeper 节点的路径前缀</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> std::string ZNODE_PATH_PREFIX = <span class="string">"/mprpc/services"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MPRPC 框架的上下文类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcContext</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MprpcContext&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 RPC 框架</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MprpcConfig&amp; <span class="title">GetConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置信息</span></span><br><span class="line">    <span class="keyword">static</span> MprpcConfig m_config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">MprpcContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">MprpcContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MprpcContext</span>(<span class="keyword">const</span> MprpcContext&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    MprpcContext&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MprpcContext&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpccontext.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员变量</span></span><br><span class="line">MprpcConfig MprpcContext::m_config;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">MprpcContext::<span class="built_in">MprpcContext</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MprpcContext::~<span class="built_in">MprpcContext</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">MprpcContext&amp; <span class="title">MprpcContext::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> MprpcContext singleton;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印命令帮助内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowArgsHelp</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"format: command -i &lt;configfile&gt;"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 RPC 框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcContext::Init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">        <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">        <span class="comment">// 退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令行获取配置文件的路径</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">"i:"</span>)) != <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (c) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"invalid command args!"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">                <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">':'</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"need &lt;configfile&gt;"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">                <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"loading rpc config file %s"</span>, config_file.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置文件内容</span></span><br><span class="line">    m_config.<span class="built_in">LoadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置信息</span></span><br><span class="line"><span class="function">MprpcConfig&amp; <span class="title">MprpcContext::GetConfig</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_config;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的服务注册"><a href="#RPC-框架的服务注册" class="headerlink" title="RPC 框架的服务注册"></a>RPC 框架的服务注册</h4><ul><li><code>mprpcprovider.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"google/protobuf/service.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 框架专门提供用来发布 RPC 服务的网络对象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RpcProvider</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PublishService</span><span class="params">(google::protobuf::Service* service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// TCP 服务器的事件回环</span></span><br><span class="line">    muduo::net::EventLoop m_eventloop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 服务信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ServiceInfo</span> {</span></span><br><span class="line">        <span class="comment">// RPC 服务</span></span><br><span class="line">        google::protobuf::Service* m_service;</span><br><span class="line">        <span class="comment">// RPC 服务拥有的方法</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="keyword">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储注册成功的 RPC 服务的集合</span></span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 TCP 连接的创建和断开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理已建立 TCP 连接的读写事件（比如接收客户端发送的数据）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于序列化 RPC 调用的响应结果和发送网络响应数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcprovider.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcprovider.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"networkutil.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpcheader.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布 RPC 服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::PublishService</span><span class="params">(google::protobuf::Service* service)</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 服务的信息</span></span><br><span class="line">    ServiceInfo servcieInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的描述信息</span></span><br><span class="line">    <span class="keyword">const</span> google::protobuf::ServiceDescriptor* pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的完整名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">serviceName</span><span class="params">(pserviceDesc-&gt;full_name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的方法数量</span></span><br><span class="line">    <span class="keyword">int</span> methodCount = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 RPC 服务的所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) {</span><br><span class="line">        <span class="comment">// 获取 RPC 服务的方法的描述信息</span></span><br><span class="line">        <span class="keyword">const</span> google::protobuf::MethodDescriptor* pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        <span class="comment">// 获取 RPC 服务的方法的名称</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> std::string <span class="title">methodName</span><span class="params">(pmethodDesc-&gt;name())</span></span>;</span><br><span class="line">        <span class="comment">// 存储 RPC 服务的方法的描述信息</span></span><br><span class="line">        servcieInfo.m_methodMap.<span class="built_in">insert</span>({methodName, pmethodDesc});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 RPC 服务的信息</span></span><br><span class="line">    servcieInfo.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>({serviceName, servcieInfo});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取配置信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_host = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_HOST_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_port = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_PORT_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_network_interface =</span><br><span class="line">        MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(RPC_NETWORK_INTERFACE_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务提供者的 IP 和端口</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_server_ip = NetworkUtil::<span class="built_in">GetInstance</span>().<span class="built_in">FindLocalIp</span>(rpc_network_interface);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rpc_server_port = NetworkUtil::<span class="built_in">GetInstance</span>().<span class="built_in">FindAvailablePort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 服务提供者的端口是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == rpc_server_port) {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"not found available port for rpc server!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 TCP 服务器</span></span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(rpc_server_ip, rpc_server_port)</span></span>;</span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">tcpServer</span><span class="params">(&amp;m_eventloop, address, <span class="string">"RpcProvider"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP 连接创建和断开的回调</span></span><br><span class="line">    tcpServer.<span class="built_in">setConnectionCallback</span>(<span class="built_in">bind</span>(&amp;RpcProvider::onConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置已建立 TCP 连接读写事件的回调</span></span><br><span class="line">    tcpServer.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        <span class="built_in">bind</span>(&amp;RpcProvider::onMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 EventLoop 的线程数量（比如：1 个 I/O 线程，3 个 Worker 线程）</span></span><br><span class="line">    tcpServer.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ZK 客户端</span></span><br><span class="line">    ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="keyword">bool</span> started = zkClient.<span class="built_in">Start</span>(zk_server_host, <span class="built_in">atoi</span>(zk_server_port.<span class="built_in">c_str</span>()));</span><br><span class="line">    <span class="comment">// ZK 服务端连接失败</span></span><br><span class="line">    <span class="keyword">if</span> (!started) {</span><br><span class="line">        <span class="comment">// 停止往下继续执行，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有已发布的 RPC 服务注册进 ZK 服务端</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; service : m_serviceMap) {</span><br><span class="line">        <span class="comment">// RPC 服务的 IP 和端口信息</span></span><br><span class="line">        <span class="keyword">const</span> std::string rpc_address = rpc_server_ip + <span class="string">":"</span> + std::<span class="built_in">to_string</span>(rpc_server_port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RPC 服务的名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">        <span class="keyword">const</span> std::string service_name = service.first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的路径前缀，比如 /mprpc/services/user.UserServiceRpc</span></span><br><span class="line">        <span class="keyword">const</span> std::string path_prefix = ZNODE_PATH_PREFIX + <span class="string">"/"</span> + service_name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的完整路径，比如 /mprpc/services/user.UserServiceRpc/127.0.0.1:7070</span></span><br><span class="line">        <span class="keyword">const</span> std::string node_full_path = path_prefix + <span class="string">"/"</span> + rpc_address;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的数据，比如 127.0.0.1:7070</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* node_data = rpc_address.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的数据长度</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> node_data_len = rpc_address.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ZNode 节点（临时节点）</span></span><br><span class="line">        <span class="keyword">const</span> std::string created_path =</span><br><span class="line">            zkClient.<span class="built_in">CreateRecursive</span>(node_full_path.<span class="built_in">c_str</span>(), node_data, node_data_len, ZOO_EPHEMERAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 ZNode 节点是否创建成功（即 RPC 服务是否注册成功）</span></span><br><span class="line">        <span class="keyword">if</span> (!created_path.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="comment">// ZNode 节点创建成功</span></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"success to register rpc service, name: %s, path: %s, data: %s"</span>, service_name.<span class="built_in">c_str</span>(),</span><br><span class="line">                     node_full_path.<span class="built_in">c_str</span>(), node_data);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// ZNode 节点创建失败</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"failed to register rpc service, name: %s, path: %s, data: %s"</span>, service_name.<span class="built_in">c_str</span>(),</span><br><span class="line">                      node_full_path.<span class="built_in">c_str</span>(), node_data);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"rpc provider start at %s:%d"</span>, rpc_server_ip.<span class="built_in">c_str</span>(), rpc_server_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 TCP 服务器</span></span><br><span class="line">    tcpServer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以阻塞方式等待新客户端的连接、已连接客户端的读写事件等</span></span><br><span class="line">    m_eventloop.<span class="built_in">loop</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 TCP 连接的创建和断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;<span class="built_in">connected</span>()) {</span><br><span class="line">        <span class="comment">// 断开连接（释放资源）</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 TCP 连接的读写事件（比如接收客户端发送的数据）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 接收到的字符流，数据格式：header_size（4 字节） + header_str（service_name + method_name + args_size） + args_str</span></span><br><span class="line">    <span class="keyword">const</span> std::string recv_buf = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前 4 个字节的内容</span></span><br><span class="line">    <span class="keyword">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="keyword">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 header_size 读取请求数据头的原始字符流</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的基础信息</span></span><br><span class="line">    std::string service_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="keyword">uint32_t</span> args_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 请求数据头的反序列化</span></span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    <span class="keyword">if</span> (rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str)) {</span><br><span class="line">        <span class="comment">// 数据反序列化成功</span></span><br><span class="line">        service_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 数据反序列化失败</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc header string %s unserialize error!"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的参数的字符流数据</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"header_size: %u"</span>, header_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"rpc_header_str: %s"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"service_name: %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"method_name: %s"</span>, method_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_size: %u"</span>, args_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_str: %s"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 RPC 服务</span></span><br><span class="line">    <span class="keyword">auto</span> sit = m_serviceMap.<span class="built_in">find</span>(service_name);</span><br><span class="line">    <span class="comment">// 如果找不到对应的 RPC 服务</span></span><br><span class="line">    <span class="keyword">if</span> (sit == m_serviceMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc service %s is not exist!"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 RPC 服务的方法</span></span><br><span class="line">    <span class="keyword">auto</span> mit = sit-&gt;second.m_methodMap.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span> (mit == sit-&gt;second.m_methodMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc method %s::%s is not exist!"</span>, service_name.<span class="built_in">c_str</span>(), method_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的服务和方法</span></span><br><span class="line">    google::protobuf::Service* service = sit-&gt;second.m_service;</span><br><span class="line">    <span class="keyword">const</span> google::protobuf::MethodDescriptor* method = mit-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反序列化生成本地 RPC 方法调用的请求参数</span></span><br><span class="line">    google::protobuf::Message* request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span> (!request-&gt;<span class="built_in">ParseFromString</span>(rpc_args_str)) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc request args '%s' unserialize error!"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成本地 RPC 方法调用的响应结果</span></span><br><span class="line">    google::protobuf::Message* response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地 RPC 方法调用的回调，实际上调用的是 RpcProvider::SendRpcResponse()</span></span><br><span class="line">    google::protobuf::Closure* done =</span><br><span class="line">        google::protobuf::NewCallback&lt;RpcProvider, <span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp;, google::protobuf::Message*&gt;(</span><br><span class="line">            <span class="keyword">this</span>, &amp;RpcProvider::SendRpcResponse, conn, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 节点的本地方法</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于序列化 RPC 调用的响应结果和发送网络响应数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::SendRpcResponse</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span> </span>{</span><br><span class="line">    <span class="comment">// 序列化 RPC 调用的响应结果</span></span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span> (response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str)) {</span><br><span class="line">        <span class="comment">// 通过网络将本地 RPC 方法的执行结果发送给 RPC 服务调用方</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc response serialize error!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 模拟 HTTP 的短连接服务，由 RPC 服务提供方主动断开连接</span></span><br><span class="line">    conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的服务调用"><a href="#RPC-框架的服务调用" class="headerlink" title="RPC 框架的服务调用"></a>RPC 框架的服务调用</h4><ul><li><code>mprpccontroller.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcController</span> :</span> <span class="keyword">public</span> google::protobuf::RpcController {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MprpcController</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Failed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">ErrorText</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFailed</span><span class="params">(<span class="keyword">const</span> std::string&amp; reason)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前未实现具体的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartCancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsCanceled</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_failed;          <span class="comment">// RPC 方法执行过程中的状态</span></span><br><span class="line">    std::string m_errText;  <span class="comment">// RPC 方法执行过程中的错误信息</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpccontroller.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"></span><br><span class="line">MprpcController::<span class="built_in">MprpcController</span>() {</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errText = <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::Reset</span><span class="params">()</span> </span>{</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errText = <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MprpcController::Failed</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_failed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">MprpcController::ErrorText</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_errText;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::SetFailed</span><span class="params">(<span class="keyword">const</span> std::string&amp; reason)</span> </span>{</span><br><span class="line">    m_failed = <span class="literal">true</span>;</span><br><span class="line">    m_errText = reason;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(reason.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::StartCancel</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MprpcController::IsCanceled</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcchannel.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/message.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcChannel</span> :</span> <span class="keyword">public</span> google::protobuf::RpcChannel {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 随机生成一个整数，范围 [0, range-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomInt</span><span class="params">(<span class="keyword">int</span> range)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一实现 RPC 方法调用的数据序列化和网络数据发送（针对 RPC 服务调用者）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CallMethod</span><span class="params">(<span class="keyword">const</span> google::protobuf::MethodDescriptor* method, google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> google::protobuf::Message* request, google::protobuf::Message* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                    google::protobuf::Closure* done)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcchannel.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcchannel.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpcheader.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成一个整数，范围 [0, range-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MprpcChannel::randomInt</span><span class="params">(<span class="keyword">int</span> range)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (range &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::mt19937 <span class="title">gen</span><span class="params">(std::random_device{}())</span></span>;</span><br><span class="line">        std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>, range - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dis</span>(gen);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一实现 RPC 方法调用的数据序列化和网络数据发送（针对 RPC 服务调用者）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcChannel::CallMethod</span><span class="params">(<span class="keyword">const</span> google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                              google::protobuf::RpcController* controller, <span class="keyword">const</span> google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                              google::protobuf::Message* response, google::protobuf::Closure* done)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 RPC 服务的完整名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">service_name</span><span class="params">(method-&gt;service()-&gt;full_name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的方法名称</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">method_name</span><span class="params">(method-&gt;name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用参数的序列化字符串的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> args_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_args_str;</span><br><span class="line">    <span class="keyword">if</span> (request-&gt;<span class="built_in">SerializeToString</span>(&amp;rpc_args_str)) {</span><br><span class="line">        args_size = rpc_args_str.<span class="built_in">size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"rpc request serialize error!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 RPC 调用的请求数据头</span></span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    rpcHeader.<span class="built_in">set_service_name</span>(service_name);</span><br><span class="line">    rpcHeader.<span class="built_in">set_method_name</span>(method_name);</span><br><span class="line">    rpcHeader.<span class="built_in">set_args_size</span>(args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 请求数据头的序列化字符串的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    <span class="keyword">if</span> (rpcHeader.<span class="built_in">SerializeToString</span>(&amp;rpc_header_str)) {</span><br><span class="line">        header_size = rpc_header_str.<span class="built_in">size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"rpc header serialize error!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络发送的数据，格式：header_size（4 字节） + header_str（service_name + method_name + args_size） + args_str</span></span><br><span class="line">    std::string rpc_send_str;</span><br><span class="line">    rpc_send_str.<span class="built_in">insert</span>(<span class="number">0</span>, std::<span class="built_in">string</span>((<span class="keyword">char</span>*)&amp;header_size, <span class="number">4</span>));</span><br><span class="line">    rpc_send_str += rpc_header_str;</span><br><span class="line">    rpc_send_str += rpc_args_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"header_size: %u"</span>, header_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"rpc_header_str: %s"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"service_name: %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"method_name: %s"</span>, method_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_size: %u"</span>, args_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_str: %s"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地创建一个 TCP 客户端</span></span><br><span class="line">    <span class="keyword">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clientfd) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"create socket failed, errno is %d"</span>, errno);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ZK 服务端的连接信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_host = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_HOST_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_port = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_PORT_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ZK 客户端</span></span><br><span class="line">    ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="keyword">bool</span> started = zkClient.<span class="built_in">Start</span>(zk_server_host, <span class="built_in">atoi</span>(zk_server_port.<span class="built_in">c_str</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ZK 服务端启动失败</span></span><br><span class="line">    <span class="keyword">if</span> (!started) {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"zookeeper client connect failed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 服务对应的 ZNode 节点的路径，比如 /mprpc/services/user.UserServiceRpc</span></span><br><span class="line">    <span class="keyword">const</span> std::string node_path = ZNODE_PATH_PREFIX + <span class="string">"/"</span> + service_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ZNode 子节点列表（即已注册的 RPC 服务列表），比如 127.0.0.1:7070</span></span><br><span class="line">    std::vector&lt;std::string&gt; child_list = zkClient.<span class="built_in">GetChildren</span>(node_path.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ZNode 子节点列表为空（即查找不到已注册的 RPC 服务）</span></span><br><span class="line">    <span class="keyword">if</span> (child_list.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"not found rpc service %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机获取一个 RPC 服务提供者的地址，比如 127.0.0.1:7070</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = child_list.<span class="built_in">size</span>() == <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">randomInt</span>(child_list.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_addr = child_list[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 PRC 服务提供者的 IP 和端口</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> pos = rpc_provider_addr.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="comment">// 如果 RPC 服务提供者的地址无效</span></span><br><span class="line">    <span class="keyword">if</span> (std::string::npos == pos) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"invalid rpc service address %s"</span>, rpc_provider_addr.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_ip = rpc_provider_addr.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_port = rpc_provider_addr.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"ready to invoke rpc service, name: %s, address: %s"</span>, service_name.<span class="built_in">c_str</span>(), rpc_provider_addr.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装 TCP 客户端的连接信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(rpc_provider_port.<span class="built_in">c_str</span>()));</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(rpc_provider_ip.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 TCP 客户端连接 RPC 服务节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">connect</span>(clientfd, (struct sockaddr*)&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr))) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"connect server failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络发送 RPC 调用的请求参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">send</span>(clientfd, rpc_send_str.<span class="built_in">c_str</span>(), rpc_send_str.<span class="built_in">size</span>(), <span class="number">0</span>)) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"send rpc rquest failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络接收 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">int</span> recv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> recv_buf[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (recv_size = <span class="built_in">recv</span>(clientfd, recv_buf, <span class="number">1024</span>, <span class="number">0</span>))) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"receive rpc response failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (!response-&gt;<span class="built_in">ParseFromArray</span>(recv_buf, recv_size)) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"rpc response unserialize failed, response content is %s"</span>, recv_buf);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ZooKeeper-的访问操作"><a href="#ZooKeeper-的访问操作" class="headerlink" title="ZooKeeper 的访问操作"></a>ZooKeeper 的访问操作</h4><ul><li><code>zookeeperclient.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zookeeper/zookeeper.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ZNode 节点的状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ZNodeStatus</span> {</span></span><br><span class="line">    EXIST,     <span class="comment">// 已存在</span></span><br><span class="line">    NOTEXIST,  <span class="comment">// 不存在</span></span><br><span class="line">    UNKNOWN    <span class="comment">// 未知状态</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeper 客户端的封装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Start</span><span class="params">(<span class="keyword">const</span> std::string &amp;host, <span class="keyword">const</span> <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 创建 ZNode 节点</span></span><br><span class="line">    <span class="function">std::string <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen = <span class="number">0</span>, <span class="keyword">int</span> mode = ZOO_PERSISTENT)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 递归创建 ZNode 节点</span></span><br><span class="line">    <span class="function">std::string <span class="title">CreateRecursive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen = <span class="number">0</span>, <span class="keyword">int</span> mode = ZOO_PERSISTENT)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取子节点列表</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">GetChildren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的数据</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的状态</span></span><br><span class="line">    <span class="function">Stat <span class="title">GetStat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="function">ZNodeStatus <span class="title">Exist</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">zhandle_t</span> *m_zhandle;  <span class="comment">// ZK 的客户端句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>zookeeperclient.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////// ZK 客户端同步操作扩展代码 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步检查 ZNode 节点是否存在的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncExistsContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;              <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;  <span class="comment">// 检查结果</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步检查 ZNode 是否存在的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_exists_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> struct Stat *stat, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    SyncExistsContext *ctx = (SyncExistsContext *)data;</span><br><span class="line">    <span class="comment">// 存储检查结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line">    <span class="comment">// 唤醒正在等待检查结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步检查 ZNode 节点是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_exists_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncExistsContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aexists</span>(zh, path, watch, znode_exists_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待检查结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回检查结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建 ZNode 节点的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncCreateContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                 <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;     <span class="comment">// 创建结果</span></span><br><span class="line">    <span class="keyword">char</span> path_buf[<span class="number">512</span>] = {<span class="number">0</span>};  <span class="comment">// 用于返回实际创建的节点路径</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步创建 ZNode 节点的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_create_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncCreateContext *ctx = (SyncCreateContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储创建结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储实际创建的节点路径</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; path) {</span><br><span class="line">        <span class="built_in">strncpy</span>(ctx-&gt;path_buf, path, <span class="built_in"><span class="keyword">sizeof</span></span>(ctx-&gt;path_buf) - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待创建结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建 ZNode 节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_create_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">const</span> struct ACL_vector *acl,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> mode, <span class="keyword">char</span> *path_buf_out, <span class="keyword">int</span> path_buf_out_len)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncCreateContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_acreate</span>(zh, path, data, datalen, acl, mode, znode_create_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待检查结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回实际创建的节点路径</span></span><br><span class="line">    <span class="keyword">if</span> (path_buf_out &amp;&amp; path_buf_out_len &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">strncpy</span>(path_buf_out, ctx.path_buf, path_buf_out_len - <span class="number">1</span>);</span><br><span class="line">        path_buf_out[path_buf_out_len - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回检查结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 节点数据和状态的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncGetContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                    <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;        <span class="comment">// 操作结果</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="literal">nullptr</span>;          <span class="comment">// 数据缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> buf_len = <span class="number">0</span>;              <span class="comment">// 数据缓冲区的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> *<span class="title">stat</span> =</span> <span class="literal">nullptr</span>;  <span class="comment">// ZNode 节点的状态</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取 ZNode 节点数据和状态的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_get_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> value_len, <span class="keyword">const</span> struct Stat *stat, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetContext *ctx = (SyncGetContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储操作结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 ZNode 节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (rc == ZOK &amp;&amp; stat &amp;&amp; ctx-&gt;stat) {</span><br><span class="line">        *ctx-&gt;stat = *stat;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 ZNode 节点的数据</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; value &amp;&amp; value_len &gt; <span class="number">0</span> &amp;&amp; ctx-&gt;buf &amp;&amp; ctx-&gt;buf_len &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> copy_len = (value_len &lt; ctx-&gt;buf_len - <span class="number">1</span>) ? value_len : ctx-&gt;buf_len - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ctx-&gt;buf, value, copy_len);</span><br><span class="line">        ctx-&gt;buf[copy_len] = <span class="string">'\0'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待获取结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 节点的数据和状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_get_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch, <span class="keyword">char</span> *buf_out, <span class="keyword">int</span> buf_out_len, struct Stat *stat_out)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetContext ctx;</span><br><span class="line">    ctx.stat = stat_out;</span><br><span class="line">    ctx.buf = buf_out;</span><br><span class="line">    ctx.buf_len = buf_out_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aget</span>(zh, path, watch, znode_get_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待获取结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回操作结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 子节点列表的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncGetChildrenContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                          <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;              <span class="comment">// 操作结果</span></span><br><span class="line">    std::vector&lt;std::string&gt; children;  <span class="comment">// 子节点列表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取 ZNode 子节点列表的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zoo_get_children_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> struct String_vector *strings, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetChildrenContext *ctx = (SyncGetChildrenContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储操作结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储子节点列表</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; strings) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings-&gt;count; i++) {</span><br><span class="line">            ctx-&gt;children.<span class="built_in">emplace_back</span>(strings-&gt;data[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待获取结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 子节点列表</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">zoo_get_children_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch)</span> </span>{</span><br><span class="line">    <span class="comment">// 子节点列表</span></span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetChildrenContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aget_children</span>(zh, path, watch, zoo_get_children_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待获取结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取子节点列表成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == ctx.rc) {</span><br><span class="line">        <span class="comment">// 直接转移 children 所有权给 result</span></span><br><span class="line">        result = std::<span class="built_in">move</span>(ctx.children);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取子节点列表失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"failed to get children of node %s"</span>, path);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回子节点列表</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的 Watcher 监听器，接收 ZkServer 给 ZkClient 发送的通知</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_watcher</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">int</span> type, <span class="keyword">int</span> state, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">void</span> *watcherCtx)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断接收到的事件类型是不是会话事件类型</span></span><br><span class="line">    <span class="keyword">if</span> (type == ZOO_SESSION_EVENT) {</span><br><span class="line">        <span class="comment">// ZK 客户端连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (state == ZOO_CONNECTED_STATE) {</span><br><span class="line">            <span class="comment">// 从 ZK 客户端的上下文中获取预设置的信号量</span></span><br><span class="line">            <span class="keyword">sem_t</span> *init_sem = (<span class="keyword">sem_t</span> *)<span class="built_in">zoo_get_context</span>(zh);</span><br><span class="line">            <span class="comment">// 唤醒正在等待 ZK 客户端初始化完成的线程</span></span><br><span class="line">            <span class="built_in">sem_post</span>(init_sem);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ZK 客户端身份认证失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == ZOO_AUTH_FAILED_STATE) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper auth failed"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ZK 客户端会话过期</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == ZOO_EXPIRED_SESSION_STATE) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper session expired"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////// ZK 客户端实现代码 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ZkClient::<span class="built_in">ZkClient</span>() : <span class="built_in">m_zhandle</span>(<span class="literal">nullptr</span>) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ZkClient::~<span class="built_in">ZkClient</span>() {</span><br><span class="line">    <span class="keyword">if</span> (m_zhandle != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="comment">// 关闭 ZK 的客户端句柄（释放资源）</span></span><br><span class="line">        <span class="built_in">zookeeper_close</span>(m_zhandle);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 ZK 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ZkClient::Start</span><span class="params">(<span class="keyword">const</span> std::string &amp;host, <span class="keyword">const</span> <span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">    <span class="comment">// 拼接 ZK 服务端的连接信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string conn_str = host + <span class="string">":"</span> + std::<span class="built_in">to_string</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 ZK 的客户端句柄，连接 ZK 服务端（特别注意：这里是异步初始化）</span></span><br><span class="line"><span class="comment">     * ZooKeeper C API 的多线程版本有三个线程，包括：</span></span><br><span class="line"><span class="comment">     * (1) API 调用线程（当前调用 ZK API 的线程）</span></span><br><span class="line"><span class="comment">     * (2) 网络 I/O 线程，基于 pthread_create() + poll 实现</span></span><br><span class="line"><span class="comment">     * (3) Watcher 回调线程，基于 pthread_create() 实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    m_zhandle = <span class="built_in">zookeeper_init</span>(conn_str.<span class="built_in">c_str</span>(), global_watcher, <span class="number">30000</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_zhandle) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper client init failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> init_sem;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;init_sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将信号量存放到 ZK 客户端的上下文中</span></span><br><span class="line">    <span class="built_in">zoo_set_context</span>(m_zhandle, &amp;init_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置等待 ZK 客户端连接的超时时间（10 秒）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;ts);</span><br><span class="line">    ts.tv_sec += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待 ZK 客户端初始化完成</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sem_timedwait</span>(&amp;init_sem, &amp;ts) != <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;init_sem);</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper client connect timeout"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;init_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"zookeeper client init success"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上根据指定的 Path 创建 ZNode 节点</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">int</span> mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZNode 节点已存在</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">"znode %s create failed, because it existed"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ZNode 节点不存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ZNONODE == flag) {</span><br><span class="line">        <span class="comment">// 实际创建的节点路径</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> path_buf_len = <span class="number">512</span>;</span><br><span class="line">        <span class="keyword">char</span> path_buf[path_buf_len] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步创建 ZNode 节点</span></span><br><span class="line">        flag = <span class="built_in">zoo_create_sync</span>(m_zhandle, path, data, datalen, &amp;ZOO_OPEN_ACL_UNSAFE, mode, path_buf, path_buf_len);</span><br><span class="line">        <span class="comment">// 节点创建成功</span></span><br><span class="line">        <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"znode %s create success"</span>, path_buf);</span><br><span class="line">            <span class="comment">// 返回实际创建的节点路径</span></span><br><span class="line">            <span class="keyword">return</span> path_buf;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 节点创建失败</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">            <span class="comment">// 返回空字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发生错误，比如会话过期、身份认证失败等</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 递归创建 ZNode 节点</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::CreateRecursive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">int</span> mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::string current_path;</span><br><span class="line">    std::string result_path;</span><br><span class="line">    <span class="keyword">size_t</span> current_pos = <span class="number">1</span>;       <span class="comment">// 跳过第一个 '/'</span></span><br><span class="line">    <span class="function">std::string <span class="title">full_path</span><span class="params">(path)</span></span>;  <span class="comment">// 拷贝节点路径，避免修改原始字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_pos &lt;= full_path.<span class="built_in">size</span>()) {</span><br><span class="line">        <span class="keyword">size_t</span> next_pos = full_path.<span class="built_in">find</span>(<span class="string">'/'</span>, current_pos);</span><br><span class="line">        <span class="keyword">if</span> (next_pos == std::string::npos) {</span><br><span class="line">            <span class="comment">// 最后一级路径（完整路径）</span></span><br><span class="line">            current_path = full_path;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            current_path = full_path.<span class="built_in">substr</span>(<span class="number">0</span>, next_pos);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> is_last_path = (next_pos == std::string::npos);   <span class="comment">// 是否为最后一级路径</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *path_data = is_last_path ? data : <span class="string">""</span>;      <span class="comment">// 父路径不写入数据</span></span><br><span class="line">        <span class="keyword">int</span> path_data_len = is_last_path ? datalen : <span class="number">0</span>;        <span class="comment">// 父路径的数据长度为零</span></span><br><span class="line">        <span class="keyword">int</span> path_mode = is_last_path ? mode : ZOO_PERSISTENT;  <span class="comment">// 父路径为持久节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        std::string created_path = <span class="built_in">Create</span>(current_path.<span class="built_in">c_str</span>(), path_data, path_data_len, path_mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果节点创建失败</span></span><br><span class="line">        <span class="keyword">if</span> (created_path.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="comment">// 判断节点是否存在</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, current_path.<span class="built_in">c_str</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 如果节点存在，使用（兼容）已存在的节点</span></span><br><span class="line">            <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">                created_path = current_path;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果节点不存在或者发生错误，则直接返回空字符串</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 打印日志信息</span></span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">                <span class="comment">// 返回空字符串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是最后一级路径，则跳出 While 循环</span></span><br><span class="line">        <span class="keyword">if</span> (is_last_path) {</span><br><span class="line">            result_path = created_path;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        current_pos = next_pos + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_path;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取子节点列表</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">ZkClient::GetChildren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空列表</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取子节点列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">zoo_get_children_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的数据</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::GetData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> data_buf_len = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">char</span> data_buf[data_buf_len] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取 ZNode 节点的数据</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_get_sync</span>(m_zhandle, path, <span class="number">0</span>, data_buf, data_buf_len, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 获取节点数据成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 返回节点数据</span></span><br><span class="line">        <span class="keyword">return</span> data_buf;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取节点数据失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"get znode data failed, path: %s"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的状态</span></span><br><span class="line"><span class="function">Stat <span class="title">ZkClient::GetStat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空数据</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">stat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取 ZNode 节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_get_sync</span>(m_zhandle, path, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;stat);</span><br><span class="line">    <span class="comment">// 获取节点状态成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 返回节点状态</span></span><br><span class="line">        <span class="keyword">return</span> stat;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取节点状态失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"get znode stat failed, path: %s"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空数据</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 判断 ZNode 节点是否存在</span></span><br><span class="line"><span class="function">ZNodeStatus <span class="title">ZkClient::Exist</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZNode 节点已存在</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="keyword">return</span> EXIST;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ZNode 节点不存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ZNONODE == flag) {</span><br><span class="line">        <span class="keyword">return</span> NOTEXIST;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发生错误，比如会话过期、身份认证失败等</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查节点路径是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ZkClient::checkPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">nullptr</span> || path[<span class="number">0</span>] != <span class="string">'/'</span>) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"invalid node path: %s"</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="RPC-框架测试代码"><a href="#RPC-框架测试代码" class="headerlink" title="RPC 框架测试代码"></a>RPC 框架测试代码</h3><p>这里的项目测试代码位于 <code>example</code> 目录下，实质是 RPC 框架的使用案例代码，用于给 RPC 框架的第三方使用者演示如何发布和调用 RPC 服务。</p><h4 id="Protobuf-协议文件-1"><a href="#Protobuf-协议文件-1" class="headerlink" title="Protobuf 协议文件"></a>Protobuf 协议文件</h4><ul><li><code>user.proto</code> 协议文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package user;</span><br><span class="line"></span><br><span class="line">// 允许生成通用的 C++ 服务接口（可选项）</span><br><span class="line">option cc_generic_services = true;</span><br><span class="line"></span><br><span class="line">// 请求结果</span><br><span class="line">message ResultCode {</span><br><span class="line">    uint32 errcode = 1; </span><br><span class="line">    bytes errmsg = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 登录请求</span><br><span class="line">message LoginRequest {</span><br><span class="line">    bytes name = 1;</span><br><span class="line">    bytes password = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 登录响应</span><br><span class="line">message LoginResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    bool success = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 注册请求</span><br><span class="line">message RegisterRequest {</span><br><span class="line">    bytes name = 1;</span><br><span class="line">    bytes password = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 注册响应</span><br><span class="line">message RegisterResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    bool success = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义RPC服务接口类和服务函数</span><br><span class="line">service UserServiceRpc {</span><br><span class="line">    rpc Register(RegisterRequest) returns (RegisterResponse);</span><br><span class="line"></span><br><span class="line">    rpc Login(LoginRequest) returns (LoginResponse);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>friend.proto</code> 协议文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package friends;</span><br><span class="line"></span><br><span class="line">// 允许生成通用的 C++ 服务接口（可选项）</span><br><span class="line">option cc_generic_services = true;</span><br><span class="line"></span><br><span class="line">// 请求结果</span><br><span class="line">message ResultCode {</span><br><span class="line">    uint32 errcode = 1; </span><br><span class="line">    bytes errmsg = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 好友信息</span><br><span class="line">message Friend {</span><br><span class="line">    uint32 userid = 1;</span><br><span class="line">    bytes username = 2;</span><br><span class="line"></span><br><span class="line">    // 枚举类型</span><br><span class="line">    enum SEX {</span><br><span class="line">        MAN = 0;</span><br><span class="line">        WOMAN = 1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SEX sex = 3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取好友列表的请求</span><br><span class="line">message GetFriendListRequest {</span><br><span class="line">    uint32 userid = 1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取好友列表的响应</span><br><span class="line">message GetFriendListResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    // 好友列表</span><br><span class="line">    repeated Friend friends = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义RPC服务接口类和服务函数</span><br><span class="line">service FriendServiceRpc {</span><br><span class="line">    rpc GetFriendList(GetFriendListRequest) returns (GetFriendListResponse);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-RPC-框架提供服务"><a href="#使用-RPC-框架提供服务" class="headerlink" title="使用 RPC 框架提供服务"></a>使用 RPC 框架提供服务</h4><ul><li><code>rpcprovider.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcprovider.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 服务，继承基类 UserServiceRpc（由 Protobuf 自动生成）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> :</span> <span class="keyword">public</span> user::UserServiceRpc {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 本地的登录函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Login</span><span class="params">(std::string name, std::string password)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local Login function, name: %s, password: %s"</span>, name.<span class="built_in">c_str</span>(), password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地的注册函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Register</span><span class="params">(std::string name, std::string password)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local Register function, name: %s, password: %s"</span>, name.<span class="built_in">c_str</span>(), password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 UserServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Login</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::user::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">               ::user::LoginResponse* response, ::google::protobuf::Closure* done)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string password = request-&gt;<span class="built_in">password</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        <span class="keyword">bool</span> success = <span class="built_in">Login</span>(name, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        user::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(success);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给 RPC 服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 UserServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::user::RegisterRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ::user::RegisterResponse* response, ::google::protobuf::Closure* done)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string password = request-&gt;<span class="built_in">password</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        <span class="keyword">bool</span> success = <span class="built_in">Register</span>(name, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        user::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(success);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给RPC服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 服务，继承基类 FriendServiceRpc（由 Protobuf 自动生成）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendServcie</span> :</span> <span class="keyword">public</span> friends::FriendServiceRpc {</span><br><span class="line">    <span class="comment">// 本地获取好友列表的函数</span></span><br><span class="line">    <span class="function">std::vector&lt;friends::Friend&gt; <span class="title">GetFriendList</span><span class="params">(<span class="keyword">uint32_t</span> userid)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local GetFriendList function, userid: %u"</span>, userid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        std::vector&lt;friends::Friend&gt; result;</span><br><span class="line"></span><br><span class="line">        friends::Friend f1;</span><br><span class="line">        f1.<span class="built_in">set_userid</span>(<span class="number">1</span>);</span><br><span class="line">        f1.<span class="built_in">set_username</span>(<span class="string">"Jim"</span>);</span><br><span class="line">        f1.<span class="built_in">set_sex</span>(friends::Friend::MAN);</span><br><span class="line">        result.<span class="built_in">push_back</span>(f1);</span><br><span class="line"></span><br><span class="line">        friends::Friend f2;</span><br><span class="line">        f2.<span class="built_in">set_userid</span>(<span class="number">2</span>);</span><br><span class="line">        f2.<span class="built_in">set_username</span>(<span class="string">"Tom"</span>);</span><br><span class="line">        f2.<span class="built_in">set_sex</span>(friends::Friend::MAN);</span><br><span class="line">        result.<span class="built_in">push_back</span>(f2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 FriendServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetFriendList</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::friends::GetFriendListRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::friends::GetFriendListResponse* response, ::google::protobuf::Closure* done)</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        <span class="keyword">uint32_t</span> userid = request-&gt;<span class="built_in">userid</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        std::vector&lt;friends::Friend&gt; friends = <span class="built_in">GetFriendList</span>(userid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        friends::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应的数据</span></span><br><span class="line">        <span class="keyword">for</span> (friends::Friend&amp; item : friends) {</span><br><span class="line">            friends::Friend* f = response-&gt;<span class="built_in">add_friends</span>();</span><br><span class="line">            f-&gt;<span class="built_in">set_sex</span>(item.<span class="built_in">sex</span>());</span><br><span class="line">            f-&gt;<span class="built_in">set_userid</span>(item.<span class="built_in">userid</span>());</span><br><span class="line">            f-&gt;<span class="built_in">set_username</span>(item.<span class="built_in">username</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给RPC服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 RPC 服务的发布</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    Logger::<span class="built_in">GetInstance</span>().<span class="built_in">SetLogLevel</span>(INFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 框架的初始化操作（比如加载 RPC 配置文件）</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"init rpc framework..."</span>);</span><br><span class="line">    MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用来发布 RPC 服务的网络对象类</span></span><br><span class="line">    RpcProvider provider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    provider.<span class="built_in">PublishService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    provider.<span class="built_in">PublishService</span>(<span class="keyword">new</span> <span class="built_in">FriendServcie</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-RPC-框架调用服务"><a href="#使用-RPC-框架调用服务" class="headerlink" title="使用 RPC 框架调用服务"></a>使用 RPC 框架调用服务</h4><ul><li><code>rpcconsumer.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 注册方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">user::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    user::RegisterRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">"jim"</span>);</span><br><span class="line">    request.<span class="built_in">set_password</span>(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    user::RegisterResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">Register</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function Register invoke success"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function Register invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 登录方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Login</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">user::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    user::LoginRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">"jim"</span>);</span><br><span class="line">    request.<span class="built_in">set_password</span>(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    user::LoginResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">Login</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function Login invoke success"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function Login invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 获取好友列表方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetFriendList</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">friends::FriendServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    friends::GetFriendListRequest request;</span><br><span class="line">    request.<span class="built_in">set_userid</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    friends::GetFriendListResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">GetFriendList</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function GetFriendList invoke success"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取返回的数据</span></span><br><span class="line">        <span class="keyword">auto</span> friends = response.<span class="built_in">friends</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : friends) {</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"userid: %u, username: %s, sex: %d"</span>, item.<span class="built_in">userid</span>(), item.<span class="built_in">username</span>().<span class="built_in">c_str</span>(), item.<span class="built_in">sex</span>());</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function GetFriendList invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 RPC 服务的调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    Logger::<span class="built_in">GetInstance</span>().<span class="built_in">SetLogLevel</span>(INFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 框架的初始化操作（比如加载 RPC 配置文件）</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"init rpc framework..."</span>);</span><br><span class="line">    MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 注册方法</span></span><br><span class="line">    <span class="built_in">Register</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 登录方法</span></span><br><span class="line">    <span class="built_in">Login</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 获取好友列表方法</span></span><br><span class="line">    <span class="built_in">GetFriendList</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待一段时间，在程序结束之前，尽量让日志信息都被写入日志文件</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="项目代码下载"><a href="#项目代码下载" class="headerlink" title="项目代码下载"></a>项目代码下载</h3><p>完整的 RPC 框架项目代码可以在 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-mprpc">这里</a> 下载得到。</p><h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><ul><li>(1) 更改 <code>conf</code> 目录下的 <code>rpc.conf</code> 配置文件，指定 ZooKeeper 服务器的 IP 和端口号等信息 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ZooKeeper的IP地址（必填）</span><br><span class="line">zk_server_host=127.0.0.1</span><br><span class="line"># ZooKeeper的端口号（必填）</span><br><span class="line">zk_server_port=2181</span><br><span class="line"># RPC服务提供者优先使用的网卡接口（可选）</span><br><span class="line">rpc_network_interface=eth1</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 通过 CMake 编译构建整个项目 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权脚本执行</span></span><br><span class="line">chmod +x autobuild.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一键编译构建脚本</span></span><br><span class="line">./autobuild.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 启动 ZooKeeper 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 ZooKeeper 服务器</span></span><br><span class="line">sudo systemctl start zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 服务器的运行状态</span></span><br><span class="line">sudo systemctl status zookeeper</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 启动 RPC 服务提供者的案例程序 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 RPC 服务提供者的案例程序（可使用相同的命令启动多个 RPC 服务提供者，不需要考虑端口冲突问题）</span></span><br><span class="line">./example_rpc_provider -i rpc.conf</span><br></pre></td></tr></tbody></table></figure><ul><li>(5) 启动 RPC 服务调用者的案例程序 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 RPC 服务调用者的案例程序（可使用相同的命令启动多个 RPC 服务调用者，不需要考虑端口冲突问题）</span></span><br><span class="line">./example_rpc_consumer -i rpc.conf</span><br></pre></td></tr></tbody></table></figure><ul><li>(6) 查看 RPC 框架运行输出的日志文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 RPC 框架运行输出的日志文件（请自行更改日志文件名）</span></span><br><span class="line">vim 2025-06-12-log.txt</span><br></pre></td></tr></tbody></table></figure><h2 id="项目调试"><a href="#项目调试" class="headerlink" title="项目调试"></a>项目调试</h2><ul><li>GDB 调试 C/C++ 代码，可用于定位线程死锁等问题的发生 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GDB 调试指定的可执行文件（应用程序）</span></span><br><span class="line">gdb example_rpc_provider</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 设置断点（格式：源文件名称＋行号）</span></span><br><span class="line">(gdb) <span class="built_in">break</span> mprpcconfig.cc:19</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 指定参数运行应用程序（运行后，会停留在断点处）</span></span><br><span class="line">(gdb) run -i rpc.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 断点调试 - 运行下一行代码</span></span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 断点调试 - 查看指定变量的值</span></span><br><span class="line">(gdb) p src_buf</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 退出调试</span></span><br><span class="line">(gdb) quit</span><br></pre></td></tr></tbody></table></figure><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><p>在上述的 RPC 框架代码中，每当 RPC 服务端处理完成一个 RPC 请求后，都会主动断开与 RPC 客户端的 TCP 连接；同样，RPC 客户端在获取到响应结果后，也会主动断开与 RPC 服务端的 TCP 连接。这种实现方式属于短连接模式，在生产环境中通常比较少见。原因如下：</p><ul><li><p>TCP 连接的创建和释放代价较高，每次请求都涉及：</p><ul><li>三次握手（建立连接）</li><li>四次挥手（关闭连接）</li></ul></li><li><p>在高并发场景下，频繁建立和关闭 TCP 连接会导致：</p><ul><li>系统资源消耗大（文件描述符、内核网络栈负载）</li><li>服务端的性能瓶颈，特别是处理大量短时请求时</li></ul></li></ul><p>以阿里巴巴开源的 RPC 框架 Dubbo 为例，Dubbo 默认采用 TCP 的单一长连接和 NIO 异步通信模型，其主要特点是：</p><ul><li>客户端与服务端之间建立持久化的长连接（通常是连接池或多路复用）</li><li>异步非阻塞通信（基于 Netty 实现）</li><li>复用连接发送多次请求，避免了重复的 TCP 握手和断开操作，显著降低了网络资源和 CPU 消耗</li></ul><p>因此在生产环境中，建议使用 TCP 的单一长连接和 NIO 异步通信模型（Muduo 网络库天生支持），以此保证 RPC 框架的高并发性能。值得一提的是，使用 TCP 长连接后，需要额外处理 TCP 分包的问题，也就是将 TCP 字节流里的数据识别为一个个消息（RPC 请求消息）。</p><table><thead><tr><th>模式</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td>短连接（请求 - 响应后立即断开）</td><td>简单实现，资源浪费大</td><td>一般用于简单的 HTTP/1.0 接口或调试环境</td></tr><tr><td>长连接（复用 TCP 连接）</td><td>性能优越，适合高并发</td><td> gRPC、Dubbo、Redis、数据库连接等</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/18340f27.html">ZooKeeper 入门系列教程</a></li><li><a href="/posts/46940ea4.html">C++ 快速上手使用 Protobuf</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 如何实现 RPC 分布式网络通信框架，使用了 Muduo、Protobuf、ZooKeeper 等技术。</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="RPC" scheme="https://www.techgrow.cn/tags/RPC/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 开发集群聊天服务器</title>
    <link href="https://www.techgrow.cn/posts/e635f0aa.html"/>
    <id>https://www.techgrow.cn/posts/e635f0aa.html</id>
    <published>2025-05-29T13:55:33.000Z</published>
    <updated>2025-06-04T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写高性能网络库（Muduo）</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 实现集群聊天服务器，使用了 Json 库和 Muduo 网络库，并引入了 Redis、MySQL、Nginx 中间件。</p><span id="more"></span><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><table><thead><tr><th>软件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>11</code></td><td></td></tr><tr><td>Boost</td><td><code>1.74.0.3</code></td><td>Muduo 库依赖 Boost 库</td></tr><tr><td> Muduo</td><td><code>2.0.3</code></td><td><a href="https://github.com/chenshuo/muduo">Muduo 库</a>，基于 C++ 开发，用于网络编程</td></tr><tr><td> hiredis</td><td><code>1.3.0</code></td><td><a href="https://github.com/redis/hiredis">Reids 库</a> ，基于 C 语言开发，用于操作 Redis</td></tr><tr><td>nlohmann/json</td><td><code>3.12.0</code></td><td><a href="https://github.com/nlohmann/json">Json 库</a>，基于 C++ 开发，用于 Json 序列化和反序列化</td></tr><tr><td> MySQL C API （Connector/C）</td><td><code>8.4.5</code></td><td>用于读写 MySQL 数据库，基于 C 语言开发</td></tr><tr><td> Redis</td><td><code>7.0.15</code></td><td>Redis 服务器</td></tr><tr><td> MySQL</td><td><code>8.4.5</code></td><td>MySQL 服务器</td></tr><tr><td> Nginx</td><td><code>1.28.0</code></td><td>Nginx 服务器</td></tr><tr><td> G++（GCC）</td><td><code>12.2.0</code></td><td>建议使用 <code>5.5</code>、<code>7.5</code> 版本的 G++（GCC） 编译器</td></tr><tr><td> CMake</td><td><code>3.25.1</code></td><td>C/C++ 项目构建工具</td></tr><tr><td> Linux</td><td><code>Debian 12</code></td><td>Muduo 库不支持 Windows 平台</td></tr><tr><td> Visual Studio Code</td><td><code>1.100.2</code></td><td>使用 VSCode 远程开发特性</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">平台兼容性说明</p><p>由于使用了 Muduo 库，且 Muduo 库仅支持 Linux 平台；因此本文提供的所有 C++ 集群聊天服务器代码支持在 Linux 平台运行，不支持 Windows 平台，默认是基于 Debian 12 进行远程开发。</p></div><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>使用 C++ 开发 Linux 应用时，常见的开发环境有以下几种：</p><ul><li>(1) <a href="https://blog.csdn.net/icacxygh001/article/details/120981354">Linux 环境下直接使用 VSCode、Clion 等 IDE 进行本地开发</a></li><li> (2) <a href="https://blog.csdn.net/xiaowangabc1/article/details/147927306">Windows + VSCode + MinGW 搭建本地 C/C++ 开发环境</a></li><li> (3) <a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89469717">Windows + Visual Studio 搭建远程 Linux 跨平台项目</a></li><li> (4) <a href="/posts/630b5e44.html">Windows + VSCode 搭建远程 Linux 开发环境</a></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>上面介绍的三种开发环境，任意选择一种自己熟悉的就可以；如果日常使用的是 Windows 系统，建议选择第四种开发环境（VSCode 远程开发）；如果习惯使用 Linux 系统，强烈建议选择第一种开发环境（Linux 本地开发）。</p></div><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><ul><li>安装常用的工具 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装开发工具</span></span><br><span class="line">sudo apt-get install -y vim git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装网络工具</span></span><br><span class="line">sudo apt-get install -y wget curl telnet netcat-openbsd socat tcpdump hping3</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-GCC"><a href="#安装-GCC" class="headerlink" title="安装 GCC"></a>安装 GCC</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC、G++、GDB</span></span><br><span class="line">sudo apt-get install -y build-essential gdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 GCC 版本</span></span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 G++ 版本</span></span><br><span class="line">g++ --version</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-CMake"><a href="#安装-CMake" class="headerlink" title="安装 CMake"></a>安装 CMake</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 CMake</span></span><br><span class="line">sudo apt-get -y install cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 CMake 版本</span></span><br><span class="line">cmake -version</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><ul><li>安装 Redis</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Redis</span></span><br><span class="line">sudo apt-get install -y redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 Redis</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Redis 的运行状态</span></span><br><span class="line">sudo systemctl status redis-server</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Redis 版本</span></span><br><span class="line">redis-server --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 客户端执行 Ping 操作</span></span><br><span class="line">redis-cli ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 Redis 服务器响应以下内容，则说明 Redis 服务器正常运行</span></span><br><span class="line">PONG</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">Redis 默认配置文件的路径</p><p>通过 APT 安装 Redis 服务器后，其主配置文件的路径为 <code>/etc/redis/redis.conf</code>。</p></div><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><ul><li>安装依赖包 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖软件（比如 pcre、zlib、ssl）</span></span><br><span class="line">sudo apt install -y build-essential libpcre3 libpcre3-dev zlib1g zlib1g-dev libssl-dev</span><br></pre></td></tr></tbody></table></figure><ul><li>编译安装 Nginx</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://nginx.org/download/nginx-1.28.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf nginx-1.28.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.28.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">./configure --with-stream --with-http_ssl_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure><ul><li>Nginx 安装说明</li></ul><table><thead><tr><th>安装说明</th><th>路径</th></tr></thead><tbody><tr><td> Nginx 默认安装路径</td><td><code>/usr/local/nginx</code></td></tr><tr><td>Nginx 主配置文件路径</td><td><code>/usr/local/nginx/conf/nginx.conf</code></td></tr><tr><td>Nginx 二进制可执行文件路径</td><td><code>/usr/local/nginx/sbin/nginx</code></td></tr></tbody></table><ul><li>Nginx 管理命令 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 Nginx</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优雅关闭 Nginx</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s quit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立刻关闭 Nginx</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 Nginx 配置文件</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载 Nginx 配置文件</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 Systemd 服务（实现 Nginx 服务自启动）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Systemd 服务配置文件，添加以下配置内容</span></span><br><span class="line">sudo vi /etc/systemd/system/nginx.service</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=The NGINX HTTP and reverse proxy server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s quit</span><br><span class="line">PIDFile=/usr/<span class="built_in">local</span>/nginx/logs/nginx.pid</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重载系统配置文件</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 Nginx 服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 Nginx 服务</span></span><br><span class="line">sudo systemctl start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Nginx 服务的运行状态</span></span><br><span class="line">sudo systemctl status nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优雅关闭 Nginx 服务</span></span><br><span class="line">sudo systemctl stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载 Nginx 服务的配置文件</span></span><br><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Nginx <code>1.9.0</code> 版本之前，Nginx 仅支持基于 HTTP 协议 的 Web 服务器负载均衡，无法处理 TCP 层的流量转发。自 Nginx <code>1.9.0</code> 版本开始，官方引入了名为 <code>stream</code> 的新模块，使 Nginx 能够支持基于 TCP 和 UDP 的四层负载均衡，从而扩展了其在数据库代理、邮件服务、消息中间件等非 HTTP 场景中的应用能力。值得一提的是，尽管 <code>stream</code> 模块在 <code>1.9.0</code> 版本中开始被引入，但在官方源码中该模块默认并未启用。因此，在编译 Nginx 源码时，如果希望使用 <code>stream</code> 模块的功能，则必须显式添加 <code>--with-stream</code> 编译参数，这样才能将其集成进最终构建的二进制可执行文件中。</p></div><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><ul><li>添加 MySQL 官方 APT 源 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 APT 配置包（访问 https://dev.mysql.com/downloads/repo/apt/ 可以获取最新版本）</span></span><br><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.8.34-1_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 APT 配置包</span></span><br><span class="line"><span class="comment"># 在安装过程中会弹出配置界面，通常默认选择的是 MySQL 8.4 版本，如果需要安装其他版本（如 8.0），可以按回车键进入子菜单选择其他版本</span></span><br><span class="line"><span class="comment"># 由于集群聊天服务器需要使用到 MySQL 客户端，因此还需要安装 MySQL Connectors（不需要改动选择，因为默认已经选择安装）</span></span><br><span class="line">sudo dpkg -i mysql-apt-config_0.8.34-1_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 APT 索引</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></tbody></table></figure><ul><li>安装 MySQL</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 MySQL（安装过程中会提示输入 MySQL 的 root 用户的密码）</span></span><br><span class="line">sudo apt-get install -y mysql-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 MySQL</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 MySQL 的运行状态</span></span><br><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">MySQL 默认配置文件的路径</p><p>通过 APT 安装 MySQL 服务器后，其主配置文件的路径为 <code>/etc/mysql/my.cnf</code>。</p></div><ul><li>安装 MySQL C API 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 MySQL 客户端开发包（包含了 MySQL C API 的头文件和动态库文件）</span></span><br><span class="line">sudo apt-get install -y libmysqlclient-dev</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 MySQL 安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录 MySQL</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 MySQL 版本</span></span><br><span class="line"><span class="keyword">select</span> version();</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 MySQL C API 库的安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /usr -iname libmysqlclient*</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.a</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.so.24</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.so.24.0.5</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">MySQL C API 库</p><p>本文使用 <code>libmysqlclient.so</code> 库来操作 MySQL 数据库，该库称为 MySQL C API（也叫 Connector/C），它是基于 C 语言实现的。C++ 项目也可以使用这个库，只要用 <code>extern "C"</code> 来链接（或者直接使用 MySQL 提供的头文件中已经加好的处理）。</p></div><h3 id="安装-Boost-库"><a href="#安装-Boost-库" class="headerlink" title="安装 Boost 库"></a>安装 Boost 库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Boost 的所有组件和头文件</span></span><br><span class="line">sudo apt-get install -y libboost-all-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Bootst 版本</span></span><br><span class="line">sudo dpkg -s libboost-all-dev | grep Version</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>由于 Muduo 使用了 Boost 库（如 <code>boost::any</code>），因此需要安装 Boost 库。</p></div><h3 id="安装-Muduo-库"><a href="#安装-Muduo-库" class="headerlink" title="安装 Muduo 库"></a>安装 Muduo 库</h3><ul><li>编译安装 Muduo 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chenshuo/muduo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入代码目录</span></span><br><span class="line"><span class="built_in">cd</span> muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Muduo 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Muduo 库的静态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep muduo</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Muduo 的编译依赖 CMake 和 Boost 库，默认编译生成的是静态库（<code>.a</code>），如果需要编译生成共享库（<code>.so</code>），可以自行修改 <code>CMakeLists.txt</code> 中的配置。</li><li>Muduo 支持 C++ 11，仅支持 Linux 平台，不支持 Windows 平台，建议使用 <code>7.x</code> 及以后版本的 <code>g++</code> 编译器。</li></ul></div><h3 id="安装-Hiredis-库"><a href="#安装-Hiredis-库" class="headerlink" title="安装 Hiredis 库"></a>安装 Hiredis 库</h3><ul><li>编译安装 Hiredis 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/redis/hiredis.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> hiredis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Hiredis 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/hiredis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Hiredis 库的静态库和动态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep hiredis</span><br></pre></td></tr></tbody></table></figure><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h3><ul><li>客户端新用户注册</li><li>客户端用户登录</li><li>添加好友和添加群组</li><li>好友聊天</li><li>群组聊天</li><li>离线消息</li><li> Nginx 配置 TCP 负载均衡</li><li>集群聊天系统支持客户端跨服务器通信</li></ul><h3 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h3><ul><li>掌握 Json 的编程应用</li><li>掌握 CMake 构建自动化编译环境</li><li>掌握 Muduo 网络库的编程以及实现原理</li><li>掌握 Nginx 配置部署 TCP 负载均衡器的应用以及原理</li><li>掌握服务器的网络 I/O 模块、业务模块、数据模块分层的设计思想</li><li>掌握 Redis 发布 - 订阅的编程实践以及应用原理</li></ul><h3 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h3><p>在集群聊天服务器项目中，使用 Nginx 作为 TCP 负载均衡器，同时使用 Redis 的发布 - 订阅特性来解决客户端跨服务器通信问题。整体工作流程如下图所示：</p><p><img data-src="../../../asset/2025/06/cluster-chat-loadbalance-1.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p>Nginx 单机作为负载均衡器时，经过合理的系统参数优化和配置（如 <code>ulimit</code>、内核参数调整等），通常可以稳定支撑 5 万～6 万个并发 TCP 连接。但是，由于 Nginx 本质上是属于应用层的四层代理，其性能仍受限于单机的 CPU、内存、网络带宽和文件描述符等资源限制。若需支持 超过 10 万甚至上百万的并发 TCP 连接，可采用 LVS + Keepalived + Nginx 的分层架构实现更高性能、更高可用性、更强伸缩性的负载均衡方案，该方案的部署拓扑结构 <a href="../../../asset/2025/06/cluster-chat-loadbalance-2.png">如图</a> 所示。</p></div><h3 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h3><ul><li>单例设计模式</li><li> Muduo 网络库</li><li> MySQL 数据库编程</li><li> CMake 构建编译环境</li><li> Json 序列化和反序列化</li><li> Nginx 的 TCP 负载均衡器使用</li><li> Redis 的发布 - 订阅编程实践</li></ul><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><h3 id="Nginx-负载均衡配置"><a href="#Nginx-负载均衡配置" class="headerlink" title="Nginx 负载均衡配置"></a>Nginx 负载均衡配置</h3><p>在集群聊天服务器项目中，由于使用了 Nginx 作为 TCP 负载均衡器，因此需要在 Nginx 的配置文件中（<code>nginx.conf</code>）添加 <code>stream</code> 模块的配置内容，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">events {</span><br><span class="line">  ........</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># nginx tcp loadbalance config</span><br><span class="line">stream {</span><br><span class="line">    # 集群聊天的服务器列表</span><br><span class="line">    upstream chat_server {</span><br><span class="line">        server 127.0.0.1:6000 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">        server 127.0.0.1:6002 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    # TCP 负载均衡器（负责转发流量）</span><br><span class="line">    server {</span><br><span class="line">        listen 8000;</span><br><span class="line">        proxy_pass chat_server;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">http {</span><br><span class="line">  ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Redis-发布-订阅使用"><a href="#Redis-发布-订阅使用" class="headerlink" title="Redis 发布 - 订阅使用"></a>Redis 发布 - 订阅使用</h3><p>在集群聊天服务器项目中，使用 Redis 的发布 - 订阅特性来解决客户端跨服务器通信问题。Reids 的发布 - 订阅功能，主要使用以下几个 Redis 命令来实现：</p><ul><li>订阅指定的 Channel</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe news</span><br></pre></td></tr></tbody></table></figure><ul><li>发布消息到指定的 Channel</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish news <span class="string">"hello"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>取消订阅指定的 Channel</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsubscribe news</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>在集群聊天服务器项目中，为了方便操作 Redis，会使用到 <a href="https://github.com/redis/hiredis">Hiredis</a> 库。</p></div><h3 id="MySQL-数据库初始化"><a href="#MySQL-数据库初始化" class="headerlink" title="MySQL 数据库初始化"></a>MySQL 数据库初始化</h3><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>C++ 集群聊天服务器项目的数据库表设计如下：</p><p><img data-src="../../../asset/2025/05/cxx-cluster-chat-server-1.png"></p><h4 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h4><ul><li>创建数据库 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `chat` <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></tbody></table></figure><ul><li>切换数据库 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE `chat`;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建用户表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `state` enum(<span class="string">'online'</span>,<span class="string">'offline'</span>) <span class="keyword">DEFAULT</span> <span class="string">'offline'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `name` (`name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">22</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建好友表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `friend` (</span><br><span class="line">  `userid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `friendid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `userid` (`userid`,`friendid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建用户组表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `allgroup` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `groupname` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `groupdesc` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `groupname` (`groupname`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建用户与用户组关联表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `groupuser` (</span><br><span class="line">  `groupid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `userid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `grouprole` enum(<span class="string">'creator'</span>,<span class="string">'normal'</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `groupid` (`groupid`,`userid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建离线消息表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `offlinemessage` (</span><br><span class="line">  `userid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `message` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `createtime` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><h3 id="集群聊天服务器开发"><a href="#集群聊天服务器开发" class="headerlink" title="集群聊天服务器开发"></a>集群聊天服务器开发</h3><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── sql</span><br><span class="line">│&nbsp;&nbsp; └── db.sql</span><br><span class="line">├── include</span><br><span class="line">│   ├── public</span><br><span class="line">│   │   ├── config.hpp</span><br><span class="line">│   │   ├── public.hpp</span><br><span class="line">│   │   └── times.hpp</span><br><span class="line">│   └── server</span><br><span class="line">│       ├── chatserver.hpp</span><br><span class="line">│       ├── chatservice.hpp</span><br><span class="line">│       ├── dao</span><br><span class="line">│       │   ├── friendmodel.hpp</span><br><span class="line">│       │   ├── groupmodel.hpp</span><br><span class="line">│       │   ├── groupusermodel.hpp</span><br><span class="line">│       │   ├── offlinemessagemodel.hpp</span><br><span class="line">│       │   └── usermodel.hpp</span><br><span class="line">│       ├── db</span><br><span class="line">│       │   └── db.hpp</span><br><span class="line">│       ├── domain</span><br><span class="line">│       │   ├── friend.hpp</span><br><span class="line">│       │   ├── group.hpp</span><br><span class="line">│       │   ├── groupuser.hpp</span><br><span class="line">│       │   ├── offlinemessage.hpp</span><br><span class="line">│       │   └── user.hpp</span><br><span class="line">│       └── redis</span><br><span class="line">│           └── redis.hpp</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── main.cpp</span><br><span class="line">│   └── server</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">│       ├── chatserver.cpp</span><br><span class="line">│       ├── chatservice.cpp</span><br><span class="line">│       ├── dao</span><br><span class="line">│       │   ├── friendmodel.cpp</span><br><span class="line">│       │   ├── groupmodel.cpp</span><br><span class="line">│       │   ├── groupusermodel.cpp</span><br><span class="line">│       │   ├── offlinemessagemodel.cpp</span><br><span class="line">│       │   └── usermodel.cpp</span><br><span class="line">│       ├── db</span><br><span class="line">│       │   └── db.cpp</span><br><span class="line">│       ├── main.cpp</span><br><span class="line">│       └── redis</span><br><span class="line">│           └── redis.cpp</span><br><span class="line">└── thirdparty</span><br><span class="line">    └── json.hpp</span><br></pre></td></tr></tbody></table></figure><h4 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h4><div class="admonition note"><p class="admonition-title">下载完整的项目代码</p><p>由于篇幅有限，下面只给出集群聊天服务端和客户端的部分核心代码，完整的项目代码可以在 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-cluster-chat-server">这里</a> 下载得到。</p></div><h5 id="公共核心代码"><a href="#公共核心代码" class="headerlink" title="公共核心代码"></a>公共核心代码</h5><ul><li><code>include/public/config.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局配置信息的头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 连接信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_IP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> DB_PORT = <span class="number">3306</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_USER = <span class="string">"root"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_PASSWORD = <span class="string">"Cxx_Chat_12345"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_NAME = <span class="string">"chat"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis 连接信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string REDIS_IP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> REDIS_PORT = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CONFIG_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>include/public/public.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUBLIC_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误编码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ErrorCode</span> {</span></span><br><span class="line">    SUCCESS = <span class="number">0</span>,           <span class="comment">// 请求处理成功</span></span><br><span class="line">    REGISTER_FAIL,         <span class="comment">// 注册失败</span></span><br><span class="line">    REPEAT_REGISTER,       <span class="comment">// 用户名已被注册</span></span><br><span class="line">    LOGIN_AUTH_FAIL,       <span class="comment">// 用户名或密码不正确</span></span><br><span class="line">    REPEAT_LOGIN,          <span class="comment">// 账号在其他设备已登录</span></span><br><span class="line">    ADD_FRIEND_FAIL,       <span class="comment">// 添加好友失败</span></span><br><span class="line">    JOIN_GROUP_FAIL,       <span class="comment">// 加入群组失败</span></span><br><span class="line">    SINGLE_CHAT_FAIL,      <span class="comment">// 一对一聊天失败</span></span><br><span class="line">    GROUP_CHAT_FAIL,       <span class="comment">// 群组聊天失败</span></span><br><span class="line">    INVALID_MESSAGE_TYPE,  <span class="comment">// 消息类型无效</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MsgType</span> {</span></span><br><span class="line">    LOGIN_MSG = <span class="number">1</span>,         <span class="comment">// 登录消息</span></span><br><span class="line">    LOGIN_MSG_ACK,         <span class="comment">// 登录响应消息</span></span><br><span class="line">    REGISTER_MSG,          <span class="comment">// 注册消息</span></span><br><span class="line">    REGISTER_MSG_ACK,      <span class="comment">// 注册响应消息</span></span><br><span class="line">    SINGLE_CHAT_MSG,       <span class="comment">// 一对一聊天消息</span></span><br><span class="line">    SINGLE_CHAT_MSG_ACK,   <span class="comment">// 一对一聊天响应消息</span></span><br><span class="line">    ADD_FRIEND_MSG,        <span class="comment">// 添加好友消息</span></span><br><span class="line">    ADD_FRIEND_MSG_ACK,    <span class="comment">// 添加好友响应消息</span></span><br><span class="line">    CREATE_GROUP_MSG,      <span class="comment">// 创建群组消息</span></span><br><span class="line">    CREATE_GROUP_MSG_ACK,  <span class="comment">// 创建群组响应消息</span></span><br><span class="line">    JOIN_GROUP_MSG,        <span class="comment">// 加入群组消息</span></span><br><span class="line">    JOIN_GROUP_MSG_ACK,    <span class="comment">// 加入群组响应消息</span></span><br><span class="line">    GROUP_CHAT_MSG,        <span class="comment">// 群聊天消息</span></span><br><span class="line">    GROUP_CHAT_MSG_ACK,    <span class="comment">// 群聊天响应消息</span></span><br><span class="line">    LOGIN_OUT_MSG,         <span class="comment">// 退出登录消息</span></span><br><span class="line">    LOGIN_OUT_MSG_ACK,     <span class="comment">// 退出登录响应消息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// PUBLIC_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>include/public/times.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIMES_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/c_local_time_adjustor.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/posix_time/posix_time.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间戳（单位：毫秒）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">getTimestampMs</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前系统的时间点</span></span><br><span class="line">    chrono::system_clock::time_point now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 转换为时间戳</span></span><br><span class="line">    <span class="keyword">return</span> chrono::duration_cast&lt;chrono::milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间戳（单位：毫秒）格式化为系统本地时间的字符串</span></span><br><span class="line"><span class="comment">// timestampMs: Unix 时间戳（自 1970-01-01 00:00:00 UTC 起的毫秒数）</span></span><br><span class="line"><span class="comment">// formatStr: 格式化字符串，例如 "%Y-%m-%d %H:%M:%S"</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">formatTimestampLocal</span><span class="params">(<span class="keyword">long</span> timestampMs, <span class="keyword">const</span> std::string&amp; formatStr)</span> </span>{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::posix_time;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::gregorian;</span><br><span class="line">    <span class="keyword">using</span> boost::date_time::c_local_adjustor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 UTC 时间：从 epoch 加上毫秒数</span></span><br><span class="line">    <span class="function">ptime <span class="title">epoch</span><span class="params">(date(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">    time_duration duration = <span class="built_in">milliseconds</span>(timestampMs);</span><br><span class="line">    ptime utc_time = epoch + duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为系统本地时间</span></span><br><span class="line">    <span class="keyword">typedef</span> c_local_adjustor&lt;ptime&gt; local_adj;</span><br><span class="line">    ptime local_time = local_adj::<span class="built_in">utc_to_local</span>(utc_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化输出</span></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    time_facet* facet = <span class="keyword">new</span> <span class="built_in">time_facet</span>(formatStr.<span class="built_in">c_str</span>());</span><br><span class="line">    oss.<span class="built_in">imbue</span>(std::<span class="built_in">locale</span>(std::locale::<span class="built_in">classic</span>(), facet));</span><br><span class="line">    oss &lt;&lt; local_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// TIMES_H</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="服务端核心代码"><a href="#服务端核心代码" class="headerlink" title="服务端核心代码"></a>服务端核心代码</h5><div class="admonition note"><p class="admonition-title">提示</p><p>在集群聊天服务端中，使用了 Json 库和 Muduo 网络库，并引入了 MySQL、Redis。</p></div><h6 id="Redis-操作代码"><a href="#Redis-操作代码" class="headerlink" title="Redis 操作代码"></a>Redis 操作代码</h6><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Redis 安装完成后，切记不要设置密码，否则下面的 C++ 代码将无法正常连接 Redis 服务器，这是因为下面的 C++ 代码并没有实现 Redis 的身份认证功能。</p></div><ul><li><code>include/server/redis/redis.hpp</code> 头文件 </li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> REDIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis 操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Redis</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Redis</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接redis服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向redis指定的通道subscribe消息</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">int</span> channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向redis指定的通道unsubscribe消息</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unsubscribe</span><span class="params">(<span class="keyword">int</span> channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在独立线程中异步接收订阅通道中的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">observer_channel_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向redis指定的通道publish消息</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">publish</span><span class="params">(<span class="keyword">int</span> channel, string message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化向业务层上报通道消息的回调对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init_notify_handler</span><span class="params">(function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, string)&gt; fn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// hiredis同步上下文对象（即redis客户端），负责publish消息</span></span><br><span class="line">    redisContext *_publish_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hiredis同步上下文对象（即redis客户端），负责subscribe消息</span></span><br><span class="line">    redisContext *_subcribe_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调操作，收到订阅的消息，给service层上报</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, string)&gt; _notify_message_handler;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/redis/redis.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Redis::<span class="built_in">Redis</span>() : _publish_context(<span class="literal">nullptr</span>), _subcribe_context(<span class="literal">nullptr</span>) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Redis::~<span class="built_in">Redis</span>() {</span><br><span class="line">    <span class="keyword">if</span> (_publish_context != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">redisFree</span>(_publish_context);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_subcribe_context != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">redisFree</span>(_subcribe_context);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接redis服务器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::connect</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 负责publish发布消息的上下文对象（即redis客户端）</span></span><br><span class="line">    _publish_context = <span class="built_in">redisConnect</span>(REDIS_IP.<span class="built_in">c_str</span>(), REDIS_PORT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == _publish_context || _publish_context-&gt;err) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"connect redis failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (_publish_context) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"connect redis error: "</span> &lt;&lt; _publish_context-&gt;errstr &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">redisFree</span>(_publish_context);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负责subscribe订阅消息的上下文对象（即redis客户端）</span></span><br><span class="line">    _subcribe_context = <span class="built_in">redisConnect</span>(REDIS_IP.<span class="built_in">c_str</span>(), REDIS_PORT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == _subcribe_context || _subcribe_context-&gt;err) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"connect redis failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (_subcribe_context) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"connect redis error: "</span> &lt;&lt; _subcribe_context-&gt;errstr &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">redisFree</span>(_subcribe_context);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在单独的线程中，监听通道上的事件，有消息就给业务层进行上报</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([&amp;]() { observer_channel_message(); })</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"connect redis success!"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向redis指定的通道subscribe消息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::subscribe</span><span class="params">(<span class="keyword">int</span> channel)</span> </span>{</span><br><span class="line">    <span class="comment">// SUBSCRIBE命令本身会造成线程阻塞等待通道里面发生消息，这里只做订阅通道，不接收通道消息</span></span><br><span class="line">    <span class="comment">// 通道消息的接收专门在observer_channel_message()函数中的独立线程中进行</span></span><br><span class="line">    <span class="comment">// 这里只负责发送订阅命令，不阻塞接收Redis服务器的响应消息，否则会和notifyMsg线程抢占响应资源</span></span><br><span class="line">    <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisAppendCommand</span>(<span class="keyword">this</span>-&gt;_subcribe_context, <span class="string">"SUBSCRIBE %d"</span>, channel)) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"subscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// redisBufferWrite()函数可以循环发送缓冲区中的数据，直到缓冲区数据发送完毕（done被置为1）</span></span><br><span class="line">    <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) {</span><br><span class="line">        <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisBufferWrite</span>(<span class="keyword">this</span>-&gt;_subcribe_context, &amp;done)) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"subscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向redis指定的通道unsubscribe消息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::unsubscribe</span><span class="params">(<span class="keyword">int</span> channel)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisAppendCommand</span>(<span class="keyword">this</span>-&gt;_subcribe_context, <span class="string">"UNSUBSCRIBE %d"</span>, channel)) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"unsubscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// redisBufferWrite()函数可以循环发送缓冲区中的数据，直到缓冲区数据发送完毕（done被置为1）</span></span><br><span class="line">    <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) {</span><br><span class="line">        <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisBufferWrite</span>(<span class="keyword">this</span>-&gt;_subcribe_context, &amp;done)) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"unsubscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在独立线程中异步接收订阅通道中的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Redis::observer_channel_message</span><span class="params">()</span> </span>{</span><br><span class="line">    redisReply *reply = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (REDIS_OK == <span class="built_in">redisGetReply</span>(<span class="keyword">this</span>-&gt;_subcribe_context, (<span class="keyword">void</span> **)&amp;reply)) {</span><br><span class="line">        <span class="comment">// 订阅收到的消息是一个带三个元素的数组</span></span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="literal">nullptr</span> &amp;&amp; reply-&gt;element[<span class="number">2</span>] != <span class="literal">nullptr</span> &amp;&amp; reply-&gt;element[<span class="number">2</span>]-&gt;str != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="comment">// 给业务层上报通道上发生的消息</span></span><br><span class="line">            _notify_message_handler(<span class="built_in">atoi</span>(reply-&gt;element[<span class="number">1</span>]-&gt;str), reply-&gt;element[<span class="number">2</span>]-&gt;str);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; observer_channel_message quit &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向redis指定的通道publish消息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::publish</span><span class="params">(<span class="keyword">int</span> channel, string message)</span> </span>{</span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">    redisReply *reply = (redisReply *)<span class="built_in">redisCommand</span>(_publish_context, <span class="string">"PUBLISH %d %s"</span>, channel, message.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == reply) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"publish command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化向业务层上报通道消息的回调对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Redis::init_notify_handler</span><span class="params">(function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, string)&gt; fn)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;_notify_message_handler = fn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="MySQL-操作代码"><a href="#MySQL-操作代码" class="headerlink" title="MySQL 操作代码"></a>MySQL 操作代码</h6><div class="admonition note"><p class="admonition-title">提示</p><p>这里使用 MySQL C API（Connector/C）库来读写 MySQL 数据库，该库基于 C 语言开发。</p></div><ul><li><code>include/server/db/db.hpp</code> 源文件 </li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DB_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化数据库连接</span></span><br><span class="line">    <span class="built_in">MySQL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放数据库连接</span></span><br><span class="line">    ~<span class="built_in">MySQL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新操作</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询操作</span></span><br><span class="line">    <span class="function">MYSQL_RES *<span class="title">query</span><span class="params">(string sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据库连接</span></span><br><span class="line">    <span class="function">MYSQL *<span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *_conn;  <span class="comment">// 数据库连接</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// DB_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/db/db.cpp</code> 源文件 </li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"db.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数据库连接</span></span><br><span class="line">MySQL::<span class="built_in">MySQL</span>() {</span><br><span class="line">    _conn = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放数据库连接</span></span><br><span class="line">MySQL::~<span class="built_in">MySQL</span>() {</span><br><span class="line">    <span class="keyword">if</span> (_conn != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">mysql_close</span>(_conn);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MySQL::connect</span><span class="params">()</span> </span>{</span><br><span class="line">    MYSQL *p = <span class="built_in">mysql_real_connect</span>(_conn, DB_IP.<span class="built_in">c_str</span>(), DB_USER.<span class="built_in">c_str</span>(), DB_PASSWORD.<span class="built_in">c_str</span>(), DB_NAME.<span class="built_in">c_str</span>(), DB_PORT,</span><br><span class="line">                                  <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="comment">// C和C++代码默认的编码字符是ASCII，如果不设置，从MySQL查询到的中文内容可能会显示？乱码</span></span><br><span class="line">        <span class="built_in">mysql_query</span>(_conn, <span class="string">"set names utf8mb4"</span>);</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"connect mysql success!"</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"connect mysql failed!"</span>;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="built_in">mysql_error</span>(_conn);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MySQL::update</span><span class="params">(string sql)</span> </span>{</span><br><span class="line">    LOG_DEBUG &lt;&lt; sql;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) {</span><br><span class="line">        LOG_ERROR &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">" "</span> &lt;&lt; sql &lt;&lt; <span class="string">" execute failed!"</span>;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="built_in">mysql_error</span>(_conn);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="function">MYSQL_RES *<span class="title">MySQL::query</span><span class="params">(string sql)</span> </span>{</span><br><span class="line">    LOG_DEBUG &lt;&lt; sql;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) {</span><br><span class="line">        LOG_ERROR &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">" "</span> &lt;&lt; sql &lt;&lt; <span class="string">" execute failed!"</span>;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="built_in">mysql_error</span>(_conn);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_store_result</span>(_conn);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据库连接</span></span><br><span class="line"><span class="function">MYSQL *<span class="title">MySQL::getConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> _conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="聊天服务端代码"><a href="#聊天服务端代码" class="headerlink" title="聊天服务端代码"></a>聊天服务端代码</h6><blockquote><p>聊天服务器的代码</p></blockquote><ul><li><code>include/server/chatserver.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CHATSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHATSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器的头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天服务器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ChatServer</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">const</span> string&amp; nameArg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ChatServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 处理用户的连接创建和断开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用户读写事件（比如接收客户端发送的数据）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    TcpServer _server;  <span class="comment">// TCP 服务器对象</span></span><br><span class="line">    EventLoop* _loop;   <span class="comment">// 指向事件回环的指针</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CHATSERVER_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/chatserver.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"chatserver.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"chatservice.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ChatServer::<span class="built_in">ChatServer</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">const</span> string&amp; nameArg)</span><br><span class="line">    : _server(loop, listenAddr, nameArg), _loop(loop) {</span><br><span class="line">    <span class="comment">// 设置服务端注册用户连接的创建和断开回调</span></span><br><span class="line">    _server.<span class="built_in">setConnectionCallback</span>(<span class="built_in">bind</span>(&amp;ChatServer::onConnection, <span class="keyword">this</span>, placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务端注册用户读写事件的回调</span></span><br><span class="line">    _server.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        <span class="built_in">bind</span>(&amp;ChatServer::onMessage, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置EventLoop的线程数量（比如：1个I/O线程，3个Worker线程）</span></span><br><span class="line">    _server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ChatServer::~<span class="built_in">ChatServer</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 开启事件循环处理</span></span><br><span class="line">    _server.<span class="built_in">start</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户的连接创建和断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;<span class="built_in">connected</span>()) {</span><br><span class="line">        <span class="comment">// 处理用户连接关闭的情况</span></span><br><span class="line">        ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">clientConnClose</span>(conn);</span><br><span class="line">        <span class="comment">// 断开连接（释放资源）</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户读写事件（比如接收客户端发送的数据）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取客户端发送的数据</span></span><br><span class="line">    string message = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"server received message : "</span> &lt;&lt; message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON 字符串反序列化</span></span><br><span class="line">    json jsonObj = json::<span class="built_in">parse</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非法消息直接忽略处理</span></span><br><span class="line">    <span class="keyword">if</span> (!jsonObj.<span class="built_in">contains</span>(<span class="string">"msgType"</span>)) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::INVALID_MESSAGE_TYPE;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"消息类型无效"</span>;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="keyword">int</span> msgType = jsonObj[<span class="string">"msgType"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息处理器</span></span><br><span class="line">    <span class="keyword">auto</span> msgHandler = ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">getMsgHandler</span>(msgType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用消息处理器，执行相应的业务处理</span></span><br><span class="line">    <span class="built_in">msgHandler</span>(conn, make_shared&lt;json&gt;(jsonObj), time);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>聊天核心业务的代码</p></blockquote><ul><li><code>include/server/chatservice.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CHATSERVICE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHATSERVICE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天核心业务的头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friendmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"groupmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"groupusermodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessagemodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usermodel.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理消息的回调类型（使用智能指针是为了兼容低版本的G++编译器）</span></span><br><span class="line"><span class="keyword">using</span> MsgHandler = function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天服务器的业务类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatService</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ChatService* <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理登录业务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理注册业务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reg</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理一对一聊天消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">singleChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理添加好友消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFriend</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理创建群组消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理加入群组消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">joinGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理群聊天消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">groupChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理退出登录消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loginOut</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息对应的处理器</span></span><br><span class="line">    <span class="function">MsgHandler <span class="title">getMsgHandler</span><span class="params">(<span class="keyword">int</span> msgType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理Redis订阅通道中发生的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRedisSubScribeMessage</span><span class="params">(<span class="keyword">int</span> userid, string msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用户连接关闭的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clientConnClose</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理服务器退出（Ctrl+C）后的业务重置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">ChatService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">ChatService</span>(<span class="keyword">const</span> ChatService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    ChatService&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ChatService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联消息ID和消息处理器（用于解耦业务代码）</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, MsgHandler&gt; _msgHandlerMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储在线用户的通信连接（操作时必须自行保证线程安全）</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, TcpConnectionPtr&gt; _userConnMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥锁，保证 _userConnMap 的线程安全</span></span><br><span class="line">    mutex _connMapmutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// User 表的数据操作对象</span></span><br><span class="line">    UserModel _userModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OfflineMessage 表的数据操作对象</span></span><br><span class="line">    OfflineMessageModel _offflineMessageModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Friend 表的数据操作对象</span></span><br><span class="line">    FriendModel _friendModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Group 表的数据操作对象</span></span><br><span class="line">    GroupModel _groupModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GroupUser 表的数据操作对象</span></span><br><span class="line">    GroupUserModel _groupUserModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis 操作对象</span></span><br><span class="line">    Redis _redis;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CHATSERVICE_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/chatservice.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器的业务实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"chatservice.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friendmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessagemodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"times.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usermodel.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ChatService::<span class="built_in">ChatService</span>() {</span><br><span class="line">    <span class="comment">// 连接Redis服务器</span></span><br><span class="line">    <span class="keyword">if</span> (_redis.<span class="built_in">connect</span>()) {</span><br><span class="line">        <span class="comment">// 设置Redis订阅通道的回调对象（负责处理Redis订阅消息）</span></span><br><span class="line">        _redis.<span class="built_in">init_notify_handler</span>(</span><br><span class="line">            <span class="built_in">bind</span>(&amp;ChatService::handleRedisSubScribeMessage, <span class="keyword">this</span>, placeholders::_1, placeholders::_2));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联登录业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(</span><br><span class="line">        {MsgType::LOGIN_MSG, <span class="built_in">bind</span>(&amp;ChatService::login, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联注册业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(</span><br><span class="line">        {MsgType::REGISTER_MSG, <span class="built_in">bind</span>(&amp;ChatService::reg, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联一对一聊天业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::SINGLE_CHAT_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::singleChat, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联添加好友业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::ADD_FRIEND_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::addFriend, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联添加群组业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::CREATE_GROUP_MSG, <span class="built_in">bind</span>(&amp;ChatService::createGroup, <span class="keyword">this</span>, placeholders::_1,</span><br><span class="line">                                                           placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联加入群组业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::JOIN_GROUP_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::joinGroup, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联群聊天业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::GROUP_CHAT_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::groupChat, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联退出登录业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::LOGIN_OUT_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::loginOut, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">ChatService* <span class="title">ChatService::instance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> ChatService instance;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取消息对应的处理器</span></span><br><span class="line"><span class="function">MsgHandler <span class="title">ChatService::getMsgHandler</span><span class="params">(<span class="keyword">int</span> msgType)</span> </span>{</span><br><span class="line">    <span class="comment">// 查找消息处理器</span></span><br><span class="line">    <span class="keyword">auto</span> it = _msgHandlerMap.<span class="built_in">find</span>(msgType);</span><br><span class="line">    <span class="comment">// 如果消息处理器不存在</span></span><br><span class="line">    <span class="keyword">if</span> (it == _msgHandlerMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 返回一个默认的消息处理器（空操作）</span></span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            LOG_ERROR &lt;&lt; <span class="string">"not found message handler by message type "</span> &lt;&lt; msgType;</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> _msgHandlerMap[msgType];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理Redis订阅通道中发生的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::handleRedisSubScribeMessage</span><span class="params">(<span class="keyword">int</span> userid, string msg)</span> </span>{</span><br><span class="line">    <span class="comment">// JSON 反序列化</span></span><br><span class="line">    json js = json::<span class="built_in">parse</span>(msg.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送的时间</span></span><br><span class="line">    <span class="keyword">long</span> timestamp = js[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息接收者的连接信息</span></span><br><span class="line">    <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(userid);</span><br><span class="line">    <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 消息接收者在线（指在当前聊天服务器中），直接转发消息</span></span><br><span class="line">        it-&gt;second-&gt;<span class="built_in">send</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 当接收到Redis订阅消息时，如果消息接收者刚好下线，则存储离线消息</span></span><br><span class="line">        OfflineMessage <span class="built_in">msg</span>(userid, js.<span class="built_in">dump</span>(), timestamp);</span><br><span class="line">        _offflineMessageModel.<span class="built_in">insert</span>(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理登录业务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::login</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    string name = (*data)[<span class="string">"name"</span>].get&lt;string&gt;();</span><br><span class="line">    string password = (*data)[<span class="string">"password"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户信息</span></span><br><span class="line">    User user = _userModel.<span class="built_in">selectByName</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">    <span class="keyword">if</span> (user.<span class="built_in">getId</span>() != <span class="number">-1</span> &amp;&amp; user.<span class="built_in">getPassword</span>() == password) {</span><br><span class="line">        <span class="comment">// 重复登录</span></span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">getState</span>() == <span class="string">"online"</span>) {</span><br><span class="line">            <span class="comment">// 返回数据给客户端</span></span><br><span class="line">            json response;</span><br><span class="line">            response[<span class="string">"errNum"</span>] = ErrorCode::REPEAT_LOGIN;</span><br><span class="line">            response[<span class="string">"errMsg"</span>] = <span class="string">"该账号在其他设备已登录"</span>;</span><br><span class="line">            response[<span class="string">"msgType"</span>] = MsgType::LOGIN_MSG_ACK;</span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 登录成功</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            unique_lock&lt;mutex&gt; <span class="built_in">lock</span>(_connMapmutex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储在线用户的通信连接</span></span><br><span class="line">            _userConnMap.<span class="built_in">insert</span>({user.<span class="built_in">getId</span>(), conn});</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放互斥锁</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向Redis订阅Channel</span></span><br><span class="line">            _redis.<span class="built_in">subscribe</span>(user.<span class="built_in">getId</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新用户登录状态</span></span><br><span class="line">            user.<span class="built_in">setState</span>(<span class="string">"online"</span>);</span><br><span class="line">            _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回给客户端的数据</span></span><br><span class="line">            json response;</span><br><span class="line">            response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">            response[<span class="string">"userId"</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">            response[<span class="string">"userName"</span>] = user.<span class="built_in">getName</span>();</span><br><span class="line">            response[<span class="string">"msgType"</span>] = MsgType::LOGIN_MSG_ACK;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询该用户是否有离线消息</span></span><br><span class="line">            vector&lt;OfflineMessage&gt; messages = _offflineMessageModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (!messages.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="comment">// 返回该用户的所有离线消息</span></span><br><span class="line">                response[<span class="string">"offlinemsg"</span>] = messages;</span><br><span class="line">                <span class="comment">// 读取该用户的离线消息后，将该用户的离线消息全部删除掉</span></span><br><span class="line">                _offflineMessageModel.<span class="built_in">remove</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询该用户的好友列表</span></span><br><span class="line">            vector&lt;User&gt; friends = _friendModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (!friends.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="comment">// 返回该用户的好友列表</span></span><br><span class="line">                response[<span class="string">"friends"</span>] = friends;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询该用户的群组列表</span></span><br><span class="line">            vector&lt;Group&gt; groups = _groupUserModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (!groups.<span class="built_in">empty</span>()) {</span><br><span class="line">                response[<span class="string">"groups"</span>] = groups;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回数据给客户端</span></span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 登录失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::LOGIN_AUTH_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"用户名或密码不正确"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::LOGIN_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理注册业务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::reg</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建用户对象</span></span><br><span class="line">    string name = (*data)[<span class="string">"name"</span>].get&lt;string&gt;();</span><br><span class="line">    string password = (*data)[<span class="string">"password"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户名是否已被注册</span></span><br><span class="line">    User oldUser = _userModel.<span class="built_in">selectByName</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (oldUser.<span class="built_in">getId</span>() != <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::REPEAT_REGISTER;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"用户名已被注册"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::REGISTER_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户记录</span></span><br><span class="line">    <span class="function">User <span class="title">newUser</span><span class="params">(name, password)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> result = _userModel.<span class="built_in">insert</span>(newUser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户记录成功</span></span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">        response[<span class="string">"userId"</span>] = newUser.<span class="built_in">getId</span>();</span><br><span class="line">        response[<span class="string">"userName"</span>] = newUser.<span class="built_in">getName</span>();</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::REGISTER_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 插入用户记录失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::REGISTER_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"用户注册失败"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::REGISTER_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理一对一聊天消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::singleChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 消息发送者的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> fromId = (*data)[<span class="string">"fromId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送者的用户名称</span></span><br><span class="line">    string fromName = (*data)[<span class="string">"fromName"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送者的消息内容</span></span><br><span class="line">    string fromMsg = (*data)[<span class="string">"fromMsg"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送的时间戳</span></span><br><span class="line">    <span class="keyword">long</span> fromTimestamp = (*data)[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息接收者的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> toId = (*data)[<span class="string">"toId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息接收者是否在当前聊天服务器中</span></span><br><span class="line">    <span class="keyword">bool</span> toExisted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否已经添加消息接收者为好友</span></span><br><span class="line">    Friend friendRel = _friendModel.<span class="built_in">select</span>(fromId, toId);</span><br><span class="line">    <span class="keyword">if</span> (friendRel.<span class="built_in">getUserId</span>() == <span class="number">-1</span> || friendRel.<span class="built_in">getFriendId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::SINGLE_CHAT_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"未添加对方好友, 无法进行一对一聊天"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::SINGLE_CHAT_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息接收者的连接信息</span></span><br><span class="line">    <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(toId);</span><br><span class="line">    <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 记录消息接收者在线（指在当前聊天服务器中）</span></span><br><span class="line">        toExisted = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 消息接收者在线（指在当前聊天服务器中），直接转发消息</span></span><br><span class="line">        it-&gt;second-&gt;<span class="built_in">send</span>((*data).<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息接收者不在当前聊天服务器中</span></span><br><span class="line">    <span class="keyword">if</span> (!toExisted) {</span><br><span class="line">        User toUser = _userModel.<span class="built_in">select</span>(toId);</span><br><span class="line">        <span class="comment">// 判断消息接收者是否在线（指在其他聊天服务器中）</span></span><br><span class="line">        <span class="keyword">if</span> (toUser.<span class="built_in">getState</span>() == <span class="string">"online"</span>) {</span><br><span class="line">            <span class="comment">// 消息接收者在线，通过Redis发布消息</span></span><br><span class="line">            _redis.<span class="built_in">publish</span>(toId, (*data).<span class="built_in">dump</span>());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 消息接收者不在线，存储离线消息</span></span><br><span class="line">            OfflineMessage <span class="built_in">msg</span>(toId, (*data).<span class="built_in">dump</span>(), fromTimestamp);</span><br><span class="line">            _offflineMessageModel.<span class="built_in">insert</span>(msg);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::SINGLE_CHAT_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理添加好友消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::addFriend</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好友的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> friendId = (*data)[<span class="string">"friendId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制不允许添加自己为好友</span></span><br><span class="line">    <span class="keyword">if</span> (userId == friendId) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::ADD_FRIEND_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"不允许添加自己为好友"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::ADD_FRIEND_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断好友是否真实存在</span></span><br><span class="line">    User friendUser = _userModel.<span class="built_in">select</span>(friendId);</span><br><span class="line">    <span class="keyword">if</span> (friendUser.<span class="built_in">getId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::ADD_FRIEND_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"好友ID不存在"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::ADD_FRIEND_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增好友关系</span></span><br><span class="line">    _friendModel.<span class="built_in">insert</span>(userId, friendId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::ADD_FRIEND_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理创建群组消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::createGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组名称</span></span><br><span class="line">    string groupName = (*data)[<span class="string">"groupName"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组描述</span></span><br><span class="line">    string groupDesc = (*data)[<span class="string">"groupDesc"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增群组</span></span><br><span class="line">    <span class="function">Group <span class="title">group</span><span class="params">(groupName, groupDesc)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> result = _groupModel.<span class="built_in">insert</span>(group);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加群组的创建人信息</span></span><br><span class="line">    <span class="keyword">if</span> (result &amp;&amp; group.<span class="built_in">getId</span>() != <span class="number">-1</span>) {</span><br><span class="line">        GroupUser groupUser;</span><br><span class="line">        groupUser.<span class="built_in">setGroupId</span>(group.<span class="built_in">getId</span>());</span><br><span class="line">        groupUser.<span class="built_in">setUserId</span>(userId);</span><br><span class="line">        groupUser.<span class="built_in">setGroupRole</span>(<span class="string">"creator"</span>);</span><br><span class="line">        <span class="comment">// 新增群组和用户的关联信息</span></span><br><span class="line">        _groupUserModel.<span class="built_in">insert</span>(groupUser);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"groupId"</span>] = group.<span class="built_in">getId</span>();</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::CREATE_GROUP_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理加入群组消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::joinGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组ID</span></span><br><span class="line">    <span class="keyword">int</span> groupId = (*data)[<span class="string">"groupId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断群组是否真实存在</span></span><br><span class="line">    Group group = _groupModel.<span class="built_in">select</span>(groupId);</span><br><span class="line">    <span class="keyword">if</span> (group.<span class="built_in">getId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::JOIN_GROUP_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"群组ID不存在"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::JOIN_GROUP_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增群组和用户的关联信息</span></span><br><span class="line">    <span class="function">GroupUser <span class="title">groupUser</span><span class="params">(groupId, userId, <span class="string">"normal"</span>)</span></span>;</span><br><span class="line">    _groupUserModel.<span class="built_in">insert</span>(groupUser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::JOIN_GROUP_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理群聊天消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::groupChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 消息发送者的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> fromId = (*data)[<span class="string">"fromId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送者的用户名称</span></span><br><span class="line">    string fromName = (*data)[<span class="string">"fromName"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送的时间戳</span></span><br><span class="line">    <span class="keyword">long</span> fromTimestamp = (*data)[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组的ID</span></span><br><span class="line">    <span class="keyword">int</span> groupId = (*data)[<span class="string">"groupId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组消息的内容</span></span><br><span class="line">    string groupMsg = (*data)[<span class="string">"groupMsg"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户是否已经加入群组</span></span><br><span class="line">    GroupUser groupUser = _groupUserModel.<span class="built_in">select</span>(groupId, fromId);</span><br><span class="line">    <span class="keyword">if</span> (groupUser.<span class="built_in">getGroupId</span>() == <span class="number">-1</span> || groupUser.<span class="built_in">getUserId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::JOIN_GROUP_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"未加入该群组, 无法进行群聊"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::JOIN_GROUP_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询群组内的用户（除了发送群组消息的用户）</span></span><br><span class="line">    vector&lt;User&gt; users = _groupUserModel.<span class="built_in">selectGroupUsers</span>(groupId, fromId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理群聊消息</span></span><br><span class="line">    <span class="keyword">if</span> (!users.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        unique_lock&lt;mutex&gt; lock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历群组内的用户</span></span><br><span class="line">        <span class="keyword">for</span> (User&amp; user : users) {</span><br><span class="line">            <span class="comment">// 获取用户的连接信息</span></span><br><span class="line">            <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">                <span class="comment">// 用户在线（指在当前聊天服务器中），直接转发群聊消息</span></span><br><span class="line">                it-&gt;second-&gt;<span class="built_in">send</span>((*data).<span class="built_in">dump</span>());</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                User toUser = _userModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">                <span class="comment">// 判断用户是否在线（指在其他聊天服务器中）</span></span><br><span class="line">                <span class="keyword">if</span> (toUser.<span class="built_in">getState</span>() == <span class="string">"online"</span>) {</span><br><span class="line">                    <span class="comment">// 用户在线，通过Redis发布群聊消息</span></span><br><span class="line">                    _redis.<span class="built_in">publish</span>(user.<span class="built_in">getId</span>(), (*data).<span class="built_in">dump</span>());</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 用户不在线，存储离线群聊消息</span></span><br><span class="line">                    OfflineMessage message;</span><br><span class="line">                    message.<span class="built_in">setUserId</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">                    message.<span class="built_in">setCreateTime</span>(fromTimestamp);</span><br><span class="line">                    message.<span class="built_in">setMessage</span>((*data).<span class="built_in">dump</span>());</span><br><span class="line">                    _offflineMessageModel.<span class="built_in">insert</span>(message);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::GROUP_CHAT_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理退出登录消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::loginOut</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除连接信息</span></span><br><span class="line">    <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(userId);</span><br><span class="line">    <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">        _userConnMap.<span class="built_in">erase</span>(it-&gt;first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往Redis取消订阅Channel</span></span><br><span class="line">    _redis.<span class="built_in">unsubscribe</span>(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新用户的登录状态</span></span><br><span class="line">    User user;</span><br><span class="line">    user.<span class="built_in">setId</span>(userId);</span><br><span class="line">    user.<span class="built_in">setState</span>(<span class="string">"offline"</span>);</span><br><span class="line">    _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::LOGIN_OUT_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户连接关闭的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::clientConnClose</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="comment">// 用户信息</span></span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Map表中删除用户对应的连接信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = _userConnMap.<span class="built_in">begin</span>(); it != _userConnMap.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second == conn) {</span><br><span class="line">            <span class="comment">// 记录用户ID</span></span><br><span class="line">            user.<span class="built_in">setId</span>(it-&gt;first);</span><br><span class="line">            <span class="comment">// 移除连接信息</span></span><br><span class="line">            _userConnMap.<span class="built_in">erase</span>(it-&gt;first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user.<span class="built_in">getId</span>() != <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 往Redis取消订阅Channel</span></span><br><span class="line">        _redis.<span class="built_in">unsubscribe</span>(user.<span class="built_in">getId</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新用户的登录状态</span></span><br><span class="line">        user.<span class="built_in">setState</span>(<span class="string">"offline"</span>);</span><br><span class="line">        _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理服务器退出（Ctrl+C）后的业务重置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::reset</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 重置所有用户的登录状态</span></span><br><span class="line">    _userModel.<span class="built_in">resetState</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>数据库业务操作的代码</p></blockquote><ul><li><code>include/server/dao/friendmodel.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FRIENDMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRIENDMODEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Friend 表的数据操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendModel</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加好友关系</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找好友列表</span></span><br><span class="line">    <span class="function">vector&lt;User&gt; <span class="title">select</span><span class="params">(<span class="keyword">int</span> userid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找好友关系</span></span><br><span class="line">    <span class="function">Friend <span class="title">select</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// FRIENDMODEL_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/dao/friendmodel.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;friendmodel.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"db.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加好友关系</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FriendModel::insert</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> sql[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 SQL 语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">"insert into friend(userid, friendid) values(%d, %d)"</span>, userid, friendid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 SQL 语句</span></span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>() &amp;&amp; mysql.<span class="built_in">update</span>(sql)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找好友列表</span></span><br><span class="line"><span class="function">vector&lt;User&gt; <span class="title">FriendModel::select</span><span class="params">(<span class="keyword">int</span> userid)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> sql[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询结果</span></span><br><span class="line">    vector&lt;User&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 SQL 语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql,</span><br><span class="line">            <span class="string">"select u.id, u.name, u.state from friend f inner join user u on f.friendid = u.id where f.userid = %d"</span>,</span><br><span class="line">            userid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 SQL 语句</span></span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>()) {</span><br><span class="line">        MYSQL_RES* res = mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">mysql_num_rows</span>(res) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 获取所有查询结果</span></span><br><span class="line">            MYSQL_ROW row;</span><br><span class="line">            <span class="keyword">while</span> ((row = <span class="built_in">mysql_fetch_row</span>(res)) != <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">int</span> id = <span class="built_in">atoi</span>(row[<span class="number">0</span>]);</span><br><span class="line">                string name = row[<span class="number">1</span>];</span><br><span class="line">                string state = row[<span class="number">2</span>];</span><br><span class="line">                result.<span class="built_in">emplace_back</span>(id, name, state);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回查询结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找好友关系</span></span><br><span class="line"><span class="function">Friend <span class="title">FriendModel::select</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> sql[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询结果</span></span><br><span class="line">    Friend result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 SQL 语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">"select userid, friendid from friend where userid = %d and friendid = %d"</span>, userid, friendid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 SQL 语句</span></span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>()) {</span><br><span class="line">        MYSQL_RES* res = mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">mysql_num_rows</span>(res) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 获取所有查询结果</span></span><br><span class="line">            MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res);</span><br><span class="line">            result.<span class="built_in">setUserId</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">            result.<span class="built_in">setFriendId</span>(<span class="built_in">atoi</span>(row[<span class="number">1</span>]));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回查询结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="客户端核心代码"><a href="#客户端核心代码" class="headerlink" title="客户端核心代码"></a>客户端核心代码</h5><h6 id="聊天客户端代码"><a href="#聊天客户端代码" class="headerlink" title="聊天客户端代码"></a>聊天客户端代码</h6><div class="admonition note"><p class="admonition-title">提示</p><p>在集群聊天客户端中，使用了 Linux 的 <code>socket</code> 和 <code>semaphore</code>，并没有引入 Muduo 网络库。</p></div><ul><li><code>src/client/main.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"group.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"groupmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessage.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessagemodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"times.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usermodel.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录当前登录用户的基本信息</span></span><br><span class="line">User g_currentUser;</span><br><span class="line"><span class="comment">// 记录当前登录用户的好友列表信息</span></span><br><span class="line">vector&lt;User&gt; g_currentUserFriendList;</span><br><span class="line"><span class="comment">// 记录当前登录用户的群组列表信息</span></span><br><span class="line">vector&lt;Group&gt; g_currentUserGroupList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于读/写线程之间的通信</span></span><br><span class="line"><span class="keyword">sem_t</span> rwsem;</span><br><span class="line"><span class="comment">// 控制主菜单程序运行</span></span><br><span class="line"><span class="keyword">bool</span> isMainMenuRunning = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 记录用户的登录状态</span></span><br><span class="line"><span class="keyword">atomic_bool</span> g_isLoginSuccess{<span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主菜单程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainMenu</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 子线程接收到消息后的处理逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readTaskHandler</span><span class="params">(<span class="keyword">int</span> clientfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示当前登录用户的基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showCurrentUserData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////首页功能/////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天客户端程序实现, 主线程用作消息发送线程, 子线程用作消息接收线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"command invalid, example: ./chat_client 127.0.0.1 8000"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析通过命令行参数传递的IP和端口号</span></span><br><span class="line">    <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建client端的socket</span></span><br><span class="line">    <span class="keyword">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clientfd) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"socket create failed"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填写client需要连接的服务器信息（IP和端口号）</span></span><br><span class="line">    sockaddr_in server;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sockaddr_in));</span><br><span class="line"></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client和server进行连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;server, <span class="built_in"><span class="keyword">sizeof</span></span>(sockaddr_in))) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"connect server failed"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化读写线程通信用的信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;rwsem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器成功, 启动一个接收消息的子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">readTask</span><span class="params">(readTaskHandler, clientfd)</span></span>;</span><br><span class="line">    readTask.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程用于接收用户输入, 负责发送数据</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 显示首页面菜单: 登录、注册、退出程序</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"========================"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"1. login"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"2. register"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"3. quit"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"========================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户输入验证循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"choice: "</span>;</span><br><span class="line">            cin &gt;&gt; choice;</span><br><span class="line">            <span class="comment">// 判断输入是否合法</span></span><br><span class="line">            <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) {</span><br><span class="line">                <span class="comment">// 输入不是整数，清除错误标志</span></span><br><span class="line">                cin.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">                cin.<span class="built_in">ignore</span>(<span class="number">10000</span>, <span class="string">'\n'</span>);</span><br><span class="line">                cerr &lt;&lt; <span class="string">"invalid choice!"</span> &lt;&lt; endl;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 清除残留的换行符</span></span><br><span class="line">                cin.<span class="built_in">ignore</span>(<span class="number">10000</span>, <span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据用户输入执行操作</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (choice) {</span><br><span class="line">            <span class="comment">// 登录业务</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: {</span><br><span class="line">                <span class="keyword">char</span> name[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                <span class="keyword">char</span> password[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                cout &lt;&lt; <span class="string">"user name: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(name, <span class="number">50</span>);</span><br><span class="line">                cout &lt;&lt; <span class="string">"user password: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(password, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">                json js;</span><br><span class="line">                js[<span class="string">"msgType"</span>] = LOGIN_MSG;</span><br><span class="line">                js[<span class="string">"name"</span>] = name;</span><br><span class="line">                js[<span class="string">"password"</span>] = password;</span><br><span class="line">                string request = js.<span class="built_in">dump</span>();</span><br><span class="line"></span><br><span class="line">                g_isLoginSuccess = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, request.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(request.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) {</span><br><span class="line">                    cerr &lt;&lt; <span class="string">"send login msg error: "</span> &lt;&lt; request &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待信号量, 由子线程处理完登录的响应消息后, 通知主线程继续执行</span></span><br><span class="line">                <span class="built_in">sem_wait</span>(&amp;rwsem);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 用户登录成功</span></span><br><span class="line">                <span class="keyword">if</span> (g_isLoginSuccess) {</span><br><span class="line">                    <span class="comment">// 进入聊天主菜单</span></span><br><span class="line">                    isMainMenuRunning = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">mainMenu</span>(clientfd);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 注册业务</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: {</span><br><span class="line">                <span class="keyword">char</span> name[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                <span class="keyword">char</span> pwd[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                cout &lt;&lt; <span class="string">"user name: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(name, <span class="number">50</span>);</span><br><span class="line">                cout &lt;&lt; <span class="string">"user password: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(pwd, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">                json js;</span><br><span class="line">                js[<span class="string">"msgType"</span>] = REGISTER_MSG;</span><br><span class="line">                js[<span class="string">"name"</span>] = name;</span><br><span class="line">                js[<span class="string">"password"</span>] = pwd;</span><br><span class="line">                string request = js.<span class="built_in">dump</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, request.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(request.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) {</span><br><span class="line">                    cerr &lt;&lt; <span class="string">"send reg msg error: "</span> &lt;&lt; request &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待信号量, 由子线程处理完注册的响应消息后, 通知主线程继续执行</span></span><br><span class="line">                <span class="built_in">sem_wait</span>(&amp;rwsem);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 退出程序业务</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">close</span>(clientfd);</span><br><span class="line">                <span class="built_in">sem_destroy</span>(&amp;rwsem);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cerr &lt;&lt; <span class="string">"invalid choice!"</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理注册的响应逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRegResponse</span><span class="params">(json &amp;responsejs)</span> </span>{</span><br><span class="line">    <span class="comment">// 注册失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != responsejs[<span class="string">"errNum"</span>].get&lt;<span class="keyword">int</span>&gt;()) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"注册失败: "</span> &lt;&lt; responsejs[<span class="string">"errMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 注册成功</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"注册成功, 用户ID: "</span> &lt;&lt; responsejs[<span class="string">"userId"</span>] &lt;&lt; <span class="string">" , 用户名称: "</span> &lt;&lt; responsejs[<span class="string">"userName"</span>].get&lt;string&gt;()</span><br><span class="line">             &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理登录的响应逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoginResponse</span><span class="params">(json &amp;responsejs)</span> </span>{</span><br><span class="line">    <span class="comment">// 登录失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != responsejs[<span class="string">"errNum"</span>].get&lt;<span class="keyword">int</span>&gt;()) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"登录失败: "</span> &lt;&lt; responsejs[<span class="string">"errMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">        g_isLoginSuccess = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 记录当前登录用户的基本信息</span></span><br><span class="line">        g_currentUser.<span class="built_in">setId</span>(responsejs[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        g_currentUser.<span class="built_in">setName</span>(responsejs[<span class="string">"userName"</span>].get&lt;string&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前用户的好友列表信息</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">"friends"</span>)) {</span><br><span class="line">            <span class="comment">// 初始化好友列表</span></span><br><span class="line">            g_currentUserFriendList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            vector&lt;User&gt; vec = responsejs[<span class="string">"friends"</span>];</span><br><span class="line">            <span class="keyword">for</span> (User &amp;user : vec) {</span><br><span class="line">                g_currentUserFriendList.<span class="built_in">push_back</span>(user);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前用户的群组列表信息</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">"groups"</span>)) {</span><br><span class="line">            <span class="comment">// 初始化群组列表</span></span><br><span class="line">            g_currentUserGroupList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            vector&lt;Group&gt; vec = responsejs[<span class="string">"groups"</span>];</span><br><span class="line">            <span class="keyword">for</span> (Group &amp;group : vec) {</span><br><span class="line">                g_currentUserGroupList.<span class="built_in">push_back</span>(group);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示登录用户的基本信息</span></span><br><span class="line">        <span class="built_in">showCurrentUserData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示当前用户的离线消息（个人聊天信息或者群组消息）</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">"offlinemsg"</span>)) {</span><br><span class="line">            vector&lt;OfflineMessage&gt; vec = responsejs[<span class="string">"offlinemsg"</span>];</span><br><span class="line">            <span class="keyword">for</span> (OfflineMessage &amp;message : vec) {</span><br><span class="line">                <span class="comment">// 离线消息的内容（JSON字符串）</span></span><br><span class="line">                json content = json::<span class="built_in">parse</span>(message.<span class="built_in">getMessage</span>());</span><br><span class="line">                <span class="comment">// 离线消息的发送时间</span></span><br><span class="line">                string datetime = formatTimestampLocal(message.<span class="built_in">getCreateTime</span>(), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">                <span class="comment">// 打印一对一聊天消息</span></span><br><span class="line">                <span class="keyword">if</span> (SINGLE_CHAT_MSG == content[<span class="string">"msgType"</span>].get&lt;<span class="keyword">int</span>&gt;()) {</span><br><span class="line">                    cout &lt;&lt; <span class="string">"好友消息["</span> &lt;&lt; content[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" "</span></span><br><span class="line">                         &lt;&lt; content[<span class="string">"fromName"</span>].get&lt;string&gt;() &lt;&lt; <span class="string">" said: "</span> &lt;&lt; content[<span class="string">"fromMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 打印群组聊天消息</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    cout &lt;&lt; <span class="string">"群聊消息["</span> &lt;&lt; content[<span class="string">"groupId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" ["</span> &lt;&lt; content[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span></span><br><span class="line">                         &lt;&lt; content[<span class="string">"fromName"</span>].get&lt;string&gt;() &lt;&lt; <span class="string">" said: "</span> &lt;&lt; content[<span class="string">"groupMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        g_isLoginSuccess = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程（接收消息的线程）执行的业务逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readTaskHandler</span><span class="params">(<span class="keyword">int</span> clientfd)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">recv</span>(clientfd, buffer, <span class="number">1024</span>, <span class="number">0</span>);  <span class="comment">// 阻塞等待消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == len || <span class="number">0</span> == len) {</span><br><span class="line">            <span class="built_in">close</span>(clientfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收ChatServer转发的数据, 反序列化生成JSON数据对象</span></span><br><span class="line">        json js = json::<span class="built_in">parse</span>(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息类型</span></span><br><span class="line">        <span class="keyword">int</span> msgType = js[<span class="string">"msgType"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 错误编码</span></span><br><span class="line">        <span class="keyword">int</span> errNum = js.<span class="built_in">contains</span>(<span class="string">"errNum"</span>) ? js[<span class="string">"errNum"</span>].get&lt;<span class="keyword">int</span>&gt;() : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理接收到的一对一聊天消息</span></span><br><span class="line">        <span class="keyword">if</span> (SINGLE_CHAT_MSG == msgType) {</span><br><span class="line">            string datetime = formatTimestampLocal(js[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;(), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">"好友消息["</span> &lt;&lt; js[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" "</span> &lt;&lt; js[<span class="string">"fromName"</span>].get&lt;string&gt;()</span><br><span class="line">                 &lt;&lt; <span class="string">" said: "</span> &lt;&lt; js[<span class="string">"fromMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理接收到的群组聊天消息</span></span><br><span class="line">        <span class="keyword">if</span> (GROUP_CHAT_MSG == msgType) {</span><br><span class="line">            string datetime = formatTimestampLocal(js[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;(), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">"群聊消息["</span> &lt;&lt; js[<span class="string">"groupId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" ["</span> &lt;&lt; js[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span></span><br><span class="line">                 &lt;&lt; js[<span class="string">"fromName"</span>].get&lt;string&gt;() &lt;&lt; <span class="string">" said: "</span> &lt;&lt; js[<span class="string">"groupMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理登录响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (LOGIN_MSG_ACK == msgType) {</span><br><span class="line">            <span class="built_in">doLoginResponse</span>(js);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;rwsem);  <span class="comment">// 通知主线程, 登录结果处理完成</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理注册响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (REGISTER_MSG_ACK == msgType) {</span><br><span class="line">            <span class="built_in">doRegResponse</span>(js);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;rwsem);  <span class="comment">// 通知主线程, 注册结果处理完成</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理成功创建群组响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (CREATE_GROUP_MSG_ACK == msgType &amp;&amp; SUCCESS == errNum) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"群组创建成功, 群组ID: "</span> &lt;&lt; js[<span class="string">"groupId"</span>].get&lt;<span class="keyword">int</span>&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理成功加入群组响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (JOIN_GROUP_MSG_ACK == msgType &amp;&amp; SUCCESS == errNum) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"加入群组成功"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理成功添加好友响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (ADD_FRIEND_MSG_ACK == msgType &amp;&amp; SUCCESS == errNum) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"好友添加成功"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理其他业务的错误响应</span></span><br><span class="line">        <span class="keyword">if</span> (SUCCESS != errNum &amp;&amp; js.<span class="built_in">contains</span>(<span class="string">"errMsg"</span>)) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"操作失败: "</span> &lt;&lt; js[<span class="string">"errMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示当前登录成功用户的基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showCurrentUserData</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"======================login user======================"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"current login user =&gt; id:"</span> &lt;&lt; g_currentUser.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" name:"</span> &lt;&lt; g_currentUser.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------friend list---------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!g_currentUserFriendList.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">for</span> (User &amp;user : g_currentUserFriendList) {</span><br><span class="line">            cout &lt;&lt; user.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getName</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getState</span>() &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------group list----------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!g_currentUserGroupList.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">for</span> (Group &amp;group : g_currentUserGroupList) {</span><br><span class="line">            cout &lt;&lt; group.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; group.<span class="built_in">getGroupName</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; group.<span class="built_in">getGroupDesc</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (User &amp;user : group.<span class="built_in">getUsers</span>()) {</span><br><span class="line">                cout &lt;&lt; user.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getName</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getState</span>() &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"======================================================"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////主菜单功能/////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "help" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span> fd = <span class="number">0</span>, string str = <span class="string">""</span>)</span></span>;</span><br><span class="line"><span class="comment">// "singlechat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">singlechat</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "addfriend" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfriend</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "creategroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creategroup</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "joingroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joingroup</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "groupchat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">groupchat</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "loginout" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loginout</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统支持的客户端命令列表</span></span><br><span class="line">unordered_map&lt;string, string&gt; commandMap = {{<span class="string">"help"</span>, <span class="string">"显示所有支持的命令, 格式 help"</span>},</span><br><span class="line">                                            {<span class="string">"singlechat"</span>, <span class="string">"一对一聊天, 格式 singlechat:friendid:message"</span>},</span><br><span class="line">                                            {<span class="string">"addfriend"</span>, <span class="string">"添加好友, 格式 addfriend:friendid"</span>},</span><br><span class="line">                                            {<span class="string">"creategroup"</span>, <span class="string">"创建群组, 格式 creategroup:groupname:groupdesc"</span>},</span><br><span class="line">                                            {<span class="string">"joingroup"</span>, <span class="string">"加入群组, 格式 joingroup:groupid"</span>},</span><br><span class="line">                                            {<span class="string">"groupchat"</span>, <span class="string">"群组聊天, 格式 groupchat:groupid:message"</span>},</span><br><span class="line">                                            {<span class="string">"loginout"</span>, <span class="string">"退出登录, 格式 loginout"</span>}};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册系统支持的客户端命令处理</span></span><br><span class="line">unordered_map&lt;string, function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, string)&gt;&gt; commandHandlerMap = {</span><br><span class="line">    {<span class="string">"help"</span>, help},           {<span class="string">"singlechat"</span>, singlechat}, {<span class="string">"addfriend"</span>, addfriend}, {<span class="string">"creategroup"</span>, creategroup},</span><br><span class="line">    {<span class="string">"joingroup"</span>, joingroup}, {<span class="string">"groupchat"</span>, groupchat},   {<span class="string">"loginout"</span>, loginout}};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主菜单程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainMenu</span><span class="params">(<span class="keyword">int</span> clientfd)</span> </span>{</span><br><span class="line">    <span class="built_in">help</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">while</span> (isMainMenuRunning) {</span><br><span class="line">        <span class="comment">// 存储用户选择执行的命令</span></span><br><span class="line">        string command;</span><br><span class="line">        cin.<span class="built_in">getline</span>(buffer, <span class="number">1024</span>);</span><br><span class="line">        <span class="function">string <span class="title">commandbuf</span><span class="params">(buffer)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> idx = commandbuf.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">            command = commandbuf;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            command = commandbuf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找相应命令的事件处理器</span></span><br><span class="line">        <span class="keyword">auto</span> it = commandHandlerMap.<span class="built_in">find</span>(command);</span><br><span class="line">        <span class="keyword">if</span> (it == commandHandlerMap.<span class="built_in">end</span>()) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"invalid input command!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用相应命令的事件处理回调函数</span></span><br><span class="line">        it-&gt;<span class="built_in">second</span>(clientfd, commandbuf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, commandbuf.<span class="built_in">size</span>() - idx));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "help" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>, string)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"&gt;&gt;&gt; show command list &gt;&gt;&gt; "</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : commandMap) {</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">" : "</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "addfriend" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfriend</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式: friendid</span></span><br><span class="line">    <span class="keyword">int</span> friendId = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (friendId &lt;= <span class="number">0</span>) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"add friend command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = ADD_FRIEND_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"friendId"</span>] = friendId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send add friend msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "singlechat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">singlechat</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式: friendid:message</span></span><br><span class="line">    <span class="keyword">int</span> idx = str.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"single chat command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> friendId = <span class="built_in">atoi</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>, idx).<span class="built_in">c_str</span>());</span><br><span class="line">    string message = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = SINGLE_CHAT_MSG;</span><br><span class="line">    request[<span class="string">"fromId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"fromName"</span>] = g_currentUser.<span class="built_in">getName</span>();</span><br><span class="line">    request[<span class="string">"fromMsg"</span>] = message;</span><br><span class="line">    request[<span class="string">"fromTimestamp"</span>] = <span class="built_in">getTimestampMs</span>();</span><br><span class="line">    request[<span class="string">"toId"</span>] = friendId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send single chat msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "creategroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creategroup</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式: groupname:groupdesc</span></span><br><span class="line">    <span class="keyword">int</span> idx = str.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"create group command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    string groupName = str.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">    string groupDesc = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = CREATE_GROUP_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"groupName"</span>] = groupName;</span><br><span class="line">    request[<span class="string">"groupDesc"</span>] = groupDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send create group msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "joingroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joingroup</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式：groupid</span></span><br><span class="line">    <span class="keyword">int</span> groupId = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (groupId &lt;= <span class="number">0</span>) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"join group command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = JOIN_GROUP_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"groupId"</span>] = groupId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send join group msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "groupchat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">groupchat</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式：groupid:message</span></span><br><span class="line">    <span class="keyword">int</span> idx = str.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"group chat command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> groupId = <span class="built_in">atoi</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>, idx).<span class="built_in">c_str</span>());</span><br><span class="line">    string groupMsg = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = GROUP_CHAT_MSG;</span><br><span class="line">    request[<span class="string">"fromId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"fromName"</span>] = g_currentUser.<span class="built_in">getName</span>();</span><br><span class="line">    request[<span class="string">"fromTimestamp"</span>] = <span class="built_in">getTimestampMs</span>();</span><br><span class="line">    request[<span class="string">"groupId"</span>] = groupId;</span><br><span class="line">    request[<span class="string">"groupMsg"</span>] = groupMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send group chat msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "loginout" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loginout</span><span class="params">(<span class="keyword">int</span> clientfd, string)</span> </span>{</span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = LOGIN_OUT_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send login out msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        isMainMenuRunning = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h4><ul><li><p>(1) 启动 Nginx、Redis、MySQL 服务，并配置 Nginx 的 TCP 负载均衡器</p></li><li><p>(2) 启动集群聊天服务端程序</p><ul><li>启动第一个聊天服务端程序：<code>./bin/chat_server 127.0.0.1 6000</code></li><li>启动第二个聊天服务端程序：<code>./bin/chat_server 127.0.0.1 6002</code></li></ul></li><li><p>(3) 启动集群聊天客户端程序</p><ul><li>启动第一个聊天客户端程序：<code>./bin/chat_client 127.0.0.1 8000</code>，连接的是 Nginx 的 TCP 负载均衡器</li><li>启动第二个聊天客户端程序：<code>./bin/chat_client 127.0.0.1 8000</code>，连接的是 Nginx 的 TCP 负载均衡器</li></ul></li></ul><h2 id="项目输出"><a href="#项目输出" class="headerlink" title="项目输出"></a>项目输出</h2><h3 id="输出求职简历"><a href="#输出求职简历" class="headerlink" title="输出求职简历"></a>输出求职简历</h3><ul><li><p>项目名称</p><ul><li>集群聊天服务器</li><li>基于 Muduo 网络库实现的集群聊天服务器</li></ul></li><li><p>开发工具</p><ul><li>VSCode 远程 Linux 开发</li><li> CMake 构建 C/C++ 项目</li><li> Linux Shell 编写项目自动编译脚本</li></ul></li><li><p>项目内容</p><ul><li>使用 Muduo 网络库实现项目的网络核心模块，提供高并发网络 I/O 服务，解耦网络和业务模块的代码</li><li>使用 Json 序列化和反序列化消息作为私有通信协议</li><li>配置 Nginx 基于 TCP 的负载均衡，实现聊天服务器的集群功能，提高后端服务的并发能力</li><li>基于 Redis 的发布 - 订阅功能，实现客户端跨服务器通信</li><li>使用 MySQL 关系型数据库作为项目数据的落地存储</li><li>使用数据库连接池提高数据库的访问性能</li></ul></li><li><p>项目收获</p><ul><li>熟悉了基于 Muduo 网络库进行服务端程序开发</li><li>掌握了 Nginx 的 TCP 负载均衡配置</li><li>掌握了 MySQL 和服务端中间件 Redis 的应用</li></ul></li><li><p>项目问题</p><ul><li>问题描述<ul><li>通过代码脚本或者专业的压测工具（比如 JMeter）测试聊天服务器的并发性能</li></ul></li><li>问题解决<ul><li>设置进程可使用文件描述符（<code>fd</code>）资源的上限数量，提高聊天服务器的并发性能</li></ul></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在面试流程中描述项目内容时，切忌详细罗列项目中的业务，重点是介绍项目用到什么技术，突出技术点 。</p></div><h3 id="常见的面试题"><a href="#常见的面试题" class="headerlink" title="常见的面试题"></a>常见的面试题</h3><h4 id="为什么要使用-Redis"><a href="#为什么要使用-Redis" class="headerlink" title="为什么要使用 Redis"></a>为什么要使用 Redis</h4><ul><li><p>问题描述</p><ul><li>为什么要使用 Redis 来实现客户端跨服务器通信？各个聊天服务器之间能不能直接进行通信呢？</li></ul></li><li><p>问题解答</p><ul><li><a href="../../../asset/2025/06/cxx-chatserver-qa-1.png">这里的设计</a>，会在各个 ChatServer 服务器互相之间直接建立 TCP 连接进行通信，相当于在服务器网络之间进行广播。这样的设计使得各个服务器之间耦合度太高，不利于系统扩展，并且会占用系统大量的 Socket 资源，各服务器之间的带宽压力很大，不能够节省资源给更多的客户端提供服务，因此绝对不是一个好的设计。</li><li>集群部署的服务器之间进行通信，最好的方式就是引入消息队列中间件，解耦各个服务器，使整个系统松耦合，提高服务器的响应能力，节省服务器的带宽资源，整体的设计应该 <a href="../../../asset/2025/06/cxx-chatserver-qa-2.png">如此</a>。</li><li>在集群环境中，经常使用的消息队列中间件有 ActiveMQ、RabbitMQ、Kafka、RocketMQ 等，它们都是应用场景广泛并且性能很好的消息队列，供集群服务器、分布式服务之间进行消息通信。限于集群聊天服务器项目的业务并不是非常复杂，并且对并发性能也没有太高的要求，因此消息队列选型的是 - Redis 发布 - 订阅。</li></ul></li></ul><h4 id="Redis-实现的功能不稳定"><a href="#Redis-实现的功能不稳定" class="headerlink" title="Redis 实现的功能不稳定"></a>Redis 实现的功能不稳定</h4><ul><li><p>问题描述</p><ul><li>当消息的生产速度大于消息的消费速度时，随着时间的推移，会造成 Redis 积压消息；如果消息积压的数量太大，会导致内存占用激增，Redis 最终可能会宕机。</li></ul></li><li><p>问题解答</p><ul><li>使用消息队列中间件替代 Redis 的发布 - 订阅功能，比如 Kafka、RabbitMQ、RocketMQ 等。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Redis 的主要功能有：缓存数据库（支持持久化）、分布式锁、发布 - 订阅，其中发布 - 订阅功能只适用于非核心业务、流量不是很大的业务。</p></div><h4 id="如何保证消息的可靠传输"><a href="#如何保证消息的可靠传输" class="headerlink" title="如何保证消息的可靠传输"></a>如何保证消息的可靠传输</h4><ul><li><p>问题描述</p><ul><li>如何保证客户端发送出去的消息，一定能够被服务端接收到，从而保证消息不丢失呢？</li></ul></li><li><p>问题解答</p><ul><li>在业务层中，可以通过消息序号 + ACK 应答机制实现消息的可靠传输，实现步骤如下：</li><li>(1) 客户端发送的每条消息都附加一个递增的 <code>seq</code> 序号（比如 1、2、3）。</li><li>(2) 客户端将未被确认的消息保存在本地的缓存队列中，用于后续重发和确认处理。</li><li>(3) 服务端收到消息后，返回 ACK 应答给客户端，标明确认的消息序号（比如 <code>seq:1</code>）。</li><li>(4) 客户端处理 ACK 响应：客户端接收到 ACK 响应后，从本地缓存队列中移除对应 <code>seq</code> 的消息，表示消息已被成功确认。</li><li>(5) 消息重发机制：客户端启动一个定时器线程，定时扫描缓存队列中未被确认的消息（比如每 3 秒扫描一次）。如果某条消息在一定时间内（比如 5 秒）未收到 ACK 确认，则自动重发该消息，直到收到服务端的 ACK 确认或者超过最大重试次数。</li></ul></li></ul><h4 id="如何保证数据传输的安全性"><a href="#如何保证数据传输的安全性" class="headerlink" title="如何保证数据传输的安全性"></a>如何保证数据传输的安全性</h4><ul><li><p>问题描述</p><ul><li>由于数据（比如聊天消息）是明文传输的，存在一定的数据安全问题，如何解决？</li></ul></li><li><p>问题解答</p><ul><li>使用对称加密算法（如 AES）和非对称加密算法（如 RSA）来保证数据传输的安全性，实现步骤如下：</li><li>(1) 客户端登录时，使用服务端的 RSA 公钥加密数据，其中的数据包含一个随机生成的 AES 密钥和登录信息，然后将加密后的数据发送给服务端。</li><li>(2) 服务端收到数据后，使用自己的 RSA 私钥解密数据，获得客户端的 AES 密钥和登录信息，并完成身份验证。</li><li>(3) 后续通信阶段，客户端与服务端使用同一个 AES 密钥对数据进行对称加密和解密，从而实现高效且安全的数据传输。</li><li>(4) AES 密钥应为一次性生成的会话密钥（Session Key）。RSA 加解密只用于密钥交换和登录信息保护，后续通信使用高性能的 AES 加解密。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">加密算法介绍</p><ul><li>在大型的 IM 软件（比如 QQ）中，会同时使用到对称加密算法和非对称加密算法，兼顾考虑数据安全性和加解密效率。</li><li><code>对称加密算法</code>：使用同一个密钥进行加密和解密，速度快，但需要考虑安全地共享密钥。常见的对称加密算法包括 DES、AES、3DES 等。</li><li><code>非对称加密算法</code>：使用一对公钥和私钥，公钥负责加密、私钥负责解密，安全性高，速度慢，适用于密钥交换与身份验证。常见的非对称加密算法包括 DSA、RSA、ECC 等。</li></ul></div><h4 id="客户端消息如何按顺序显示"><a href="#客户端消息如何按顺序显示" class="headerlink" title="客户端消息如何按顺序显示"></a>客户端消息如何按顺序显示</h4><ul><li><p>问题描述</p><ul><li>客户端接收到服务端发送的消息，如何按顺序显示？</li></ul></li><li><p>问题解答</p><ul><li>(1) 服务端消息加序号：服务端发送的每条消息都附加一个递增的 <code>seq</code> 序号，每个用户或会话维护独立的 <code>seq</code> 序号。</li><li>(2) 客户端缓存乱序消息：客户端接收到消息后，放入本地的有序缓存中，并使用 <code>expected_seq</code> 表示下一条应该显示的消息的序号。</li><li>(3) 按序显示 + 缓存清理：若客户端接收到消息序号等于 <code>expected_seq</code>，则立即显示，并从缓存中继续查找后续的连续消息，依次显示。</li><li>(4) 处理乱序和丢包：如果客户端接收到的是 <code>seq &gt; expected_seq</code>，则先缓存消息，暂时不显示。若某条消息长时间未到达，可发起消息重传请求或跳过处理。</li></ul></li></ul><h4 id="历史聊天消息应该如何存储"><a href="#历史聊天消息应该如何存储" class="headerlink" title="历史聊天消息应该如何存储"></a>历史聊天消息应该如何存储</h4><ul><li><p>问题描述</p><ul><li>历史聊天消息，有哪些存储方案？</li></ul></li><li><p>问题解答</p><ul><li>本地消息存储<ul><li>使用 SQLite 等嵌入式数据库：轻量、便于查询，适合单设备离线存储。</li><li>使用本地文件系统：以用户或群组为单位创建文件夹，按日期或大小分多个文件保存，适合大批量存储，读取简单但查询不方便。</li></ul></li><li>云端消息存储<ul><li>使用关系型数据库（如 MySQL）：结构化存储，支持高效查询和分页加载，适合结构清晰的聊天记录。</li><li>使用文件存储系统（如对象存储或分布式文件系统）：适合存储大批量的聊天原始记录或备份数据，读取顺序性强，但查询性能较弱。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">大规模系统中的历史聊天消息存储</p><ul><li>(1) 消息队列 + 消息落库架构，提升写入性能。</li><li>(2) Elasticsearch 作为全文索引系统，用于历史聊天记录搜索。</li><li>(3) 冷热数据分离：近期消息存储在数据库，历史消息转存在文件存储系统（如对象存储或分布式文件系统）。</li></ul></div><h4 id="如何感知客户端在线还是掉线"><a href="#如何感知客户端在线还是掉线" class="headerlink" title="如何感知客户端在线还是掉线"></a>如何感知客户端在线还是掉线</h4><ul><li><p>问题描述</p><ul><li>如果网络拥堵严重，ChatServer（聊天服务端）如何感知 ChatClient（聊天客户端）在线还是掉线呢？</li></ul></li><li><p>问题解答</p><ul><li>在 ChatServer（聊天服务端）和 ChatClient（聊天客户端）之间实现心跳保持机制，实现步骤如下：<ul><li>(1) 客户端定期发送心跳包（比如：每秒发一次 <code>MSG_TYPE: heartbeat</code>）</li><li>(2) 服务端为每个客户端维护一个心跳计数器，每秒自动加一</li><li> (3) 服务端每收到一次客户端发送的心跳包，就将该客户端的心跳计数器归零</li><li> (4) 若客户端的心跳计数器超过 5（即 5 秒内未收到心跳），则判断客户端已掉线</li><li> (5) 客户端掉线后，服务端开始清理该客户端的连接和资源</li></ul></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>TCP 传输层有 Keepalive 机制，可以通过 Linux 内核参数来调整（如下表所示）。但是，ChatServer 不能依赖该机制来实现心跳保持机制，因为 ChatServer 检测到 ChatClient 掉线后，需要主动清理相应的连接和资源。</li></ul></div><table><thead><tr><th>参数名</th><th>作用</th><th>默认值（一般情况）</th></tr></thead><tbody><tr><td><code>net.ipv4.tcp_keepalive_time</code></td><td>TCP 连接空闲多久后开始发送 Keepalive 探测包（单位：秒）</td><td>7200 秒（2 小时）</td></tr><tr><td><code>net.ipv4.tcp_keepalive_intvl</code></td><td>发送 Keepalive 探测包之间的时间间隔（单位：秒）</td><td>75 秒</td></tr><tr><td><code>net.ipv4.tcp_keepalive_probes</code></td><td>Keepalive 最大探测次数，超过则认定连接失效（断开）</td><td>9 次</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/m0_74795952/article/details/145707561">C++ 实现集群聊天服务器</a></li><li><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/97895611">C++ 使用 Redis 发布 - 订阅功能遇到的问题</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 开发集群聊天服务器，使用了 Muduo、Json、MySQL、Redis、Linux 等技术。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMake 快速入门指南</title>
    <link href="https://www.techgrow.cn/posts/effcb0d2.html"/>
    <id>https://www.techgrow.cn/posts/effcb0d2.html</id>
    <published>2025-05-27T14:25:49.000Z</published>
    <updated>2025-05-27T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<div class="row"><embed src="/pdf/CMake快速入门指南.pdf" width="100%" height="1024px" isolation="isolate" type="application/pdf"></div>]]></content>
    
    
    <summary type="html">本文主要介绍 CMake 的快速入门教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="在线电子书" scheme="https://www.techgrow.cn/tags/%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于 Linux 下 VSCode 搭建 C/C++ 开发环境</title>
    <link href="https://www.techgrow.cn/posts/83b1bb3b.html"/>
    <id>https://www.techgrow.cn/posts/83b1bb3b.html</id>
    <published>2025-05-25T14:25:49.000Z</published>
    <updated>2025-05-25T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将在 Linux 系统中，搭建 VSCode 开发 C/C++ 程序的环境（本地开发），适用于绝大多数的 Linux 发行版，比如 CentOS、Ubuntu、Debian 等。</p><span id="more"></span><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ul><li>(1) 在 Linux 系统中安装 VSCode<ul><li><a href="/posts/d8f0998b.html">Linux 安装 VSCode 的详细教程</a></li></ul></li><li> (2) 在 VSCode 中安装 C/C++ 相关插件，比如：<ul><li><code>C/C++</code>：C/C++ 核心插件，提供 C/C++ 智能感知、调试、导航、语法提示等核心功能。</li><li><code>C/C++ Extension Pack</code>：C/C++ 插件组合包，用于一键安装多个与 C/C++ 开发相关的扩展，方便快速配置。</li><li><code>Code Runner</code>：代码快速运行插件（可选安装），仅支持运行单个源文件，支持多种语言，包括 C/C++、Java、JS、PHP、Python、、Go、Lua 等。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/630b5e44.html">VSCode 搭建远程 Linux 开发环境</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍基于 Linux 下 VSCode 如何搭建 C/C++ 开发环境。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>VSCode 搭建远程 Linux 开发环境</title>
    <link href="https://www.techgrow.cn/posts/630b5e44.html"/>
    <id>https://www.techgrow.cn/posts/630b5e44.html</id>
    <published>2025-05-22T14:25:49.000Z</published>
    <updated>2025-05-22T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 VSCode 如何搭建远程 Linux 开发环境（远程开发），实现的效果相当于在远程 Linux 服务器上直接开发 C/C++ 项目，适用于 Windows 系统。</p><span id="more"></span><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><blockquote><p>VSCode 搭建远程 Linux 开发环境的步骤：</p></blockquote><ul><li>(1) 在远程 Linux 系统中运行 SSH 服务</li><li> (2) 在本地 Windows 系统的 VSCode 中安装 C/C++ 相关插件，比如：<ul><li><code>Remote Development</code>：远程开发插件，支持连接远程 Linux 服务器、Docker 容器、WSL。</li><li><code>C/C++</code>：C/C++ 核心插件，提供 C/C++ 智能感知、调试、导航、语法提示等核心功能。</li><li><code>C/C++ Extension Pack</code>：C/C++ 插件组合包，用于一键安装多个与 C/C++ 开发相关的扩展，方便快速配置。</li><li><code>Code Runner</code>：代码快速运行插件（可选安装），仅支持运行单个源文件，支持多种语言，包括 C/C++、Java、JS、PHP、Python、、Go、Lua 等。</li></ul></li><li>(3) 在本地 Windows 系统的 VSCode 中配置远程 Linux 服务器的信息。</li><li>(4) 在本地 Windows 系统的 VSCode 中连接远程的 Linux 服务器进行开发（即远程开发）。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>VSCode 远程开发的详细搭建教程，可以参考文末给出的 <a href="/posts/630b5e44.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a>，这里不再累述。</p></div><blockquote><p>VSCode 安装 C/C++ 相关插件后的样子如下图所示：</p></blockquote><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-1.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里注意不要安装 <code>C/C++ Runner</code> 这款插件（支持直接运行单个或多个 C/C++ 源文件），因为 <code>C/C++ Runner</code> 插件不会自动安装到远程环境中，也不支持在远程环境中运行，因为它的设计是为了在本地运行程序。</p></div><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="直接运行程序找不到头文件"><a href="#直接运行程序找不到头文件" class="headerlink" title="直接运行程序找不到头文件"></a>直接运行程序找不到头文件</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>当 C/C++ 源文件中引入了自定义的头文件，执行 VSCode 右上角的 <code>运行 C/C++ 文件</code> 按钮运行程序后（如下图所示），会出现找不到头文件的错误。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-2.png"></p><ul><li>这是因为 VSCode 是使用 <code>g++</code> 命令直接编译当前打开的 <code>.cpp</code> 文件，仅执行 <code>g++ file.cpp -o file &amp;&amp; ./file</code> 这种快速编译运行命令，而没有加上自定义头文件所在的目录路径（<code>-I</code> 参数）所导致的。</li></ul><h4 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h4><ul><li>创建或编辑当前项目的 <code>.vscode/c_cpp_properties.json</code> 文件，或者使用 <code>cmd + shift + p</code> 快捷键打开命令面板并输入 <code>C/C++ Edit Configurations (JSON)</code>），然后更改对应的配置内容 </li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Linux"</span>,</span><br><span class="line">            <span class="attr">"includePath"</span>: [</span><br><span class="line">                <span class="string">"${workspaceFolder}/**"</span>       <span class="comment">// 用于 VSCode 的 IntelliSense 引擎（代码提示、跳转、补全等），帮助它找到头文件的位置，不是用于编译代码。编译用的头文件路径是在 tasks.json 或 CMakeLists.txt 中通过 `-I` 参数来指定</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"defines"</span>: [],</span><br><span class="line">            <span class="attr">"compilerPath"</span>: <span class="string">"/usr/bin/g++"</span>,   <span class="comment">// 指定使用的编译器</span></span><br><span class="line">            <span class="attr">"cStandard"</span>: <span class="string">"c11"</span>,               <span class="comment">// 指定 C 版本</span></span><br><span class="line">            <span class="attr">"cppStandard"</span>: <span class="string">"gnu++11"</span>,         <span class="comment">// 指定 C++ 版本</span></span><br><span class="line">            <span class="attr">"intelliSenseMode"</span>: <span class="string">"linux-gcc-x64"</span></span><br><span class="line">        }</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">4</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑当前项目的 <code>.vscode/tasks.json</code> 文件，然后添加 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppbuild"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"C/C++: g++ build active file"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"/usr/bin/g++"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"-fdiagnostics-color=always"</span>,</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"${file}"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"${fileDirname}/${fileBasenameNoExtension}"</span>, <span class="comment">// 指定输出的可执行文件名</span></span><br><span class="line">                <span class="string">"-Iinclude"</span>, <span class="comment">// 指定项目的头文件</span></span><br><span class="line">                <span class="string">"-lpthread"</span> <span class="comment">// 指定链接的静态库或者动态库（必须注意顺序，从上到下链接），可选配置</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"options"</span>: {</span><br><span class="line">                <span class="attr">"cwd"</span>: <span class="string">"${workspaceFolder}"</span></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">"problemMatcher"</span>: [</span><br><span class="line">                <span class="string">"$gcc"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"group"</span>: {</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>然后执行 VSCode 右上角的 <code>运行 C/C++ 文件</code> 按钮运行程序后（如下图所示），就可以正常运行 C/C++ 程序</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-8.png"></p><h4 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h4><ul><li>创建或编辑当前项目的 <code>.vscode/tasks.json</code> 文件，然后添加 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"tasks"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"Run Main with include"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-Iinclude"</span>,       <span class="comment">// 指定头文件路径</span></span><br><span class="line">        <span class="string">"main.cpp"</span>,        <span class="comment">// 指定目标源文件名</span></span><br><span class="line">        <span class="string">"-o"</span>,</span><br><span class="line">        <span class="string">"main"</span>             <span class="comment">// 指定输出的可执行文件名</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"group"</span>: <span class="string">"build"</span>,</span><br><span class="line">      <span class="attr">"problemMatcher"</span>: [],</span><br><span class="line">      <span class="attr">"detail"</span>: <span class="string">"Compile with header path"</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑当前项目的 <code>.vscode/launch.json</code> 文件，然后指定 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Launch main"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"${workspaceFolder}/main"</span>,     <span class="comment">// 指定可执行文件</span></span><br><span class="line">      <span class="attr">"args"</span>: [],</span><br><span class="line">      <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"${workspaceFolder}"</span>,</span><br><span class="line">      <span class="attr">"preLaunchTask"</span>: <span class="string">"Run Main with include"</span>,      <span class="comment">// 指定 Task</span></span><br><span class="line">      <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">      <span class="attr">"miDebuggerPath"</span>: <span class="string">"/usr/bin/gdb"</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>按下快捷键 <code>Ctrl + Shift + D</code>，调出 VSCode 的 <code>运行和调试</code> 面板，然后在顶部选择自定义的配置 <code>Launch main</code>，最后点击左边的 <code>绿色</code> 按钮就可以正常运行程序。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-3.png"></p><ul><li>第一次运行程序后，VSCode 的底部工具栏会新增 <code>Launch main</code> 相关的操作按钮，以后可以直接在底部工具栏运行或调试 C/C++ 程序，还可以使用快捷键 <code>F5</code> 直接运行。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>VSCode 中 <code>运行 C/C++ 文件</code> 按钮的行为非常简单（如下表所示），因此更推荐使用 CMake 管理 C/C++ 项目，并使用 <code>launch.json</code> + <code>task.json</code> 来调用它。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>默认使用 <code>g++</code> 编译当前文件</td><td>忽略项目结构和依赖关系</td></tr><tr><td>不支持多源文件编译</td><td>如果有 <code>main.cpp</code> 和 <code>other.cpp</code>，它不会编译全部源文件</td></tr><tr><td>不自动添加 <code>-I</code>、<code>-L</code> 参数</td><td>所以无法识别头文件或链接库</td></tr><tr><td>不识别 CMake 项目</td><td>所以不适合正式工程</td></tr></tbody></table><h3 id="CMake-项目无法直接运行"><a href="#CMake-项目无法直接运行" class="headerlink" title="CMake 项目无法直接运行"></a>CMake 项目无法直接运行</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>当点击 VSCode 右上角的 <code>运行 C/C++ 文件</code> 按钮时，CMake 项目无法正常运行（如下图所示）。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-4.png"></p><ul><li>这是因为点击 <code>运行 C/C++ 文件</code> 按钮后，其实触发的是 <code>C/C++: Run</code> 快捷命令，这个命令不会走 CMake，而是仅对当前打开的 <code>.cpp</code> 文件执行 <code>g++ file.cpp -o file &amp;&amp; ./file</code> 这种快速编译运行命令。</li></ul><h4 id="解决方案一-1"><a href="#解决方案一-1" class="headerlink" title="解决方案一"></a>解决方案一</h4><ul><li>创建或编辑当前项目的 <code>.vscode/tasks.json</code> 文件，然后添加 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"tasks"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"CMake Build"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"cmake -S . -B build &amp;&amp; cmake --build build"</span>,</span><br><span class="line">      <span class="attr">"problemMatcher"</span>: []</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑当前项目的 <code>.vscode/launch.json</code> 文件，然后指定 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Run CMake Executable"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"${workspaceFolder}/build/main"</span>,   <span class="comment">// 指定 CMake 输出的可执行文件名</span></span><br><span class="line">      <span class="attr">"args"</span>: [],</span><br><span class="line">      <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"${workspaceFolder}"</span>,</span><br><span class="line">      <span class="attr">"preLaunchTask"</span>: <span class="string">"CMake Build"</span>,   <span class="comment">// 指定 Task</span></span><br><span class="line">      <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">      <span class="attr">"miDebuggerPath"</span>: <span class="string">"/usr/bin/gdb"</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>按下快捷键 <code>Ctrl + Shift + D</code>，调出 VSCode 的 <code>运行和调试</code> 面板，然后在顶部选择自定义的配置 <code>Run CMake Executable</code>，最后点击左边的 <code>绿色</code> 按钮就可以正常运行 CMake 项目。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-5.png"></p><ul><li>第一次运行程序后，VSCode 的底部工具栏会新增 <code>Launch main</code> 相关的操作按钮，以后可以直接在底部工具栏运行或调试 CMake 项目，还可以使用快捷键 <code>F5</code> 直接运行。</li></ul><h4 id="解决方案二-1"><a href="#解决方案二-1" class="headerlink" title="解决方案二"></a>解决方案二</h4><p>在 VSCode 中安装 <code>CMake Tools</code> 插件，打开 CMake 项目后点击左下角状态栏，确认 <code>CMake Tools</code> 插件已经识别 CMake 项目，然后就可以选择生成、调试、运行 CMake 项目了。</p><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-6.png"></p><h3 id="免密码连接远程-Linux-服务器"><a href="#免密码连接远程-Linux-服务器" class="headerlink" title="免密码连接远程 Linux 服务器"></a>免密码连接远程 Linux 服务器</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>VSCode 安装完 <code>Remote Development</code> 插件后，每次连接远程的 Linux 服务器都会提示输入密码，非常不方便。</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>(1) 在本地的 Windows 系统中，安装 Git Bash 工具；然后在 Git Bash 中执行以下命令生成 SSH 公钥，默认保存位置是：<code>~/.ssh/id_rsa</code>（私钥）和 <code>~/.ssh/id_rsa.pub</code>（公钥）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 SSH 秘钥对，一路回车即可（通常无需设置密码）</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 在本地的 Git Bash 中，执行以下命令将公钥拷贝到远程 Linux 服务器中 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝公钥到远程 Linux 服务器（第一次会要求输入远程服务器的密码，之后设置完成即可免密）</span></span><br><span class="line">ssh-copy-id root@192.168.1.100</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 测试 SSH 登录是否免密成功 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.1.100</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 重新运行 VSCode，选择需要连接的 Linux 服务器，观察是否成功免密建立远程连接</li></ul><h3 id="C-C-代码实现格式化"><a href="#C-C-代码实现格式化" class="headerlink" title="C/C++ 代码实现格式化"></a>C/C++ 代码实现格式化</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>VSCode 默认的 C/C++ 代码格式化风格不太习惯，比如每个大括号都是换行显示的，希望更改为自己所需的代码风格。</p><h4 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>(1) 在远程 Linux 服务器上安装 <code>clang-format</code> 代码格式化工具 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y clang-format</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 在本地的 VSCode 中安装 Clang-Format 插件</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-7.png"></p><ul><li> (3) 创建或编辑当前项目的 <code>.vscode/settings.json</code> 文件，添加以下配置内容：</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">// C 代码格式化配置</span></span><br><span class="line">    <span class="attr">"[c]"</span>: {</span><br><span class="line">        <span class="attr">"editor.defaultFormatter"</span>: <span class="string">"xaver.clang-format"</span>, <span class="comment">// 指定格式化器，远程服务器必须先安装 clang-format 工具</span></span><br><span class="line">        <span class="attr">"editor.formatOnSave"</span>: <span class="literal">false</span> <span class="comment">// 可选，保存文件时自动格式化</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// C++ 代码格式化配置</span></span><br><span class="line">    <span class="attr">"[cpp]"</span>: {</span><br><span class="line">        <span class="attr">"editor.defaultFormatter"</span>: <span class="string">"xaver.clang-format"</span>, <span class="comment">// 指定格式化器，远程服务器必须先安装 clang-format 工具</span></span><br><span class="line">        <span class="attr">"editor.formatOnSave"</span>: <span class="literal">false</span> <span class="comment">// 可选，保存文件时自动格式化</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 代码格式化规则</span></span><br><span class="line">    <span class="attr">"clang-format.style"</span>: <span class="string">"{ BasedOnStyle: Google, IndentWidth: 4, TabWidth: 4, AccessModifierOffset: -4, UseTab: Never, ColumnLimit: 120, AllowShortFunctionsOnASingleLine: None }"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>提示：推荐将代码格式化规则配置在项目根目录下的 <code>.clang-format</code> 文件中（如下），然后在当前项目的 <code>.vscode/settings.json</code> 文件中添加配置内容 <code>"clang-format.style": "file"</code>，让代码格式化插件去自动读取项目中的 <code>.clang-format</code> 文件。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 基于哪种代码风格，可选：LLVM、Google、Chromium、Mozilla、WebKit 等</span><br><span class="line">BasedOnStyle: Google</span><br><span class="line"></span><br><span class="line"># 每一层缩进使用的空格数（默认 Google 是 2，这里改为 4）</span><br><span class="line">IndentWidth: 4</span><br><span class="line"></span><br><span class="line"># 设置一个制表符（Tab）等价于多少个空格（影响对齐）</span><br><span class="line">TabWidth: 4</span><br><span class="line"></span><br><span class="line"># 使访问修饰符（如 private:）顶格，不缩进</span><br><span class="line">AccessModifierOffset: -4</span><br><span class="line"></span><br><span class="line"># 是否使用 Tab 缩进：</span><br><span class="line">#   - Never: 一律使用空格</span><br><span class="line">#   - Always: 总是使用 Tab</span><br><span class="line">#   - ForIndentation: 缩进用 Tab，对齐用空格</span><br><span class="line">UseTab: Never</span><br><span class="line"></span><br><span class="line"># 每行的最大字符数限制</span><br><span class="line">ColumnLimit: 120</span><br><span class="line"></span><br><span class="line"># 强制所有函数体换行，即使只有一行</span><br><span class="line">AllowShortFunctionsOnASingleLine: None</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 配置 VSCode 的 C/C++ 代码格式化快捷键<ul><li>按 <code>Ctrl + Shift + P</code> 组合建打开命令面板</li><li>输入 <code>Preferences: Open Keyboard Shortcuts (JSON)</code> 并回车</li><li>在打开的 <code>keybindings.json</code> 文件里，添加以下配置内容：<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="comment">// 格式化选中的 C/C++ 代码块</span></span><br><span class="line">    {</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"ctrl+l"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"editor.action.formatSelection"</span>,</span><br><span class="line">        <span class="attr">"when"</span>: <span class="string">"editorTextFocus &amp;&amp; (editorLangId == 'cpp' || editorLangId == 'c') &amp;&amp; editorHasSelection"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 格式化整个 C/C++ 源文件</span></span><br><span class="line">    {</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"ctrl+l"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"editor.action.formatDocument"</span>,</span><br><span class="line">        <span class="attr">"when"</span>: <span class="string">"editorTextFocus &amp;&amp; (editorLangId == 'cpp' || editorLangId == 'c') &amp;&amp; !editorHasSelection"</span></span><br><span class="line">    }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/weixin_51278158/article/details/130186395">VSCode 使用 SSH 进行远程开发</a></li><li><a href="https://cloud.tencent.com/developer/article/2282762">VSCode 远程开发 - SSH 入门保姆级教程</a></li><li><a href="https://blog.csdn.net/qq_41897304/article/details/131282774">Windows 平台下 VSCode 配置远程 Linux 开发环境</a></li><li><a href="https://www.cnblogs.com/lidabo/p/18348376">Windows 平台使用 VSCode 远程连接 Linux 进行 C++ 开发配置教程</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 VSCode 如何搭建远程 Linux 开发环境。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 手写线程池</title>
    <link href="https://www.techgrow.cn/posts/585aa296.html"/>
    <id>https://www.techgrow.cn/posts/585aa296.html</id>
    <published>2025-05-13T13:55:33.000Z</published>
    <updated>2025-05-13T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 手写一个线程池，并分别提供 C++ 11 和 C++ 17 两种版本的线程池实现。线程池作为五大池之一（内存池、连接池、协程池、线程池、进程池），应用非常广泛，不管是客户端程序，还是后台服务程序，都是提高业务处理能力的必备模块。有很多开源的线程池实现，虽然各自接口在使用上稍有区别，但是其核心实现原理都是基本相同的。</p><h3 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h3><p>在基于 C++ 手写线程池之前，应该熟悉并掌握以下技术内容：</p><ul><li>熟练基于 C++ 11 的面向对象编程</li><li>熟悉组合和继承、继承多态、STL 容器、智能指针、函数对象、绑定器、<code>lambda</code> 表达式、可变参数模板编程等。</li><li>熟悉 C++ 11 多线程编程，比如线程互斥、线程同步、原子操作、CAS 等。</li><li>熟悉 <code>thread</code>、<code>mutex</code>、<code>unique_lock</code>、<code>condition_variable</code>、<code>atomic</code> 等。</li><li>熟悉 C++ 17 和 C++ 20 的新特性，比如 C++ 17 的 <code>any</code> 类型和 C++ 20 的 <code>counting_semaphore</code> 信号量类型等。</li></ul><span id="more"></span><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>本文使用以下工具来开发 C++ 线程池项目：</p><ul><li>C++ 11 / C++ 17</li><li>Visual Studio 2019</li><li>CMake 构建编译环境</li><li> GDB 调试分析定位线程死锁问题</li><li> Linux 编译项目生成动态链接库（<code>.so</code>）</li></ul><h3 id="版本特性"><a href="#版本特性" class="headerlink" title="版本特性"></a>版本特性</h3><p>C++ 各版本支持的特性如下：</p><table><thead><tr><th>特性名称</th><th>对应头文件</th><th>最低支持的 C++ 标准版本</th><th>说明</th></tr></thead><tbody><tr><td><code>std::make_unique</code></td><td><code>&lt;memory&gt;</code></td><td>C++ 14</td><td>C++ 14 引入，用于简洁安全地创建 <code>unique_ptr</code> 智能指针。</td></tr><tr><td><code>std::any</code></td><td><code>&lt;any&gt;</code></td><td>C++ 17</td><td> 提供类型安全的类型擦除容器。</td></tr><tr><td><code>std::counting_semaphore</code></td><td><code>&lt;semaphore&gt;</code></td><td>C++ 20</td><td>C++ 20 引入的信号量机制。</td></tr><tr><td><code>std::packaged_task</code></td><td><code>&lt;future&gt;</code></td><td>C++ 11</td><td> 将可调用对象封装起来，并用于异步执行。</td></tr><tr><td><code>std::future</code></td><td><code>&lt;future&gt;</code></td><td>C++ 11</td><td> 异步操作的结果获取机制，可以与 <code>std::async</code>、<code>std::promise</code> 搭配使用。</td></tr><tr><td>可变参数模板</td><td>语言特性</td><td> C++ 11</td><td> 支持模板中参数数量可变，用于构建灵活函数模板，如递归参数展开等。</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><p>如果使用的是 GCC、Clang 或 MSVC 编译器，需确保编译器版本也支持相应的 C++ 标准。若需进一步查询编译器支持的标准或特性情况，可以参考 <a href="https://zh.cppreference.com">C/C++ 参考手册</a>。</p></div><h3 id="兼容平台"><a href="#兼容平台" class="headerlink" title="兼容平台"></a>兼容平台</h3><p>本文提供的所有 C++ 线程池代码都可以兼容 Windows 和 Linux 平台，并分别提供 C++ 11 和 C++ 17 两种版本的线程池实现。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li><p><strong>并发（Concurrency）</strong></p><ul><li>在单核处理器上，多个线程之间通过操作系统的调度机制交替执行，每个线程轮流占用 CPU 的时间片（例如每 10 毫秒切换一次）。由于每个线程执行的时间片非常短，人们在宏观上感受到这些线程像是 “同时” 在执行一样，虽然它们在物理层面上是串行执行的。这种 “看起来同时执行” 的场景被称为并发。</li></ul></li><li><p><strong>并行（Parallelism）</strong></p><ul><li>在多核处理器或多 CPU 系统中，多个线程可以被分配到不同的核心上同时执行，彼此之间互不抢占 CPU 时间资源，是真正意义上的 “同时执行”。这种多个任务在物理层面并行的执行方式称为并行。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>简而言之，并发是 "逻辑上的同时发生"，并行是 "物理上的同时进行"。</p></div><h3 id="多线程的适用场景"><a href="#多线程的适用场景" class="headerlink" title="多线程的适用场景"></a>多线程的适用场景</h3><p>多线程程序的性能就一定好吗？不一定，要看具体的应用场景：</p><ul><li><p><strong>I/O 密集型场景</strong></p><ul><li>对于涉及大量 I/O 操作（如磁盘读写、网络通信、数据库访问等）的程序，这些操作通常会导致线程阻塞，从而释放 CPU 时间片。此时，通过多线程并发处理，可以有效利用 CPU 的空闲时间，提高程序的吞吐量和响应速度。因此，无论是 CPU 单核、CPU 多核、多 CPU，多线程通常都能带来较好的性能提升，因此适合运行多线程程序。</li></ul></li><li><p><strong>CPU 密集型场景</strong></p><ul><li>CPU 单核<ul><li>在 CPU 单核中，多个线程无法真正并行执行，只能通过 CPU 时间片轮转实现 “伪并发”。多线程会导致频繁的线程上下文切换，增加 CPU 调度开销，甚至可能因为线程数量过多而拖慢整体性能。<strong>在这种情况下，使用单线程可能反而更高效，因此不适合运行多线程程序</strong>。</li></ul></li><li>CPU 多核、多 CPU<ul><li> 多个线程可以被调度到多个核心上并行运行，从而充分利用计算资源，提高程序的运行效率。对于 CPU 密集型任务（如图像处理、大规模计算等），多线程可以显著提升性能，尤其是在合理控制线程数量、避免过度竞争的前提下，因此适合运行多线程程序。</li></ul></li></ul></li></ul><h3 id="多线程的协作机制"><a href="#多线程的协作机制" class="headerlink" title="多线程的协作机制"></a>多线程的协作机制</h3><p>在 C++ 中，为了实现多线程之间的正确协作与安全访问共享资源，通常需要使用线程互斥与线程同步机制。</p><h4 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h4><p>线程互斥用于防止多个线程同时访问共享资源，从而避免数据竞争和数据不一致的问题。常用机制包括：</p><ul><li><p><code>mutex</code> 互斥锁</p><ul><li>提供基本的加锁与解锁操作（<code>lock()</code> / <code>unlock()</code> 或 <code>lock_guard</code> / <code>unique_lock</code> 自动管理），确保同一时间只有一个线程能够访问临界区（共享资源）。</li></ul></li><li><p><code>recursive_mutex</code> 递归互斥锁</p><ul><li>支持同一个线程多次对同一个互斥锁加锁，适用于递归函数调用场景。</li></ul></li><li><p><code>atomic</code> 原子类型</p><ul><li>提供无锁的并发访问机制，支持原子操作，如自增、比较交换等，适用于简单共享变量的并发访问，性能较高。</li></ul></li></ul><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>线程同步用于协调多个线程之间的执行顺序，例如一个线程等待另一个线程完成某项任务后再继续执行。常用机制包括：</p><ul><li><p><code>condition_variable</code> 条件变量</p><ul><li>配合互斥锁（<code>mutex</code>）使用，允许线程在满足某个条件之前进入等待状态，并在条件满足后被唤醒。适合用于生产者 - 消费者模型等场景。</li></ul></li><li><p><code>semaphore</code> 信号量（C++ 20 引入）</p><ul><li>用于控制对某个资源的并发访问数量，即限制同一时刻最多有 N 个线程访问某个共享资源（可用作限流器），适用于如电商秒杀、停车场停车等业务场景。</li></ul></li><li><p><code>barrier</code> / <code>latch</code>（C++ 20 引入）</p><ul><li>用于多线程之间的阶段性同步。例如，所有线程都执行到某一步后再一起进入下一阶段。</li></ul></li></ul><h3 id="多线程的额外开销"><a href="#多线程的额外开销" class="headerlink" title="多线程的额外开销"></a>多线程的额外开销</h3><p>为了完成任务，创建很多的线程可以吗？线程真的是越多越好吗？答案是否定的。</p><ul><li>线程的创建和销毁都是非常 “重” 的操作（涉及用户空间和内核空间的切换）；</li><li>线程栈（通常为 8MB）本身占用大量内存空间；</li><li>线程的上下文切换需要占用大量时间；</li><li>大量线程同时唤醒，会导致操作系统经常出现锯齿状负载或者瞬间负载量很大，造成系统宕机。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Linux 平台下，通过 <code>pthread</code> 库默认最多可以创建约 <code>380</code> 个线程。若希望创建更多的线程，可以降低线程栈的大小（比如 8KB），还可以增大 Linux 系统的最大可打开文件描述符数（<code>ulimit -n</code>），或者最大可创建的用户进程数 / 线程数（<code>ulimit -u</code>）。</p></div><h2 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h2><h3 id="线程池的使用优势"><a href="#线程池的使用优势" class="headerlink" title="线程池的使用优势"></a>线程池的使用优势</h3><p>在操作系统中，线程的创建和销毁都是较为 “昂贵” 的操作，不仅耗时，而且会消耗较多的系统资源。如果在服务运行过程中，每当有任务到来就动态创建线程来执行，任务完成后又立即销毁线程，那么在高并发或大流量场景下，频繁的线程创建与销毁会显著降低系统的实时响应能力，增加 CPU 开销，从而影响整体业务的处理效率。线程池的出现正是为了解决这一问题。在线程池机制中，服务进程在启动阶段就会预先创建好一组可复用的线程（即线程池），这些线程会在后台处于等待状态。当业务任务到来时，系统无需重新创建线程，而是直接从线程池中取出一个空闲线程来执行任务（Task）。任务执行完毕后，该线程不会被销毁，而是归还给线程池，等待下一次任务（Task）的分配。</p><ul><li>线程池带来了多种优势：<ul><li>减少线程创建和销毁的开销，提高系统性能；</li><li>避免线程资源耗尽，通过线程池大小限制线程总数，控制系统并发量；</li><li>提升响应速度，线程可立即复用，减少任务启动延迟；</li><li>便于线程管理和监控，统一由线程池控制线程生命周期和运行状态。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>线程池是一种非常重要的并发编程工具，特别适用于高并发、高吞吐、对实时性有要求的业务场景。</p></div><h3 id="线程池的两种模式"><a href="#线程池的两种模式" class="headerlink" title="线程池的两种模式"></a>线程池的两种模式</h3><ul><li><p><strong>Fixed 模式线程池（固定大小线程池）</strong></p><ul><li>在这种模式下，线程池中的线程数量在创建时就被固定，且在整个线程池的生命周期内保持不变。一般在初始化线程池时，会根据当前机器的 CPU 核心数量或业务需求设定一个合理的线程数。</li><li>当有任务到来时，如果线程池中有空闲线程，则立即分配执行；如果线程都处于忙碌状态，则任务会被放入等待队列中，排队等待有空闲的线程。</li><li>Fixed 模式适合任务量较为稳定、对系统资源可控性要求较高的场景，有助于防止线程数量膨胀导致系统负载过高。</li></ul></li><li><p><strong>Cached 模式线程池（缓存线程池）</strong></p><ul><li>在这种模式下，线程池的线程数量不是固定的，而是可以根据实际任务量动态增长。当有新的任务到来时，如果线程池中没有空闲线程，会临时创建新的线程来处理任务，并在任务完成后将其归还到线程池中。</li><li>为了防止线程无限增长，通常会设置一个线程最大数量的阀值。此外，如果某个线程在空闲超过指定时间（如 60 秒）后仍无新任务可执行，它将被自动销毁，从而释放资源。线程池会始终保留初始的核心线程数，用于处理正常业务流量。</li><li>Cached 模式适用于任务处理量波动较大、流量突发性强的场景，可以在短时间内快速扩展线程池以应对高并发流量，但需要注意合理设置线程上限以避免资源耗尽。</li></ul></li></ul><h2 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h2><h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><p><img data-src="../../../asset/2025/05/cxx-thread-pool-1.png"></p><h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><ul><li>(1) 基于 C++ 可变参数模板编程和引用折叠原理，实现线程池 <code>submitTask</code> 接口，支持任意任务函数和任意参数的传递</li><li> (2) 使用 <code>future</code> 类型定制 <code>submitTask</code> 接口提交任务的返回值</li><li> (3) 使用 <code>map</code> 和 <code>queue</code> 容器管理线程对象和任务</li><li> (4) 基于条件变量 <code>condition_variable</code> 和互斥锁 <code>mutex</code> 实现任务提交线程和任务执行线程间的同步通信机制</li><li> (5) 支持 <code>fixed</code> 模式和 <code>cached</code> 模式的线程池定制</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="C-11-版本"><a href="#C-11-版本" class="headerlink" title="C++ 11 版本"></a>C++ 11 版本</h4><p>这里基于 C++ 11 手写一个线程池，并自行实现 <code>make_unique()</code>、<code>any</code> 类型、信号量类型。</p><div class="admonition note"><p class="admonition-title">代码下载</p><p>C++ 11 实现线程池的完整案例代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-thread-pool/c%2B%2B-11-thread-pool">这里</a> 下载得到，所有案例代码都兼容 Windows 和 Linux 平台。</p></div><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><ul><li><code>extend.h</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXTEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// make_unique() /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> extend {</span><br><span class="line">    <span class="comment">// 创建非数组类型对象</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;!std::is_array&lt;T&gt;::value, std::unique_ptr&lt;T&gt;&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">make_unique</span><span class="params">(Args &amp;&amp;... args)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建未知大小的数组（例如 make_unique&lt;T[]&gt;(n)）</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;std::is_array&lt;T&gt;::value &amp;&amp; std::extent&lt;T&gt;::value == <span class="number">0</span>, std::unique_ptr&lt;T&gt;&gt;::type</span><br><span class="line">    <span class="built_in">make_unique</span>(std::<span class="keyword">size_t</span> size) {</span><br><span class="line">        <span class="keyword">using</span> ElementType = <span class="keyword">typename</span> std::remove_extent&lt;T&gt;::type;</span><br><span class="line">        <span class="keyword">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> ElementType[size]());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止使用定长数组（例如 make_unique&lt;int[10]&gt; 是不合法的）</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;(std::extent&lt;T&gt;::value != <span class="number">0</span>), <span class="keyword">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">make_unique</span><span class="params">(Args &amp;&amp;...)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// Any 类型 /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any 类型（可以接收任意数据类型）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Any</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用带左值的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Any</span>(<span class="keyword">const</span> Any &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用带左值的赋值运算符</span></span><br><span class="line">    Any &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Any &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值的拷贝构造函数（移动拷贝构造）</span></span><br><span class="line">    <span class="built_in">Any</span>(Any&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值的赋值运算符（移动赋值运算符）</span></span><br><span class="line">    Any &amp;<span class="keyword">operator</span>=(Any &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用构造函数（让 Any 类型可以接收任意数据类型）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(T&amp;&amp; data)</span> : base_(extend::make_unique&lt;Derive&lt;typename std::decay&lt;T&gt;::type&gt;&gt;(std::forward&lt;T&gt;(data))) {</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换（将 Any 类型存储的数据类型提取出来）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T <span class="title">cast</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (base_ == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"Any is empty"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将基类指针转换为派生类指针（类型向下转换）</span></span><br><span class="line">        Derive &lt;T&gt; *p = <span class="keyword">dynamic_cast</span>&lt;Derive &lt;T&gt; *&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"type is unmatch!"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回真实的数据类型</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;<span class="built_in">getData</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 基类类型</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 虚析构函数</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类类型</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 通用构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">        <span class="title">Derive</span><span class="params">(U &amp;&amp;data)</span> : data_(std::forward&lt;U&gt;(data)) {</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~<span class="built_in">Derive</span>() {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> data_;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T data_;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;    <span class="comment">// 基类指针</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// Semaphore 信号量 /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量类（用于线程通信）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Semaphore</span>(<span class="keyword">int</span> limit = <span class="number">0</span>) : <span class="built_in">limit_</span>(limit), <span class="built_in">isDestroyed</span>(<span class="literal">false</span>) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Semaphore</span>() {</span><br><span class="line">        <span class="comment">// 标记当前对象已经被析构</span></span><br><span class="line">        isDestroyed = <span class="literal">true</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个信号量资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!isDestroyed) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待信号量资源</span></span><br><span class="line">            cond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> limit_ &gt; <span class="number">0</span>; });</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更改资源计数</span></span><br><span class="line">            limit_--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个信号量资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!isDestroyed) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更改资源计数</span></span><br><span class="line">            limit_++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知其他线程获取信号量资源</span></span><br><span class="line">            <span class="comment">// 特别注意，在默认情况下，Linux 平台中 condition_variable 的析构函数什么也没做，会导致这里状态已经失效；一旦外部使用它的对象（比如 Result）提前析构，就会无故阻塞线程，造成线程死锁</span></span><br><span class="line">            cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> limit_;                     <span class="comment">// 资源计数</span></span><br><span class="line">    std::mutex mtx_;                <span class="comment">// 互斥锁</span></span><br><span class="line">    std::condition_variable cond_;  <span class="comment">// 条件变量</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isDestroyed;   <span class="comment">// 是否已经被析构（用于解决Linux平台的兼容问题）</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EXTEND_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>thread_pool.h</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"extend.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池核心参数 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的线程数量（默认是CPU的核心数）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INIT_THREAD_SIZE = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TASK_MAX_THRESHHOLD = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_SIZE_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程允许的最大空闲时间（单位秒）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">PoolMode</span> {</span></span><br><span class="line">    MODE_FIXED,    <span class="comment">// 固定大小线程池</span></span><br><span class="line">    MODE_CACHED    <span class="comment">// 缓存线程池</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务抽象类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务执行结果类的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Task</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Task</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数，实现用户自定义的任务处理逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Result *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Result *result_;    <span class="comment">// 任务执行结果（使用裸指针，避免智能指针循环引用问题）</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务结果类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="keyword">bool</span> isValid = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Result</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    <span class="function">Any <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(Any data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断任务执行结果是否有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断关联的任务是否已完成</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFinished</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Any data_;                        <span class="comment">// 存储任务执行的结果</span></span><br><span class="line">    Semaphore sem_;                   <span class="comment">// 线程通信的信号量</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isValid_;        <span class="comment">// 任务执行结果是否有效</span></span><br><span class="line">    std::shared_ptr&lt;Task&gt; task_;      <span class="comment">// 关联的任务</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isFinished_;     <span class="comment">// 关联的任务是否已执行完成</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数对象的类型</span></span><br><span class="line">    <span class="keyword">using</span> ThreadHandler = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程构造</span></span><br><span class="line">    <span class="built_in">Thread</span>(ThreadHandler handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程析构</span></span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程ID</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> threadId_;                    <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> generateId_;           <span class="comment">// 用于辅助生成全局唯一的线程ID</span></span><br><span class="line">    ThreadHandler threadHandler_;     <span class="comment">// 线程处理函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池析构</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initThreadSize = INIT_THREAD_SIZE)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务给线程池</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Result&gt; <span class="title">submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池的运行状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理已完成的任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanTaskResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;        <span class="comment">// 线程集合</span></span><br><span class="line">    PoolMode poolMode_;                                               <span class="comment">// 线程池的模式</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isPoolRuning_;                                   <span class="comment">// 表示线程池是否正在运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> initThreadSize_;                                           <span class="comment">// 初始的线程数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> idleThreadSize_;                                  <span class="comment">// 空闲线程的数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> curThreadSize_;                                   <span class="comment">// 当前线程池的线程数量</span></span><br><span class="line">    <span class="keyword">int</span> threadSizeMaxThreshHold_;                                     <span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"></span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;Task&gt;&gt; taskQueue_;                     <span class="comment">// 任务队列</span></span><br><span class="line">    std::<span class="keyword">atomic_uint</span> taskSize_;                                       <span class="comment">// 当前任务队列的任务数量</span></span><br><span class="line">    <span class="keyword">size_t</span> taskQueMaxThreshHold_;                                     <span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"></span><br><span class="line">    std::mutex taskQueMtx_;                                           <span class="comment">// 任务队列操作的互斥锁</span></span><br><span class="line">    std::condition_variable notFull_;                                 <span class="comment">// 表示任务队列不满，用于通知用户线程提交任务</span></span><br><span class="line">    std::condition_variable notEmpty_;                                <span class="comment">// 表示任务队列不空，用于通知线程池中的线程执行任务</span></span><br><span class="line">    std::condition_variable allExit_;                                 <span class="comment">// 表示等待线程池回收所有线程</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Result&gt;&gt; taskResults_;                <span class="comment">// 任务执行结果列表，用于避免任务执行结果比任务早被析构</span></span><br><span class="line">    std::mutex taskResultsMtx_;                                       <span class="comment">// 任务执行结果的互斥锁</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// THREAD_POOL_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>thread_pool.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务抽象类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Task::<span class="built_in">Task</span>() : <span class="built_in">result_</span>(<span class="literal">nullptr</span>) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task::exec</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 执行任务处理逻辑（发生多态调用）</span></span><br><span class="line">    Any data = <span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="keyword">if</span> (result_ != <span class="literal">nullptr</span>) {</span><br><span class="line">        result_-&gt;<span class="built_in">setVal</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task::setResult</span><span class="params">(Result *p)</span> </span>{</span><br><span class="line">    result_ = p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务结果类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Result::<span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="keyword">bool</span> isValid) : <span class="built_in">task_</span>(task), <span class="built_in">isValid_</span>(isValid), <span class="built_in">isFinished_</span>(<span class="literal">false</span>) {</span><br><span class="line">    <span class="comment">// 关联任务和任务执行结果</span></span><br><span class="line">    task-&gt;<span class="built_in">setResult</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取任务执行结果</span></span><br><span class="line"><span class="function">Any <span class="title">Result::get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 如果任务执行结果无效，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!isValid_) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待获取一个信号量资源（即让当前线程等待任务执行完成）</span></span><br><span class="line">    sem_.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回任务执行完成的结果</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(data_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Result::setVal</span><span class="params">(Any data)</span> </span>{</span><br><span class="line">    <span class="comment">// 存储任务执行结果</span></span><br><span class="line">    data_ = std::<span class="built_in">move</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联的任务已执行完成</span></span><br><span class="line">    isFinished_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个信号量资源（即通知其他线程获取任务执行结果）</span></span><br><span class="line">    sem_.<span class="built_in">post</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断任务执行结果是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Result::isValid</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isValid_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断关联的任务是否已完成</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Result::isFinished</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isFinished_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程构造</span></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadHandler handler) : <span class="built_in">threadHandler_</span>(handler), <span class="built_in">threadId_</span>(generateId_++) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程析构</span></span><br><span class="line">Thread::~<span class="built_in">Thread</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个线程，并执行线程处理函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadHandler_, threadId_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将子线程设置为分离线程</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread::getId</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> threadId_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于辅助生成全局唯一的线程ID</span></span><br><span class="line"><span class="keyword">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 ////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池构造</span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>() {</span><br><span class="line">    idleThreadSize_ = <span class="number">0</span>;</span><br><span class="line">    curThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">    initThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">    threadSizeMaxThreshHold_ = THREAD_SIZE_MAX_THRESHHOLD;</span><br><span class="line">    taskSize_ = <span class="number">0</span>;</span><br><span class="line">    taskQueMaxThreshHold_ = TASK_MAX_THRESHHOLD;</span><br><span class="line">    poolMode_ = PoolMode::MODE_FIXED;</span><br><span class="line">    isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池析构</span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">    <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">    isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁，用于等待线程池里面所有的线程结束运行（线程有两种状态：阻塞等待获取任务 &amp; 正在执行任务中）</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须先获取互斥锁，然后再唤醒所有正在等待获取任务的线程，避免发生线程死锁问题</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程池里的所有线程回收完成</span></span><br><span class="line">    allExit_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的工作模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setMode</span><span class="params">(PoolMode mode)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        poolMode_ = mode;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; !<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        threadSizeMaxThreshHold_ = threshhold;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查线程池的运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ThreadPool::checkRunningState</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isPoolRuning_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理已完成的任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::cleanTaskResult</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">    <span class="comment">// 将满足条件的元素移动到容器末尾</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = std::<span class="built_in">remove_if</span>(taskResults_.<span class="built_in">begin</span>(), taskResults_.<span class="built_in">end</span>(), [](<span class="keyword">const</span> std::shared_ptr&lt;Result&gt; &amp;res) {</span><br><span class="line">        <span class="keyword">return</span> res-&gt;<span class="built_in">isFinished</span>();</span><br><span class="line">    });</span><br><span class="line">    <span class="comment">// 删除容器末尾那段区域的所有元素</span></span><br><span class="line">    taskResults_.<span class="built_in">erase</span>(new_end, taskResults_.<span class="built_in">end</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="keyword">int</span> initThreadSize)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">    isPoolRuning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录初始的线程数量</span></span><br><span class="line">    initThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前线程池的线程数量</span></span><br><span class="line">    curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">        <span class="comment">// 创建线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">        std::unique_ptr&lt;Thread&gt; thread = extend::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        <span class="comment">// 将线程对象放入线程集合中</span></span><br><span class="line">        threads_.<span class="built_in">emplace</span>(thread-&gt;<span class="built_in">getId</span>(), std::<span class="built_in">move</span>(thread));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动初始的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>();    <span class="comment">// 启动一个线程去执行线程处理函数</span></span><br><span class="line">        idleThreadSize_++;        <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span> </span>{</span><br><span class="line">    <span class="comment">// 记录当前线程首次运行的时间</span></span><br><span class="line">    <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For死循环，为了实现在线程池结束时，所有任务必须执行完成，线程池才可以回收线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 等待获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让当前线程等待获取任务，使用While循环避免虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 如果任务列表为空，且线程池要结束运行，则回收当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">                <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                <span class="comment">// 唤醒等待线程池回收完毕的线程</span></span><br><span class="line">                allExit_.<span class="built_in">notify_all</span>();</span><br><span class="line">                <span class="comment">// 打印日志信息</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">"thread pool destroy, thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 线程池Cached模式的处理,由于Cached模式下有可能已经创建了很多的线程，但是空闲时间超过最大阀值，因此需要将多余的空闲线程回收掉</span></span><br><span class="line">            <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_) {</span><br><span class="line">                std::cv_status waitResult = notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 需要区分超时返回，还是线程正常被唤醒返回</span></span><br><span class="line">                <span class="keyword">if</span> (std::cv_status::timeout == waitResult) {</span><br><span class="line">                    <span class="keyword">auto</span> nowTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">                    <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(nowTime - lastTime);</span><br><span class="line">                    <span class="comment">// 当线程的空闲时间超过最大阀值，且当前线程池的线程数量大于初始线程数量，则开始回收线程池中的空闲线程</span></span><br><span class="line">                    <span class="keyword">if</span> (duration.<span class="built_in">count</span>() &gt; THREAD_MAX_IDLE_TIME &amp;&amp; curThreadSize_ &gt; initThreadSize_) {</span><br><span class="line">                        <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                        threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                        <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">                        idleThreadSize_--;</span><br><span class="line">                        <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">                        curThreadSize_--;</span><br><span class="line">                        <span class="comment">// 打印日志信息</span></span><br><span class="line">                        std::cout &lt;&lt; <span class="string">"idle thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                        <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 线程池Fixed模式的处理</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 等待任务队列不为空</span></span><br><span class="line">                notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新空闲线程数量（在当前线程执行任务之前）</span></span><br><span class="line">        idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从任务队列中获取需要执行的任务</span></span><br><span class="line">        std::shared_ptr&lt;Task&gt; task = taskQueue_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务从任务队列中移除</span></span><br><span class="line">        taskQueue_.<span class="built_in">pop</span>();</span><br><span class="line">        taskSize_--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 成功获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果获取了任务之后，任务队列依旧不为空，则继续通知其他线程执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (taskQueue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">            notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为刚获取了任务，任务队列肯定有空余位置（不满），通知用户提交任务到线程池</span></span><br><span class="line">        notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放互斥锁（在当前线程执行任务之前）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程负责执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">nullptr</span>) {</span><br><span class="line">            task-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新空闲线程数量（在当前线程执行完任务之后）</span></span><br><span class="line">        idleThreadSize_++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理已完成的任务执行结果（在当前线程执行完任务之后）</span></span><br><span class="line">        <span class="built_in">cleanTaskResult</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前线程最后执行完任务的时间</span></span><br><span class="line">        lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务给线程池</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Result&gt; <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务队列有空余位置（不满）</span></span><br><span class="line">    <span class="keyword">bool</span> waitResult = notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [<span class="keyword">this</span>]() { <span class="keyword">return</span> taskQueue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; });</span><br><span class="line">    <span class="comment">// 如果等待超时，则返回无效的任务执行结果</span></span><br><span class="line">    <span class="keyword">if</span> (!waitResult) {</span><br><span class="line">        <span class="comment">// 打印错误信息</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"task queue is full, submit task failed."</span>;</span><br><span class="line">        <span class="comment">// 无效的任务执行结果</span></span><br><span class="line">        std::shared_ptr&lt;Result&gt; result = std::make_shared&lt;Result&gt;(task, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">        <span class="comment">// 将任务执行结果保存起来，防止用户未使用而导致提前析构</span></span><br><span class="line">        taskResults_.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">        <span class="comment">// 返回任务执行结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务队列有空余位置（不满），则将任务放入任务队列中</span></span><br><span class="line">    taskQueue_.<span class="built_in">emplace</span>(task);</span><br><span class="line">    taskSize_++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为刚放入了新任务，任务队列肯定不为空，通知线程池中的线程去执行任务</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池Cached模式的处理，根据任务数量动态增加线程池的线程数量</span></span><br><span class="line">    <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; taskSize_ &gt; idleThreadSize_ &amp;&amp; curThreadSize_ &lt; threadSizeMaxThreshHold_) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"expand and create new thread."</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 创建新线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">        std::unique_ptr&lt;Thread&gt; thread = extend::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        <span class="comment">// 获取线程ID（必须在线程放入线程集合之前获取一次线程ID，否则后续将可能获取到空值）</span></span><br><span class="line">        <span class="keyword">int</span> threadId = thread-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        <span class="comment">// 将新线程对象放入线程集合中</span></span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(thread));</span><br><span class="line">        <span class="comment">// 启动新线程</span></span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">        idleThreadSize_++;</span><br><span class="line">        <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">        curThreadSize_++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有效的任务执行结果</span></span><br><span class="line">    std::shared_ptr&lt;Result&gt; result = std::make_shared&lt;Result&gt;(task);</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">    <span class="comment">// 将任务执行结果保存起来，防止用户未使用而导致提前析构</span></span><br><span class="line">    taskResults_.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">    <span class="comment">// 返回任务执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> ULong = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义任务类（模拟并行计算）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculateTask</span> :</span> <span class="keyword">public</span> Task {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CalculateTask</span>(ULong begin, ULong end) : <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"execute task by thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程执行计算</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ULong i = begin_; i &lt;= end_; ++i) {</span><br><span class="line">            sum += i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前线程的计算结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Any</span>(sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ULong begin_;    <span class="comment">// 开始计算的位置</span></span><br><span class="line">    ULong end_;      <span class="comment">// 结束计算的位置</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 线程池的工作模式</span></span><br><span class="line">    <span class="keyword">int</span> poolMode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 获取用户输入</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"请选择线程池的工作模式，0 - Fixed，1 - Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; poolMode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为非法输入</span></span><br><span class="line">        <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) {</span><br><span class="line">            <span class="comment">// 清除错误标志位</span></span><br><span class="line">            std::cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">// 丢弃错误输入</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"输入无效，请重新输入一个合法的数字！\n"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部作用域开始</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPool pool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// Fixed模式（固定大小线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_FIXED);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Fixed"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Cached模式（缓存线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">            pool.<span class="built_in">setThreadSizeMaxThreshHold</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程池（指定初始的线程数量）</span></span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::shared_ptr&lt;Result&gt;&gt; results;</span><br><span class="line">        ULong begin = <span class="number">0</span>;</span><br><span class="line">        ULong end = <span class="number">0</span>;</span><br><span class="line">        ULong step = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交多个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// 计算区间</span></span><br><span class="line">            begin = end + <span class="number">1</span>;</span><br><span class="line">            end = begin + step - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建任务</span></span><br><span class="line">            std::shared_ptr&lt;Task&gt; task = std::make_shared&lt;CalculateTask&gt;(begin, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            std::shared_ptr&lt;Result&gt; result = pool.<span class="built_in">submitTask</span>(task);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储任务执行结果</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;<span class="built_in">isValid</span>()) {</span><br><span class="line">                results.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计任务执行结果</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取任务执行结果</span></span><br><span class="line">            ULong result = results[i]-&gt;<span class="built_in">get</span>().cast&lt;ULong&gt;();</span><br><span class="line">            sum += result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出并行计算结果</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"==&gt; 计算结果：1 + 2 + ... + "</span> &lt;&lt; end &lt;&lt; <span class="string">" = "</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是Cached模式，则等待一段时间，触发线程池回收空闲线程</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">1</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）..."</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(THREAD_MAX_IDLE_TIME + <span class="number">5</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 局部作用域结束，线程池自动析构，回收线程池中的所有线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞主线程，直到用户按下任意键才结束程序</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 平台编译测试代码，生成并运行可执行测试程序（使用的 <code>g++</code> 版本是 <code>4.8.5</code>）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++ -Iinclude src/thread_pool.cpp src/test.cpp -o thread_pool_test -pthread -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行测试程序</span></span><br><span class="line">./thread_pool_test</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Fixed 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Fixed</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">thread pool destroy, thread 480 exited.</span><br><span class="line">thread pool destroy, thread 11872 exited.</span><br><span class="line">thread pool destroy, thread 2620 exited.</span><br><span class="line">thread pool destroy, thread 9140 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Cached 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Cached</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15144 成功获取任务...</span><br><span class="line">execute task by thread 15144</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 20812 成功获取任务...</span><br><span class="line">execute task by thread 20812</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 3904 成功获取任务...</span><br><span class="line">execute task by thread 3904</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 15616 成功获取任务...</span><br><span class="line">execute task by thread 15616</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 9800 成功获取任务...</span><br><span class="line">execute task by thread 9800</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）...</span><br><span class="line">idle thread 15616 exited.</span><br><span class="line">idle thread 9800 exited.</span><br><span class="line">idle thread 480 exited.</span><br><span class="line">idle thread 15144 exited.</span><br><span class="line">thread pool destroy, thread 20864 exited.</span><br><span class="line">thread pool destroy, thread 11812 exited.</span><br><span class="line">thread pool destroy, thread 20812 exited.</span><br><span class="line">thread pool destroy, thread 3904 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><h5 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h5><p>为了便于将线程池库提供给第三方使用，可以将线程池项目的核心源码编译成动态链接库。下面将以 Linux 平台为例，介绍使用不同的方式将线程池项目编译为动态链接库（<code>.so</code> 文件）。值得一提的是，C++ 线程池项目的目录结构如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c++-11-thread-pool</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│&nbsp;&nbsp; ├── extend.h</span><br><span class="line">│&nbsp;&nbsp; └── thread_pool.h</span><br><span class="line">└── src</span><br><span class="line">    ├── test.cpp</span><br><span class="line">    └── thread_pool.cpp</span><br></pre></td></tr></tbody></table></figure><h6 id="GCC-编译"><a href="#GCC-编译" class="headerlink" title="GCC 编译"></a>GCC 编译</h6><div class="admonition note"><p class="admonition-title">版本说明</p><p>本文使用的 <code>g++</code> 版本是 <code>4.8.5</code>，若版本过低，可能会出现线程池代码编译失败的问题。</p></div><ul><li>项目的编译构建 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成动态链接库</span></span><br><span class="line">g++ -fPIC -Iinclude -shared src/thread_pool.cpp -o libthread_pool.so -pthread -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++ -Iinclude src/thread_pool.cpp src/test.cpp -o thread_pool_test -pthread -std=c++11</span><br></pre></td></tr></tbody></table></figure><ul><li>编译参数的说明</li></ul><table><thead><tr><th>编译参数</th><th></th><th>参数说明</th></tr></thead><tbody><tr><td><code>-fPIC</code></td><td></td><td>生成位置无关代码，<code>.so</code> 文件必须使用</td></tr><tr><td><code>-Iinclude</code></td><td></td><td>指定头文件目录为 <code>include</code></td></tr><tr><td><code>-shared</code></td><td></td><td>指定编译生成共享库（动态链接库）</td></tr><tr><td><code>src/thread_pool.cpp</code></td><td></td><td>指定源文件路径</td></tr><tr><td><code>-o libthread_pool.so</code></td><td></td><td>指定编译输出的文件名</td></tr><tr><td><code>-pthread</code></td><td></td><td>链接 <code>pthread</code> 库</td></tr><tr><td><code>-std=c++11</code></td><td></td><td>指定 C++ 版本</td></tr></tbody></table><ul><li>动态链接库的安装（可选），如果不安装，第三方程序在运行时可能会遇到找不到动态链接库的问题 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将头文件安装到系统中</span></span><br><span class="line">sudo cp ./include/* /usr/<span class="built_in">local</span>/include</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将编译生成的动态链接库安装到系统中</span></span><br><span class="line">sudo cp libthread_pool.so /usr/<span class="built_in">local</span>/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统的动态链接库配置文件</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt; /etc/ld.so.conf.d/custom.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载系统的动态链接库配置</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></tbody></table></figure><h6 id="CMake-编译"><a href="#CMake-编译" class="headerlink" title="CMake 编译"></a>CMake 编译</h6><div class="admonition note"><p class="admonition-title">版本说明</p><p>本文使用的 <code>g++</code> 版本是 <code>4.8.5</code>，CMake 版本是 <code>3.25.1</code>，若版本过低，可能会出现线程池代码编译失败的问题。值得一提的是，CMake 的详细使用教程可以参考 <a href="/posts/b6161f29.html">这里</a>。</p></div><ul><li>项目的 CMake 配置 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line"># 项目名称和语言</span><br><span class="line">project(cxx_11_thread_pool VERSION 1.0 LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"># 设置 C++ 版本</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line"></span><br><span class="line"># 设置构建模式</span><br><span class="line">set(CMAKE_BUILD_TYPE Debug CACHE STRING "" FORCE)</span><br><span class="line"></span><br><span class="line"># 设置头文件目录</span><br><span class="line">include_directories(${CMAKE_SOURCE_DIR}/include)</span><br><span class="line"></span><br><span class="line"># 设置源文件</span><br><span class="line">file(GLOB SRC_FILES src/*.cpp)</span><br><span class="line"></span><br><span class="line"># 编译生成动态链接库</span><br><span class="line">add_library(thread_pool SHARED ${SRC_FILES})</span><br><span class="line"></span><br><span class="line"># 设置动态链接库的文件名称</span><br><span class="line">set_target_properties(thread_pool PROPERTIES</span><br><span class="line">        OUTPUT_NAME "thread_pool"</span><br><span class="line">        PREFIX "lib"</span><br><span class="line">        SUFFIX ".so"</span><br><span class="line">        POSITION_INDEPENDENT_CODE ON</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 设置动态链接库的链接标志</span><br><span class="line">if (CMAKE_SYSTEM_NAME STREQUAL "Linux")</span><br><span class="line">    target_link_libraries(thread_pool PRIVATE pthread)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line"># 编译生成可执行测试程序</span><br><span class="line">add_executable(thread_pool_test ${SRC_FILES})</span><br><span class="line"></span><br><span class="line"># 设置可执行测试程序的链接标志</span><br><span class="line">if (CMAKE_SYSTEM_NAME STREQUAL "Linux")</span><br><span class="line">    target_link_libraries(thread_pool_test PRIVATE pthread)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line"># 设置默认的安装前缀路径</span><br><span class="line">if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)</span><br><span class="line">    set(CMAKE_INSTALL_PREFIX "/usr/local" CACHE PATH "Install path prefix." FORCE)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"># 将头文件和编译生成的动态链接库安装到指定位置（可选）</span><br><span class="line">install(DIRECTORY include/ DESTINATION include)</span><br><span class="line">install(TARGETS thread_pool DESTINATION lib)</span><br></pre></td></tr></tbody></table></figure><ul><li>项目的编译构建 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成动态链接库和可执行测试程序</span></span><br><span class="line">cmake -S . -B build &amp;&amp; cmake --build build</span><br></pre></td></tr></tbody></table></figure><ul><li>编译参数的说明</li></ul><table><thead><tr><th>编译参数</th><th>参数说明</th></tr></thead><tbody><tr><td><code>-S .</code></td><td>指定源码目录为当前目录（包含 <code>CMakeLists.txt</code>）</td></tr><tr><td><code>-B build</code></td><td>指定构建目录为 <code>build</code>，不存在时会自动创建</td></tr><tr><td><code>cmake --build build</code></td><td>执行编译（相当于 <code>make</code>）</td></tr></tbody></table><ul><li>动态链接库的安装（可选），如果不安装，第三方程序在运行时可能会遇到找不到动态链接库的问题 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将头文件和编译生成的动态链接库安装到系统中</span></span><br><span class="line">sudo cmake --install build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统的动态链接库配置文件</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt; /etc/ld.so.conf.d/custom.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载系统的动态链接库配置</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></tbody></table></figure><h4 id="C-17-版本"><a href="#C-17-版本" class="headerlink" title="C++ 17 版本"></a>C++ 17 版本</h4><p>这里基于 C++ 17 手写一个线程池，使用了可变参数模板、<code>make_unique()</code>、<code>packaged_task</code>、<code>future</code> 特性。</p><div class="admonition note"><p class="admonition-title">代码下载</p><p>C++ 17 实现线程池的完整案例代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-thread-pool/c%2B%2B-17-thread-pool">这里</a> 下载得到，所有案例代码都兼容 Windows 和 Linux 平台。</p></div><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><ul><li><code>thread_pool.h</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池核心参数 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的线程数量（默认是CPU的核心数）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INIT_THREAD_SIZE = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TASK_MAX_THRESHHOLD = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_SIZE_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程允许的最大空闲时间（单位秒）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">PoolMode</span> {</span></span><br><span class="line">    MODE_FIXED,    <span class="comment">// 固定大小线程池</span></span><br><span class="line">    MODE_CACHED    <span class="comment">// 缓存线程池</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数对象的类型</span></span><br><span class="line">    <span class="keyword">using</span> ThreadHandler = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程构造</span></span><br><span class="line">    <span class="built_in">Thread</span>(ThreadHandler handler) : <span class="built_in">threadHandler_</span>(handler), <span class="built_in">threadId_</span>(generateId_++) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程析构</span></span><br><span class="line">    ~<span class="built_in">Thread</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个线程，并执行线程处理函数</span></span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">(threadHandler_, threadId_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子线程设置为分离线程</span></span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程ID</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> threadId_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> threadId_;                    <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> generateId_;           <span class="comment">// 用于辅助生成全局唯一的线程ID</span></span><br><span class="line">    ThreadHandler threadHandler_;     <span class="comment">// 线程处理函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于辅助生成全局唯一的线程ID</span></span><br><span class="line"><span class="keyword">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>() {</span><br><span class="line">        idleThreadSize_ = <span class="number">0</span>;</span><br><span class="line">        curThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">        initThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">        threadSizeMaxThreshHold_ = THREAD_SIZE_MAX_THRESHHOLD;</span><br><span class="line">        taskSize_ = <span class="number">0</span>;</span><br><span class="line">        taskQueMaxThreshHold_ = TASK_MAX_THRESHHOLD;</span><br><span class="line">        poolMode_ = PoolMode::MODE_FIXED;</span><br><span class="line">        isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池析构</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">        <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">        isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁，用于等待线程池里面所有的线程结束运行（线程有两种状态：阻塞等待获取任务 &amp; 正在执行任务中）</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须先获取互斥锁，然后再唤醒所有正在等待获取任务的线程，避免发生线程死锁问题</span></span><br><span class="line">        notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程池里的所有线程回收完成</span></span><br><span class="line">        allExit_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            poolMode_ = mode;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; !<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            threadSizeMaxThreshHold_ = threshhold;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initThreadSize)</span> </span>{</span><br><span class="line">        <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">        isPoolRuning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录初始的线程数量</span></span><br><span class="line">        initThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前线程池的线程数量</span></span><br><span class="line">        curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建初始的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">            <span class="comment">// 创建线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">            std::unique_ptr&lt;Thread&gt; thread = std::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">            <span class="comment">// 将线程对象放入线程集合中</span></span><br><span class="line">            threads_.<span class="built_in">emplace</span>(thread-&gt;<span class="built_in">getId</span>(), std::<span class="built_in">move</span>(thread));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动初始的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">            threads_[i]-&gt;<span class="built_in">start</span>();    <span class="comment">// 启动一个线程去执行线程处理函数</span></span><br><span class="line">            idleThreadSize_++;       <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务给线程池（使用可变参数模板 + 引用折叠 + 完美转发）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func &amp;&amp;func, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt; </span>{</span><br><span class="line">        <span class="comment">// 推导任务执行结果的类型（返回值类型）</span></span><br><span class="line">        <span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装一个任意可调用对象（函数、函数对象、Lambda表达式等）为异步任务</span></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">                std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取与异步任务关联的Future，方便用户获取任务执行结果</span></span><br><span class="line">        std::future&lt;RType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待任务队列有空余位置（不满）</span></span><br><span class="line">        <span class="keyword">bool</span> waitResult = notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [<span class="keyword">this</span>]() { <span class="keyword">return</span> taskQueue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; });</span><br><span class="line">        <span class="comment">// 如果等待超时，则直接返回Future</span></span><br><span class="line">        <span class="keyword">if</span> (!waitResult) {</span><br><span class="line">            <span class="comment">// 打印错误信息</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">"task queue is full, submit task failed."</span>;</span><br><span class="line">            <span class="comment">// 封装一个空的任务</span></span><br><span class="line">            <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;([]() -&gt; RType { <span class="keyword">return</span> <span class="built_in">RType</span>(); });</span><br><span class="line">            <span class="comment">// 执行一个空的任务</span></span><br><span class="line">            (*task)();</span><br><span class="line">            <span class="comment">// 返回与任务关联的Future</span></span><br><span class="line">            <span class="keyword">return</span> task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果任务队列有空余位置（不满），则将任务放入任务队列中</span></span><br><span class="line">        taskQueue_.<span class="built_in">emplace</span>([task]() {</span><br><span class="line">            (*task)();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前任务队列的任务数量</span></span><br><span class="line">        taskSize_++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为刚放入了新任务，任务队列肯定不为空，通知线程池中的线程去执行任务</span></span><br><span class="line">        notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池Cached模式的处理，根据任务数量动态增加线程池的线程数量</span></span><br><span class="line">        <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; taskSize_ &gt; idleThreadSize_ &amp;&amp; curThreadSize_ &lt; threadSizeMaxThreshHold_) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"expand and create new thread."</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 创建新线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">            std::unique_ptr&lt;Thread&gt; thread = std::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">            <span class="comment">// 获取线程ID（必须在线程放入线程集合之前获取一次线程ID，否则后续将可能获取到空值）</span></span><br><span class="line">            <span class="keyword">int</span> threadId = thread-&gt;<span class="built_in">getId</span>();</span><br><span class="line">            <span class="comment">// 将新线程对象放入线程集合中</span></span><br><span class="line">            threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(thread));</span><br><span class="line">            <span class="comment">// 启动新线程</span></span><br><span class="line">            threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">            <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">            idleThreadSize_++;</span><br><span class="line">            <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">            curThreadSize_++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回与任务关联的Future</span></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span> </span>{</span><br><span class="line">        <span class="comment">// 记录当前线程首次运行的时间</span></span><br><span class="line">        <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For死循环，为了实现在线程池结束时，所有任务必须执行完成，线程池才可以回收线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 等待获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让当前线程等待获取任务，使用While循环避免虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 如果任务列表为空，且线程池要结束运行，则回收当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">                    <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                    threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                    <span class="comment">// 唤醒等待线程池回收完毕的线程</span></span><br><span class="line">                    allExit_.<span class="built_in">notify_all</span>();</span><br><span class="line">                    <span class="comment">// 打印日志信息</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">"thread pool destroy, thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 线程池Cached模式的处理,由于Cached模式下有可能已经创建了很多的线程，但是空闲时间超过最大阀值，因此需要将多余的空闲线程回收掉</span></span><br><span class="line">                <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_) {</span><br><span class="line">                    std::cv_status waitResult = notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 需要区分超时返回，还是线程正常被唤醒返回</span></span><br><span class="line">                    <span class="keyword">if</span> (std::cv_status::timeout == waitResult) {</span><br><span class="line">                        <span class="keyword">auto</span> nowTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">                        <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(nowTime - lastTime);</span><br><span class="line">                        <span class="comment">// 当线程的空闲时间超过最大阀值，且当前线程池的线程数量大于初始线程数量，则开始回收线程池中的空闲线程</span></span><br><span class="line">                        <span class="keyword">if</span> (duration.<span class="built_in">count</span>() &gt; THREAD_MAX_IDLE_TIME &amp;&amp; curThreadSize_ &gt; initThreadSize_) {</span><br><span class="line">                            <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                            threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                            <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">                            idleThreadSize_--;</span><br><span class="line">                            <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">                            curThreadSize_--;</span><br><span class="line">                            <span class="comment">// 打印日志信息</span></span><br><span class="line">                            std::cout &lt;&lt; <span class="string">"idle thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                            <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 线程池Fixed模式的处理</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 等待任务队列不为空</span></span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新空闲线程数量（在当前线程执行任务之前）</span></span><br><span class="line">            idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从任务队列中获取需要执行的任务</span></span><br><span class="line">            Task task = taskQueue_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务从任务队列中移除</span></span><br><span class="line">            taskQueue_.<span class="built_in">pop</span>();</span><br><span class="line">            taskSize_--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 成功获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果获取了任务之后，任务队列依旧不为空，则继续通知其他线程执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (taskQueue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">                notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为刚获取了任务，任务队列肯定有空余位置（不满），通知用户提交任务到线程池</span></span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放互斥锁（在当前线程执行任务之前）</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前线程负责执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新空闲线程数量（在当前线程执行完任务之后）</span></span><br><span class="line">            idleThreadSize_++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新当前线程最后执行完任务的时间</span></span><br><span class="line">            lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池的运行状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> isPoolRuning_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;        <span class="comment">// 线程集合</span></span><br><span class="line">    PoolMode poolMode_;                                               <span class="comment">// 线程池的模式</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isPoolRuning_;                                   <span class="comment">// 表示线程池是否正在运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> initThreadSize_;                                           <span class="comment">// 初始的线程数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> idleThreadSize_;                                  <span class="comment">// 空闲线程的数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> curThreadSize_;                                   <span class="comment">// 当前线程池的线程数量</span></span><br><span class="line">    <span class="keyword">int</span> threadSizeMaxThreshHold_;                                     <span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;                               <span class="comment">// 类型重定义，使用Function类模板作为任务</span></span><br><span class="line">    std::queue&lt;Task&gt; taskQueue_;                                      <span class="comment">// 任务队列</span></span><br><span class="line">    std::<span class="keyword">atomic_uint</span> taskSize_;                                       <span class="comment">// 当前任务队列的任务数量</span></span><br><span class="line">    <span class="keyword">size_t</span> taskQueMaxThreshHold_;                                     <span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"></span><br><span class="line">    std::mutex taskQueMtx_;                                           <span class="comment">// 任务队列操作的互斥锁</span></span><br><span class="line">    std::condition_variable notFull_;                                 <span class="comment">// 表示任务队列不满，用于通知用户线程提交任务</span></span><br><span class="line">    std::condition_variable notEmpty_;                                <span class="comment">// 表示任务队列不空，用于通知线程池中的线程执行任务</span></span><br><span class="line">    std::condition_variable allExit_;                                 <span class="comment">// 表示等待线程池回收所有线程</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// THREAD_POOL_H</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> ULong = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算逻辑</span></span><br><span class="line"><span class="function">ULong <span class="title">sum</span><span class="params">(ULong begin, ULong end)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"execute task by thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程执行加法计算</span></span><br><span class="line">    ULong sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ULong i = begin; i &lt;= end; ++i) {</span><br><span class="line">        sum += i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回计算结果</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 线程池的工作模式</span></span><br><span class="line">    <span class="keyword">int</span> poolMode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 获取用户输入</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"请选择线程池的工作模式，0 - Fixed，1 - Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; poolMode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为非法输入</span></span><br><span class="line">        <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) {</span><br><span class="line">            <span class="comment">// 清除错误标志位</span></span><br><span class="line">            std::cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">// 丢弃错误输入</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"输入无效，请重新输入一个合法的数字！\n"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部作用域开始</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPool pool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// Fixed模式（固定大小线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_FIXED);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Fixed"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Cached模式（缓存线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">            pool.<span class="built_in">setThreadSizeMaxThreshHold</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程池（指定初始的线程数量）</span></span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储与任务关联的Future</span></span><br><span class="line">        std::vector&lt;std::future&lt;ULong&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">        ULong begin = <span class="number">0</span>;</span><br><span class="line">        ULong end = <span class="number">0</span>;</span><br><span class="line">        ULong step = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交多个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// 计算区间</span></span><br><span class="line">            begin = end + <span class="number">1</span>;</span><br><span class="line">            end = begin + step - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            std::future&lt;ULong&gt; result = pool.<span class="built_in">submitTask</span>(sum, begin, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储与任务关联的Future</span></span><br><span class="line">            results.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(result));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计任务执行结果</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取任务执行结果</span></span><br><span class="line">            ULong result = results[i].<span class="built_in">get</span>();</span><br><span class="line">            sum += result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出并行计算结果</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"==&gt; 计算结果：1 + 2 + ... + "</span> &lt;&lt; end &lt;&lt; <span class="string">" = "</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是Cached模式，则等待一段时间，触发线程池回收空闲线程</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">1</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）..."</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(THREAD_MAX_IDLE_TIME + <span class="number">5</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 局部作用域结束，线程池自动析构，回收线程池中的所有线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞主线程，直到用户按下任意键才结束程序</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 平台编译测试代码，生成并运行可执行测试程序（使用的 <code>g++</code> 版本是 <code>12.2.0</code>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-17-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++<span class="params"> -Iinclude</span> src/<span class="built_in">test</span>.cpp<span class="params"> -o</span> thread_pool_test<span class="params"> -pthread</span><span class="params"> -std</span>=c++17</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行测试程序</span></span><br><span class="line">./thread_pool_test</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Fixed 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Fixed</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">thread pool destroy, thread 480 exited.</span><br><span class="line">thread pool destroy, thread 11872 exited.</span><br><span class="line">thread pool destroy, thread 2620 exited.</span><br><span class="line">thread pool destroy, thread 9140 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Cached 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Cached</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15144 成功获取任务...</span><br><span class="line">execute task by thread 15144</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 20812 成功获取任务...</span><br><span class="line">execute task by thread 20812</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 3904 成功获取任务...</span><br><span class="line">execute task by thread 3904</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 15616 成功获取任务...</span><br><span class="line">execute task by thread 15616</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 9800 成功获取任务...</span><br><span class="line">execute task by thread 9800</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）...</span><br><span class="line">idle thread 15616 exited.</span><br><span class="line">idle thread 9800 exited.</span><br><span class="line">idle thread 480 exited.</span><br><span class="line">idle thread 15144 exited.</span><br><span class="line">thread pool destroy, thread 20864 exited.</span><br><span class="line">thread pool destroy, thread 11812 exited.</span><br><span class="line">thread pool destroy, thread 20812 exited.</span><br><span class="line">thread pool destroy, thread 3904 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><h5 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h5><div class="admonition warning"><p class="admonition-title">动态链接库说明</p><p>由于上面基于 C++ 17 实现的线程池，其核心源码全部都写在头文件中，也就是说 <code>thread_pool.h</code> 是纯 Header-Only（例如类模板 / 函数模板全部实现都在头文件中），因此该线程池项目是无法编译成动态链接库（比如 <code>.so</code>）的。如果一定要编译成动态链接库，可以将线程池的核心代码逻辑移植到 <code>.cpp</code> 源文件，然后再编译成动态链接库。由于篇幅有限，这里不再累述。</p></div><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>(1) 基于 C++ 11 / C++ 17 实现线程池，当线程池准备结束运行（销毁），需要等待线程池中所有线程退出时，发生线程死锁问题，导致应用进程无法正常退出。</li><li>(2) 基于 C++ 11 实现线程池，在 Windows 平台下可以正常运行，但在 Linux 平台下运行时自定义实现的信号量类型 Semaphore 会出现线程死锁问题（原因是 <code>condition_variable</code> 的析构函数为空导致，一旦 Result 对象比 Task 对象早被析构就会出现线程死锁）。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>这里提到的两个线程死锁问题，在上面给出的 C++ 11 / C++ 17 线程池代码中已经解决了。</p></div><h4 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h4><p>定位死锁问题时，通常可以通过 <code>gdb</code> 附加（<code>attach</code>）到正在运行的目标进程，然后使用以下命令进行分析：</p><ul><li>使用 <code>ps</code> 命令查找目标进程的 ID；</li><li>使用 <code>gdb attch &lt;pid&gt;</code> 命令附加到目标进程；</li><li>使用 <code>info threads</code> 命令查看当前进程中所有线程的状态及线程 ID；</li><li>使用 <code>thread &lt;tid&gt;</code> 命令切换到指定的线程；</li><li>使用 <code>bt</code> 命令查看当前线程的调用堆栈信息，判断其是否被阻塞、在等待互斥锁（<code>mutex</code>）、或处于循环等待状态；</li><li>重复以上操作，依次分析所有可疑线程的调用堆栈信息，找出多个线程相互等待资源的典型死锁原因。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看目标进程的 ID</span></span><br><span class="line">ps -aux|grep thread_pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 附加的目标进程</span></span><br><span class="line">$ gdb attach &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（查看目标进程中的所有线程）</span></span><br><span class="line">&gt; (gdb) info threads</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（切换到指定的线程）</span></span><br><span class="line">&gt; (gdb) thread &lt;id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（查看当前线程的调用堆栈信息）</span></span><br><span class="line">&gt; (gdb) bt</span><br></pre></td></tr></tbody></table></figure><p>结合项目源码和线程之间的加锁、解锁逻辑，定位到具体发生死锁的代码片段后，可以进一步分析导致死锁的根本原因，常见的原因包括：</p><ul><li>多个线程交叉持有多个锁，且锁的获取顺序不一致；</li><li>忽略了可能抛异常或提前返回，导致某个线程未能正确释放锁；</li><li>加锁和等待条件变量的时机不当等；</li><li>多个资源需要同时加锁时，未采用统一锁策略（比如没有统一使用 <code>lock()</code> 或 <code>unique_lock</code>）。</li></ul><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>规范加锁顺序，避免循环依赖；</li><li>拆分锁或减少锁的粒度；</li><li>使用 <code>try_lock()</code> 等避免阻塞的锁操作；</li><li>引入超时机制，防止死锁的出现；</li><li>在合适的场景下，可以引入无锁并发编程模型（如基于 CAS 的算法），以提升性能并减少锁竞争带来的开销。</li></ul><h2 id="项目输出总结"><a href="#项目输出总结" class="headerlink" title="项目输出总结"></a>项目输出总结</h2><h3 id="应用到企业项目中"><a href="#应用到企业项目中" class="headerlink" title="应用到企业项目中"></a>应用到企业项目中</h3><ul><li>耗时任务处理</li><li>高并发高性能网络服务器</li><li> Master-Slave 线程模型（可用于并行计算）</li></ul><h3 id="输出到求职简历上"><a href="#输出到求职简历上" class="headerlink" title="输出到求职简历上"></a>输出到求职简历上</h3><ul><li><p><strong>项目名称</strong></p><ul><li>基于可变参数模板实现线程池</li></ul></li><li><p><strong>项目描述</strong></p><ul><li>基于可变参数模板和引用折叠原理，实现线程池 <code>submitTask</code> 接口，支持任意任务函数和任意参数的传递</li><li>使用 <code>future</code> 类型定制 <code>submitTask</code> 接口提交任务的返回值</li><li>使用 <code>map</code> 和 <code>queue</code> 容器管理线程对象和任务</li><li>基于条件变量 <code>condition_variable</code> 和互斥锁 <code>mutex</code> 实现任务提交线程和任务执行线程之间的通信机制</li><li>支持 Fixed 和 Cached 模式的线程池</li><li>……（自由发挥）</li></ul></li><li><p><strong>项目问题</strong></p><ul><li>遇到的问题<ul><li>基于 C++ 11 / C++ 17 实现线程池，当线程池准备结束运行（销毁），需要等待线程池中所有线程退出时，发生线程死锁问题，导致应用进程无法正常退出。</li><li>基于 C++ 11 实现线程池，在 Windows 平台下可以正常运行，但在 Linux 平台下运行时自定义实现的信号量类型会出现线程死锁问题（原因是 <code>condition_variable</code> 的析构函数为空导致，一旦 Result 对象比 Task 对象早被析构就会出现线程死锁）。</li></ul></li><li>问题的定位<ul><li>使用 <code>ps</code> 命令查找目标进程的 ID；</li><li>使用 <code>gdb attch &lt;pid&gt;</code> 命令附加到目标进程；</li><li>使用 <code>info threads</code> 命令查看当前进程中所有线程的状态及线程 ID；</li><li>使用 <code>thread &lt;tid&gt;</code> 命令切换到指定的线程；</li><li>使用 <code>bt</code> 命令查看当前线程的调用堆栈信息，判断其是否被阻塞、在等待互斥锁（<code>mutex</code>）、或处于循环等待状态；</li><li>重复以上操作，依次分析所有可疑线程的调用堆栈信息，找出多个线程相互等待资源的典型死锁原因。</li></ul></li><li>问题的解决<ul><li>结合项目源码和线程之间的加锁、解锁逻辑，定位到具体发生死锁的代码片段后，可以进一步分析导致死锁的根本原因，常见的原因包括：</li><li>(1) 多个线程交叉持有多个锁，且锁的获取顺序不一致。</li><li>(2) 忽略了可能抛异常或提前返回，导致某个线程未能正确释放锁。</li><li>(3) 加锁和等待条件变量的时机不当等。</li><li>(4) 多个资源需要同时加锁时，未采用统一锁策略（比如没有统一使用 <code>lock()</code> 或 <code>unique_lock</code>）。</li></ul></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/a2a7ad9b.html">C++ 多线程编程之一</a></li><li><a href="/posts/832c55b5.html">Java 之线程池使用详解</a></li><li><a href="/posts/17b04dfd.html">Java 线程死锁的定位与分析</a></li><li><a href="/posts/dc8f1477.html">如何估算 Java 线程池的大小与队列长度</a></li><li><a href="/posts/f7fd0987.html">Java 多线程编程之七队列、线程池、线程通信</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 手写一个线程池，并提供 C++ 11 和 C++ 17 两种版本的实现代码。</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 内存池源码剖析</title>
    <link href="https://www.techgrow.cn/posts/5bc5018f.html"/>
    <id>https://www.techgrow.cn/posts/5bc5018f.html</id>
    <published>2025-04-18T13:55:33.000Z</published>
    <updated>2025-04-18T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/712a574b.html">SGI STL 内存池源码剖析</a></li><li><a href="/posts/5bc5018f.html">Nginx 内存池源码剖析</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将剖析 Nginx 内存池的源码，并介绍内存池的底层设计和工作原理，最后基于 C++ 移植 Nginx 内存池的核心源码。值得一提的是，移植后的 C++ 代码兼容 Windows 和 Linux 平台。</p><div class="admonition note"><p class="admonition-title">C++ 常见的池</p><p>在 C++ 中，常见的池有对象池、内存池、连接池、协程池、线程池、进程池。</p></div><span id="more"></span><h3 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h3><p>内存管理，是指软件运行时对计算机内存资源的分配和使用的技术。<strong>其最主要的目的是如何高效、快速地分配内存，并且在适当的时候释放和回收内存资源。</strong></p><h3 id="源码学习目标"><a href="#源码学习目标" class="headerlink" title="源码学习目标"></a>源码学习目标</h3><p>在剖析 Nginx 内存管理的源码之前，先思考以下几个问题：</p><ul><li>(1) Nginx 为什么要进行内存管理？</li><li>(2) Nginx 如何进行内存管理？</li><li>(3) Nginx 的内存管理解决了哪些问题？</li></ul><h2 id="Nginx-内存池"><a href="#Nginx-内存池" class="headerlink" title="Nginx 内存池"></a>Nginx 内存池</h2><h3 id="内存池的源码剖析"><a href="#内存池的源码剖析" class="headerlink" title="内存池的源码剖析"></a>内存池的源码剖析</h3><p>这里剖析的 Nginx 版本是 <code>1.12.2</code>，Nginx 内存池的核心源码主要位于 <code>ngx_palloc.h</code> 和 <code>ngx_palloc.c</code> 源文件中。</p><h4 id="重要类型和变量的定义"><a href="#重要类型和变量的定义" class="headerlink" title="重要类型和变量的定义"></a>重要类型和变量的定义</h4><ul><li>Nginx 内存池的粒度信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NGX_MAX_ALLOC_FROM_POOL should be (ngx_pagesize - 1), i.e. 4095 on x86. On Windows NT it decreases a number of locked pages in a kernel.</span></span><br><span class="line"><span class="comment">// 小块内存池单次分配的最大内存大小，不能超过 ngx_pagesize - 1，超过这个大小的内存不会从内存池中分配，而是通过 malloc() 之类的方式单独分配内存。</span></span><br><span class="line"><span class="comment">//ngx_pagesize 是系统页面大小（例如 x86 平台是 4096 字节），减 1 是为了确保对齐且不会跨页，最终小块内存池单次分配的最大内存大小为 4095 字节（x86 平台）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池的默认初始大小为 16KB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_DEFAULT_POOL_SIZE (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池分配时的对齐字节数为 16 字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_POOL_ALIGNMENT 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存的最小可接受大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MIN_POOL_SIZE ngx_align ((sizeof (ngx_pool_t) + 2 * sizeof (ngx_pool_large_t)), NGX_POOL_ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存分配时的对齐字节数，通常是 4 字节（32 位系统）或者 8 字节（64 位系统）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_ALIGNMENT sizeof (unsigned long)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Nginx 内存池的主结构体类型 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;         <span class="comment">// 小块内存池的数据头</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;       <span class="comment">// 小块内存分配的最大值</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;   <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;     <span class="comment">// 该指针挂接一个 ngx_chain_t 结构</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;     <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;   <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *log;       <span class="comment">// 内存分配相关的日志记录</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>小块内存的数据头信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">   u_char               *last;      <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">   u_char               *end;       <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">   <span class="keyword">ngx_pool_t</span>           *next;      <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">   <span class="keyword">ngx_uint_t</span>            failed;    <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">} <span class="keyword">ngx_pool_data_t</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>大块内存的类型定义 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">   <span class="keyword">ngx_pool_large_t</span>     *next;      <span class="comment">// 下一个大块内存</span></span><br><span class="line">   <span class="keyword">void</span>                 *alloc;     <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>清理操作的类型定义，包括一个清理回调函数、传给回调函数的数据和下一个清理操作的地址 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;    <span class="comment">// 清理回调函数的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>  <span class="title">ngx_pool_cleanup_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> {</span></span><br><span class="line">   ngx_pool_cleanup_pt   handler;   <span class="comment">// 函数指针，指向内存清理操作的回调函数</span></span><br><span class="line">   <span class="keyword">void</span>                 *data;      <span class="comment">// 传递给回调函数的参数</span></span><br><span class="line">   <span class="keyword">ngx_pool_cleanup_t</span>   *next;      <span class="comment">// 指向下一个清理操作</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="重要的内存池函数接口"><a href="#重要的内存池函数接口" class="headerlink" title="重要的内存池函数接口"></a>重要的内存池函数接口</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span> *<span class="title">ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span>;   <span class="comment">// 创建内存池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;    <span class="comment">// 销毁内存池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;      <span class="comment">// 重置内存池</span></span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理核心函数"><a href="#内存池管理核心函数" class="headerlink" title="内存池管理核心函数"></a>内存池管理核心函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> * <span class="title">ngx_palloc_small</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span>   <span class="comment">// 内存池分配小块内存的入口函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">ngx_palloc_block</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span>     <span class="comment">// 内存池分配新小块内存（在小块内存块空间不足时）</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">ngx_palloc_large</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span>     <span class="comment">// 内存池分配大块内存的入口函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">ngx_int_t</span> <span class="title">ngx_pfree</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span>     <span class="comment">// 内存池释放大块内存的入口函数</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="内存池的底层设计"><a href="#内存池的底层设计" class="headerlink" title="内存池的底层设计"></a>内存池的底层设计</h3><p>Nginx 中所有请求都单独对应一个内存池，在这个请求的过程中，所有涉及到内存分配的地方，都到该请求相关的内存池中处理，而中间不会去释放内存，内存池的生命周期与请求一样，请求完毕则直接回收内存。这样的好处在于：统一分配和统一释放，降低了内存泄露问题的出现。Nginx 的内存池设计分为两个部分：</p><ul><li>大块内存：超过 <code>max</code> 大小（默认 4095 字节）的内存分配，走大块内存分配，这部分内存管理由 <code>ngx_pool_large_t</code> 结构体负责。</li><li>小块内存：在 <code>ngx_pool_t</code> 链表中遍历符合要求的 <code>ngx_pool_t</code> 结构体，找到符合要求大小的 <code>pool</code> 直接返回，否则就申请新的小块内存 <code>pool</code>。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>小块内存在分配后不会被单独释放，而是在整个内存池销毁（<code>ngx_destroy_pool()</code>）时，通过 <code>free()</code> 一次性释放。</li><li>大块内存会在整个内存池重置（<code>ngx_reset_pool()</code>）或者整个内存池销毁（<code>ngx_destroy_pool()</code>）时被 <code>free()</code> 释放，但还可以手动调用 <code>ngx_pfree()</code> 单独释放。</li><li>小块内存的重用机制：Nginx 也有机制尝试在链表中查找可用内存块（并非永远只分配不回收），但它不做碎片整理或回收，只是简单地继续分配新的小块内存。</li></ul></div><h4 id="内存池结构设计"><a href="#内存池结构设计" class="headerlink" title="内存池结构设计"></a>内存池结构设计</h4><p>Nginx 采用内存池的结构设计来管理内存，而内存池是由若干固定大小的内存块组成的单向链表（如下图所示）。从图中可以看出来，内存池的头结点维护着内存池的总体信息，从头结点开始，可以访问内存池的小块内存（单向链表，由 <code>ngx_pool_data_t</code> 结构特维护），大块内存（单向链表，由 <code>ngx_pool_large_t</code> 结构特维护），以及抽象内存数据（单向链表，由 <code>ngx_pool_chain_t</code> 结构体维护）。</p><p><img data-src="../../../asset/2025/04/nginx-memory-4.png"></p><h4 id="ngx-pool-data-t"><a href="#ngx-pool-data-t" class="headerlink" title="ngx_pool_data_t"></a>ngx_pool_data_t</h4><p><code>ngx_pool_data_t</code> 结构体负责存储每个 <code>ngx_pool_t</code> 结构体的元数据：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">   u_char               *last;      <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">   u_char               *end;       <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">   <span class="keyword">ngx_pool_t</span>           *next;      <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">   <span class="keyword">ngx_uint_t</span>            failed;    <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">} <span class="keyword">ngx_pool_data_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/04/nginx-memory-pool-1.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p><code>failed</code> 成员的引入是为了避免某个 <code>pool</code> 虽然还有可用的内存空间，但是由于内存空间很小了，导致经常性的分配内存空间失败，当累计失败的次数达到某个阈值时，下一次再次查找内存就直接跳过这个 <code>pool</code>，直接去寻找内存池链表中的下一个 <code>pool</code>。在 <code>ngx_pool_s</code> 结构体中，<code>current</code> 指针会随着 <code>failed</code> 的增加而发生改变，如果 <code>current</code> 指向的内存池的 <code>failed</code> 达到了 <code>4</code> 的话，<code>current</code> 就会指向下一个内存池。</p></div><h4 id="ngx-pool-large-t"><a href="#ngx-pool-large-t" class="headerlink" title="ngx_pool_large_t"></a>ngx_pool_large_t</h4><p><code>ngx_pool_large_t</code> 结构体用于存储大内存块，这一块就比较简单粗暴了，直接调用 <code>malloc()</code> 分配一块大内存来使用，多个大内存块之间也是以链表形式来组织数据。正常情况下，这些大块内存会在整个内存池销毁时统一释放，比如在请求处理完毕后、连接断开后、Worker 进程（子进程）退出后会释放大块内存。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">   <span class="keyword">ngx_pool_large_t</span>     *next;      <span class="comment">// 下一个大块内存</span></span><br><span class="line">   <span class="keyword">void</span>                 *alloc;     <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>大块内存的分配请求不会直接在内存池上分配内存来满足，而是直接向操作系统申请一大块内存（底层直接调用 <code>malloc()</code> 分配内存），然后将这块内存挂到内存池头部的 <code>large</code> 指针下。内存池的作用在于解决小块内存池的频繁申请问题，对于这种大块内存，是可以忍受直接申请的。为什么大块内存分配后是挂在链表头部而不是尾部呢？根据程序局部性原理，最近分配的内存一般经常使用，挂在头部可以提高空闲内存块的查找效率。</p></div><h4 id="ngx-pool-t"><a href="#ngx-pool-t" class="headerlink" title="ngx_pool_t"></a>ngx_pool_t</h4><p><code>ngx_pool_t</code> 结构体用于表示一个内存池，内存池的内部以链表形式来组织数据。如下图：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;         <span class="comment">// 小块内存池的数据头</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;       <span class="comment">// 小块内存分配的最大值</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;   <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;     <span class="comment">// 该指针挂接一个 ngx_chain_t 结构</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;     <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;   <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *log;       <span class="comment">// 内存分配相关的日志记录</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/04/nginx-memory-pool-2.png"></p><p>需要注意的是：</p><ul><li>内存池内部以链表形式组织起来的，完成这个工作的就是前面的 <code>ngx_pool_data_t</code> 结构体的 <code>next</code> 成员。</li><li><code>current</code> 指针，用于表示当前该内存池在使用的 <code>pool</code> 指针。除了内存池链表的头结点之外，内存池链表其他节点的该指针无效。之所以需要这个指针，就是前面提到的，在某个内存池多次失效的情况下，下一次直接跳过该内存池查找内存空间，<code>current</code> 指针保存当前在内存池链表的哪一个内存池上面查找内存空间。</li><li><code>large</code> 指针，指向 <code>ngx_pool_large_t</code> 结构体，用于管理大块内存。</li></ul><h3 id="内存池的工作原理"><a href="#内存池的工作原理" class="headerlink" title="内存池的工作原理"></a>内存池的工作原理</h3><h4 id="内存池的创建"><a href="#内存池的创建" class="headerlink" title="内存池的创建"></a>内存池的创建</h4><ul><li>经过测试，Nginx 会为每个 Http 连接（Connection）创建大小为 <code>256</code> 字节的 <code>pool</code>，为每个请求（Request）创建大小为 <code>4096</code> 的 <code>pool</code>。</li><li>当客户端使用长连接向服务器请求资源时，Nginx 处理完 Request 后会释放 Request 对应的 <code>pool</code>，但不会立即释放 Connection 对应的 <code>pool</code>，而是等连接超时后再释放。</li><li>在一次简单的会话中（比如请求首页），从连接建立到连接关闭，至少有约 30 次的内存分配（调用 <code>ngx_palloc()</code>）。</li></ul><h4 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h4><ul><li><p><strong>小块内存的分配</strong></p><ul><li>对于小块内存的分配，Nginx 会首先尝试在当前小块内存池中查找是否存在足够的空闲内存空间。</li><li>如果当前小块内存池的可用内存不足以满足需求，Nginx 会尝试遍历该小块内存池的链表（即多个小块内存池），寻找可用的内存空间。</li><li>如果仍然找不到可用的内存空间，则会创建一个新的小块内存块，并将其添加到该小块内存池链表的尾部。</li><li><strong>小块内存的分配是按顺序进行的，不会进行回收，因此分配效率很高，适合频繁分配和释放内存的场景（比如 Web 服务器处理大量短连接）。</strong></li></ul></li><li><p><strong>大块内存的分配</strong></p><ul><li>对于大块内存的分配，当分配的内存大小超过小块内存分配的阈值（一般是 <code>4095</code> 字节，根据平台决定），Nginx 会直接调用 <code>malloc()</code> 申请一块大内存，并将该大块内存封装成一个 <code>ngx_pool_large_t</code> 节点，挂载到内存池的大块内存链表的头部。</li><li>这类内存块比较大、分配成本比较高，通常用于缓存大数据或模块中临时需要的较大资源。</li><li>由于<strong>小块内存使用的是顺序分配模型，而大块内存是从系统申请分配的</strong>，因此两者的管理方式不同，但最终都会在内存池销毁时（比如处理完 HTTP 请求、HTTP 连接关闭等）统一释放，确保资源不会泄漏。</li></ul></li></ul><h4 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h4><p>Nginx 从内存池分配内存的流程如下图所示：</p><p><img data-src="../../../asset/2025/04/nginx-memory-pool-3.png"></p><h4 id="内存池的销毁"><a href="#内存池的销毁" class="headerlink" title="内存池的销毁"></a>内存池的销毁</h4><ul><li><p>一个 Web Server 通常会持续不断地接收 Connection 和 Request，因此 Nginx 将内存池划分为不同的层级，包括进程级内存池、Connection 级内存池以及 Request 级内存池。具体来说，当创建一个 Worker 进程时，系统会为该 Worker 分配一个独立的内存池；当有新的 Connection 到来时，又会在该 Worker 的内存池基础上为该 Connection 分配一个新的内存池；当该 Connection 上接收到一个新的 Request 时，再在 Connection 的内存池中为该 Request 创建一个新的内存池。</p></li><li><p>这种分层次的内存池管理方式，使得在处理完一个 Request 后，可以一次性释放该 Request 的整个内存池；当 Connection 关闭时，可以释放该 Connection 对应的内存池；而当 Worker 进程退出时，其对应的内存池也会整体释放。通过这种机制，确保了内存既有分配，也能及时回收，避免了内存泄漏的问题。</p></li><li><p>从内存的分配与释放策略可以看出，Nginx 内存池的核心作用在于将多个小块内存的分配操作集中处理，并在适当的时机统一释放，从而避免频繁的小内存申请，降低内存碎片的产生，提升了系统的内存管理效率和性能。</p></li></ul><h3 id="内存池的源码测试"><a href="#内存池的源码测试" class="headerlink" title="内存池的源码测试"></a>内存池的源码测试</h3><p>这里将介绍如何编写代码测试 Nginx 内存池的 <code>ngx_destroy_pool()</code> 接口，并编译运行自定义的测代码。</p><h4 id="编译-Nginx-源码"><a href="#编译-Nginx-源码" class="headerlink" title="编译 Nginx 源码"></a>编译 Nginx 源码</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://nginx.org/download/nginx-1.12.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf nginx-1.12.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j4</span><br></pre></td></tr></tbody></table></figure><h4 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h4><p>在 Nginx 的源码目录下（比如 <code>nginx-1.12.2</code>），创建 C 源文件 <code>ngx_testpool.c</code>，其测试代码的内容如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nginx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_palloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误日志处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_log_error_core</span> <span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">stData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> {</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc1</span> <span class="params">(<span class="keyword">char</span> *p)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"free ptr mem!\n"</span>);</span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc2</span> <span class="params">(FILE *pf)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"close file!\n"</span>);</span><br><span class="line">    fclose (pf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span> *pool = ngx_create_pool (<span class="number">512</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_create_pool fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小块内存池分配内存</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = ngx_palloc (pool, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_palloc 128 bytes fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大块内存池分配内存</span></span><br><span class="line">    stData *p2 = ngx_palloc (pool, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_palloc 512 bytes fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p2-&gt;ptr = <span class="built_in">malloc</span> (<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (p2-&gt;ptr, <span class="string">"hello world"</span>);</span><br><span class="line">    p2-&gt;pfile = fopen (<span class="string">"data.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span> *c1 = ngx_pool_cleanup_add (pool, <span class="keyword">sizeof</span> (<span class="keyword">char</span> *));</span><br><span class="line">    c1-&gt;handler = cleanFunc1;</span><br><span class="line">    c1-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span> *c2 = ngx_pool_cleanup_add (pool, <span class="keyword">sizeof</span> (FILE *));</span><br><span class="line">    c2-&gt;handler = cleanFunc2;</span><br><span class="line">    c2-&gt;data = p2-&gt;pfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁内存池，步骤：(1) 调用所有的预置的清理函数 (2) 释放所有大块内存 (3) 释放小块内存池所有内存</span></span><br><span class="line">    ngx_destroy_pool (pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="运行测试代码"><a href="#运行测试代码" class="headerlink" title="运行测试代码"></a>运行测试代码</h4><ul><li>编译测试代码 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译测试代码（生成目标文件）</span></span><br><span class="line">gcc -c -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules -o ngx_testpool.o  ngx_testpool.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接测试代码（生成可执行文件）</span></span><br><span class="line">gcc -o ngx_testpool ngx_testpool.o objs/src/core/ngx_palloc.o objs/src/os/unix/ngx_alloc.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行文件</span></span><br><span class="line">./ngx_testpool</span><br></pre></td></tr></tbody></table></figure><ul><li>测试代码运行的输出结果 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close file!</span><br><span class="line">free ptr mem!</span><br></pre></td></tr></tbody></table></figure><h3 id="内存池的源码移植"><a href="#内存池的源码移植" class="headerlink" title="内存池的源码移植"></a>内存池的源码移植</h3><p>这里将介绍如何基于 C++ 11 移植 Nginx 内存池的核心源码，其中移植的代码主要位于 Nginx（版本是 <code>1.12.2</code>）的 <code>ngx_palloc.h</code> 和 <code>ngx_palloc.c</code> 源文件中。</p><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><ul><li><code>ngx_mem_pool.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值 d 调整为临近数值 a 的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align (d, a) (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值 p 调整为临近数值 a 的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr (p, a) (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的内存全部初始化为 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memzero (buf, n) (void) memset (buf, 0, n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> u_char = <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ngx_uint_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理函数（回调函数）的类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理操作的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> {</span></span><br><span class="line">    ngx_pool_cleanup_pt handler;     <span class="comment">// 函数指针，指向内存清理操作的回调函数</span></span><br><span class="line">    <span class="keyword">void</span> *data;                      <span class="comment">// 传递给回调函数的参数</span></span><br><span class="line">    ngx_pool_cleanup_s *next;        <span class="comment">// 下一个清理函数，最终形成单向链表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大块内存的内存池的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">    ngx_pool_large_s *next;      <span class="comment">// 下一个大块内存，最终形成单向链表</span></span><br><span class="line">    <span class="keyword">void</span> *alloc;                 <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存的内存池的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_data_t</span> {</span></span><br><span class="line">    u_char *last;           <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">    u_char *end;            <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">    ngx_pool_s *next;       <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span> failed;      <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池的主结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span> d;              <span class="comment">// 小块内存池的头部信息</span></span><br><span class="line">    <span class="keyword">size_t</span> max;                     <span class="comment">// 小块内存分配的最大空间</span></span><br><span class="line">    ngx_pool_s *current;            <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    ngx_pool_large_s *large;        <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    ngx_pool_cleanup_s *cleanup;    <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个物理页面的默认大小（4KB）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_PAGESIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// 小块内存可分配的最大空间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MAX_ALLOC_FROM_POOL = NGX_PAGESIZE - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 内存池的默认初始大小（16KB）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_DEFAULT_POOL_SIZE = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// 内存池分配时的对齐字节数（16 字节）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_POOL_ALIGNMENT = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 小块内存的最小可接受大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MIN_POOL_SIZE = <span class="built_in">ngx_align</span> ((<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s) + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_large_s)), NGX_POOL_ALIGNMENT);</span><br><span class="line"><span class="comment">// 小块内存分配时的对齐字节数，通常是 4 字节（32 位系统）或者 8 字节（64 位系统）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_ALIGNMENT = <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ngx_mem_pool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span> (<span class="keyword">int</span> size = NGX_DEFAULT_POOL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ngx_mem_pool</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span> (<span class="keyword">const</span> ngx_mem_pool &amp;pool) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ngx_mem_pool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ngx_mem_pool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 从内存池中申请指定大小的内存，并考虑内存字节对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内存池中申请指定大小的内存，不考虑内存字节对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_pnalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 ngx_palloc 实现内存分配，并将内存初始化为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_pcalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_pfree</span> <span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作（回调）函数</span></span><br><span class="line">    <span class="function">ngx_pool_cleanup_s *<span class="title">ngx_pool_cleanup_add</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 创建指定大小的内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配小块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_small</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配大块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_large</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的小块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_block</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指向内存池的入口指针</span></span><br><span class="line">    ngx_pool_s *_pool;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ngx_mem_pool.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ngx_mem_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ngx_mem_pool::<span class="built_in">ngx_mem_pool</span> (<span class="keyword">int</span> size) {</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">ngx_create_pool</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (_pool == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span> (<span class="string">"create memory pool fail..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ngx_mem_pool::~<span class="built_in">ngx_mem_pool</span> () {</span><br><span class="line">    <span class="comment">// 销毁内存池</span></span><br><span class="line">    <span class="keyword">if</span> (_pool != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">ngx_destroy_pool</span> ();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定大小的内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt; NGX_MIN_POOL_SIZE) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"create memory pool fail, pool size too small"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存空间</span></span><br><span class="line">    _pool = (ngx_pool_s *) <span class="built_in">malloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (_pool == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小块内存池的头部信息</span></span><br><span class="line">    _pool-&gt;d.last = (u_char *) _pool + <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    _pool-&gt;d.end = (u_char *) _pool + size;</span><br><span class="line">    _pool-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    _pool-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小块内存分配的最大空间</span></span><br><span class="line">    size = size - <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    _pool-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    _pool-&gt;current = _pool;</span><br><span class="line">    _pool-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">    _pool-&gt;cleanup = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _pool;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内存池中申请指定大小的内存，并考虑内存字节对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="keyword">this</span>-&gt;_pool-&gt;max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span> (size, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内存池中申请指定大小的内存，不考虑内存字节对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_pnalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="keyword">this</span>-&gt;_pool-&gt;max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span> (size, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ngx_palloc 实现内存分配，并将内存初始化为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_pcalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">ngx_palloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (p) {</span><br><span class="line">        <span class="built_in">ngx_memzero</span> (p, size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配小块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_small</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span> </span>{</span><br><span class="line">    u_char *m;</span><br><span class="line">    ngx_pool_s *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">this</span>-&gt;_pool-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历小块内存池链表，查找有可用空间的小块内存</span></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (align) {</span><br><span class="line">            m = <span class="built_in">ngx_align_ptr</span> (m, NGX_ALIGNMENT);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) {</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当找不到有可用空间的小块内存，则直接分配新的小块内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_block</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配大块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_large</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span> n;</span><br><span class="line">    ngx_pool_large_s *large;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的大块内存</span></span><br><span class="line">    p = <span class="built_in">malloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历大块内存池链表，将新的大块内存添加到链表中</span></span><br><span class="line">    <span class="keyword">for</span> (large = <span class="keyword">this</span>-&gt;_pool-&gt;large; large; large = large-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">nullptr</span>) {</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    large = (ngx_pool_large_s *) <span class="built_in">ngx_palloc_small</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_large_s), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">free</span> (p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = <span class="keyword">this</span>-&gt;_pool-&gt;large;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配新的小块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_block</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    u_char *m;</span><br><span class="line">    <span class="keyword">size_t</span> psize;</span><br><span class="line">    ngx_pool_s *p, *_new;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的小块内存的大小</span></span><br><span class="line">    psize = (<span class="keyword">size_t</span>) (<span class="keyword">this</span>-&gt;_pool-&gt;d.end - (u_char *) <span class="keyword">this</span>-&gt;_pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的小块内存</span></span><br><span class="line">    m = (u_char *) <span class="built_in">malloc</span> (psize);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    _new = (ngx_pool_s *) m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的小块内存的头部信息</span></span><br><span class="line">    _new-&gt;d.end = m + psize;</span><br><span class="line">    _new-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    _new-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = <span class="built_in">ngx_align_ptr</span> (m, NGX_ALIGNMENT);</span><br><span class="line">    _new-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="keyword">this</span>-&gt;_pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) {</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p-&gt;d.next = _new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放大块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_pfree</span> <span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_reset_pool</span> <span class="params">()</span> </span>{</span><br><span class="line">    ngx_pool_s *p;</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置小块内存池链表中的第一块内存，实现后续小块内存的复用</span></span><br><span class="line">    p = <span class="keyword">this</span>-&gt;_pool;</span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置小块内存池链表中的第二块到最后一块内存，实现后续小块内存的复用</span></span><br><span class="line">    <span class="keyword">for</span> (p = p-&gt;d.next; p; p = p-&gt;d.next) {</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;current = <span class="keyword">this</span>-&gt;_pool;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_destroy_pool</span> <span class="params">()</span> </span>{</span><br><span class="line">    ngx_pool_s *p, *n;</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line">    ngx_pool_cleanup_s *c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用所有清理操作（回调）函数</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="keyword">this</span>-&gt;_pool-&gt;cleanup; c; c = c-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) {</span><br><span class="line">            c-&gt;<span class="built_in">handler</span> (c-&gt;data);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放小块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="keyword">this</span>-&gt;_pool, n = <span class="keyword">this</span>-&gt;_pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) {</span><br><span class="line">        <span class="built_in">free</span> (p);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加资源清理操作（回调）函数</span></span><br><span class="line"><span class="function">ngx_pool_cleanup_s *<span class="title">ngx_mem_pool::ngx_pool_cleanup_add</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    ngx_pool_cleanup_s *c;</span><br><span class="line"></span><br><span class="line">    c = (ngx_pool_cleanup_s *) <span class="built_in">ngx_palloc</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_cleanup_s));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) {</span><br><span class="line">        c-&gt;data = <span class="built_in">ngx_palloc</span> (size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        c-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到资源清理操作链表中（头插法）</span></span><br><span class="line">    c-&gt;next = <span class="keyword">this</span>-&gt;_pool-&gt;cleanup;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ngx_mem_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> {</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc1</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) arg;</span><br><span class="line">    cout &lt;&lt; <span class="string">"free ptr memory!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc2</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">    FILE *p = (FILE *) arg;</span><br><span class="line">    cout &lt;&lt; <span class="string">"close file!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">fclose</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="function">unique_ptr&lt;ngx_mem_pool&gt; <span class="title">pool</span> <span class="params">(<span class="keyword">new</span> ngx_mem_pool (<span class="number">256</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小块内存池分配内存</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = pool-&gt;<span class="built_in">ngx_palloc</span> (<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"ngx_palloc 128 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大块内存池分配内存</span></span><br><span class="line">    Data *p2 = (Data *) pool-&gt;<span class="built_in">ngx_palloc</span> (<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"ngx_palloc 512 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p2-&gt;ptr = (<span class="keyword">char</span> *) <span class="built_in">malloc</span> (<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2-&gt;ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"malloc 12 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span> (p2-&gt;ptr, <span class="string">"hello world"</span>);</span><br><span class="line">    p2-&gt;pfile = <span class="built_in">fopen</span> (<span class="string">"data.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    ngx_pool_cleanup_s *c1 = pool-&gt;<span class="built_in">ngx_pool_cleanup_add</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">char</span> *));</span><br><span class="line">    c1-&gt;handler = cleanFunc1;</span><br><span class="line">    c1-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    ngx_pool_cleanup_s *c2 = pool-&gt;<span class="built_in">ngx_pool_cleanup_add</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (FILE *));</span><br><span class="line">    c2-&gt;handler = cleanFunc2;</span><br><span class="line">    c2-&gt;data = p2-&gt;pfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存池由智能指针管理，程序运行结束后会自动销毁内存池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close file!</span><br><span class="line">free ptr memory!</span><br></pre></td></tr></tbody></table></figure><h4 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h4><p>Nginx 内存池移植后的完整案例代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-nginx-memory-pool">这里</a> 下载得到。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><blockquote><p>Nginx 为什么要进行内存管理？</p></blockquote><ul><li><p>Nginx 作为高性能 Web 服务器，在各个环节都必须考虑如何提高性能的问题，比如使用 <code>malloc()</code> 申请内存是很耗时的，这时候就需要优化内存的分配。</p></li><li><p>在使用系统的 <code>malloc()</code> 和 <code>free()</code> 面临几个问题：Web 服务器对内存的需求有大有小，系统运行久了会产生大量的内存碎片，最终造成内存操作更加耗时直到无可用内存，导致服务器宕机。</p></li></ul><blockquote><p>Nginx 如何进行内存管理？</p></blockquote><ul><li><p>Nginx 首先将内存池进行分级管理：包括进程级、连接级和请求级三个层次；随后再根据内存使用情况的不同，将内存池细分为三类：小块内存、大块内存以及自定义资源内存。</p></li><li><p>进程级内存池在通过 <code>Fork()</code> 创建 Worker 子进程时完成初始化。由于 <code>Fork()</code> 会复制父进程的数据段和堆栈段，因此每个子进程拥有独立的内存空间。根据 Web Server 的运行特点，当客户端建立连接时，会在函数 <code>void ngx_event_accept (ngx_event_t *ev)</code> 中创建连接级的内存池；当客户端发起请求时，会在函数 <code>void ngx_http_init_connection (ngx_connection_t *c)</code> 中创建请求级的内存池。</p></li><li><p>在处理 HTTP 请求的过程中，所有与该请求相关的内存分配操作都在对应连接的内存池中完成。根据实际需要的内存大小及资源类型，Nginx 会采用不同的分配策略：对于较小的内存块，采用顺序分配以提高效率；对于较大的内存块或特殊资源，则使用独立分配方式以便于管理。</p></li><li><p>当请求处理完成后，请求级的内存池会被整体释放；当连接超时或者断开时，连接级的内存池随之释放；当进程退出时，系统会释放进程占用的全部内存池资源。通过这种分级且分类型的内存管理机制，Nginx 有效提升了内存分配效率，降低了内存碎片率，同时确保了资源的可控释放和系统的高性能运行。</p></li></ul><blockquote><p>Nginx 的内存管理解决了哪些问题？</p></blockquote><ul><li><strong>简化了内存操作</strong>：程序员不必担心何时释放内存，当连接释放时，就回收该连接对应的内存池。</li><li><strong>避免了内存碎片</strong>：从外部内存碎片来看，采用一次性申请一个内存页，避免了外部内存碎片；从内部内存碎片来看，对大小内存申请分别管理，提高了内存利用率，避免了内部内存碎片。</li><li><strong>避免了内存泄露</strong>：在同一内存池上进行内存申请和回收，当连接关闭后，不存在没有被回收的内存，即可以避免内存泄漏问题。</li><li><strong>提高了内存访问效率</strong>：充分利用程序局部性原理，结合内存对齐和内存分页机制，有效提高了 CPU 访存的 Cache 命中率。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.kancloud.cn/digest/understandingnginx/202588">Nginx 内存池管理详解</a></li><li><a href="https://www.cnblogs.com/didiaoxiong/p/nginx_memory.html">Nginx 1.4.0 内存管理详解</a></li><li><a href="https://heapdump.cn/article/4444830">Nginx 内存分配与释放 — 堆 (内存池) 源码与原理</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Nginx 内存池的底层源码。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="源码剖析" scheme="https://www.techgrow.cn/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>C++ 算法入门教程之一</title>
    <link href="https://www.techgrow.cn/posts/73b8af5d.html"/>
    <id>https://www.techgrow.cn/posts/73b8af5d.html</id>
    <published>2025-04-07T13:55:33.000Z</published>
    <updated>2025-04-07T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大数的加减法"><a href="#大数的加减法" class="headerlink" title="大数的加减法"></a>大数的加减法</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/mrqiuwen/article/details/127057549">C++ 实现大数加减法</a></li><li><a href="https://zhuanlan.zhihu.com/p/92141234">一文读懂大数加减乘除</a></li><li><a href="https://www.cnblogs.com/hello-nullptr/p/18536106">C++ 大整数相加的实现</a></li><li><a href="https://cloud.tencent.com/developer/article/1818199">大数加减乘除运算总结</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 常用的数据结构与算法。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SGI STL 内存池源码剖析</title>
    <link href="https://www.techgrow.cn/posts/712a574b.html"/>
    <id>https://www.techgrow.cn/posts/712a574b.html</id>
    <published>2025-03-23T13:55:33.000Z</published>
    <updated>2025-03-23T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/712a574b.html">SGI STL 内存池源码剖析</a></li><li><a href="/posts/5bc5018f.html">Nginx 内存池源码剖析</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将剖析 SGI STL 二级空间配置器中的内存池源码，并介绍内存池的底层设计和工作原理，最后移植 SGI STL 内存池的核心源码。值得一提的是，移植后的 C++ 代码兼容 Windows 和 Linux 平台。</p><div class="admonition note"><p class="admonition-title">C++ 常见的池</p><p>在 C++ 中，常见的池有对象池、内存池、连接池、协程池、线程池、进程池。</p></div><span id="more"></span><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><ul><li><a href="../../../downloads/2025/05/sgi-stl.zip">SGI STL 官方源码下载</a></li></ul><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><ul><li><a href="#">《STL 源码剖析》 第二章 - 空间配置器（Allocator）</a></li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>C++ 中的 STL（Standard Template Library）是标准模板库，提供了一组通用的数据结构和算法，如向量（<code>vector</code>）、链表（<code>list</code>）、集合（<code>set</code>）、映射（<code>map</code>）、排序、查找等；基于模板实现，支持泛型编程，代码复用性高、效率也好。</p><h3 id="多种实现"><a href="#多种实现" class="headerlink" title="多种实现"></a>多种实现</h3><p>除了 C++ 自身提供的 STL 之外，常见的第三方 STL（标准模板库）实现有以下几种：</p><ul><li><p><strong>RW STL（Rogue Wave STL）</strong></p><ul><li>开发者：<ul><li>Rogue Wave Software 公司（后被 Perforce 收购）</li></ul></li><li>性质：<ul><li>商业版本的 C++ 标准模板库实现</li></ul></li><li>代表产品：<ul><li>作为 SourcePro C++ 产品的一部分提供（包含 STL、线程库、网络库、数据库访问库等）</li></ul></li><li>产品特点：<ul><li>遵循 ISO C++ 标准</li><li>跨平台，适配多种操作系统和编译器</li><li>提供高级调试、异常安全、多线程支持</li><li>可配置性强，适用于嵌入式和大型系统</li></ul></li><li>应用场景：<ul><li>金融系统、通信系统、嵌入式开发、航空航天、政府项目等对可靠性要求高的场景</li></ul></li></ul></li><li><p><strong> PJ STL（Dinkumware STL）</strong></p><ul><li>开发者：<ul><li>P. J. Plauger（C++ 标准委员会成员），其自己公司 Dinkumware 提供支持</li></ul></li><li>性质：<ul><li>商业版本的 C++ 标准模板库实现</li></ul></li><li>代表使用者：<ul><li>Microsoft Visual C++（尤其是 VC++ 6 及后续版本）默认使用 PJ STL</li></ul></li><li> 特点：<ul><li>遵循 ISO C++ 标准</li><li>接口稳定、实现清晰，强调工程实用性</li><li>提供 STL、C 标准库（如 <code>&lt;cmath&gt;</code>，<code>&lt;cstdlib&gt;</code>）、TR1 和部分 C++ 11 / 14 特性</li></ul></li><li>优势：<ul><li>商业支持</li><li>与微软编译器深度集成</li><li>重视可移植性和性能</li></ul></li><li>局限：<ul><li>并非开源，文档和源代码可见性有限</li></ul></li></ul></li><li><p><strong> HP STL（Hewlett-Packard STL）</strong></p><ul><li>开发者：<ul><li>Hewlett-Packard 公司（惠普实验室），由 Alexander Stepanov 及其团队在 HP（惠普）初步实现</li></ul></li><li>性质：<ul><li>STL 的原始实现，是 SGI STL 的前身</li></ul></li><li>历史意义：<ul><li>1994 年 Stepanov 在 HP Labs（惠普实验室）首次实现 STL，随后向 C++ 标准委员会提交</li><li>后由 SGI 改进并推广形成 SGI STL，逐渐成为业界学习模板编程的典范</li></ul></li><li>特点：<ul><li>结构清晰，贴近标准草案</li><li>强调通用算法和迭代器的分离设计</li><li>奠定了 STL 的基础架构，如容器、迭代器、算法的三大支柱</li></ul></li><li>应用与影响：<ul><li>虽然未被广泛部署于实际商业编译器中，但在学术界和标准委员会中具有开创性意义</li><li>是理解 STL 起源与设计哲学的关键资料</li></ul></li><li>现状：<ul><li>已不再维护，但源码与设计理念在 SGI STL 中得以继承和发扬</li></ul></li></ul></li><li><p><strong> SGI STL（Silicon Graphics STL）</strong></p><ul><li>开发者：<ul><li>Alexander Stepanov（STL 之父）、Meng Lee 等人在 SGI（Silicon Graphics Inc.）公司开发</li></ul></li><li>性质：<ul><li>最早公开发布的 STL 实现之一，并作为学习范例广泛传播</li></ul></li><li>特点：<ul><li>完全开源，源码可读性和学习性极强</li><li>强调泛型编程、模板技巧和性能优化</li><li>提供了 <code>allocator</code>、<code>traits</code>、<code>function object</code>、<code>iterator</code> 等先进设计</li></ul></li><li>贡献：<ul><li>为后来的标准库实现（如 GCC 的 libstdc++）提供了基础</li><li>推动了 STL 的工业化、模块化和标准化</li></ul></li><li>现状：<ul><li>虽然已经不再更新，但作为教学和研究材料仍具重要历史价值</li></ul></li></ul></li></ul><blockquote><p>第三方 STL 实现的总结对比表</p></blockquote><table><thead><tr><th>名称</th><th>开发者</th><th>是否开源</th><th>典型应用</th><th>特点描述</th></tr></thead><tbody><tr><td> RW STL</td><td>Rogue Wave Software</td><td>❌ 商业版</td><td>金融、嵌入式、政府、工业系统</td><td>工程化程度高，稳定性强，附带调试与多线程支持，属于 SourcePro C++ 一部分</td></tr><tr><td> PJ STL</td><td>P. J. Plauger / Dinkumware</td><td>❌ 商业版</td><td> Visual C++、商业工具链</td><td>工程稳健，兼容性好，被微软 Visual Studio 多版本采用</td></tr><tr><td> HP STL</td><td>Alexander Stepanov / HP</td><td>✅ 开源</td><td>教育、历史研究、标准演化</td><td> STL 的最早实现版本，设计哲学完整，影响了 SGI STL 和后续标准化进程</td></tr><tr><td> SGI STL</td><td>Alexander Stepanov / SGI</td><td>✅ 开源</td><td>教育、研究、GCC libstdc++ 原型</td><td>泛型编程示范，模板设计前沿，影响广泛</td></tr></tbody></table><h2 id="SGI-STL"><a href="#SGI-STL" class="headerlink" title="SGI STL"></a>SGI STL</h2><h3 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h3><h4 id="SGI-STL-是什么"><a href="#SGI-STL-是什么" class="headerlink" title="SGI STL 是什么"></a>SGI STL 是什么</h4><p>SGI STL 是由 Alexander Stepanov 和 Meng Lee 等人在 SGI（Silicon Graphics Inc.）公司开发的 C++ 标准模板库实现，最早出现在 1990 年代。这个库实现了 STL 的核心思想：泛型编程与容器 - 算法 - 迭代器模型。<strong>SGI STL 包含了一级空间配置器和二级空间配置器，其中一级空间配置器 <code>allocator</code> 采用 <code>malloc()</code> 和 <code>free()</code> 来管理内存，和 C++ 标准模板库（STL）中提供的 <code>allocator</code> 是一样的，但其二级空间配置器 <code>allocator</code> 采用了基于自由链表（Free List）原理的内存池机制来实现内存管理。具体来说，当申请的内存块超过 <code>128</code> 字节时，视之为 “足够大”，会调用一级空间配置器；当申请的内存块小于 <code>128</code> 字节时，视之为 “过小”，会调用二级空间配置器，采用复杂的内存池管理方式，这样可以避免小内存频繁申请和释放导致的内存碎片问题，同时提高效率。</strong></p><div class="admonition warning"><p class="admonition-title">STL 空间配置器的作用</p><ul><li>在 C++ STL 中，空间配置器（<code>allocator</code>）的作用主要有两种：</li><li>(1) 分离了对象的内存开辟（<code>allocate()</code>）和对象的构造（<code>construct()</code>）。</li><li>(2) 分离了对象的析构（<code>destroy()</code>）和对象的内存释放（<code>deallocate()</code>）。</li></ul></div><h4 id="SGI-STL-的主要特性"><a href="#SGI-STL-的主要特性" class="headerlink" title="SGI STL 的主要特性"></a>SGI STL 的主要特性</h4><ul><li>提供了 STL 的主要组件：<code>vector</code>、<code>list</code>、<code>map</code>、<code>set</code>、<code>algorithm</code>、<code>iterator</code> 等。</li><li>包含一些非标准扩展，例如：<ul><li><code>slist</code>（单向链表）</li><li><code>hash_map</code> / <code>hash_set</code>（后来的 <code>unordered_map</code> / <code>unordered_set</code> 的前身）</li></ul></li><li>代码高度模板化、效率高、注释详尽。</li><li>源码开放，很多 C++ 开发者都用它来学习 STL 的底层实现。</li></ul><h4 id="SGI-STL-的历史作用"><a href="#SGI-STL-的历史作用" class="headerlink" title="SGI STL 的历史作用"></a>SGI STL 的历史作用</h4><p>SGI STL 是 现代 C++ STL 的原型，其思想和实现对 C++ 98 标准 STL 的设计有极大影响。许多早期编译器，如 GCC、MSVC、Intel C++，都在某个时期采用过 SGI STL 或其变种（比如 STLport）。</p><div class="admonition note"><p class="admonition-title">今天还需要使用 SGI STL 吗</p><ul><li>通常不需要使用 SGI STL，因为现代 C++ 编译器都自带符合标准的 STL 实现，比如 GCC：libstdc++、Clang：libc++、MSVC：Dinkumware。</li><li>如果是为了学习 STL 的内部实现机制（底层原理），SGI STL 是一个非常好的教学资源；但在生产环境中，应该使用现代 C++ STL（标准模板库）。</li></ul></div><h4 id="SGI-STL-与-C-STL-的区别"><a href="#SGI-STL-与-C-STL-的区别" class="headerlink" title="SGI STL 与 C++ STL 的区别"></a>SGI STL 与 C++ STL 的区别</h4><table><thead><tr><th>项目</th><th> SGI STL</th><th>C++ STL（标准模板库）</th></tr></thead><tbody><tr><td>作者 / 出处</td><td> SGI 公司（如 STLport）</td><td>C++ 标准委员会</td></tr><tr><td>标准性</td><td>非正式实现，非标准的一些扩展</td><td>从 C++ 98 开始，成为标准 C++ 的一部分</td></tr><tr><td>扩展内容</td><td><code>hash_map</code>、<code>slist</code>、<code>rope</code> 等非标准组件</td><td>标准化容器如 <code>vector</code>、<code>deque</code>、<code>map</code>、<code>set</code> 等</td></tr><tr><td>可移植性</td><td>与平台、编译器耦合程度较高</td><td>作为标准模板库，各主流编译器都支持</td></tr><tr><td>现代兼容性</td><td>不支持 C++ 11 及以后的特性</td><td>现代 STL 持续演进（如 <code>move semantics</code>, <code>unordered_map</code>, <code>ranges</code> 等）</td></tr><tr><td>教育价值</td><td>非常适合学习 STL 实现机制</td><td>通常以黑箱方式使用</td></tr></tbody></table><h3 id="自由链表"><a href="#自由链表" class="headerlink" title="自由链表"></a>自由链表</h3><p>这里将介绍 SGI STL 二级空间配置器中自由链表的底层实现。</p><h4 id="自由链表是什么"><a href="#自由链表是什么" class="headerlink" title="自由链表是什么"></a>自由链表是什么</h4><p>自由链表是一种用于管理空闲内存块的链表结构。每个链表节点指向一个未被使用的内存块，便于快速分配和回收。在 SGI STL 的二级空间配置器中，自由链表有以下特点：</p><ul><li>每种固定大小的内存块（如 8 字节、16 字节、24 字节 …）都有一个对应的自由链表。</li><li>小对象内存块的复用：当用户释放内存时，并不会直接 <code>free()</code>，而是将内存放回对应的自由链表中，供后续复用。</li><li>分配内存时，优先从自由链表中取；只有自由链表为空时，才会从系统堆（Heap）分配一大块内存进行切分。</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>数量</td><td> 16 个自由链表（按 8 ~ 128 字节分为 16 类）</td></tr><tr><td>数据结构</td><td><code>union obj</code> 实现链表节点</td></tr><tr><td>分配策略</td><td>优先从自由链表取，否则从堆中批量 <code>refill()</code></td></tr><tr><td>回收策略</td><td>小块内存回收到对应的自由链表，大块内存直接释放</td></tr><tr><td>性能优势</td><td>避免频繁 <code>malloc</code> / <code>free</code>，显著减少内存碎片和内存开辟 / 释放的开销</td></tr></tbody></table><h4 id="自由链表的结构"><a href="#自由链表的结构" class="headerlink" title="自由链表的结构"></a>自由链表的结构</h4><p><img data-src="../../../asset/2025/04/sgi-stl-2.png"></p><h5 id="内存块粒度与分类"><a href="#内存块粒度与分类" class="headerlink" title="内存块粒度与分类"></a>内存块粒度与分类</h5><ul><li>内存块的粒度信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (__SUNPRO_CC) || defined (__GNUC__)</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_ALIGN = <span class="number">8</span>};            <span class="comment">// 小块内存的对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_MAX_BYTES = <span class="number">128</span>};      <span class="comment">// 二级空间配置器最大管理范围（128 字节）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_NFREELISTS = <span class="number">16</span>};      <span class="comment">// 自由链表的数量，计算方式：_MAX_BYTES / _ALIGN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>一共维护 16 个自由链表，每个自由链表负责管理一种字节大小的内存块：</li></ul><table><thead><tr><th>自由链表的下标</th><th>内存块的大小</th></tr></thead><tbody><tr><td> 0</td><td>8 字节</td></tr><tr><td> 1</td><td>16 字节</td></tr><tr><td> 2</td><td>24 字节</td></tr><tr><td>…</td><td>…</td></tr><tr><td>15</td><td>128 字节</td></tr></tbody></table><h5 id="自由链表节点结构"><a href="#自由链表节点结构" class="headerlink" title="自由链表节点结构"></a>自由链表节点结构</h5><ul><li>每个空闲内存块都可以看作是一个 <code>_Obj</code>，其中 <code>_M_free_list_link</code> 用来链接空闲内存块（最终形成自由链表）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span>    <span class="comment">// 下一个内存 chunk 块的地址</span></span><br><span class="line">    <span class="keyword">char</span> _M_client_data [<span class="number">1</span>];          <span class="comment">// 实际分配给用户的内存起始位置</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="自由链表的存储结构"><a href="#自由链表的存储结构" class="headerlink" title="自由链表的存储结构"></a>自由链表的存储结构</h5><ul><li>这个数组保存了每种块大小的链表头指针 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list [_NFREELISTS];  <span class="comment">// 16 个自由链表</span></span><br></pre></td></tr></tbody></table></figure><h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><ul><li>当调用 <code>allocate(n)</code>：<ul><li>如果 <code>n &gt; 128</code>，则交由一级空间配置器处理（直接调用 <code>malloc()</code> 分配内存）。</li><li>否则：<ul><li>(1) 将 <code>n</code> 向上对齐到 8 的倍数（实现内存对齐）。</li><li>(2) 找到对应的自由链表索引。</li><li>(3) 如果该链表非空，从中取一个满足大小的空闲内存块返回。</li><li>(4) 如果链表为空，调用 <code>refill()</code> 从堆上批量分配一大块内存（默认分配 2 x 20 个块），挂到自由链表上。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2025/04/sgi-stl-7.png"></p><h5 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h5><ul><li>当调用 <code>deallocate(p, n)</code>：<ul><li>如果 <code>n &gt; 128</code>，则交由一级空间配置器处理（直接调用 <code>free()</code> 释放内存）。</li><li>否则：<ul><li>(1) 将 <code>n</code> 向上对齐到 8 的倍数（实现内存对齐）。</li><li>(2) 找到对应的自由链表索引。</li><li>(3) 把块头强制转换为 <code>obj*</code>，插入到自由链表的头部（头插法）。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2025/04/sgi-stl-8.png"></p><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><p>在剖析 SGI STL 的内存池源码时，建议以 <code>vector</code> 容器的源码作为切入点，然后一步步分析一级和二级空间配置器的底层实现，如下图所示：</p><p><img data-src="../../../asset/2025/04/sgi-stl-3.png"></p><h4 id="空间配置器的相关定义"><a href="#空间配置器的相关定义" class="headerlink" title="空间配置器的相关定义"></a>空间配置器的相关定义</h4><ul><li><code>vector</code> 容器的定义 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> __STL_DEFAULT_ALLOCATOR (_Tp) &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> :</span> <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt; { }</span><br></pre></td></tr></tbody></table></figure><ul><li><code>vector</code> 容器的默认空间配置器是 <code>__STL_DEFAULT_ALLOCATOR ( _Tp)</code>，它是一个宏定义，如下：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __STL_DEFAULT_ALLOCATOR</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR (T) allocator<span class="meta-string">&lt; T &gt;</span>   <span class="comment">// 使用标准 STL allocator（一级空间配置器）</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR (T) alloc            <span class="comment">// 使用 SGI alloc（二级空间配置器）</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>从上面可以看到 <code>__STL_DEFAULT_ALLOCATOR</code> 通过宏控制有两种空间配置器实现，一种是 <code>allocator&lt;T&gt;</code>，另一种是 <code>alloc</code>，这两种分别就是 SGI STL 的一级空间配置器和二级空间配置器的实现 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span>           // 一级空间配置器内存管理类（底层通过 <span class="title">malloc</span> 和 <span class="title">free</span> 管理内存）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> {</span> }      <span class="comment">// 二级空间配置器内存管理类（底层通过自定义内存池实现内存管理）</span></span><br></pre></td></tr></tbody></table></figure><ul><li>SGI STL 的一级和二级空间配置器对比</li></ul><table><thead><tr><th>类型</th><th>实现类</th><th>内存管理机制</th><th>用途</th><th>源码位置</th></tr></thead><tbody><tr><td>一级空间配置器</td><td><code>__malloc_alloc_template</code></td><td><code>malloc() / free()</code></td><td>分配大块内存</td><td>定义在 <code>stl_alloc.h</code> 头文件，<a href="../../../asset/2025/04/sgi-stl-4.png">如图所示</a></td></tr><tr><td>二级空间配置器</td><td><code>__default_alloc_template</code></td><td>内存池机制</td><td>分配小块内存，其核心机制就是使用一组自由链表（Free List）来管理内存块，提高小对象（小于等于 128 字节）的内存分配效率，底层也是使用 <code>malloc() / free()</code> 分配和释放内存</td><td>定义在 <code>stl_alloc.h</code> 头文件，<a href="../../../asset/2025/04/sgi-stl-5.png">如图所示</a></td></tr></tbody></table><div class="admonition note"><p class="admonition-title">SGI STL 默认的空间配置器</p><p>从上面的 <code>vector</code> 容器源码可以发现，SGI STL 的每一个容器都已经指定其缺省的空间配置器为 <code>alloc</code>，即默认使用的是二级空间配置器 <code>__default_alloc_template</code>。</p></div><h4 id="重要类型和变量的定义"><a href="#重要类型和变量的定义" class="headerlink" title="重要类型和变量的定义"></a>重要类型和变量的定义</h4><p>在 SGI STL 的二级空间配置器（<code>__default_alloc_template</code>）中，有以下重要类型和变量定义，其底层的自由链表节点结构如下图所示：</p><p><img data-src="../../../asset/2025/04/sgi-stl-1.png"></p><ul><li>内存池的粒度信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (__SUNPRO_CC) || defined (__GNUC__)</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_ALIGN = <span class="number">8</span>};            <span class="comment">// 小块内存的对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_MAX_BYTES = <span class="number">128</span>};      <span class="comment">// 小块内存的最大字节数（128 字节）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_NFREELISTS = <span class="number">16</span>};      <span class="comment">// 自由链表的数量，计算方式：_MAX_BYTES / _ALIGN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>每一个内存 chunk 块的头信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span>     <span class="comment">// 下一个内存 chunk 块的地址</span></span><br><span class="line">    <span class="keyword">char</span> _M_client_data [<span class="number">1</span>];           <span class="comment">// 实际分配给用户的内存起始位置</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>组织所有自由链表的数组，数组的每一个元素的类型都是 <code>_Obj*</code>，全部初始化为 <code>0</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list [_NFREELISTS]; </span><br></pre></td></tr></tbody></table></figure><ul><li>记录内存 chunk 块的分配情况 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chunk allocation state.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="重要的辅助接口函数"><a href="#重要的辅助接口函数" class="headerlink" title="重要的辅助接口函数"></a>重要的辅助接口函数</h4><ul><li>将 <code>__bytes</code> 上调至最邻近的 8 的倍数（实现内存对齐）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up (<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>返回 <code>__bytes</code> 大小的 chunk 块位于自由链表数组中的索引 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index (<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理核心函数"><a href="#内存池管理核心函数" class="headerlink" title="内存池管理核心函数"></a>内存池管理核心函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配内存的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span> <span class="params">(<span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配新的 chunk 块，并将分配好的 chunk 块进行连接，添加到自由链表当中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* _S_refill (<span class="keyword">size_t</span> __n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配相应内存字节大小的 chunk 块</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc (<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 chunk 块归还到内存池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span> <span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池扩容/缩容函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span> <span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理总结说明"><a href="#内存池管理总结说明" class="headerlink" title="内存池管理总结说明"></a>内存池管理总结说明</h4><blockquote><p>SGI STL 对内存分配和内存释放的设计哲学</p></blockquote><ul><li>向 System Heap 要内存空间。</li><li>考虑多线程（Multi Threads）状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多 “小型区块内存” 可能造成的内存碎片（Fragment）问题</li></ul><blockquote><p>SGI STL 二级空间配置器中内存池的优点</p></blockquote><ul><li><p><strong>内存分配具有预留机制</strong></p><ul><li>对于每种特定字节大小的 chunk（内存块）分配，内存池并不会仅分配刚好所需的内存，而是会一次性申请较大一块内存，并将其划分为多个 chunk（比如 40 个）。其中一部分（20 个 chunk）立即用于分配，另一部分（20 个 chunk）作为备用，供后续相同字节大小的分配请求使用。更重要的是，如果其他字节大小的 chunk 分配失败，这部分备用内存也有可能被重新划分后用于其他字节大小的 chunk 分配请求，从而提升内存使用的灵活性与效率。</li></ul></li><li><p><strong>最大化利用碎片内存</strong></p><ul><li>在将一大块备用内存划分为若干 chunk 后，可能会剩下一小部分无法完整划分的内存碎片。SGI STL 会在后续分配中尽可能再次利用这些内存碎片，避免资源浪费，确保备用内存池被 “用得干干净净”。</li></ul></li><li><p><strong>具有健壮的回退机制</strong></p><ul><li>当某一特定字节大小的内存块分配失败时，二级空间配置器会遍历所有字节大小的自由链表，查找是否有可用的空闲 chunk 块可暂时 “借用”。如果发现其他链表中有满足需求的空闲 chunk 块，就会将其临时分配出去，以缓解当前内存分配压力。如果其他链表中没有满足需求的空闲 chunk 块可以借用，就会直接调用 <code>malloc()</code> 继续分配内存空间。</li></ul></li><li><p><strong>支持 OOM 回调机制</strong></p><ul><li>如果其他自由链表中没有空闲的 chunk 块可以借用，且调用 <code>malloc()</code> 分配内存失败，那么二级空间配置器将尝试调用用户预设的 <code>oom_handler</code> 回调函数（可以用于释放用户自定义的内存资源），以应对 <code>malloc()</code> 执行失败的情况（在死循环中处理）。若用户未设置 <code>oom_handler</code> 回调函数，则直接抛出 OOM（Out Of Memory）异常，提示内存分配失败，确保程序行为的可控性和安全性。</li></ul></li></ul><blockquote><p>SGI STL 一级和二级空间配置器的关系</p></blockquote><p><img data-src="../../../asset/2025/04/sgi-stl-9.png"></p><blockquote><p>SGI STL 内存池的的核心源码文件</p></blockquote><p><img data-src="../../../asset/2025/04/sgi-stl-6.png"></p><h3 id="源码移植"><a href="#源码移植" class="headerlink" title="源码移植"></a>源码移植</h3><p>这里将基于 C++ 11 移植 SGI STL 二级空间配置器中的内存池代码，即单独抽出内存池的代码以复用，其中移植的代码主要位于 SGI STL 的 <code>stl_alloc.h</code> 头文件中。</p><h4 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h4><ul><li><code>allocator.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一级空间配置器，按字节分配大块内存</span></span><br><span class="line"><span class="comment">// 封装 malloc() 和 free() 来实现内存管理，可以设置发生 OOM 时释放内存的回调函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __result) {</span><br><span class="line">            <span class="comment">// 调用OOM处理流程</span></span><br><span class="line">            __result = _S_oom_malloc(__n);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(__p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存空间重分配</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __result) {</span><br><span class="line">            <span class="comment">// 调用OOM处理流程</span></span><br><span class="line">            __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的OOM处理函数，返回旧的处理函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in"><span class="keyword">void</span></span> (*__old)() = __malloc_alloc_oom_handler;</span><br><span class="line">        __malloc_alloc_oom_handler = __f;</span><br><span class="line">        <span class="keyword">return</span> (__old);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存空间开辟时的OOM处理流程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> *_S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存空间重分配时的OOM处理流程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> *_S_oom_realloc(<span class="keyword">void</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OOM回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="params">(*__malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)</span><span class="params">()</span> </span>= <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__malloc_alloc_template&lt;inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n) {</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span> *__result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环，不断尝试释放、申请、再释放、再申请...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) { <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); }</span><br><span class="line">        <span class="comment">// 调用OOM回调函数</span></span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        <span class="comment">// 再次尝试申请内存</span></span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__malloc_alloc_template&lt;inst&gt;::_S_oom_realloc(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> __n) {</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span> *__result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环，不断尝试释放、重分配、再释放、再重分配...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) { <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); }</span><br><span class="line">        <span class="comment">// 调用OOM回调函数</span></span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        <span class="comment">// 再次尝试内存重分配</span></span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定义类型</span></span><br><span class="line"><span class="keyword">using</span> malloc_alloc = __malloc_alloc_template&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级空间配置器，按字节分配小块内存</span></span><br><span class="line"><span class="comment">// 基于自由链表原理的内存池机制来实现内存管理</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__ret = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配大块内存（当字节数大于 128）</span></span><br><span class="line">        <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) {</span><br><span class="line">            <span class="comment">// 调用一级空间配置器分配大内存</span></span><br><span class="line">            __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 分配小块内存</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表的互斥锁</span></span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; __lock_instance(_S_free_list_mtx[_S_freelist_index(__n)]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取自由链表的头节点</span></span><br><span class="line">            _Obj *__result = *__my_free_list;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果头节点为空（即没有空闲的内存 chunk 块），则分配新的内存 chunk 块</span></span><br><span class="line">            <span class="keyword">if</span> (__result == <span class="literal">nullptr</span>) {</span><br><span class="line">                __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果有空闲的内存 chunk 块，则将其取出来，并维护自由链表的结构</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 将自由链表的头节点指向下一个内存 chunk 块</span></span><br><span class="line">                *__my_free_list = __result-&gt;_M_free_list_link;</span><br><span class="line">                __ret = __result;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> __ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> __n)</span> </span>{</span><br><span class="line">        <span class="comment">// 大块内存（当字节数大于 128）直接交由一级空间配置器释放掉</span></span><br><span class="line">        <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) {</span><br><span class="line">            malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 小块内存回收到自由链表</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">            _Obj *__q = (_Obj *) __p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表的互斥锁</span></span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; __lock_instance(_S_free_list_mtx[_S_freelist_index(__n)]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回收内存，将释放的小块内存插入到自由链表的头部（头插法）</span></span><br><span class="line">            __q-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = __q;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存池扩容 / 缩容</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__result;</span><br><span class="line">        <span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种情况：当新旧大小均超过最大内存池处理阈值是，直接调用系统的 realloc()</span></span><br><span class="line">        <span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) {</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">realloc</span>(__p, __new_sz));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种情况：当新旧内存块在内存池中的对齐后大小相等，则直接复用旧内存块</span></span><br><span class="line">        <span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) {</span><br><span class="line">            <span class="keyword">return</span> (__p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三种情况：需要执行内存重分配</span></span><br><span class="line">        __result = <span class="built_in">allocate</span>(__new_sz);    <span class="comment">// 申请新内存块（根据内存池策略）</span></span><br><span class="line">        __copy_sz = __new_sz &gt; __old_sz ? __old_sz : __new_sz;   <span class="comment">// 安全拷贝大小（取较小值）</span></span><br><span class="line">        <span class="built_in">memcpy</span>(__result, __p, __copy_sz);    <span class="comment">// 数据拷贝（仅拷贝有效内容）</span></span><br><span class="line">        <span class="built_in">deallocate</span>(__p, __old_sz);     <span class="comment">// 释放旧内存块（根据旧内存块的大小进行回收）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> {</span> _ALIGN = <span class="number">8</span> };            <span class="comment">// 小块内存的对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> {</span> _MAX_BYTES = <span class="number">128</span> };      <span class="comment">// 小块内存的最大字节数（128 字节）</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> {</span> _NFREELISTS = <span class="number">16</span> };      <span class="comment">// 自由链表的数量，计算方式：_MAX_BYTES / _ALIGN</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个内存 chunk 块的头信息</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> *_<span class="title">M_free_list_link</span>;</span>        <span class="comment">// 下一个内存 chunk 块的地址</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];                <span class="comment">// 实际分配给用户的内存起始位置</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录内存 chunk 块的分配情况</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *_S_start_free;     <span class="comment">// 整个内存池的起始位置，只在 _S_chunk_alloc() 中发生变化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *_S_end_free;       <span class="comment">// 整个内存池的结束位置，只在 _S_chunk_alloc() 中发生变化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组织所有自由链表的数组，数组的每一个元素的类型都是 _Obj*</span></span><br><span class="line">    <span class="keyword">static</span> _Obj *<span class="keyword">volatile</span> _S_free_list[_NFREELISTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有自由链表的互斥锁的数组（内存池基于自由链表实现，需要考虑线程安全问题，为每个自由链表添加一个互斥锁，降低锁的粒度）</span></span><br><span class="line">    <span class="keyword">static</span> std::mutex _S_free_list_mtx[_NFREELISTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 __bytes 上调至最邻近的 8 的倍数（实现内存对齐）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 __bytes 大小的 chunk 块位于自由链表数组中的索引</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的内存 chunk 块，并将分配好的 chunk 块进行连接，添加到自由链表当中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> *_S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配相应字节大小的内存 chunk 块</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span> &amp;__nobjs);</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员变量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;inst&gt;::_S_start_free = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;inst&gt;::_S_end_free = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line">std::mutex __default_alloc_template&lt;inst&gt;::_S_free_list_mtx[_NFREELISTS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;inst&gt;::_Obj *<span class="keyword">volatile</span> __default_alloc_template&lt;inst&gt;::_S_free_list[_NFREELISTS] = {<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">                                                                                                                     <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__default_alloc_template&lt;inst&gt;::_S_refill(<span class="keyword">size_t</span> __n) {</span><br><span class="line">    <span class="comment">// 一次性分配 20 个内存 chunk 块，但万一内存空间不足，获得的块数可能小于 20</span></span><br><span class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配多个指定大小的内存 chunk 块，参数 __nobjs 使用引用传递</span></span><br><span class="line">    <span class="keyword">char</span> *__chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line"></span><br><span class="line">    _Obj *<span class="keyword">volatile</span> *__my_free_list;</span><br><span class="line">    _Obj *__result;</span><br><span class="line">    _Obj *__current_obj;</span><br><span class="line">    _Obj *__next_obj;</span><br><span class="line">    <span class="keyword">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只获得一个内存 chunk 块，就直接分配给调用者使用，自由链表不会添加新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) {</span><br><span class="line">        <span class="keyword">return</span> (__chunk);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将分配到的多个内存 chunk 块添加到对应的自由链表中（即将各个 chunk 块串联起来）</span></span><br><span class="line">    __result = (_Obj *) __chunk;    <span class="comment">// 这个内存 chunk 返回给调用者</span></span><br><span class="line">    *__my_free_list = __next_obj = (_Obj *) (__chunk + __n);</span><br><span class="line">    <span class="keyword">for</span> (__i = <span class="number">1</span>;; __i++) {     <span class="comment">// 从 1 开始，因为第 0 个返回给调用者</span></span><br><span class="line">        __current_obj = __next_obj;</span><br><span class="line">        __next_obj = (_Obj *) ((<span class="keyword">char</span> *) __next_obj + __n);</span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) {</span><br><span class="line">            __current_obj-&gt;_M_free_list_link = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            __current_obj-&gt;_M_free_list_link = __next_obj;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (__result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span> &amp;__nobjs) {</span><br><span class="line">    <span class="keyword">char</span> *__result;</span><br><span class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;    <span class="comment">// 计算需要分配的总字节数</span></span><br><span class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;    <span class="comment">// 获取整个内存池剩余空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种情况：整个内存池的剩余空间完全可以满足需求</span></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) {</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 第二种情况：整个内存池的剩余空间不能满足全部需求，但至少能分配一个以上的内存 chunk 块</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) {</span><br><span class="line">        <span class="comment">// 更改为实际能够供应的内存 chunk 数</span></span><br><span class="line">        __nobjs = (<span class="keyword">int</span>) (__bytes_left / __size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 第三种情况：整个内存池的剩余空间不足一个内存 chunk 块大小</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 计算需要申请的内存总量：2倍需求 + 附加量（堆大小的1/16并向上对齐）</span></span><br><span class="line">        <span class="keyword">size_t</span> __bytes_to_get = <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试回收利用内存池的剩余碎片</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list = _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line">            <span class="comment">// 将剩余碎片插入到自由链表的头部（头插法）</span></span><br><span class="line">            ((_Obj *) _S_start_free)-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj *) _S_start_free;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请新的内存块并添加到内存池中</span></span><br><span class="line">        _S_start_free = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(__bytes_to_get);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  新的内存块申请失败处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == _S_start_free) {</span><br><span class="line">            <span class="keyword">size_t</span> __i;</span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list;</span><br><span class="line">            _Obj *__p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试从其他字节数更大的自由链表中查找可用内存块</span></span><br><span class="line">            <span class="comment">// 注意：不尝试从字节数更小的自由链表中查找，因为在多处理器环境中容易出现问题</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size; __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES; __i += (<span class="keyword">size_t</span>) _ALIGN) {</span><br><span class="line">                <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="comment">// 找到可用内存块</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">nullptr</span> != __p) {</span><br><span class="line">                    <span class="comment">// 调整自由链表以获取未使用的内存块</span></span><br><span class="line">                    *__my_free_list = __p-&gt;_M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="keyword">char</span> *) __p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="comment">// 递归调用自身，为了修正 __nobjs</span></span><br><span class="line">                    <span class="keyword">return</span> (_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// 注意：任何剩余碎片最终都会被加入到合适的自由链表中备用</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 所有自由链表都无可用内存时的最后处理手段</span></span><br><span class="line">            _S_end_free = <span class="literal">nullptr</span>;    <span class="comment">// 异常安全处理</span></span><br><span class="line">            _S_start_free = (<span class="keyword">char</span> *) malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);    <span class="comment">// 调用一级空间配置器分配内存（可能会抛出OOM异常）</span></span><br><span class="line">            <span class="comment">// 此处假设分配操作总会成功（要么抛出异常，要么解决问题）</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新内存池管理参数</span></span><br><span class="line">        _S_heap_size += __bytes_to_get;    <span class="comment">// 累计分配的内存总量</span></span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get;    <span class="comment">// 设置新的内存池结束位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用自身，为了修正 __nobjs（此时内存池已有新申请的内存块）</span></span><br><span class="line">        <span class="keyword">return</span> (_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定义类型</span></span><br><span class="line"><span class="keyword">using</span> default_alloc = __default_alloc_template&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间配置器的接口，符合 STL 规范，按元素的大小分配内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simple_alloc</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定义类型</span></span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">simple_alloc</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">simple_alloc</span><span class="params">(<span class="keyword">const</span> simple_alloc &amp;)</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _U, class _Other&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="title">simple_alloc</span><span class="params">(<span class="keyword">const</span> simple_alloc&lt;_U, _Other&gt; &amp;)</span> <span class="keyword">noexcept</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="literal">nullptr</span> : (T *) Alloc::<span class="built_in">allocate</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) Alloc::<span class="built_in">allocate</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) {</span><br><span class="line">            Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（利用可变参数模板 + 引用折叠 + 完美转发）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *__p, Args &amp;&amp;... args)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(__p) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *__p)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存析构对象</span></span><br><span class="line">        __p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"allocator.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deepCopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *source)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (source) {</span><br><span class="line">            name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(source) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name, source);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            name = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> age) : <span class="built_in">age</span>(age) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person(name, age)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">deepCopy</span>(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;other) : <span class="built_in">age</span>(other.age) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person(const Person&amp;)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">deepCopy</span>(other.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符</span></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Person &amp;other) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person&amp; operator=(const Person&amp;)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) {</span><br><span class="line">            <span class="comment">// 先释放原有内存</span></span><br><span class="line">            <span class="keyword">delete</span>[] name;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拷贝新数据</span></span><br><span class="line">            age = other.age;</span><br><span class="line">            <span class="built_in">deepCopy</span>(other.name);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; (name ? name : <span class="string">"[Unnamed]"</span>) &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试基础类型的内存分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 SGI STL 二级空间配置器</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>, simple_alloc&lt;<span class="keyword">int</span>, default_alloc&gt;&gt; vec1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">        vec1.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;item : vec1) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试自定义类型的内存分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用 SGI STL 二级空间配置器</span></span><br><span class="line">    vector&lt;Person, simple_alloc&lt;Person, default_alloc&gt;&gt; vec2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不想频繁触发容器扩容，可以强制指定容器的预留容量</span></span><br><span class="line">    <span class="comment">// vec2.reserve(5);</span></span><br><span class="line"></span><br><span class="line">    vec2.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">"Jim"</span>, <span class="number">18</span>));</span><br><span class="line">    vec2.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">"Peter"</span>, <span class="number">23</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec2.<span class="built_in">begin</span>(); it != vec2.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        it-&gt;<span class="built_in">display</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>测试代码运行的输出结果 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3 4 1 8 8 5 10 1 8 8 </span><br><span class="line">Person(name, age)           // 构造临时对象 Jim</span><br><span class="line">Person(const Person&amp;)       // push_back 时拷贝临时对象 Jim 进容器</span><br><span class="line">~Person()                   // 析构临时对象 Jim</span><br><span class="line">Person(name, age)           // 构造临时对象 Peter</span><br><span class="line">Person(const Person&amp;)       // push_back 时触发容器扩容后，拷贝容器已有元素 Jim 到新容器中</span><br><span class="line">Person(const Person&amp;)       // push_back 时触发容器扩容后，拷贝临时对象 Peter 到新容器中</span><br><span class="line">~Person()                   // 析构旧容器中的对象 Jim</span><br><span class="line">~Person()                   // 析构临时对象 Peter</span><br><span class="line">Name: Jim, Age: 18</span><br><span class="line">Name: Peter, Age: 23</span><br><span class="line">~Person()                   // 析构新容器中的对象 Jim</span><br><span class="line">~Person()                   // 析构新容器中的对象 Peter</span><br></pre></td></tr></tbody></table></figure><h4 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h4><p>移植后的 SGI STL 二级空间配置器的内存池代码可以在 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-sgi-stl-allocator">这里</a> 下载得到。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.51cto.com/u_16099355/10572558">容器内存分析 STL 容器内存分配</a></li><li><a href="https://www.cnblogs.com/wofeishenling/articles/17702398.html">SGI STL 二级空间配置器内存池源码</a></li><li><a href="https://www.cnblogs.com/fortunely/p/16219743.html">SGI STL 空间配置器 allocator /alloc</a></li><li><a href="https://blog.csdn.net/mmshixing/article/details/51672434">SGI STL 空间配置器 - 第二级空间配置器</a></li><li><a href="https://zhuanlan.zhihu.com/p/712899055">高效利用内存资源：掌握内存池设计与实现</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 SGI STL 内存池的底层源码。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="源码剖析" scheme="https://www.techgrow.cn/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Debian 12 搭建 IPSec VPN 实现内网互连</title>
    <link href="https://www.techgrow.cn/posts/ec9b99f7.html"/>
    <id>https://www.techgrow.cn/posts/ec9b99f7.html</id>
    <published>2025-03-16T13:48:23.000Z</published>
    <updated>2025-03-16T13:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 Debian 12 如何基于 StrongSwan‌ 搭建 IPSec VPN，以此在多台 Linux 服务器（处于不同的数据中心 - IDC）之间实现内网通信。</p><h2 id="内网互连方案介绍"><a href="#内网互连方案介绍" class="headerlink" title="内网互连方案介绍"></a>内网互连方案介绍</h2><p>在多台 Linux 服务器（处于不同的数据中心 - IDC）之间实现内网互连，有以下几种方案：</p><ul><li><p>虚拟专用网络（Virtual Private Network - VPN）</p><ul><li>通过建立虚拟专用网络连接，将服务器与内网之间建立起安全的通信隧道，实现互通。可以使用软件或硬件设备来实现虚拟专用网络连接。</li></ul></li><li><p>隧道技术（Tunneling）</p><ul><li>使用隧道技术，将服务器的网络流量封装在内网的流量中传输，从而实现互通。常见的隧道技术有 SSH 隧道、GRE 隧道、IPSec 隧道等。</li></ul></li><li><p>NAT（Network Address Translation，网络地址转换）</p><ul><li>在内网中配置 NAT 设备，将服务器的私有 IP 地址映射为内网的公共 IP 地址，从而实现互通。</li></ul></li><li><p>配置防火墙规则</p><ul><li>在内网的防火墙中配置相应的规则，允许服务器与内网之间的通信。可以通过指定源 IP 地址、目标 IP 地址、端口等来限制通信。</li></ul></li></ul><span id="more"></span><h2 id="IPSec-VPN-的简单介绍"><a href="#IPSec-VPN-的简单介绍" class="headerlink" title="IPSec VPN 的简单介绍"></a>IPSec VPN 的简单介绍</h2><h3 id="IPSec-是什么"><a href="#IPSec-是什么" class="headerlink" title="IPSec 是什么"></a>IPSec 是什么</h3><p>IPSec 是虚拟私有网络（VPN）的一种连接协议，用于在服务器和客户端之间建立加密隧道，并传输敏感数据。它由两个阶段组成，第一阶段（Phrase 1， ph1），交换密钥建立连接，使用互联网密钥交换协议（ike）；ike 密钥交换协议有两个版本，分别是 IKEV1、IKEV2；第二阶段（Phrase 2， ph2），连接建立后对数据进行加密传输，使用封装安全载荷（ESP）协议。</p><h3 id="IKEV1-与-IKEV2"><a href="#IKEV1-与-IKEV2" class="headerlink" title="IKEV1 与 IKEV2"></a>IKEV1 与 IKEV2</h3><p>IKE 属于一种混合型协议，由 Internet 安全关联和密钥管理协议（ISAKMP）和两种密钥交换协议 OAKLEY 与 SKEME 组成。IKE 创建在由 ISAKMP 定义的框架上，沿用了 OAKLEY 的密钥交换模式以及 SKEME 的共享和密钥更新技术，还定义了它自己的两种密钥交换方式：主模式和积极模式（IKEV1 才有）。IKE 有两个版本，分别是 IKEV1 与 IKEV2。值得一提的是，IKEV2 不兼容 IKEV1，IKEV1 不支持认证，IKEV2 支持认证。IKEV2 支持 EAP 认证，支持 NAT 穿透，支持私密性、完整性、源认证。工作在 UDP 的 500 /4500 端口。NAT-T 用的是 UDP 4500 端口。</p><h3 id="OpenSwan-与-StrongSwan"><a href="#OpenSwan-与-StrongSwan" class="headerlink" title="OpenSwan 与 StrongSwan"></a>OpenSwan 与 StrongSwan</h3><p>Linux 系统有两种比较常见的 IPSec 实现，分别是 OpenSwan 与 StrongSwan，两者的主要区别如下：</p><ul><li><p>协议支持</p><ul><li>OpenSwan‌<ul><li>主要支持 ‌IKEV1‌ 协议，兼容旧版设备‌。</li><li>默认使用 ‌KLIPS‌ 内核模块实现 IPSec（需手动为旧内核打补丁），对 Linux <code>2.6.9+</code> 内核支持 NETKEY‌。</li></ul></li><li>StrongSwan‌<ul><li>专注 ‌IKEV2‌ 协议，安全性更高且简化配置流程‌。</li><li>原生支持 NETKEY 内核模块（无需额外补丁），对现代 Linux 内核（如 <code>4.x+</code>）兼容性更佳‌。</li></ul></li></ul></li><li><p>配置复杂度‌</p><ul><li>‌OpenSwan‌<ul><li>依赖 <code>ipsec.conf</code> 配置文件，需手动管理多参数（如 <code>protostack=netkey</code> 需显式声明）‌。</li><li>对 NAT 穿透支持较弱（旧内核需额外补丁）‌。</li></ul></li><li>‌StrongSwan‌<ul><li>使用模块化配置（如 <code>strongswan.conf</code>），支持动态加载插件（如 <code>charon</code> 进程管理 IKE）‌。</li><li>内置 ‌NAT-Traversal‌ 功能，适配复杂网络环境更便捷‌。</li></ul></li></ul></li><li><p>维护与扩展性‌</p><ul><li>‌OpenSwan‌<ul><li>社区维护停滞，新版 Linux 发行版（如 Debian 12、Ubuntu <code>22.04+</code>）默认移除了 ‌OpenSwan‌ 的支持‌。</li><li>适合需兼容老旧设备的场景‌。</li></ul></li><li>‌StrongSwan‌<ul><li>项目持续更新，支持 ‌X.509 证书认证‌、‌EAP 扩展认证‌等现代安全机制‌。</li><li>使用 C 语言编写，提供线程池优化，大大提升多连接场景下的协商效率‌。</li></ul></li></ul></li><li><p>性能表现‌</p><ul><li>OpenSwan‌<ul><li>在低带宽场景下性能稳定，但加密转发带宽受限（实测最高约 700 Mbps）‌。</li></ul></li><li>StrongSwan‌<ul><li>通过优化加密算法（如 AES-NI 加速）和线程池技术，转发性能更高（实测带宽可达 1 Gbps+）‌。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">适用场景总结</p><ul><li>‌OpenSwan‌：需兼容旧版设备（如 Linux <code>2.4</code> 内核）、使用 IKEV1 协议的场景‌。</li><li>StrongSwan‌：现代网络环境、需要 IKEV2 协议、高安全认证及性能优化的场景‌。</li></ul></div><h2 id="IPSec-VPN-实现内网互连"><a href="#IPSec-VPN-实现内网互连" class="headerlink" title="IPSec VPN 实现内网互连"></a>IPSec VPN 实现内网互连</h2><p>由于 Debian 12 的 Linux 内核版本是 <code>6.x</code>，因此这里选择基于 StrongSwan‌ 搭建 IPSec VPN，以此在多台 Linux 服务器（处于不同的数据中心 - IDC）之间实现内网通信。各服务器的网络信息如下所示：</p><table><thead><tr><th>服务器</th><th>公网 IP</th><th> 内网 IP</th><th> 备注</th></tr></thead><tbody><tr><td>服务器一</td><td> 101.53.225.204</td><td>10.0.8.9</td><td> 云服务器</td></tr><tr><td>服务器二</td><td> 49.135.225.57</td><td>10.0.20.6</td><td> 云服务器</td></tr></tbody></table><h3 id="准备工作执行"><a href="#准备工作执行" class="headerlink" title="准备工作执行"></a>准备工作执行</h3><p>在两台 Debian 服务器上，分别执行以下操作，为后续安装和配置 IPSec VPN 做准备。</p><ul><li>安装工具软件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新软件索引</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装工具软件</span></span><br><span class="line">sudo apt install -y wget curl telnet tcpdump net-tools vim -y</span><br></pre></td></tr></tbody></table></figure><ul><li>更改系统配置 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑系统配置文件，更改或添加以下配置内容</span></span><br><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 允许转发，默认值是 0</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.ipv6.conf.all.forwarding = 1</span><br><span class="line"></span><br><span class="line"># 关闭重定向，防止恶意用户可以使用 IP 重定向来修改远程主机中的路由表</span><br><span class="line">net.ipv4.conf.all.accept_redirects = 0</span><br><span class="line">net.ipv4.conf.all.send_redirects = 0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用系统配置更改生效</span></span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></tbody></table></figure><ul><li>防火墙开放端口 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 UFW　防火墙</span></span><br><span class="line">sudo apt install -y ufw</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 TCP 22 端口（SSH）</span></span><br><span class="line">sudo ufw allow 22/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 UDP 500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 500/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 UDP 4500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 4500/udp</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用 UFW 防火墙</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙所有已开放的端口</span></span><br><span class="line">sudo ufw verbose</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加路由表规则（可选操作），通过 iptables 修改出站流量的源 IP，匹配云服务器 NAT 映射规则，否则服务器之间的网络可能会不通</span></span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由表规则添加后，若希望删除掉它，可以执行以下命令</span></span><br><span class="line">sudo iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>为了方便后续配置 IPSec VPN 和排查问题，可以先暂时不配置防火墙，也就是可以等 IPSec VPN 正常工作后再配置防火墙。</li><li>IPSec VPN 默认监听在 UDP 的 <code>500</code> 和 <code>4500</code> 两个端口，其中 UDP <code>500</code> 是用于 IKE 密钥交换协商，UDP <code>4500</code> 是用于 NAT 穿透。</li></ul></div><h3 id="服务器一配置"><a href="#服务器一配置" class="headerlink" title="服务器一配置"></a>服务器一配置</h3><h4 id="安装-StrongSwan"><a href="#安装-StrongSwan" class="headerlink" title="安装 StrongSwan"></a>安装 StrongSwan</h4><ul><li>安装 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 StrongSwan 服务</span></span><br><span class="line">sudo apt install -y strongswan strongswan-charon strongswan-libcharon libstrongswan libcharon-extra-plugins</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启 StrongSwan 服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>备份 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/ipsec.conf /etc/ipsec.conf.bak</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">        charondebug="all"</span><br><span class="line"></span><br><span class="line">conn %default                             # 配置ike默认参数</span><br><span class="line">        ikelifetime=1440m                 # ike协议的SA生命周期</span><br><span class="line">        keylife=60m                       # IPSec连接的密钥生命周期为60分钟</span><br><span class="line">        rekeymargin=3m                    # 3分钟过后密钥生命周期结束后重新生成密钥</span><br><span class="line">        keyingtries=0                     # 密钥交换期间允许最大的重试次数为0次</span><br><span class="line">        keyexchange=ikev1                 # IPSec连接使用IKE协议的版本</span><br><span class="line">        authby=secret                     # 使用预共享密钥认证方式</span><br><span class="line">    </span><br><span class="line">conn ipsecvpn                             # 创建ipsecvpn</span><br><span class="line">        leftid=101.53.225.204             # 本地网关设备的标识</span><br><span class="line">        left=101.53.225.204               # 本地网关设备的公网IP地址，如果使用本地网关的私网IP地址建立IPSec-VPN连接，则本项需配置为本地网关设备的私网IP地址</span><br><span class="line">        leftsubnet=10.0.8.0/22            # 本地设备的内网网段</span><br><span class="line">        right=49.135.225.57               # 远端设备的出口网关的公网IP地址</span><br><span class="line">        rightsubnet=10.0.20.0/22          # 远端设备的内网网段</span><br><span class="line">        auto=start                        # 主模式</span><br><span class="line">        type=tunnel                       # 隧道模式</span><br><span class="line">        ike=3des-md5-modp1024             # IKE使用3des-md5-modp1024加密套件</span><br><span class="line">        esp=3des-md5                      # esp使用3des-md5加密套件</span><br><span class="line">        forceencaps=yes                   # 强制使用NAT-T封装，即使NAT-T不是必需的</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>强烈建议加上配置 <code>forceencaps=yes</code>，因为这在云服务器（如阿里云、腾讯云）场景下特别重要，因为它们的公网 IP 可能是 NAT 映射的地址。为了适配 NAT 场景，还可以添加 <code>nat-ikev1-method=natd</code> 配置。</li></ul></div><ul><li>配置 IPSec 预共享密钥 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.secrets</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">101.53.225.204 49.135.225.57 : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">%any : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><h4 id="启动-StrongSwan"><a href="#启动-StrongSwan" class="headerlink" title="启动 StrongSwan"></a>启动 StrongSwan</h4><ul><li>启动 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启 StrongSwan 服务</span></span><br><span class="line">systemctl restart strongswan-starter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 StrongSwan 服务的运行状态</span></span><br><span class="line">systemctl status strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>启动 IPSec 服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新加载 IPSec 配置文件</span></span><br><span class="line">ipsec reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 IPSec 服务</span></span><br><span class="line">ipsec restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动名称为 ipsecvpn 的 IPSec 连接（这里暂时不会启动成功，因为另一台服务器还没有配置 IPSec）</span></span><br><span class="line">ipsec up ipsecvpn </span><br></pre></td></tr></tbody></table></figure><h4 id="关闭-StrongSwan"><a href="#关闭-StrongSwan" class="headerlink" title="关闭 StrongSwan"></a>关闭 StrongSwan</h4><ul><li>若 StrongSwan 服务无法正常启动，可以使用以下命令先关闭 IPSec 和 StrongSwan 服务，然后再重新启动服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭名称为 ipsecvpn 的 IPSec 连接</span></span><br><span class="line">sudo ipsec down ipsecvpn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 IPSec 服务</span></span><br><span class="line">sudo ipsec stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 StrongSwan 服务</span></span><br><span class="line">sudo systemctl stop strongswan-starter</span><br></pre></td></tr></tbody></table></figure><h3 id="服务器二配置"><a href="#服务器二配置" class="headerlink" title="服务器二配置"></a>服务器二配置</h3><h4 id="安装-StrongSwan-1"><a href="#安装-StrongSwan-1" class="headerlink" title="安装 StrongSwan"></a>安装 StrongSwan</h4><ul><li>安装 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 StrongSwan 服务</span></span><br><span class="line">sudo apt install -y strongswan strongswan-charon strongswan-libcharon libstrongswan libcharon-extra-plugins</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启 StrongSwan 服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>备份 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/ipsec.conf /etc/ipsec.conf.bak</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">        charondebug="all"</span><br><span class="line"></span><br><span class="line">conn %default                             # 配置ike默认参数</span><br><span class="line">        ikelifetime=1440m                 # ike协议的SA生命周期</span><br><span class="line">        keylife=60m                       # IPSec连接的密钥生命周期为60分钟</span><br><span class="line">        rekeymargin=3m                    # 3分钟过后密钥生命周期结束后重新生成密钥</span><br><span class="line">        keyingtries=0                     # 密钥交换期间允许最大的重试次数为0次</span><br><span class="line">        keyexchange=ikev1                 # IPSec连接使用IKE协议的版本</span><br><span class="line">        authby=secret                     # 使用预共享密钥认证方式</span><br><span class="line">    </span><br><span class="line">conn ipsecvpn                             # 创建ipsecvpn</span><br><span class="line">        leftid=49.135.225.57              # 本地网关设备的标识</span><br><span class="line">        left=49.135.225.57                # 本地网关设备的公网IP地址，如果使用本地网关的私网IP地址建立IPSec-VPN连接，则本项需配置为本地网关设备的私网IP地址</span><br><span class="line">        leftsubnet=10.0.8.0/22            # 本地设备的内网网段</span><br><span class="line">        right=101.53.225.204              # 远端设备的出口网关的公网IP地址</span><br><span class="line">        rightsubnet=10.0.20.0/22          # 远端设备的内网网段</span><br><span class="line">        auto=start                        # 主模式</span><br><span class="line">        type=tunnel                       # 隧道模式</span><br><span class="line">        ike=3des-md5-modp1024             # IKE使用3des-md5-modp1024加密套件</span><br><span class="line">        esp=3des-md5                      # esp使用3des-md5加密套件</span><br><span class="line">        forceencaps=yes                   # 强制使用NAT-T封装，即使NAT-T不是必需的</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>强烈建议加上配置 <code>forceencaps=yes</code>，因为这在云服务器（如阿里云、腾讯云）场景下特别重要，因为它们的公网 IP 可能是 NAT 映射的地址。为了适配 NAT 场景，还可以添加 <code>nat-ikev1-method=natd</code> 配置。</li></ul></div><ul><li>配置 IPSec 预共享密钥 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.secrets</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">49.135.225.57 101.53.225.204 : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">%any : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><h4 id="启动-StrongSwan-1"><a href="#启动-StrongSwan-1" class="headerlink" title="启动 StrongSwan"></a>启动 StrongSwan</h4><ul><li>启动 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启 StrongSwan 服务</span></span><br><span class="line">systemctl restart strongswan-starter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 StrongSwan 服务的运行状态</span></span><br><span class="line">systemctl status strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>启动 IPSec 服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新加载 IPSec 配置文件</span></span><br><span class="line">ipsec reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 IPSec 服务</span></span><br><span class="line">ipsec restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动名称为 ipsecvpn 的 IPSec 连接</span></span><br><span class="line">ipsec up ipsecvpn </span><br></pre></td></tr></tbody></table></figure><p>当两台服务器都执行 <code>ipsec up ipsecvpn</code> 命令后，就会一直检测对方服务器是否正常启动 IPSec，如果正常启动，它们自己会互相连接成功，如下图所示（<strong>图片来源自网络，仅供参考</strong>）：</p><p><img data-src="../../../asset/2025/03/ipsec-vpn-1.png"></p><h4 id="关闭-StrongSwan-1"><a href="#关闭-StrongSwan-1" class="headerlink" title="关闭 StrongSwan"></a>关闭 StrongSwan</h4><ul><li>若 StrongSwan 服务无法正常启动，可以使用以下命令先关闭 IPSec 和 StrongSwan 服务，然后再重新启动服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭名称为 ipsecvpn 的 IPSec 连接</span></span><br><span class="line">sudo ipsec down ipsecvpn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 IPSec 服务</span></span><br><span class="line">sudo ipsec stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 StrongSwan 服务</span></span><br><span class="line">sudo systemctl stop strongswan-starter</span><br></pre></td></tr></tbody></table></figure><h3 id="验证-VPN-连接"><a href="#验证-VPN-连接" class="headerlink" title="验证 VPN 连接"></a>验证 VPN 连接</h3><ul><li>在服务一查看 IPSec 的运行状态，如下图所示（<strong>图片来源自网络，仅供参考</strong>）：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 IPSec 的运行状态</span></span><br><span class="line">sudo ipsec statusall</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/03/ipsec-vpn-3.png"></p><ul><li>在服务二查看 IPSec 的运行状态，如下图所示（<strong>图片来源自网络，仅供参考</strong>）：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 IPSec 的运行状态</span></span><br><span class="line">sudo ipsec statusall</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/03/ipsec-vpn-2.png"></p><h2 id="IPSec-VPN-常见配置问题"><a href="#IPSec-VPN-常见配置问题" class="headerlink" title="IPSec VPN 常见配置问题"></a>IPSec VPN 常见配置问题</h2><h3 id="UDP-500-端口无法正常通信"><a href="#UDP-500-端口无法正常通信" class="headerlink" title="UDP 500 端口无法正常通信"></a>UDP 500 端口无法正常通信</h3><blockquote><p>问题描述</p></blockquote><p>在服务器一（<code>101.53.225.204</code>）中，执行 <code>systemctl status strongswan-starter</code> 命令查看 StrongSwan 服务的运行状态，出现以下错误信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mar 25 21:38:49 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br><span class="line">Mar 25 21:39:02 debian charon[274510]: 11[IKE] sending retransmit 3 of request message ID 0, seq 1</span><br><span class="line">Mar 25 21:39:02 debian charon[274510]: 11[NET] sending packet: from 101.53.225.204[500] to 49.135.225.57[500] (248 bytes)</span><br><span class="line">Mar 25 21:39:02 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br><span class="line">Mar 25 21:39:26 debian charon[274510]: 12[IKE] sending retransmit 4 of request message ID 0, seq 1</span><br><span class="line">Mar 25 21:39:26 debian charon[274510]: 12[NET] sending packet: from 101.53.225.204[500] to 49.135.225.57[500] (248 bytes)</span><br><span class="line">Mar 25 21:39:26 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br><span class="line">Mar 25 21:40:08 debian charon[274510]: 13[IKE] sending retransmit 5 of request message ID 0, seq 1</span><br><span class="line">Mar 25 21:40:08 debian charon[274510]: 13[NET] sending packet: from 101.53.225.204[500] to 49.135.225.57[500] (248 bytes)</span><br><span class="line">Mar 25 21:40:08 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br></pre></td></tr></tbody></table></figure><blockquote><p>问题分析</p></blockquote><p>分析错误信息可得知，可能是服务器二（<code>49.135.225.57</code>）的 UDP <code>500</code> 端口不能正常访问导致。</p><blockquote><p>问题解决</p></blockquote><ul><li><strong>(1)</strong> 在服务器二中，检查 IPSec VPN 是否有正常监听 UDP <code>500</code> 和 UDP <code>4500</code> 端口。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查端口监听</span></span><br><span class="line">netstat -ulnp | grep -E <span class="string">'500|4500'</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(2)</strong> 在服务器二中，若 Debian 系统有启用 UFW 防火墙，则需要开放 UDP <code>500</code> 和 UDP <code>4500</code> 端口。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 UDP 500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 500/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 UDP 4500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 4500/udp</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(3)</strong> 在服务器二中，使用 <code>tcpdump</code> 工具检测 UDP <code>500</code> 和 UDP <code>4500</code> 端口是否有接收到进站的流量。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any -nn udp port 500 or udp port 4500</span><br></pre></td></tr></tbody></table></figure><ul><li>若 <code>tcpdump</code> 工具没有检测到进站的流量，那么在服务器一中，可以执行以下命令手动发送数据包，以此检测服务器二 UDP <code>500</code> 端口的可达性。当提示 “Connection refused” 或 “Network is unreachable”，则说明 UDP <code>500</code> 端口未开放，需要检查防火墙配置。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -u -z -v 49.135.225.57 500</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(4)</strong> 在服务器一中，检查网络接口是否绑定了公网 IP。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show eth0</span><br></pre></td></tr></tbody></table></figure><ul><li>若在上述命令的输出中，‌没有显示公网 IP <code>101.53.225.204</code>，则可能需要通过云服务商控制台将该 IP 绑定到服务器的弹性网卡（如 <code>eth0</code>）‌。若公网 IP 是通过 NAT 映射（如云服务器弹性 IP），则需要确保 NAT 规则正确配置。</li><li>若公网流量需要通过特定网关（非默认内网网关），则需要在服务器一中添加静态路由，其中 <code>&lt;公网网关IP&gt;</code> 需替换为云服务商提供的公网网关地址（例如 <a href="../../../asset/2025/03/ipsec-vpn-4.png">VPN 网关</a>），详细教程请看 <a href="https://cloud.tencent.com/developer/article/1505715">这里</a>。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加静态路由</span></span><br><span class="line">ip route add 49.135.225.57/32 via &lt;公网网关IP&gt; dev eth0</span><br></pre></td></tr></tbody></table></figure><ul><li>验证路由是否生效，在服务器一中执行以下命令后，预期输出应该包含公网接口（如 <code>dev eth0</code>）和正确网关。若仍指向内网网关，则需要调整路由优先级或联系云服务商检查底层网络配置‌。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取路由表记录</span></span><br><span class="line">ip route get 49.135.225.57</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(5)</strong> 两台服务器分别调整 StrongSwan 配置，尝试显式指定源 IP（公网 IP），避免自动选择内网 IP。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conn ipsecvpn                             # 创建ipsecvpn</span><br><span class="line">        leftid=101.53.225.204             # 本地网关设备的标识</span><br><span class="line">        left=101.53.225.204               # 本地网关设备的公网IP地址，如果使用本地网关的私网IP地址建立IPSec-VPN连接，则本项需配置为本地网关设备的私网IP地址</span><br><span class="line">        leftsubnet=10.0.8.0/22            # 本地设备的内网网段</span><br><span class="line">        leftsourceip=101.53.225.204       # 本地设备的源IP（公网IP）</span><br><span class="line">        ......</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(6)</strong> 若上述步骤都无法定位或者解决问题，那么可以查看 IPSec 的运行状态和 StrongSwan 的日志信息来进一步定位问题。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 IPSec 的运行状态</span></span><br><span class="line">sudo ipsec statusall</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 StrongSwan 的所有日志信息</span></span><br><span class="line">journalctl -u strongswan-starter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者只查看 StrongSwan 的最新日志信息</span></span><br><span class="line">journalctl -u strongswan-starter --no-pager | tail -n 30</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="IPSec-VPN-技术科普"><a href="#IPSec-VPN-技术科普" class="headerlink" title="IPSec VPN 技术科普"></a>IPSec VPN 技术科普</h3><ul><li><a href="https://www.cnblogs.com/longlyseul/p/16966471.html">IPSec 技术详解</a></li><li><a href="https://developer.jdcloud.com/article/2535">IPSec VPN 原理介绍</a></li></ul><h3 id="IPSec-VPN-网络性能测试"><a href="#IPSec-VPN-网络性能测试" class="headerlink" title="IPSec VPN 网络性能测试"></a>IPSec VPN 网络性能测试</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/27363937370">StrongSwan 配置 IPSec VPN 的性能测试</a></li></ul><h3 id="OpenSwan-搭建-IPSec-VPN"><a href="#OpenSwan-搭建-IPSec-VPN" class="headerlink" title="OpenSwan 搭建 IPSec VPN"></a>OpenSwan 搭建 IPSec VPN</h3><ul><li><a href="https://blog.csdn.net/qq_36833548/article/details/130375242">OpenSwan 安装和简单配置</a></li><li><a href="https://blog.csdn.net/weixin_49816179/article/details/133150477">CentOS VPN 隧道技术实战</a></li><li><a href="https://bbs.sangfor.com.cn/forum.php?mod=viewthread&amp;tid=96195">OpenSwan 实现 IPSec VPN 野蛮模式对接</a></li><li><a href="https://www.liuchunhua.me/post/network/03sitetositevpn/site2sitevpn/">基于 OpenSwan 在 AWS 上构建高可用 VPN</a></li><li><a href="https://github.com/LCTT/TranslateProject/blob/master/published/201411/How%20to%20create%20a%20site-to-site%20IPsec%20VPN%20tunnel%20using%20Openswan%20in%20Linux.md">Openswan 搭建站点到站点的 IPsec VPN 隧道</a></li><li><a href="https://apple4us.com/2010/setting-up-l2tp-vpn-on-debian-ubuntu">如何在 Debian / Ubuntu 服务器上架设 L2TP / IPSec VPN</a></li></ul><h3 id="StrongSwan-搭建-IPSec-VPN"><a href="#StrongSwan-搭建-IPSec-VPN" class="headerlink" title="StrongSwan 搭建 IPSec VPN"></a>StrongSwan 搭建 IPSec VPN</h3><ul><li><a href="https://blog.csdn.net/qq_54100121/article/details/137450215">Debian 配置 IPSec VPN</a></li><li><a href="https://juejin.cn/post/7216604612404707386">Debian L2TP IPSec 服务器搭建</a></li><li><a href="https://blog.51cto.com/niubdada/5037222">CentOS 7.9 使用 StrongSwan 搭建 IPSec VPN</a></li><li><a href="https://cloud.tencent.com/developer/article/1505715">在 CentOS 上使用 StrongSwan 搭建 IPSec VPN 服务</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要记录 Debian 12 如何搭建 IPSec VPN 来实现多台服务器之间的内网通信。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
    <category term="网络安全" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器网络性能测试</title>
    <link href="https://www.techgrow.cn/posts/97085038.html"/>
    <id>https://www.techgrow.cn/posts/97085038.html</id>
    <published>2025-03-16T13:48:23.000Z</published>
    <updated>2025-03-16T13:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍 Linux 服务器的网络性能测试方法，可以根据测试后的数据判断网络性能。服务器的网络性能受多种因素的影响，例如：实例的物理距离、服务器的性能、操作系统参数等，请结合实际情况判断。</p><span id="more"></span><h2 id="安装测试工具"><a href="#安装测试工具" class="headerlink" title="安装测试工具"></a>安装测试工具</h2><p>分别登录服务器、客户端，按以下步骤在服务器和客户端上安装 iperf3 工具。</p><div class="admonition warning"><p class="admonition-title">注意</p><p>在测试环境搭建和测试时都需要保证自己拥有系统的 <code>root</code> 用户权限。</p></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.jdcloud.com/cn/virtual-private-cloud/vpc-performance-test">Linux 服务器网络性能测试</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要记录 Linux 服务器如何进行网络测试。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="网络安全" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 一键搭建 OpenVPN 服务器</title>
    <link href="https://www.techgrow.cn/posts/86c906bc.html"/>
    <id>https://www.techgrow.cn/posts/86c906bc.html</id>
    <published>2025-03-14T12:43:29.000Z</published>
    <updated>2025-03-14T12:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着工作的多样化，办公场地也不局限于公司，有些时候往往需要在家或者公共场所（远程办公）访问公司的内网服务器资源，出于网络安全考虑，互联网不能直接访问公司的内网资源，常见解决方案就是部署 VPN 服务器。本文基于 OpenVPN 搭建 VPN 服务器，搭建好之后可以使用 OpenVPN 客户端连接 VPN 服务器，这样就可以安全地访问 VPN 服务器的内网资源。</p><span id="more"></span><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><ul><li><a href="https://github.com/hwdsl2/setup-ipsec-vpn">hwdsl2/setup-ipsec-vpn</a></li><li><a href="https://github.com/hwdsl2/openvpn-install/tree/master">hwdsl2/openvpn-install</a></li></ul><h3 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h3><blockquote><p>运维面板的高权限风险  </p></blockquote><p>运维面板通常拥有极高的权限，一旦被非法访问，攻击者几乎可以完全控制服务器，安全风险极高。以下是几种常见的 Web 面板及其权限范围：  </p><ul><li><code>宝塔面板</code>：拥有服务器 <code>root</code> 权限，可对系统进行完全控制。  </li><li><code>Portainer</code>：掌管 Docker 的管理权限，能够管理所有容器和镜像。  </li><li><code>Proxmox VE</code>：具备对服务器的完整控制权，包括虚拟机和存储管理。  </li><li><code>phpMyAdmin</code>：负责 MySQL 数据库的管理，拥有数据库的完全操作权限。  </li></ul><blockquote><p>运维面板的安全脆弱性  </p></blockquote><ul><li>一些 Web 面板需要开放公网访问，例如宝塔面板，它引入了多种鉴权和防护机制，能够在一定程度上抵御攻击。然而，历史上仍然发生过多次严重安全漏洞事件。  </li><li>大多数 Web 面板的鉴权方式较为简单，通常只是一个 Web 登录框，防护强度较低。甚至部分面板并未考虑公网访问的安全性，例如 Portainer 官方明确表示其内置鉴权机制不适用于生产环境，并强烈不建议将其直接暴露在公网。</li><li>因此，如果这些鉴权机制较弱的 Web 面板直接开放到公网，将存在极大的安全隐患。  </li></ul><blockquote><p>基于 VPN 的安全防护  </p></blockquote><ul><li>VPN 是一种企业级的成熟加密通信技术，本文推荐使用 开源的 OpenVPN，其代码公开透明，安全性经过长期验证。通过在 Web 面板外层套一层 VPN，不论服务本身的安全性如何，整体访问环境都能得到有效保护。</li><li>使用 VPN 保护 Web 面板的访问是最便捷且安全的方案。其原理十分简单：对于不希望暴露在公网的服务（如高权限管理面板、私人 Web 服务），可以使用防火墙或安全组阻止外网访问。然后，部署一个 VPN 服务器，使管理者在连接 VPN 后，仿佛置身于服务器的内网环境，从而安全访问这些服务。  </li></ul><div class="admonition note"><p class="admonition-title">OpenVPN 的应用场景</p><ul><li>个人出差办公需要访问公司内网的服务器。</li><li>公司不同地区之间建立安全的网络通信（比如 IDC 与 IDC 之间安全通信）。</li></ul></div><h2 id="OpenVPN-服务器部署"><a href="#OpenVPN-服务器部署" class="headerlink" title="OpenVPN 服务器部署"></a>OpenVPN 服务器部署</h2><p>这里使用的是 <a href="https://github.com/hwdsl2/openvpn-install">OpenVPN 自动安装脚本</a>，大家可能认为脚本安装并不能保证安全性。但实际上，OpenVPN 的安全性是由 RSA 技术提供的，安装脚本每次安装都会现场生成 RSA 密钥，安全性是有保障的。使用脚本只是方便部署操作，对于个人应用场景，脚本提供的默认设置已经足够使用。该脚本支持 Ubuntu、Debian、AlmaLinux、Rocky Linux、CentOS、Fedora 系统。特别注意，如果使用的是虚拟化容器，则需要给容器开启 TUN/TAP。</p><h3 id="下载安装脚本"><a href="#下载安装脚本" class="headerlink" title="下载安装脚本"></a>下载安装脚本</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/hwdsl2/openvpn-install/master/openvpn-install.sh -O openvpn.sh</span><br></pre></td></tr></tbody></table></figure><h3 id="运行安装脚本"><a href="#运行安装脚本" class="headerlink" title="运行安装脚本"></a>运行安装脚本</h3><ul><li>使用 <code>root</code> 权限运行脚本，并使用默认选项自动安装（<strong>不推荐</strong>）OpenVPN 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --auto</span><br></pre></td></tr></tbody></table></figure><ul><li>或者使用自定义选项进行交互式安装（<strong>强烈推荐</strong>），自定义选项包括：VPN 服务器的域名、协议（TCP/UDP）和端口、VPN 客户端的 DNS 服务器以及第一个客户端的名称 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>当安装脚本执行成功后，会在运行目录下自动生成一个 <code>客户端名.ovpn</code> 的文件（默认是 <code>client.ovpn</code>），该文件就是 OpenVPN 客户端的连接配置文件，将其下载到本地，然后导入到 OpenVPN 客户端就可以连接 OpenVPN 服务器。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>执行 <code>openvpn.sh</code> 安装脚本后，会从 GitHub 下载相应的文件资源；如果安装脚本执行失败，可能是网络访问 GitHub 较慢导致的，建议再次尝试执行安装脚本。</p></div><h3 id="防火墙开放端口"><a href="#防火墙开放端口" class="headerlink" title="防火墙开放端口"></a>防火墙开放端口</h3><ul><li>当云服务器有外部防火墙（比如安全组），则需要手动调整安全组的配置，也就是开放安全组对应的协议和对应的端口，具体的协议和端口请根据上面的安装选项来配置。</li><li>当 Linux 服务器内有防火墙（比如 <code>UFW</code>），则需要手动调整安全组的配置，也就是开放安全组对应的协议和对应的端口，具体的协议和端口请根据上面的安装选项来配置。</li><li>比如，使用 <code>openvpn.sh --auto</code> 命令自动安装 OpenVPN 服务器后（基于默认安装选项），云服务器的安全组或者 Linux 服务器的防火墙都需要开放 UDP 协议的 <code>1194</code> 端口。<ul><li>Debian 开放 OpenVPN 端口：<code>sudo ufw allow 1194/udp</code></li><li>CentOS 开放 OpenVPN 端口：<code>sudo firewall-cmd --zone=public --permanent --add-port=1194/udp</code></li></ul></li></ul><h2 id="OpenVPN-的日常管理"><a href="#OpenVPN-的日常管理" class="headerlink" title="OpenVPN 的日常管理"></a>OpenVPN 的日常管理</h2><ul><li>安装脚本提供了以下命令行参数，可以用于管理 OpenVPN 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看脚本的参数</span></span><br><span class="line">sudo bash openvpn.sh --<span class="built_in">help</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Usage: bash openvpn.sh [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">  --addclient [client name]      add a new client</span><br><span class="line">  --exportclient [client name]   export configuration for an existing client</span><br><span class="line">  --listclients                  list the names of existing clients</span><br><span class="line">  --revokeclient [client name]   revoke an existing client</span><br><span class="line">  --uninstall                    remove OpenVPN and delete all configuration</span><br><span class="line">  -y, --yes                      assume "yes" as answer to prompts when revoking a client or removing OpenVPN</span><br><span class="line">  -h, --help                     show this help message and exit</span><br><span class="line"></span><br><span class="line">Install options (optional):</span><br><span class="line"></span><br><span class="line">  --auto                         auto install OpenVPN using default or custom options</span><br><span class="line">  --listenaddr [IPv4 address]    IPv4 address that OpenVPN should listen on for requests</span><br><span class="line">  --serveraddr [DNS name or IP]  server address, must be a fully qualified domain name (FQDN) or an IPv4 address</span><br><span class="line">  --proto [TCP or UDP]           protocol for OpenVPN (TCP or UDP, default: UDP)</span><br><span class="line">  --port [number]                port for OpenVPN (1-65535, default: 1194)</span><br><span class="line">  --clientname [client name]     name for the first OpenVPN client (default: client)</span><br><span class="line">  --dns1 [DNS server IP]         primary DNS server for clients (default: Google Public DNS)</span><br><span class="line">  --dns2 [DNS server IP]         secondary DNS server for clients</span><br><span class="line"></span><br><span class="line">To customize options, you may also run this script without arguments.</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 OpenVPN 客户端 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --listclients</span><br></pre></td></tr></tbody></table></figure><ul><li>移除指定的 OpenVPN 客户端 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --revokeclient client_name</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 OpenVPN 客户端 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --addclient client_name</span><br></pre></td></tr></tbody></table></figure><ul><li>卸载 OpenVPN 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --uninstall</span><br></pre></td></tr></tbody></table></figure><blockquote><p>为了日后更方便地执行安装脚本来管理 OpenVPN 服务器，可以将安装脚本移动到 Linux 系统的 <code>bin</code> 目录下，如下所示：</p></blockquote><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移动脚本文件</span></span><br><span class="line">sudo mv openvpn.sh /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权脚本文件</span></span><br><span class="line">sudo chmod 744 /usr/<span class="built_in">local</span>/bin/openvpn.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以后可以在任意目录下执行脚本</span></span><br><span class="line">sudo openvpn.sh --<span class="built_in">help</span></span><br></pre></td></tr></tbody></table></figure><h2 id="OpenVPN-客户端安装"><a href="#OpenVPN-客户端安装" class="headerlink" title="OpenVPN 客户端安装"></a>OpenVPN 客户端安装</h2><h3 id="各平台安装-GUI-客户端"><a href="#各平台安装-GUI-客户端" class="headerlink" title="各平台安装 GUI 客户端"></a>各平台安装 GUI 客户端</h3><ul><li>(1) <a href="https://openvpn.net/client/">OpenVPN 客户端</a> 在 Windows、macOS、iOS、Android 和 Linux 上均可用，macOS 用户还可以使用 Tunnelblick 作为 OpenVPN 客户端。</li><li>(2) OpenVPN 客户端要连接 OpenVPN 服务器，首先将生成的 <code>客户端名.ovpn</code> 文件安全地下载到本地设备，然后打开 OpenVPN 客户端程序，并导入 OpenVPN 客户端的配置文件（比如 <code>client.ovpn</code>）。</li><li>(3) 当 OpenVPN 服务器需要管理 OpenVPN 客户端时，可以再次运行安装脚本，比如，查看所有 OpenVPN 客户端：<code>sudo bash openvpn.sh --listclients</code>。</li></ul><h3 id="CentOS-7-安装-GUI-客户端"><a href="#CentOS-7-安装-GUI-客户端" class="headerlink" title="CentOS 7 安装 GUI 客户端"></a>CentOS 7 安装 GUI 客户端</h3><p>值得一提的是，如果 Centos 7 不需要使用 GUI 客户端，那么可以直接官方提供的 OpenVPN 3，也就是基于命令行的方式连接 OpenVPN 服务器。</p><ul><li>关闭 SELINUX</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一（临时关闭）</span></span><br><span class="line">sudo setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二（永久关闭，需要重启系统）</span></span><br><span class="line">sudo vi /etc/selinux/config</span><br><span class="line">SELINUX=disabled             <span class="comment"># 找到 SELINUX 这一行，并将其值改为 disabled</span></span><br></pre></td></tr></tbody></table></figure><ul><li>安装客户端（GUI）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install NetworkManager-openvpn</span><br><span class="line">sudo yum install NetworkManager-openvpn-gnome</span><br></pre></td></tr></tbody></table></figure><ul><li>导入 <code>.ovpn</code> 文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) 系统菜单栏导航到 settings -&gt; network -&gt; 点击 VPN 旁边的 + 号 -&gt; Import form file</span><br><span class="line">(2) 选择本地的 .ovpn 配置文件，NetworkManager 会自动识别 VPN 客户端的连接方式（比如使用 OpenVPN）</span><br><span class="line">(3) 如果有用户密码，需要在 User key password 输入框中填写用户密码</span><br><span class="line">(4) 如果有用户密码，密码保存方式选择：Store the password for all users（点击选择用户密码输入框右边那两个小人图标），否则容易出现某种奇怪的密码读取问题</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>一键安装 OpenVPN 服务器</p><ul><li><a href="https://blog.csdn.net/weixin_53391173/article/details/134180734">轻松搭建 OpenVPN 服务器</a></li><li><a href="https://blog.csdn.net/lemon_TT/article/details/136375983">OpenVPN 服务器的安装与使用</a></li><li><a href="https://www.zouht.com/3573.html">通过 OpenVPN 安全地进行服务器运维</a></li></ul></li><li><p>手动安装 OpenVPN 服务器</p><ul><li><a href="https://blog.csdn.net/qq_37510195/article/details/130777785">CentOS 搭建 OpenVPN 服务器</a></li><li><a href="https://www.cnblogs.com/cheyunhua/p/17516732.html">CentOS 7 安装 OpenVPN - 超详细</a></li></ul></li><li><p> Docker 安装 OpenVPN 服务器</p><ul><li><a href="https://cloud.tencent.com/developer/article/1953132">Docker 搭建虚拟专用网（VPN）</a></li></ul></li><li><p>CentOS 7 安装 OpenVPN 客户端</p><ul><li><a href="https://developer.baidu.com/article/details/3282576">CentOS 7 安装 OpenVPN 客户端</a></li><li><a href="https://zhuanlan.zhihu.com/p/637668940">Centos 7 安装 OpenVPN 客户端（GUI）</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Linux 系统一键搭建 OpenVPN 服务器。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="网络安全" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装 Sentinel Dashboard 单机</title>
    <link href="https://www.techgrow.cn/posts/592ca43f.html"/>
    <id>https://www.techgrow.cn/posts/592ca43f.html</id>
    <published>2025-03-13T12:05:42.000Z</published>
    <updated>2025-03-13T12:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍如何使用 Docker 和 Docker-Compose 安装 Sentinel Dashboard（单机）。</p><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li><a href="https://github.com/alibaba/Sentinel">Sentinel 官方项目</a></li><li><a href="https://github.com/alibaba/Sentinel/wiki">Sentinel 官方文档</a></li><li><a href="https://hub.docker.com/r/herodotus/sentinel-dashboard">Sentinel Dashboard 镜像（支持持久化）</a></li><li><a href="https://hub.docker.com/r/bladex/sentinel-dashboard">Sentinel Dashboard 镜像（不支持持久化）</a></li></ul><span id="more"></span><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><ul><li>拉取镜像 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bladex/sentinel-dashboard:1.8.8</span><br></pre></td></tr></tbody></table></figure><ul><li>启动容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name sentinel -d -p 8858:8858  bladex/sentinel-dashboard:1.8.8</span><br></pre></td></tr></tbody></table></figure><h3 id="Docker-Compose-安装"><a href="#Docker-Compose-安装" class="headerlink" title="Docker-Compose 安装"></a>Docker-Compose 安装</h3><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sentinel-dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bladex/sentinel-dashboard:1.8.8</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sentinel-dashboard</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8858</span><span class="string">:8858</span></span><br></pre></td></tr></tbody></table></figure><h3 id="测试-Sentinel-Dashboard"><a href="#测试-Sentinel-Dashboard" class="headerlink" title="测试 Sentinel Dashboard"></a>测试 Sentinel Dashboard</h3><p>启动 Sentinel Dashboard 容器后，浏览器通过 <code>http://127.0.0.1:8858/</code> 可以访问控制台管理页面，默认登录用户和密码分别是 <code>sentinel /sentinel</code>。</p><h3 id="Sentinel-Dashboard-持久化"><a href="#Sentinel-Dashboard-持久化" class="headerlink" title="Sentinel Dashboard 持久化"></a>Sentinel Dashboard 持久化</h3><p>Sentinel Dashboard 的流量控制规则默认存储在内存中，重启后会丢失配置规则。若希望通过 Sentinel Dashboard 界面将流量控制规则存储到 Nacos，或者将微服务的流量监控数据持久化存储到 Influxdb 时序数据库，可以使用 Dante Cloud 发布的 <a href="https://hub.docker.com/r/herodotus/sentinel-dashboard">Sentinel Dashboard 镜像</a>。</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sentinel-dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">herodotus/sentinel-dashboard:1.8.8</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sentinel-dashboard</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SENTINEL_ADMIN_USERNAME:</span> <span class="string">sentinel</span></span><br><span class="line">      <span class="attr">SENTINEL_ADMIN_PASSWORD:</span> <span class="string">sentinel</span></span><br><span class="line">      <span class="attr">INFLUXDB_URL:</span> <span class="string">http://127.0.0.1:8086</span></span><br><span class="line">      <span class="attr">INFLUXDB_USERNAME:</span> <span class="string">influx</span></span><br><span class="line">      <span class="attr">INFLUXDB_PASSWORD:</span> <span class="string">influx</span></span><br><span class="line">      <span class="attr">INFLUXDB_DATABASE:</span> <span class="string">sentinel</span></span><br><span class="line">      <span class="attr">NACOS_SERVER_ADDRESS:</span> <span class="string">http://127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">NACOS_CONFIG_DATA_ID_SUFFIX:</span> <span class="string">flow-rules</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8858:8858"</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Dante Cloud 发布的 Sentinel Dashboard 镜像，时序数据存储支持 Influxdb <code>v1.x</code> 版本，Nacos 目前仅支持 <code>v2.x</code> 版本。默认使用 Sentinel Dashboard 原有内存方式存储，可通过配置参数动态开启或者关闭 Influxdb 和 Nacos 存储机制。</p></div>]]></content>
    
    
    <summary type="html">本文主要介绍如何使用 Docker 安装 Sentinel Dashboard 单机。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
</feed>
