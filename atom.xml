<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术空间</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2025-05-29T13:55:33.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 C++ 开发集群聊天服务器</title>
    <link href="https://www.techgrow.cn/posts/e635f0aa.html"/>
    <id>https://www.techgrow.cn/posts/e635f0aa.html</id>
    <published>2025-05-29T13:55:33.000Z</published>
    <updated>2025-05-29T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 实现集群聊天服务器，使用了 Json 库和 Muduo 网络库，并引入了 Redis、MySQL、Nginx 等中间件。</p><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本文实现的 C++ 集群聊天服务器使用到以下技术：</p><ul><li>Muduo 网络库使用</li><li> MySQL 数据库编程</li><li> CMake 构建编译环境</li><li> Json 序列化和反序列化</li><li> Redis 缓存服务器编程实践</li><li> Redis 消息队列编程实践（发布 - 订阅）</li><li>Nginx 源码编译安装和 TCP 负载均衡器配置</li></ul><span id="more"></span><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><table><thead><tr><th>软件</th><th>版本</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>11</code></td></tr><tr><td>G++（GCC）</td><td><code>12.2.0</code></td></tr><tr><td>CMake</td><td><code>3.25.1</code></td></tr><tr><td>Boost</td><td><code>1.74.0.3</code></td></tr><tr><td>Muduo</td><td><code>2.0.3</code></td></tr><tr><td>Redis</td><td><code>7.0.15</code></td></tr><tr><td>MySQL</td><td><code>8.4.5</code></td></tr><tr><td>Nginx</td><td></td></tr><tr><td>Visual Studio Code</td><td><code>1.100.2</code></td></tr><tr><td>Linux</td><td><code>Debian 12</code></td></tr></tbody></table><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>使用 C++ 开发 Linux 应用时，常见的开发环境有以下几种：</p><ul><li>1、<a href="https://blog.csdn.net/icacxygh001/article/details/120981354">Linux 环境下直接使用 VSCode、Clion 等 IDE 进行本地开发</a></li><li> 2、<a href="https://blog.csdn.net/xiaowangabc1/article/details/147927306">Windows + VSCode + MinGW 搭建本地 C/C++ 开发环境</a></li><li> 3、<a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89469717">Windows + Visual Studio 搭建远程 Linux 跨平台项目</a></li><li> 4、<a href="/posts/630b5e44.html">Windows + VSCode 搭建远程 Linux 开发环境</a></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>上面介绍的三种开发环境，任意选择一种自己熟悉的就可以；如果日常使用的是 Windows 系统，建议选择第四种开发环境（VSCode 远程开发）；如果习惯使用 Linux 系统，强烈建议选择第一种开发环境（Linux 本地开发）。</p></div><h3 id="兼容平台"><a href="#兼容平台" class="headerlink" title="兼容平台"></a>兼容平台</h3><p>本文提供的所有 C++ 集群聊天服务器代码都可以兼容 Windows 和 Linux 平台，默认基于 Linux 平台进行开发。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><ul><li>安装常用的工具 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装开发工具</span></span><br><span class="line">sudo apt-get install -y vim git wget curl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装网络工具</span></span><br><span class="line">sudo apt-get install -y telnet tcpdump netcat hping3</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-GCC"><a href="#安装-GCC" class="headerlink" title="安装 GCC"></a>安装 GCC</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC、G++、GDB</span></span><br><span class="line">sudo apt-get install -y build-essential gdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 GCC 版本</span></span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 G++ 版本</span></span><br><span class="line">g++ --version</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-CMake"><a href="#安装-CMake" class="headerlink" title="安装 CMake"></a>安装 CMake</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 CMake</span></span><br><span class="line">sudo apt-get -y install cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 CMake 版本</span></span><br><span class="line">cmake -version</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><ul><li>安装 Redis</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Redis</span></span><br><span class="line">sudo apt-get install -y redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 Redis</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Redis 的运行状态</span></span><br><span class="line">sudo systemctl status redis-server</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Redis 版本</span></span><br><span class="line">redis-server --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 客户端执行 Ping 操作</span></span><br><span class="line">redis-cli ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 Redis 服务器响应以下内容，则说明 Redis 服务器正常运行</span></span><br><span class="line">PONG</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">Redis 默认配置文件的路径</p><p>通过 APT 安装 Redis 服务器后，其主配置文件的路径为 <code>/etc/redis/redis.conf</code>。</p></div><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><ul><li>添加 MySQL 官方 APT 源 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 APT 配置包（访问 https://dev.mysql.com/downloads/repo/apt/ 可以获取最新版本）</span></span><br><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.8.34-1_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 APT 配置包</span></span><br><span class="line"><span class="comment"># 在安装过程中会弹出配置界面，通常默认选择的是 MySQL 8.4 版本，如果需要安装其他版本（如 8.0），可以按回车键进入子菜单选择其他版本</span></span><br><span class="line"><span class="comment"># 由于集群聊天服务器需要使用到 MySQL 客户端，因此还需要安装 MySQL Connectors（不需要改动选择，因为默认已经选择安装）</span></span><br><span class="line">sudo dpkg -i mysql-apt-config_0.8.34-1_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 APT 索引</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></tbody></table></figure><ul><li>安装 MySQL</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 MySQL（安装过程中会提示输入 MySQL 的 root 用户的密码）</span></span><br><span class="line">sudo apt-get install -y mysql-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 MySQL</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 MySQL 的运行状态</span></span><br><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录 MySQL</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 MySQL 版本</span></span><br><span class="line"><span class="keyword">select</span> version();</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">MySQL 默认配置文件的路径</p><p>通过 APT 安装 MySQL 服务器后，其主配置文件的路径为 <code>/etc/mysql/my.cnf</code>。</p></div><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><h3 id="安装-Muduo-库"><a href="#安装-Muduo-库" class="headerlink" title="安装 Muduo 库"></a>安装 Muduo 库</h3><ul><li>编译安装 Muduo 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chenshuo/muduo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入代码目录</span></span><br><span class="line"><span class="built_in">cd</span> muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 CMake 构建</span></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译代码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Muduo 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Muduo 库的静态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep muduo</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Muduo 的编译依赖 CMake，默认编译生成的是静态库（<code>.a</code>），如果需要编译生成共享库（<code>.so</code>），可以自行修改 <code>CMakeLists.txt</code> 中的配置。</li><li>Muduo 支持 C++ 11，仅支持 Linux 平台，不支持 Windows 平台，建议使用 <code>7.x</code> 及以后版本的 <code>g++</code> 编译器。</li></ul></div><h3 id="安装-Boost-库"><a href="#安装-Boost-库" class="headerlink" title="安装 Boost 库"></a>安装 Boost 库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Boost 的所有组件和头文件</span></span><br><span class="line">sudo apt-get install -y libboost-all-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Bootst 版本</span></span><br><span class="line">sudo dpkg -s libboost-all-dev | grep Version</span><br></pre></td></tr></tbody></table></figure><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h3><ul><li>客户端新用户注册</li><li>客户端用户登录</li><li>添加好友和添加群组</li><li>好友聊天</li><li>群组聊天</li><li>离线消息</li><li> Nginx 配置 TCP 负载均衡</li><li>集群聊天系统支持客户端跨服务器通信</li></ul><h3 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h3><ul><li>掌握 Json 的编程应用</li><li>掌握 CMake 构建自动化编译环境</li><li>掌握 Muduo 网络库的编程以及实现原理</li><li>掌握 Nginx 配置部署 TCP 负载均衡器的应用以及原理</li><li>掌握服务器的网络 I/O 模块、业务模块、数据模块分层的设计思想</li><li>掌握服务器中间件的应用场景和基于发布 - 订阅的 Redis 消息队列编程实践以及应用原理</li></ul><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 开发集群聊天服务器。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于 Linux 下 VSCode 搭建 C-C++ 开发环境</title>
    <link href="https://www.techgrow.cn/posts/83b1bb3b.html"/>
    <id>https://www.techgrow.cn/posts/83b1bb3b.html</id>
    <published>2025-05-25T14:25:49.000Z</published>
    <updated>2025-05-25T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>根据您提供的信息（一模 588 分 / 校内 60 名，二模 615 分 / 校内 50 名）以及<strong>官窑第二初级中学的名额分配表</strong>，结合佛山市中考录取规则，以下是志愿填报的针对性建议：</p>]]></content>
    
    
    <summary type="html">本文主要介绍基于 Linux 下 VSCode 如何搭建 C/C++ 开发环境。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>VSCode 搭建远程 Linux 开发环境</title>
    <link href="https://www.techgrow.cn/posts/630b5e44.html"/>
    <id>https://www.techgrow.cn/posts/630b5e44.html</id>
    <published>2025-05-22T14:25:49.000Z</published>
    <updated>2025-05-22T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 VSCode 如何搭建远程 Linux 开发环境（远程开发），实现的效果相当于在远程 Linux 服务器上直接开发 C/C++ 项目，适用于 Windows 系统。</p><span id="more"></span><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><blockquote><p>VSCode 搭建远程 Linux 开发环境的步骤：</p></blockquote><ul><li>(1) 在远程 Linux 系统中运行 SSH 服务</li><li> (2) 在本地 Windows 系统的 VSCode 中安装 C/C++ 相关插件，比如：<ul><li><code>Remote Development</code>：远程开发插件，支持连接远程 Linux 服务器、Docker 容器、WSL。</li><li><code>C/C++</code>：C/C++ 核心插件，提供 C/C++ 智能感知、调试、导航、语法提示等核心功能。</li><li><code>C/C++ Extension Pack</code>：C/C++ 插件组合包，用于一键安装多个与 C/C++ 开发相关的扩展，方便快速配置。</li><li><code>Code Runner</code>：代码快速运行插件（可选），支持多种语言，包括 C/C++、Java、JS、PHP、Python、、Go、Lua 等。</li></ul></li><li>(3) 在本地 Windows 系统的 VSCode 中配置远程 Linux 服务器的信息。</li><li>(4) 在本地 Windows 系统的 VSCode 中连接远程的 Linux 服务器进行开发（即远程开发）。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>VSCode 远程开发的详细搭建教程，可以参考文末给出的 <a href="/posts/630b5e44.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a>。</p></div><blockquote><p>VSCode 安装 C/C++ 相关插件后的样子：</p></blockquote><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-1.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里注意不要安装 <code>C/C++ Runner</code> 插件（直接运行单个或多个 C/C++ 源文件），因为 <code>C/C++ Runner 插件</code> 不会自动安装到远程环境中，也不支持在远程运行，因为它的设计是为了在本地运行程序。</p></div><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="直接运行程序找不到头文件"><a href="#直接运行程序找不到头文件" class="headerlink" title="直接运行程序找不到头文件"></a>直接运行程序找不到头文件</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>当 C/C++ 源文件中引入了自定义的头文件，执行 VSCode 右上角的 <code>运行 C/C++ 文件</code> 按钮运行程序后（如下图所示），会出现找不到头文件的错误。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-2.png"></p><ul><li>这是因为 VSCode 是使用 <code>g++</code> 命令直接编译当前打开的 <code>.cpp</code> 文件，仅执行 <code>g++ file.cpp -o file &amp;&amp; ./file</code> 这种快速编译运行命令，而没有加上自定义头文件所在的目录路径（<code>-I</code> 参数）所导致的。</li></ul><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>创建或编辑当前项目的 <code>.vscode/tasks.json</code> 文件，添加 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"tasks"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"Run Main with include"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-Iinclude"</span>,       <span class="comment">// 指定头文件路径</span></span><br><span class="line">        <span class="string">"main.cpp"</span>,        <span class="comment">// 指定目标源文件名</span></span><br><span class="line">        <span class="string">"-o"</span>,</span><br><span class="line">        <span class="string">"main"</span>             <span class="comment">// 指定输出的可执行文件名</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"group"</span>: <span class="string">"build"</span>,</span><br><span class="line">      <span class="attr">"problemMatcher"</span>: [],</span><br><span class="line">      <span class="attr">"detail"</span>: <span class="string">"Compile with header path"</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑当前项目的 <code>.vscode/launch.json</code> 文件，使用指定的 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Launch main"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"${workspaceFolder}/main"</span>,     <span class="comment">// 指定可执行文件</span></span><br><span class="line">      <span class="attr">"args"</span>: [],</span><br><span class="line">      <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"${workspaceFolder}"</span>,</span><br><span class="line">      <span class="attr">"preLaunchTask"</span>: <span class="string">"Run Main with include"</span>,      <span class="comment">// 指定 Task</span></span><br><span class="line">      <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">      <span class="attr">"miDebuggerPath"</span>: <span class="string">"/usr/bin/gdb"</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>按下快捷键 <code>Ctrl + Shift + D</code>，调出 VSCode 的 <code>运行和调试</code> 面板，然后在顶部选择自定义的配置 <code>Launch main</code>，最后点击左边的 <code>绿色</code> 按钮就可以正常运行程序。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-3.png"></p><ul><li>第一次运行程序后，VSCode 的底部工具栏会新增 <code>Launch main</code> 相关的操作按钮，以后可以直接在底部工具栏运行或调试 C/C++ 程序。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>VSCode 中 <code>运行 C/C++ 文件</code> 按钮的行为非常简单（如下表所示），因此更推荐使用 CMake 管理 C/C++ 项目，并使用 <code>launch.json</code> + <code>task.json</code> 来调用它。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>默认使用 <code>g++</code> 编译当前文件</td><td>忽略项目结构和依赖关系</td></tr><tr><td>不支持多源文件编译</td><td>如果有 <code>main.cpp</code> 和 <code>other.cpp</code>，它不会编译全部源文件</td></tr><tr><td>不自动添加 <code>-I</code>、<code>-L</code> 参数</td><td>所以无法识别头文件或链接库</td></tr><tr><td>不识别 CMake 项目</td><td>所以不适合正式工程</td></tr></tbody></table><h3 id="CMake-项目无法直接运行"><a href="#CMake-项目无法直接运行" class="headerlink" title="CMake 项目无法直接运行"></a>CMake 项目无法直接运行</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>当点击 VSCode 右上角的 <code>运行 C/C++ 文件</code> 按钮时，CMake 项目无法正常运行（如下图所示）。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-4.png"></p><ul><li>这是因为点击 <code>运行 C/C++ 文件</code> 按钮后，其实触发的是 <code>C/C++: Run</code> 快捷命令，这个命令不会走 CMake，而是仅对当前打开的 <code>.cpp</code> 文件执行 <code>g++ file.cpp -o file &amp;&amp; ./file</code> 这种快速编译运行命令。</li></ul><h4 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h4><ul><li>创建或编辑当前项目的 <code>.vscode/tasks.json</code> 文件，添加 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"tasks"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"CMake Build"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"cmake -S . -B build &amp;&amp; cmake --build build"</span>,</span><br><span class="line">      <span class="attr">"problemMatcher"</span>: []</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑当前项目的 <code>.vscode/launch.json</code> 文件，使用指定的 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Run CMake Executable"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"${workspaceFolder}/build/main"</span>,   <span class="comment">// 指定 CMake 输出的可执行文件名</span></span><br><span class="line">      <span class="attr">"args"</span>: [],</span><br><span class="line">      <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"${workspaceFolder}"</span>,</span><br><span class="line">      <span class="attr">"preLaunchTask"</span>: <span class="string">"CMake Build"</span>,   <span class="comment">// 指定 Task</span></span><br><span class="line">      <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">      <span class="attr">"miDebuggerPath"</span>: <span class="string">"/usr/bin/gdb"</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>按下快捷键 <code>Ctrl + Shift + D</code>，调出 VSCode 的 <code>运行和调试</code> 面板，然后在顶部选择自定义的配置 <code>Run CMake Executable</code>，最后点击左边的 <code>绿色</code> 按钮就可以正常运行 CMake 项目。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-5.png"></p><ul><li>第一次运行程序后，VSCode 的底部工具栏会新增 <code>Launch main</code> 相关的操作按钮，以后可以直接在底部工具栏运行或调试 CMake 项目。</li></ul><h4 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h4><p>在 VSCode 中安装 <code>CMake Tools</code> 插件，打开 CMake 项目后点击左下角状态栏，确认 <code>CMake Tools</code> 插件已经识别 CMake 项目，然后就可以选择生成、调试、运行 CMake 项目了。</p><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-6.png"></p><h3 id="免密码连接远程-Linux-服务器"><a href="#免密码连接远程-Linux-服务器" class="headerlink" title="免密码连接远程 Linux 服务器"></a>免密码连接远程 Linux 服务器</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>VSCode 安装完 <code>Remote Development</code> 插件后，每次连接远程的 Linux 服务器都会提示输入密码，非常不方便。</p><h4 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>(1) 在本地的 Windows 系统中，安装 Git Bash 工具；然后在 Git Bash 中执行以下命令生成 SSH 公钥，默认保存位置是：<code>~/.ssh/id_rsa</code>（私钥）和 <code>~/.ssh/id_rsa.pub</code>（公钥）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 SSH 秘钥对，一路回车即可（通常无需设置密码）</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 在本地的 Git Bash 中，执行以下命令将公钥拷贝到远程 Linux 服务器中 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝公钥到远程 Linux 服务器（第一次会要求输入远程服务器的密码，之后设置完成即可免密）</span></span><br><span class="line">ssh-copy-id root@192.168.1.100</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 测试 SSH 登录是否免密成功 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.1.100</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 重新打开 VSCode，观察是否成功免密建立远程连接</li></ul><h3 id="C-C-代码实现格式化"><a href="#C-C-代码实现格式化" class="headerlink" title="C/C++ 代码实现格式化"></a>C/C++ 代码实现格式化</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>VSCode 默认的 C/C++ 代码格式化效果不太好，比如每个大括号都是换行显示的。</p><h4 id="问题解决-2"><a href="#问题解决-2" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>(1) 在远程 Linux 服务器上安装 <code>clang-format</code> 代码格式化工具 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y clang-format</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 在本地的 VSCode 中安装 Clang-Format 插件</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-7.png"></p><ul><li> (3) 创建或编辑当前项目的 <code>.vscode/settings.json</code> 文件，添加以下配置内容：</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">// C 代码格式化配置</span></span><br><span class="line">    <span class="attr">"[c]"</span>: {</span><br><span class="line">        <span class="attr">"editor.defaultFormatter"</span>: <span class="string">"xaver.clang-format"</span>,    <span class="comment">// 指定格式化器，远程服务器必须先安装 clang-format 工具</span></span><br><span class="line">        <span class="attr">"editor.formatOnSave"</span>: <span class="literal">true</span>    <span class="comment">// 可选，保存文件时自动格式化</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// C++ 代码格式化配置</span></span><br><span class="line">    <span class="attr">"[cpp]"</span>: {</span><br><span class="line">        <span class="attr">"editor.defaultFormatter"</span>: <span class="string">"xaver.clang-format"</span>,    <span class="comment">// 指定格式化器，远程服务器必须先安装 clang-format 工具</span></span><br><span class="line">        <span class="attr">"editor.formatOnSave"</span>: <span class="literal">true</span>    <span class="comment">// 可选，保存文件时自动格式化</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 配置 VSCode 的 C/C++ 代码格式化快捷键<ul><li>按 <code>Ctrl + Shift + P</code> 组合建打开命令面板</li><li>输入 <code>Preferences: Open Keyboard Shortcuts (JSON)</code> 并回车</li><li>在打开的 <code>keybindings.json</code> 文件里，添加以下配置内容：<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="comment">// 格式化选中的 C/C++ 代码块</span></span><br><span class="line">    {</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"ctrl+l"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"editor.action.formatSelection"</span>,</span><br><span class="line">        <span class="attr">"when"</span>: <span class="string">"editorTextFocus &amp;&amp; (editorLangId == 'cpp' || editorLangId == 'c') &amp;&amp; editorHasSelection"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 格式化整个 C/C++ 源文件</span></span><br><span class="line">    {</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"ctrl+l"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"editor.action.formatDocument"</span>,</span><br><span class="line">        <span class="attr">"when"</span>: <span class="string">"editorTextFocus &amp;&amp; (editorLangId == 'cpp' || editorLangId == 'c') &amp;&amp; !editorHasSelection"</span></span><br><span class="line">    }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/weixin_51278158/article/details/130186395">VSCode 使用 SSH 进行远程开发</a></li><li><a href="https://cloud.tencent.com/developer/article/2282762">VSCode 远程开发 - SSH 入门保姆级教程</a></li><li><a href="https://blog.csdn.net/qq_41897304/article/details/131282774">Windows 平台下 VSCode 配置远程 Linux 开发环境</a></li><li><a href="https://www.cnblogs.com/lidabo/p/18348376">Windows 平台使用 VSCode 远程连接 Linux 进行 C++ 开发配置教程</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 VSCode 如何搭建远程 Linux 开发环境。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Muduo 网络编程实战</title>
    <link href="https://www.techgrow.cn/posts/def1afc3.html"/>
    <id>https://www.techgrow.cn/posts/def1afc3.html</id>
    <published>2025-05-22T13:55:33.000Z</published>
    <updated>2025-05-22T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 Muduo 网络库的使用实战，在使用 Muduo 之前，建议先熟悉并掌握以下技术内容：</p><ul><li>熟悉 C++ 11 语法</li><li>掌握事件驱动模型（Reactor 模式）</li><li>熟悉 C/C++ 多线程并发和线程安全设计</li><li>熟悉 Linux 网络编程（如使用 <code>epoll</code>、<code>socket</code>）</li></ul><span id="more"></span><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul><li><a href="https://github.com/chenshuo/muduo">Muduo 的 GitHub 项目</a></li><li><a href="https://blog.csdn.net/Solstice">Muduo 作者的官方博客</a></li></ul><h2 id="Muduo-介绍"><a href="#Muduo-介绍" class="headerlink" title="Muduo 介绍"></a>Muduo 介绍</h2><h3 id="Muduo-的简介"><a href="#Muduo-的简介" class="headerlink" title="Muduo 的简介"></a>Muduo 的简介</h3><p>Muduo 是一个用 C++ 编写的高性能、基于事件驱动的网络库，专门设计用于构建 Linux 下高并发、低延迟的网络服务，特别适合开发分布式系统、微服务、消息中间件、网络游戏服务器等后端程序。</p><ul><li><p>核心特性</p><ul><li>基于事件驱动模型：使用 Reactor 模式，即单线程 I/O + 多线程计算。</li><li>高性能：使用 <code>epoll</code> I/O 多路复用技术、非阻塞 I/O、零内存拷贝技术。</li><li>线程安全：网络部分是线程安全的，使用线程池和回调。</li><li>C++ 11 标准：需要使用支持 C++ 11 的编译器。</li><li>仅支持 Linux 平台：利用 Linux 特性优化性能，不支持跨平台。</li><li>可组合性强：解耦的模块设计，便于扩展和组合。</li></ul></li><li><p>核心模块</p><ul><li><code>base</code>（基础模块）<ul><li>非网络相关的通用工具</li><li>如线程池、时间戳、日志系统、原子操作等</li></ul></li><li><code>net</code>（网络模块）<ul><li>TCP 服务器 / 客户端模型</li><li> Reactor 事件分发器</li><li> Buffer、Channel、EventLoop、TcpConnection 等核心组件</li></ul></li></ul></li><li><p>核心组件</p><ul><li>EventLoop<ul><li> 事件循环，是每个线程的核心对象</li><li>封装了 <code>epoll</code> 库，处理文件描述符的读写事件</li></ul></li><li> Channel<ul><li> 表示一个 <code>fd</code>（文件描述符）及其感兴趣的事件（如读写）</li><li>是 EventLoop 与具体 I/O 事件之间的桥梁</li></ul></li><li> Poller<ul><li> 封装 <code>epoll</code> 或 <code>poll</code> 的接口（Muduo 默认用 <code>epoll</code>）</li></ul></li><li>TcpServer / TcpClient<ul><li> 高层封装，简化服务端和客户端的使用</li><li>支持多线程连接处理</li></ul></li><li> Callback 机制<ul><li>所有 I/O 事件都通过用户注册的回调函数处理（高扩展性）</li></ul></li></ul></li><li><p>性能优势</p><ul><li>完全采用非阻塞、异步 I/O 模型</li><li>使用智能指针管理资源（如 <code>std::shared_ptr&lt;TcpConnection&gt;</code>）</li><li>零内存拷贝的数据缓冲机制（Buffer）</li><li>合理利用多线程资源（EventLoopThreadPool）</li></ul></li><li><p>适用场景</p><ul><li>高并发 TCP 服务器（如 Redis、MQTT、游戏网关）</li><li>微服务通信框架（可自定义通信协议）</li><li>高性能 HTTP 服务（支持 HTTP 1.0/1.1）</li><li>自研 RPC 系统</li></ul></li></ul><div class="admonition note"><p class="admonition-title">平台兼容性</p><ul><li>Muduo 库只支持 Linux 平台，不兼容 Windows 平台，因为其底层使用了 Linux 平台的 <code>pthread</code> 和 <code>epoll</code>。</li></ul></div><h3 id="Muduo-的多线程模型"><a href="#Muduo-的多线程模型" class="headerlink" title="Muduo 的多线程模型"></a>Muduo 的多线程模型</h3><ul><li><p>方案一</p><ul><li><code>accept + read/write</code></li><li>不适用于并发服务器</li></ul></li><li><p>方案二</p><ul><li><code>accept + fork - process-pre-connection</code></li><li>适合并发连接数不大，计算任务工作量大于 Fork 的开销。</li></ul></li><li><p>方案三</p><ul><li><code>accept + thread - thread-pre-connection</code></li><li>比方案二的开销小了一点，但是并发造成的线程堆积过多。</li></ul></li><li><p>方案四</p><ul><li><code>reactors in threads - one loop per thread</code></li><li>这是 Muduo 库的网络设计方案，适用于并发连接数较大的场景。</li><li>有一个 Main Reactor 负载 Accept 连接，然后将连接分发给某个 SubReactor (采用轮询的方式来选择 SubReactor)，该连接的所用操作都在那个 SubReactor 所处的线程中完成。多个连接可能被分派到多个线程中被处理，以充分利用 CPU。</li><li>有一个 Base I/O Thread 负责 Accept 新的连接，接收到新的连接以后，使用轮询的方式在 Reactor Pool 中找到合适的 SubReactor 将这个连接挂载上去，这个连接上的所有任务都在这个 SubReactor  所处的线程中完成。Reactor Poll 的大小是固定的，根据 CPU 的核心数量来确定。</li><li>如果有过多的耗费 CPU 资源的计算任务，可以提交到创建的 ThreadPool 线程池中专门处理耗时的计算任务。</li></ul></li><li><p>方案五</p><ul><li><code>reactors in process - one loop pre process</code></li><li>这是 Nginx 服务器的网络设计方案，基于进程设计，采用多个 Reactors 充当 I/O 进程和工作进程，通过一个 <code>accept</code> 锁，完美解决多个 Reactors 之间的 “惊群现象”。</li></ul></li></ul><h3 id="Muduo-的-Reactor-模型"><a href="#Muduo-的-Reactor-模型" class="headerlink" title="Muduo 的 Reactor 模型"></a>Muduo 的 Reactor 模型</h3><blockquote><p>The reactor design pattern is an event handling pattern for handling service<br>requests delivered concurrently to a service handler by one or more inputs.<br>The service handler then demultiplexes the incoming requests and dispatches<br>them synchronously to the associated request handlers.</p></blockquote><h2 id="Muduo-安装"><a href="#Muduo-安装" class="headerlink" title="Muduo 安装"></a>Muduo 安装</h2><ul><li>编译安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chenshuo/muduo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入代码目录</span></span><br><span class="line"><span class="built_in">cd</span> muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 CMake 构建</span></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译代码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Muduo 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Muduo 库的静态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep muduo</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Muduo 的编译依赖 CMake，默认编译生成的是静态库（<code>.a</code>），如果需要编译生成共享库（<code>.so</code>），可以自行修改 <code>CMakeLists.txt</code> 中的配置。</li><li>Muduo 支持 C++ 11，仅支持 Linux 平台，不支持 Windows 平台，建议使用 <code>7.x</code> 及以后版本的 <code>g++</code> 编译器。</li></ul></div><h2 id="Muduo-使用"><a href="#Muduo-使用" class="headerlink" title="Muduo 使用"></a>Muduo 使用</h2><p>Muduo 网络库的使用很容易，要实现基于 Muduo 网络库的 TCP 客户端和服务器程序，只需要简单地组合使用 <code>TcpServer</code> 和 <code>TcpClient</code> 就可以。</p><h3 id="使用-Muduo-的日志系统"><a href="#使用-Muduo-的日志系统" class="headerlink" title="使用 Muduo 的日志系统"></a>使用 Muduo 的日志系统</h3><h3 id="TCP-客户端和服务器实现"><a href="#TCP-客户端和服务器实现" class="headerlink" title="TCP 客户端和服务器实现"></a>TCP 客户端和服务器实现</h3><h3 id="使用-Muduo-的线程池执行任务"><a href="#使用-Muduo-的线程池执行任务" class="headerlink" title="使用 Muduo 的线程池执行任务"></a>使用 Muduo 的线程池执行任务</h3>]]></content>
    
    
    <summary type="html">本文主要介绍 Muduo 网络编程实战。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 手写线程池</title>
    <link href="https://www.techgrow.cn/posts/585aa296.html"/>
    <id>https://www.techgrow.cn/posts/585aa296.html</id>
    <published>2025-05-13T13:55:33.000Z</published>
    <updated>2025-05-13T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 手写一个线程池，并分别提供 C++ 11 和 C++ 17 两种版本的线程池实现。线程池作为五大池之一（内存池、连接池、协程池、线程池、进程池），应用非常广泛，不管是客户端程序，还是后台服务程序，都是提高业务处理能力的必备模块。有很多开源的线程池实现，虽然各自接口在使用上稍有区别，但是其核心实现原理都是基本相同的。</p><h3 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h3><p>在基于 C++ 手写线程池之前，应该熟悉并掌握以下技术内容：</p><ul><li>熟练基于 C++ 11 的面向对象编程</li><li>熟悉组合和继承、继承多态、STL 容器、智能指针、函数对象、绑定器、<code>lambda</code> 表达式、可变参数模板编程等。</li><li>熟悉 C++ 11 多线程编程，比如线程互斥、线程同步、原子操作、CAS 等。</li><li>熟悉 <code>thread</code>、<code>mutex</code>、<code>unique_lock</code>、<code>condition_variable</code>、<code>atomic</code> 等。</li><li>熟悉 C++ 17 和 C++ 20 的新特性，比如 C++ 17 的 <code>any</code> 类型和 C++ 20 的 <code>counting_semaphore</code> 信号量类型等。</li></ul><span id="more"></span><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>本文使用以下工具来开发 C++ 线程池项目：</p><ul><li>C++ 11 / C++ 17</li><li>Visual Studio 2019</li><li>CMake 构建编译环境</li><li> GDB 调试分析定位线程死锁问题</li><li> Linux 编译项目生成动态链接库（<code>.so</code>）</li></ul><h3 id="版本特性"><a href="#版本特性" class="headerlink" title="版本特性"></a>版本特性</h3><p>C++ 各版本支持的特性如下：</p><table><thead><tr><th>特性名称</th><th>对应头文件</th><th>最低支持的 C++ 标准版本</th><th>说明</th></tr></thead><tbody><tr><td><code>std::make_unique</code></td><td><code>&lt;memory&gt;</code></td><td>C++ 14</td><td>C++ 14 引入，用于简洁安全地创建 <code>unique_ptr</code> 智能指针。</td></tr><tr><td><code>std::any</code></td><td><code>&lt;any&gt;</code></td><td>C++ 17</td><td> 提供类型安全的类型擦除容器。</td></tr><tr><td><code>std::counting_semaphore</code></td><td><code>&lt;semaphore&gt;</code></td><td>C++ 20</td><td>C++ 20 引入的信号量机制。</td></tr><tr><td><code>std::packaged_task</code></td><td><code>&lt;future&gt;</code></td><td>C++ 11</td><td> 将可调用对象封装起来，并用于异步执行。</td></tr><tr><td><code>std::future</code></td><td><code>&lt;future&gt;</code></td><td>C++ 11</td><td> 异步操作的结果获取机制，可以与 <code>std::async</code>、<code>std::promise</code> 搭配使用。</td></tr><tr><td>可变参数模板</td><td>语言特性</td><td> C++ 11</td><td> 支持模板中参数数量可变，用于构建灵活函数模板，如递归参数展开等。</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><p>如果使用的是 GCC、Clang 或 MSVC 编译器，需确保编译器版本也支持相应的 C++ 标准。若需进一步查询编译器支持的标准或特性情况，可以参考 <a href="https://zh.cppreference.com">C/C++ 参考手册</a>。</p></div><h3 id="兼容平台"><a href="#兼容平台" class="headerlink" title="兼容平台"></a>兼容平台</h3><p>本文提供的所有 C++ 线程池代码都可以兼容 Windows 和 Linux 平台，并分别提供 C++ 11 和 C++ 17 两种版本的线程池实现。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li><p><strong>并发（Concurrency）</strong></p><ul><li>在单核处理器上，多个线程之间通过操作系统的调度机制交替执行，每个线程轮流占用 CPU 的时间片（例如每 10 毫秒切换一次）。由于每个线程执行的时间片非常短，人们在宏观上感受到这些线程像是 “同时” 在执行一样，虽然它们在物理层面上是串行执行的。这种 “看起来同时执行” 的场景被称为并发。</li></ul></li><li><p><strong>并行（Parallelism）</strong></p><ul><li>在多核处理器或多 CPU 系统中，多个线程可以被分配到不同的核心上同时执行，彼此之间互不抢占 CPU 时间资源，是真正意义上的 “同时执行”。这种多个任务在物理层面并行的执行方式称为并行。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>简而言之，并发是 "逻辑上的同时发生"，并行是 "物理上的同时进行"。</p></div><h3 id="多线程的适用场景"><a href="#多线程的适用场景" class="headerlink" title="多线程的适用场景"></a>多线程的适用场景</h3><p>多线程程序的性能就一定好吗？不一定，要看具体的应用场景：</p><ul><li><p><strong>I/O 密集型场景</strong></p><ul><li>对于涉及大量 I/O 操作（如磁盘读写、网络通信、数据库访问等）的程序，这些操作通常会导致线程阻塞，从而释放 CPU 时间片。此时，通过多线程并发处理，可以有效利用 CPU 的空闲时间，提高程序的吞吐量和响应速度。因此，无论是 CPU 单核、CPU 多核、多 CPU，多线程通常都能带来较好的性能提升，因此适合运行多线程程序。</li></ul></li><li><p><strong>CPU 密集型场景</strong></p><ul><li>CPU 单核<ul><li>在 CPU 单核中，多个线程无法真正并行执行，只能通过 CPU 时间片轮转实现 “伪并发”。多线程会导致频繁的线程上下文切换，增加 CPU 调度开销，甚至可能因为线程数量过多而拖慢整体性能。<strong>在这种情况下，使用单线程可能反而更高效，因此不适合运行多线程程序</strong>。</li></ul></li><li>CPU 多核、多 CPU<ul><li> 多个线程可以被调度到多个核心上并行运行，从而充分利用计算资源，提高程序的运行效率。对于 CPU 密集型任务（如图像处理、大规模计算等），多线程可以显著提升性能，尤其是在合理控制线程数量、避免过度竞争的前提下，因此适合运行多线程程序。</li></ul></li></ul></li></ul><h3 id="多线程的协作机制"><a href="#多线程的协作机制" class="headerlink" title="多线程的协作机制"></a>多线程的协作机制</h3><p>在 C++ 中，为了实现多线程之间的正确协作与安全访问共享资源，通常需要使用线程互斥与线程同步机制。</p><h4 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h4><p>线程互斥用于防止多个线程同时访问共享资源，从而避免数据竞争和数据不一致的问题。常用机制包括：</p><ul><li><p><code>mutex</code> 互斥锁</p><ul><li>提供基本的加锁与解锁操作（<code>lock()</code> / <code>unlock()</code> 或 <code>lock_guard</code> / <code>unique_lock</code> 自动管理），确保同一时间只有一个线程能够访问临界区（共享资源）。</li></ul></li><li><p><code>recursive_mutex</code> 递归互斥锁</p><ul><li>支持同一个线程多次对同一个互斥锁加锁，适用于递归函数调用场景。</li></ul></li><li><p><code>atomic</code> 原子类型</p><ul><li>提供无锁的并发访问机制，支持原子操作，如自增、比较交换等，适用于简单共享变量的并发访问，性能较高。</li></ul></li></ul><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>线程同步用于协调多个线程之间的执行顺序，例如一个线程等待另一个线程完成某项任务后再继续执行。常用机制包括：</p><ul><li><p><code>condition_variable</code> 条件变量</p><ul><li>配合互斥锁（<code>mutex</code>）使用，允许线程在满足某个条件之前进入等待状态，并在条件满足后被唤醒。适合用于生产者 - 消费者模型等场景。</li></ul></li><li><p><code>semaphore</code> 信号量（C++ 20 引入）</p><ul><li>用于控制对某个资源的并发访问数量，即限制同一时刻最多有 N 个线程访问某个共享资源（可用作限流器），适用于如电商秒杀、停车场停车等业务场景。</li></ul></li><li><p><code>barrier</code> / <code>latch</code>（C++ 20 引入）</p><ul><li>用于多线程之间的阶段性同步。例如，所有线程都执行到某一步后再一起进入下一阶段。</li></ul></li></ul><h3 id="多线程的额外开销"><a href="#多线程的额外开销" class="headerlink" title="多线程的额外开销"></a>多线程的额外开销</h3><p>为了完成任务，创建很多的线程可以吗？线程真的是越多越好吗？答案是否定的。</p><ul><li>线程的创建和销毁都是非常 “重” 的操作（涉及用户空间和内核空间的切换）；</li><li>线程栈（通常为 8MB）本身占用大量内存空间；</li><li>线程的上下文切换需要占用大量时间；</li><li>大量线程同时唤醒，会导致操作系统经常出现锯齿状负载或者瞬间负载量很大，造成系统宕机。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Linux 平台下，通过 <code>pthread</code> 库默认最多可以创建约 <code>380</code> 个线程。若希望创建更多的线程，可以降低线程栈的大小（比如 8KB），还可以增大 Linux 系统的最大可打开文件描述符数（<code>ulimit -n</code>），或者最大可创建的用户进程数 / 线程数（<code>ulimit -u</code>）。</p></div><h2 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h2><h3 id="线程池的使用优势"><a href="#线程池的使用优势" class="headerlink" title="线程池的使用优势"></a>线程池的使用优势</h3><p>在操作系统中，线程的创建和销毁都是较为 “昂贵” 的操作，不仅耗时，而且会消耗较多的系统资源。如果在服务运行过程中，每当有任务到来就动态创建线程来执行，任务完成后又立即销毁线程，那么在高并发或大流量场景下，频繁的线程创建与销毁会显著降低系统的实时响应能力，增加 CPU 开销，从而影响整体业务的处理效率。线程池的出现正是为了解决这一问题。在线程池机制中，服务进程在启动阶段就会预先创建好一组可复用的线程（即线程池），这些线程会在后台处于等待状态。当业务任务到来时，系统无需重新创建线程，而是直接从线程池中取出一个空闲线程来执行任务（Task）。任务执行完毕后，该线程不会被销毁，而是归还给线程池，等待下一次任务（Task）的分配。</p><ul><li>线程池带来了多种优势：<ul><li>减少线程创建和销毁的开销，提高系统性能；</li><li>避免线程资源耗尽，通过线程池大小限制线程总数，控制系统并发量；</li><li>提升响应速度，线程可立即复用，减少任务启动延迟；</li><li>便于线程管理和监控，统一由线程池控制线程生命周期和运行状态。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>线程池是一种非常重要的并发编程工具，特别适用于高并发、高吞吐、对实时性有要求的业务场景。</p></div><h3 id="线程池的两种模式"><a href="#线程池的两种模式" class="headerlink" title="线程池的两种模式"></a>线程池的两种模式</h3><ul><li><p><strong>Fixed 模式线程池（固定大小线程池）</strong></p><ul><li>在这种模式下，线程池中的线程数量在创建时就被固定，且在整个线程池的生命周期内保持不变。一般在初始化线程池时，会根据当前机器的 CPU 核心数量或业务需求设定一个合理的线程数。</li><li>当有任务到来时，如果线程池中有空闲线程，则立即分配执行；如果线程都处于忙碌状态，则任务会被放入等待队列中，排队等待有空闲的线程。</li><li>Fixed 模式适合任务量较为稳定、对系统资源可控性要求较高的场景，有助于防止线程数量膨胀导致系统负载过高。</li></ul></li><li><p><strong>Cached 模式线程池（缓存线程池）</strong></p><ul><li>在这种模式下，线程池的线程数量不是固定的，而是可以根据实际任务量动态增长。当有新的任务到来时，如果线程池中没有空闲线程，会临时创建新的线程来处理任务，并在任务完成后将其归还到线程池中。</li><li>为了防止线程无限增长，通常会设置一个线程最大数量的阀值。此外，如果某个线程在空闲超过指定时间（如 60 秒）后仍无新任务可执行，它将被自动销毁，从而释放资源。线程池会始终保留初始的核心线程数，用于处理正常业务流量。</li><li>Cached 模式适用于任务处理量波动较大、流量突发性强的场景，可以在短时间内快速扩展线程池以应对高并发流量，但需要注意合理设置线程上限以避免资源耗尽。</li></ul></li></ul><h2 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h2><h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><p><img data-src="../../../asset/2025/05/cxx-thread-pool-1.png"></p><h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><ul><li>(1) 基于 C++ 可变参数模板编程和引用折叠原理，实现线程池 <code>submitTask</code> 接口，支持任意任务函数和任意参数的传递</li><li> (2) 使用 <code>future</code> 类型定制 <code>submitTask</code> 接口提交任务的返回值</li><li> (3) 使用 <code>map</code> 和 <code>queue</code> 容器管理线程对象和任务</li><li> (4) 基于条件变量 <code>condition_variable</code> 和互斥锁 <code>mutex</code> 实现任务提交线程和任务执行线程间的同步通信机制</li><li> (5) 支持 <code>fixed</code> 模式和 <code>cached</code> 模式的线程池定制</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="C-11-版本"><a href="#C-11-版本" class="headerlink" title="C++ 11 版本"></a>C++ 11 版本</h4><p>这里基于 C++ 11 手写一个线程池，并自行实现 <code>make_unique()</code>、<code>any</code> 类型、信号量类型。</p><div class="admonition note"><p class="admonition-title">代码下载</p><p>C++ 11 实现线程池的完整案例代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-project-thread-pool/c%2B%2B-11-thread-pool">这里</a> 下载得到，所有案例代码都兼容 Windows 和 Linux 平台。</p></div><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><ul><li><code>extend.h</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXTEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// make_unique() /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> extend {</span><br><span class="line">    <span class="comment">// 创建非数组类型对象</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;!std::is_array&lt;T&gt;::value, std::unique_ptr&lt;T&gt;&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">make_unique</span><span class="params">(Args &amp;&amp;... args)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建未知大小的数组（例如 make_unique&lt;T[]&gt;(n)）</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;std::is_array&lt;T&gt;::value &amp;&amp; std::extent&lt;T&gt;::value == <span class="number">0</span>, std::unique_ptr&lt;T&gt;&gt;::type</span><br><span class="line">    <span class="built_in">make_unique</span>(std::<span class="keyword">size_t</span> size) {</span><br><span class="line">        <span class="keyword">using</span> ElementType = <span class="keyword">typename</span> std::remove_extent&lt;T&gt;::type;</span><br><span class="line">        <span class="keyword">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> ElementType[size]());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止使用定长数组（例如 make_unique&lt;int[10]&gt; 是不合法的）</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;(std::extent&lt;T&gt;::value != <span class="number">0</span>), <span class="keyword">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">make_unique</span><span class="params">(Args &amp;&amp;...)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// Any 类型 /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any 类型（可以接收任意数据类型）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Any</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用带左值的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Any</span>(<span class="keyword">const</span> Any &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用带左值的赋值运算符</span></span><br><span class="line">    Any &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Any &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值的拷贝构造函数（移动拷贝构造）</span></span><br><span class="line">    <span class="built_in">Any</span>(Any&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值的赋值运算符（移动赋值运算符）</span></span><br><span class="line">    Any &amp;<span class="keyword">operator</span>=(Any &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用构造函数（让 Any 类型可以接收任意数据类型）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(T&amp;&amp; data)</span> : base_(extend::make_unique&lt;Derive&lt;typename std::decay&lt;T&gt;::type&gt;&gt;(std::forward&lt;T&gt;(data))) {</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换（将 Any 类型存储的数据类型提取出来）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T <span class="title">cast</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (base_ == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"Any is empty"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将基类指针转换为派生类指针（类型向下转换）</span></span><br><span class="line">        Derive &lt;T&gt; *p = <span class="keyword">dynamic_cast</span>&lt;Derive &lt;T&gt; *&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"type is unmatch!"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回真实的数据类型</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;<span class="built_in">getData</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 基类类型</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 虚析构函数</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类类型</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 通用构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">        <span class="title">Derive</span><span class="params">(U &amp;&amp;data)</span> : data_(std::forward&lt;U&gt;(data)) {</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~<span class="built_in">Derive</span>() {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> data_;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T data_;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;    <span class="comment">// 基类指针</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// Semaphore 信号量 /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量类（用于线程通信）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Semaphore</span>(<span class="keyword">int</span> limit = <span class="number">0</span>) : <span class="built_in">limit_</span>(limit), <span class="built_in">isDestroyed</span>(<span class="literal">false</span>) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Semaphore</span>() {</span><br><span class="line">        <span class="comment">// 标记当前对象已经被析构</span></span><br><span class="line">        isDestroyed = <span class="literal">true</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个信号量资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!isDestroyed) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待信号量资源</span></span><br><span class="line">            cond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> limit_ &gt; <span class="number">0</span>; });</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更改资源计数</span></span><br><span class="line">            limit_--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个信号量资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!isDestroyed) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更改资源计数</span></span><br><span class="line">            limit_++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知其他线程获取信号量资源</span></span><br><span class="line">            <span class="comment">// 特别注意，在默认情况下，Linux 平台中 condition_variable 的析构函数什么也没做，会导致这里状态已经失效；一旦外部使用它的对象（比如 Result）提前析构，就会无故阻塞线程，造成线程死锁</span></span><br><span class="line">            cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> limit_;                     <span class="comment">// 资源计数</span></span><br><span class="line">    std::mutex mtx_;                <span class="comment">// 互斥锁</span></span><br><span class="line">    std::condition_variable cond_;  <span class="comment">// 条件变量</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isDestroyed;   <span class="comment">// 是否已经被析构（用于解决Linux平台的兼容问题）</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EXTEND_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>thread_pool.h</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"extend.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池核心参数 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的线程数量（默认是CPU的核心数）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INIT_THREAD_SIZE = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TASK_MAX_THRESHHOLD = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_SIZE_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程允许的最大空闲时间（单位秒）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">PoolMode</span> {</span></span><br><span class="line">    MODE_FIXED,    <span class="comment">// 固定大小线程池</span></span><br><span class="line">    MODE_CACHED    <span class="comment">// 缓存线程池</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务抽象类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务执行结果类的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Task</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Task</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数，实现用户自定义的任务处理逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Result *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Result *result_;    <span class="comment">// 任务执行结果（使用裸指针，避免智能指针循环引用问题）</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务结果类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="keyword">bool</span> isValid = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Result</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    <span class="function">Any <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(Any data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断任务执行结果是否有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断关联的任务是否已完成</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFinished</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Any data_;                        <span class="comment">// 存储任务执行的结果</span></span><br><span class="line">    Semaphore sem_;                   <span class="comment">// 线程通信的信号量</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isValid_;        <span class="comment">// 任务执行结果是否有效</span></span><br><span class="line">    std::shared_ptr&lt;Task&gt; task_;      <span class="comment">// 关联的任务</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isFinished_;     <span class="comment">// 关联的任务是否已执行完成</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数对象的类型</span></span><br><span class="line">    <span class="keyword">using</span> ThreadHandler = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程构造</span></span><br><span class="line">    <span class="built_in">Thread</span>(ThreadHandler handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程析构</span></span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程ID</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> threadId_;                    <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> generateId_;           <span class="comment">// 用于辅助生成全局唯一的线程ID</span></span><br><span class="line">    ThreadHandler threadHandler_;     <span class="comment">// 线程处理函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池析构</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initThreadSize = INIT_THREAD_SIZE)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务给线程池</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Result&gt; <span class="title">submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池的运行状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理已完成的任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanTaskResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;        <span class="comment">// 线程集合</span></span><br><span class="line">    PoolMode poolMode_;                                               <span class="comment">// 线程池的模式</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isPoolRuning_;                                   <span class="comment">// 表示线程池是否正在运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> initThreadSize_;                                           <span class="comment">// 初始的线程数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> idleThreadSize_;                                  <span class="comment">// 空闲线程的数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> curThreadSize_;                                   <span class="comment">// 当前线程池的线程数量</span></span><br><span class="line">    <span class="keyword">int</span> threadSizeMaxThreshHold_;                                     <span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"></span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;Task&gt;&gt; taskQueue_;                     <span class="comment">// 任务队列</span></span><br><span class="line">    std::<span class="keyword">atomic_uint</span> taskSize_;                                       <span class="comment">// 当前任务队列的任务数量</span></span><br><span class="line">    <span class="keyword">size_t</span> taskQueMaxThreshHold_;                                     <span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"></span><br><span class="line">    std::mutex taskQueMtx_;                                           <span class="comment">// 任务队列操作的互斥锁</span></span><br><span class="line">    std::condition_variable notFull_;                                 <span class="comment">// 表示任务队列不满，用于通知用户线程提交任务</span></span><br><span class="line">    std::condition_variable notEmpty_;                                <span class="comment">// 表示任务队列不空，用于通知线程池中的线程执行任务</span></span><br><span class="line">    std::condition_variable allExit_;                                 <span class="comment">// 表示等待线程池回收所有线程</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Result&gt;&gt; taskResults_;                <span class="comment">// 任务执行结果列表，用于避免任务执行结果比任务早被析构</span></span><br><span class="line">    std::mutex taskResultsMtx_;                                       <span class="comment">// 任务执行结果的互斥锁</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// THREAD_POOL_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>thread_pool.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务抽象类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Task::<span class="built_in">Task</span>() : <span class="built_in">result_</span>(<span class="literal">nullptr</span>) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task::exec</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 执行任务处理逻辑（发生多态调用）</span></span><br><span class="line">    Any data = <span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="keyword">if</span> (result_ != <span class="literal">nullptr</span>) {</span><br><span class="line">        result_-&gt;<span class="built_in">setVal</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task::setResult</span><span class="params">(Result *p)</span> </span>{</span><br><span class="line">    result_ = p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务结果类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Result::<span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="keyword">bool</span> isValid) : <span class="built_in">task_</span>(task), <span class="built_in">isValid_</span>(isValid), <span class="built_in">isFinished_</span>(<span class="literal">false</span>) {</span><br><span class="line">    <span class="comment">// 关联任务和任务执行结果</span></span><br><span class="line">    task-&gt;<span class="built_in">setResult</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取任务执行结果</span></span><br><span class="line"><span class="function">Any <span class="title">Result::get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 如果任务执行结果无效，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!isValid_) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待获取一个信号量资源（即让当前线程等待任务执行完成）</span></span><br><span class="line">    sem_.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回任务执行完成的结果</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(data_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Result::setVal</span><span class="params">(Any data)</span> </span>{</span><br><span class="line">    <span class="comment">// 存储任务执行结果</span></span><br><span class="line">    data_ = std::<span class="built_in">move</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联的任务已执行完成</span></span><br><span class="line">    isFinished_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个信号量资源（即通知其他线程获取任务执行结果）</span></span><br><span class="line">    sem_.<span class="built_in">post</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断任务执行结果是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Result::isValid</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isValid_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断关联的任务是否已完成</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Result::isFinished</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isFinished_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程构造</span></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadHandler handler) : <span class="built_in">threadHandler_</span>(handler), <span class="built_in">threadId_</span>(generateId_++) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程析构</span></span><br><span class="line">Thread::~<span class="built_in">Thread</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个线程，并执行线程处理函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadHandler_, threadId_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将子线程设置为分离线程</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread::getId</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> threadId_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于辅助生成全局唯一的线程ID</span></span><br><span class="line"><span class="keyword">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 ////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池构造</span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>() {</span><br><span class="line">    idleThreadSize_ = <span class="number">0</span>;</span><br><span class="line">    curThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">    initThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">    threadSizeMaxThreshHold_ = THREAD_SIZE_MAX_THRESHHOLD;</span><br><span class="line">    taskSize_ = <span class="number">0</span>;</span><br><span class="line">    taskQueMaxThreshHold_ = TASK_MAX_THRESHHOLD;</span><br><span class="line">    poolMode_ = PoolMode::MODE_FIXED;</span><br><span class="line">    isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池析构</span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">    <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">    isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁，用于等待线程池里面所有的线程结束运行（线程有两种状态：阻塞等待获取任务 &amp; 正在执行任务中）</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须先获取互斥锁，然后再唤醒所有正在等待获取任务的线程，避免发生线程死锁问题</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程池里的所有线程回收完成</span></span><br><span class="line">    allExit_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的工作模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setMode</span><span class="params">(PoolMode mode)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        poolMode_ = mode;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; !<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        threadSizeMaxThreshHold_ = threshhold;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查线程池的运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ThreadPool::checkRunningState</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isPoolRuning_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理已完成的任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::cleanTaskResult</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">    <span class="comment">// 将满足条件的元素移动到容器末尾</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = std::<span class="built_in">remove_if</span>(taskResults_.<span class="built_in">begin</span>(), taskResults_.<span class="built_in">end</span>(), [](<span class="keyword">const</span> std::shared_ptr&lt;Result&gt; &amp;res) {</span><br><span class="line">        <span class="keyword">return</span> res-&gt;<span class="built_in">isFinished</span>();</span><br><span class="line">    });</span><br><span class="line">    <span class="comment">// 删除容器末尾那段区域的所有元素</span></span><br><span class="line">    taskResults_.<span class="built_in">erase</span>(new_end, taskResults_.<span class="built_in">end</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="keyword">int</span> initThreadSize)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">    isPoolRuning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录初始的线程数量</span></span><br><span class="line">    initThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前线程池的线程数量</span></span><br><span class="line">    curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">        <span class="comment">// 创建线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">        std::unique_ptr&lt;Thread&gt; thread = extend::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        <span class="comment">// 将线程对象放入线程集合中</span></span><br><span class="line">        threads_.<span class="built_in">emplace</span>(thread-&gt;<span class="built_in">getId</span>(), std::<span class="built_in">move</span>(thread));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动初始的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>();    <span class="comment">// 启动一个线程去执行线程处理函数</span></span><br><span class="line">        idleThreadSize_++;        <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span> </span>{</span><br><span class="line">    <span class="comment">// 记录当前线程首次运行的时间</span></span><br><span class="line">    <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For死循环，为了实现在线程池结束时，所有任务必须执行完成，线程池才可以回收线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 等待获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让当前线程等待获取任务，使用While循环避免虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 如果任务列表为空，且线程池要结束运行，则回收当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">                <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                <span class="comment">// 唤醒等待线程池回收完毕的线程</span></span><br><span class="line">                allExit_.<span class="built_in">notify_all</span>();</span><br><span class="line">                <span class="comment">// 打印日志信息</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">"thread pool destroy, thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 线程池Cached模式的处理,由于Cached模式下有可能已经创建了很多的线程，但是空闲时间超过最大阀值，因此需要将多余的空闲线程回收掉</span></span><br><span class="line">            <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_) {</span><br><span class="line">                std::cv_status waitResult = notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 需要区分超时返回，还是线程正常被唤醒返回</span></span><br><span class="line">                <span class="keyword">if</span> (std::cv_status::timeout == waitResult) {</span><br><span class="line">                    <span class="keyword">auto</span> nowTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">                    <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(nowTime - lastTime);</span><br><span class="line">                    <span class="comment">// 当线程的空闲时间超过最大阀值，且当前线程池的线程数量大于初始线程数量，则开始回收线程池中的空闲线程</span></span><br><span class="line">                    <span class="keyword">if</span> (duration.<span class="built_in">count</span>() &gt; THREAD_MAX_IDLE_TIME &amp;&amp; curThreadSize_ &gt; initThreadSize_) {</span><br><span class="line">                        <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                        threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                        <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">                        idleThreadSize_--;</span><br><span class="line">                        <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">                        curThreadSize_--;</span><br><span class="line">                        <span class="comment">// 打印日志信息</span></span><br><span class="line">                        std::cout &lt;&lt; <span class="string">"idle thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                        <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 线程池Fixed模式的处理</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 等待任务队列不为空</span></span><br><span class="line">                notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新空闲线程数量（在当前线程执行任务之前）</span></span><br><span class="line">        idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从任务队列中获取需要执行的任务</span></span><br><span class="line">        std::shared_ptr&lt;Task&gt; task = taskQueue_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务从任务队列中移除</span></span><br><span class="line">        taskQueue_.<span class="built_in">pop</span>();</span><br><span class="line">        taskSize_--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 成功获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果获取了任务之后，任务队列依旧不为空，则继续通知其他线程执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (taskQueue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">            notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为刚获取了任务，任务队列肯定有空余位置（不满），通知用户提交任务到线程池</span></span><br><span class="line">        notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放互斥锁（在当前线程执行任务之前）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程负责执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">nullptr</span>) {</span><br><span class="line">            task-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新空闲线程数量（在当前线程执行完任务之后）</span></span><br><span class="line">        idleThreadSize_++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理已完成的任务执行结果（在当前线程执行完任务之后）</span></span><br><span class="line">        <span class="built_in">cleanTaskResult</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前线程最后执行完任务的时间</span></span><br><span class="line">        lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务给线程池</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Result&gt; <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务队列有空余位置（不满）</span></span><br><span class="line">    <span class="keyword">bool</span> waitResult = notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [<span class="keyword">this</span>]() { <span class="keyword">return</span> taskQueue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; });</span><br><span class="line">    <span class="comment">// 如果等待超时，则返回无效的任务执行结果</span></span><br><span class="line">    <span class="keyword">if</span> (!waitResult) {</span><br><span class="line">        <span class="comment">// 打印错误信息</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"task queue is full, submit task failed."</span>;</span><br><span class="line">        <span class="comment">// 无效的任务执行结果</span></span><br><span class="line">        std::shared_ptr&lt;Result&gt; result = std::make_shared&lt;Result&gt;(task, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">        <span class="comment">// 将任务执行结果保存起来，防止用户未使用而导致提前析构</span></span><br><span class="line">        taskResults_.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">        <span class="comment">// 返回任务执行结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务队列有空余位置（不满），则将任务放入任务队列中</span></span><br><span class="line">    taskQueue_.<span class="built_in">emplace</span>(task);</span><br><span class="line">    taskSize_++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为刚放入了新任务，任务队列肯定不为空，通知线程池中的线程去执行任务</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池Cached模式的处理，根据任务数量动态增加线程池的线程数量</span></span><br><span class="line">    <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; taskSize_ &gt; idleThreadSize_ &amp;&amp; curThreadSize_ &lt; threadSizeMaxThreshHold_) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"expand and create new thread."</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 创建新线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">        std::unique_ptr&lt;Thread&gt; thread = extend::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        <span class="comment">// 获取线程ID（必须在线程放入线程集合之前获取一次线程ID，否则后续将可能获取到空值）</span></span><br><span class="line">        <span class="keyword">int</span> threadId = thread-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        <span class="comment">// 将新线程对象放入线程集合中</span></span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(thread));</span><br><span class="line">        <span class="comment">// 启动新线程</span></span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">        idleThreadSize_++;</span><br><span class="line">        <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">        curThreadSize_++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有效的任务执行结果</span></span><br><span class="line">    std::shared_ptr&lt;Result&gt; result = std::make_shared&lt;Result&gt;(task);</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">    <span class="comment">// 将任务执行结果保存起来，防止用户未使用而导致提前析构</span></span><br><span class="line">    taskResults_.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">    <span class="comment">// 返回任务执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> ULong = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义任务类（模拟并行计算）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculateTask</span> :</span> <span class="keyword">public</span> Task {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CalculateTask</span>(ULong begin, ULong end) : <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"execute task by thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程执行计算</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ULong i = begin_; i &lt;= end_; ++i) {</span><br><span class="line">            sum += i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前线程的计算结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Any</span>(sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ULong begin_;    <span class="comment">// 开始计算的位置</span></span><br><span class="line">    ULong end_;      <span class="comment">// 结束计算的位置</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 线程池的工作模式</span></span><br><span class="line">    <span class="keyword">int</span> poolMode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 获取用户输入</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"请选择线程池的工作模式，0 - Fixed，1 - Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; poolMode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为非法输入</span></span><br><span class="line">        <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) {</span><br><span class="line">            <span class="comment">// 清除错误标志位</span></span><br><span class="line">            std::cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">// 丢弃错误输入</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"输入无效，请重新输入一个合法的数字！\n"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部作用域开始</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPool pool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// Fixed模式（固定大小线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_FIXED);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Fixed"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Cached模式（缓存线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">            pool.<span class="built_in">setThreadSizeMaxThreshHold</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程池（指定初始的线程数量）</span></span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::shared_ptr&lt;Result&gt;&gt; results;</span><br><span class="line">        ULong begin = <span class="number">0</span>;</span><br><span class="line">        ULong end = <span class="number">0</span>;</span><br><span class="line">        ULong step = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交多个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// 计算区间</span></span><br><span class="line">            begin = end + <span class="number">1</span>;</span><br><span class="line">            end = begin + step - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建任务</span></span><br><span class="line">            std::shared_ptr&lt;Task&gt; task = std::make_shared&lt;CalculateTask&gt;(begin, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            std::shared_ptr&lt;Result&gt; result = pool.<span class="built_in">submitTask</span>(task);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储任务执行结果</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;<span class="built_in">isValid</span>()) {</span><br><span class="line">                results.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计任务执行结果</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取任务执行结果</span></span><br><span class="line">            ULong result = results[i]-&gt;<span class="built_in">get</span>().cast&lt;ULong&gt;();</span><br><span class="line">            sum += result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出并行计算结果</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"==&gt; 计算结果：1 + 2 + ... + "</span> &lt;&lt; end &lt;&lt; <span class="string">" = "</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是Cached模式，则等待一段时间，触发线程池回收空闲线程</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">1</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）..."</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(THREAD_MAX_IDLE_TIME + <span class="number">5</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 局部作用域结束，线程池自动析构，回收线程池中的所有线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞主线程，直到用户按下任意键才结束程序</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 平台编译测试代码，生成并运行可执行测试程序（使用的 <code>g++</code> 版本是 <code>4.8.5</code>）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++ -Iinclude src/thread_pool.cpp src/test.cpp -o thread_pool_test -pthread -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行测试程序</span></span><br><span class="line">./thread_pool_test</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Fixed 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Fixed</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">thread pool destroy, thread 480 exited.</span><br><span class="line">thread pool destroy, thread 11872 exited.</span><br><span class="line">thread pool destroy, thread 2620 exited.</span><br><span class="line">thread pool destroy, thread 9140 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Cached 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Cached</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15144 成功获取任务...</span><br><span class="line">execute task by thread 15144</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 20812 成功获取任务...</span><br><span class="line">execute task by thread 20812</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 3904 成功获取任务...</span><br><span class="line">execute task by thread 3904</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 15616 成功获取任务...</span><br><span class="line">execute task by thread 15616</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 9800 成功获取任务...</span><br><span class="line">execute task by thread 9800</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）...</span><br><span class="line">idle thread 15616 exited.</span><br><span class="line">idle thread 9800 exited.</span><br><span class="line">idle thread 480 exited.</span><br><span class="line">idle thread 15144 exited.</span><br><span class="line">thread pool destroy, thread 20864 exited.</span><br><span class="line">thread pool destroy, thread 11812 exited.</span><br><span class="line">thread pool destroy, thread 20812 exited.</span><br><span class="line">thread pool destroy, thread 3904 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><h5 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h5><p>为了便于将线程池库提供给第三方使用，可以将线程池项目的核心源码编译成动态链接库。下面将以 Linux 平台为例，介绍使用不同的方式将线程池项目编译为动态链接库（<code>.so</code> 文件）。值得一提的是，C++ 线程池项目的目录结构如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c++-11-thread-pool</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│&nbsp;&nbsp; ├── extend.h</span><br><span class="line">│&nbsp;&nbsp; └── thread_pool.h</span><br><span class="line">└── src</span><br><span class="line">    ├── test.cpp</span><br><span class="line">    └── thread_pool.cpp</span><br></pre></td></tr></tbody></table></figure><h6 id="GCC-编译"><a href="#GCC-编译" class="headerlink" title="GCC 编译"></a>GCC 编译</h6><div class="admonition note"><p class="admonition-title">版本说明</p><p>本文使用的 <code>g++</code> 版本是 <code>4.8.5</code>，若版本过低，可能会出现线程池代码编译失败的问题。</p></div><ul><li>项目的编译构建 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成动态链接库</span></span><br><span class="line">g++ -fPIC -Iinclude -shared src/thread_pool.cpp -o libthread_pool.so -pthread -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++ -Iinclude src/thread_pool.cpp src/test.cpp -o thread_pool_test -pthread -std=c++11</span><br></pre></td></tr></tbody></table></figure><ul><li>编译参数的说明</li></ul><table><thead><tr><th>编译参数</th><th></th><th>参数说明</th></tr></thead><tbody><tr><td><code>-fPIC</code></td><td></td><td>生成位置无关代码，<code>.so</code> 文件必须使用</td></tr><tr><td><code>-Iinclude</code></td><td></td><td>指定头文件目录为 <code>include</code></td></tr><tr><td><code>-shared</code></td><td></td><td>指定编译生成共享库（动态链接库）</td></tr><tr><td><code>src/thread_pool.cpp</code></td><td></td><td>指定源文件路径</td></tr><tr><td><code>-o libthread_pool.so</code></td><td></td><td>指定编译输出的文件名</td></tr><tr><td><code>-pthread</code></td><td></td><td>链接 <code>pthread</code> 库</td></tr><tr><td><code>-std=c++11</code></td><td></td><td>指定 C++ 版本</td></tr></tbody></table><ul><li>动态链接库的安装（可选），如果不安装，第三方程序在运行时可能会遇到找不到动态链接库的问题 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将头文件安装到系统中</span></span><br><span class="line">sudo cp ./include/* /usr/<span class="built_in">local</span>/include</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将编译生成的动态链接库安装到系统中</span></span><br><span class="line">sudo cp libthread_pool.so /usr/<span class="built_in">local</span>/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统的动态链接库配置文件</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt; /etc/ld.so.conf.d/custom.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载系统的动态链接库配置</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></tbody></table></figure><h6 id="CMake-编译"><a href="#CMake-编译" class="headerlink" title="CMake 编译"></a>CMake 编译</h6><div class="admonition note"><p class="admonition-title">版本说明</p><p>本文使用的 <code>g++</code> 版本是 <code>4.8.5</code>，CMake 版本是 <code>3.25.1</code>，若版本过低，可能会出现线程池代码编译失败的问题。值得一提的是，CMake 的详细使用教程可以参考 <a href="/posts/b6161f29.html">这里</a>。</p></div><ul><li>项目的 CMake 配置 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line"># 项目名称和语言</span><br><span class="line">project(cxx_11_thread_pool VERSION 1.0 LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"># 设置 C++ 版本</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line"></span><br><span class="line"># 设置构建模式</span><br><span class="line">set(CMAKE_BUILD_TYPE Debug CACHE STRING "" FORCE)</span><br><span class="line"></span><br><span class="line"># 设置头文件目录</span><br><span class="line">include_directories(${CMAKE_SOURCE_DIR}/include)</span><br><span class="line"></span><br><span class="line"># 设置源文件</span><br><span class="line">file(GLOB SRC_FILES src/*.cpp)</span><br><span class="line"></span><br><span class="line"># 编译生成动态链接库</span><br><span class="line">add_library(thread_pool SHARED ${SRC_FILES})</span><br><span class="line"></span><br><span class="line"># 设置动态链接库的文件名称</span><br><span class="line">set_target_properties(thread_pool PROPERTIES</span><br><span class="line">        OUTPUT_NAME "thread_pool"</span><br><span class="line">        PREFIX "lib"</span><br><span class="line">        SUFFIX ".so"</span><br><span class="line">        POSITION_INDEPENDENT_CODE ON</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 设置动态链接库的链接标志</span><br><span class="line">if (CMAKE_SYSTEM_NAME STREQUAL "Linux")</span><br><span class="line">    target_link_libraries(thread_pool PRIVATE pthread)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line"># 编译生成可执行测试程序</span><br><span class="line">add_executable(thread_pool_test ${SRC_FILES})</span><br><span class="line"></span><br><span class="line"># 设置可执行测试程序的链接标志</span><br><span class="line">if (CMAKE_SYSTEM_NAME STREQUAL "Linux")</span><br><span class="line">    target_link_libraries(thread_pool_test PRIVATE pthread)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line"># 设置默认的安装前缀路径</span><br><span class="line">if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)</span><br><span class="line">    set(CMAKE_INSTALL_PREFIX "/usr/local" CACHE PATH "Install path prefix." FORCE)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"># 将头文件和编译生成的动态链接库安装到指定位置（可选）</span><br><span class="line">install(DIRECTORY include/ DESTINATION include)</span><br><span class="line">install(TARGETS thread_pool DESTINATION lib)</span><br></pre></td></tr></tbody></table></figure><ul><li>项目的编译构建 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成动态链接库和可执行测试程序</span></span><br><span class="line">cmake -S . -B build &amp;&amp; cmake --build build</span><br></pre></td></tr></tbody></table></figure><ul><li>编译参数的说明</li></ul><table><thead><tr><th>编译参数</th><th>参数说明</th></tr></thead><tbody><tr><td><code>-S .</code></td><td>指定源码目录为当前目录（包含 <code>CMakeLists.txt</code>）</td></tr><tr><td><code>-B build</code></td><td>指定构建目录为 <code>build</code>，不存在时会自动创建</td></tr><tr><td><code>cmake --build build</code></td><td>执行编译（相当于 <code>make</code>）</td></tr></tbody></table><ul><li>动态链接库的安装（可选），如果不安装，第三方程序在运行时可能会遇到找不到动态链接库的问题 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将头文件和编译生成的动态链接库安装到系统中</span></span><br><span class="line">sudo cmake --install build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统的动态链接库配置文件</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt; /etc/ld.so.conf.d/custom.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载系统的动态链接库配置</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></tbody></table></figure><h4 id="C-17-版本"><a href="#C-17-版本" class="headerlink" title="C++ 17 版本"></a>C++ 17 版本</h4><p>这里基于 C++ 17 手写一个线程池，使用了可变参数模板、<code>make_unique()</code>、<code>packaged_task</code>、<code>future</code> 特性。</p><div class="admonition note"><p class="admonition-title">代码下载</p><p>C++ 17 实现线程池的完整案例代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-project-thread-pool/c%2B%2B-17-thread-pool">这里</a> 下载得到，所有案例代码都兼容 Windows 和 Linux 平台。</p></div><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><ul><li><code>thread_pool.h</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池核心参数 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的线程数量（默认是CPU的核心数）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INIT_THREAD_SIZE = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TASK_MAX_THRESHHOLD = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_SIZE_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程允许的最大空闲时间（单位秒）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">PoolMode</span> {</span></span><br><span class="line">    MODE_FIXED,    <span class="comment">// 固定大小线程池</span></span><br><span class="line">    MODE_CACHED    <span class="comment">// 缓存线程池</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数对象的类型</span></span><br><span class="line">    <span class="keyword">using</span> ThreadHandler = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程构造</span></span><br><span class="line">    <span class="built_in">Thread</span>(ThreadHandler handler) : <span class="built_in">threadHandler_</span>(handler), <span class="built_in">threadId_</span>(generateId_++) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程析构</span></span><br><span class="line">    ~<span class="built_in">Thread</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个线程，并执行线程处理函数</span></span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">(threadHandler_, threadId_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子线程设置为分离线程</span></span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程ID</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> threadId_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> threadId_;                    <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> generateId_;           <span class="comment">// 用于辅助生成全局唯一的线程ID</span></span><br><span class="line">    ThreadHandler threadHandler_;     <span class="comment">// 线程处理函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于辅助生成全局唯一的线程ID</span></span><br><span class="line"><span class="keyword">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>() {</span><br><span class="line">        idleThreadSize_ = <span class="number">0</span>;</span><br><span class="line">        curThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">        initThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">        threadSizeMaxThreshHold_ = THREAD_SIZE_MAX_THRESHHOLD;</span><br><span class="line">        taskSize_ = <span class="number">0</span>;</span><br><span class="line">        taskQueMaxThreshHold_ = TASK_MAX_THRESHHOLD;</span><br><span class="line">        poolMode_ = PoolMode::MODE_FIXED;</span><br><span class="line">        isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池析构</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">        <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">        isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁，用于等待线程池里面所有的线程结束运行（线程有两种状态：阻塞等待获取任务 &amp; 正在执行任务中）</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须先获取互斥锁，然后再唤醒所有正在等待获取任务的线程，避免发生线程死锁问题</span></span><br><span class="line">        notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程池里的所有线程回收完成</span></span><br><span class="line">        allExit_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            poolMode_ = mode;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; !<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            threadSizeMaxThreshHold_ = threshhold;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initThreadSize)</span> </span>{</span><br><span class="line">        <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">        isPoolRuning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录初始的线程数量</span></span><br><span class="line">        initThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前线程池的线程数量</span></span><br><span class="line">        curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建初始的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">            <span class="comment">// 创建线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">            std::unique_ptr&lt;Thread&gt; thread = std::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">            <span class="comment">// 将线程对象放入线程集合中</span></span><br><span class="line">            threads_.<span class="built_in">emplace</span>(thread-&gt;<span class="built_in">getId</span>(), std::<span class="built_in">move</span>(thread));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动初始的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">            threads_[i]-&gt;<span class="built_in">start</span>();    <span class="comment">// 启动一个线程去执行线程处理函数</span></span><br><span class="line">            idleThreadSize_++;       <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务给线程池（使用可变参数模板 + 引用折叠 + 完美转发）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func &amp;&amp;func, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt; </span>{</span><br><span class="line">        <span class="comment">// 推导任务执行结果的类型（返回值类型）</span></span><br><span class="line">        <span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装一个任意可调用对象（函数、函数对象、Lambda表达式等）为异步任务</span></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">                std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取与异步任务关联的Future，方便用户获取任务执行结果</span></span><br><span class="line">        std::future&lt;RType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待任务队列有空余位置（不满）</span></span><br><span class="line">        <span class="keyword">bool</span> waitResult = notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [<span class="keyword">this</span>]() { <span class="keyword">return</span> taskQueue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; });</span><br><span class="line">        <span class="comment">// 如果等待超时，则直接返回Future</span></span><br><span class="line">        <span class="keyword">if</span> (!waitResult) {</span><br><span class="line">            <span class="comment">// 打印错误信息</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">"task queue is full, submit task failed."</span>;</span><br><span class="line">            <span class="comment">// 封装一个空的任务</span></span><br><span class="line">            <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;([]() -&gt; RType { <span class="keyword">return</span> <span class="built_in">RType</span>(); });</span><br><span class="line">            <span class="comment">// 执行一个空的任务</span></span><br><span class="line">            (*task)();</span><br><span class="line">            <span class="comment">// 返回与任务关联的Future</span></span><br><span class="line">            <span class="keyword">return</span> task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果任务队列有空余位置（不满），则将任务放入任务队列中</span></span><br><span class="line">        taskQueue_.<span class="built_in">emplace</span>([task]() {</span><br><span class="line">            (*task)();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前任务队列的任务数量</span></span><br><span class="line">        taskSize_++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为刚放入了新任务，任务队列肯定不为空，通知线程池中的线程去执行任务</span></span><br><span class="line">        notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池Cached模式的处理，根据任务数量动态增加线程池的线程数量</span></span><br><span class="line">        <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; taskSize_ &gt; idleThreadSize_ &amp;&amp; curThreadSize_ &lt; threadSizeMaxThreshHold_) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"expand and create new thread."</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 创建新线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">            std::unique_ptr&lt;Thread&gt; thread = std::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">            <span class="comment">// 获取线程ID（必须在线程放入线程集合之前获取一次线程ID，否则后续将可能获取到空值）</span></span><br><span class="line">            <span class="keyword">int</span> threadId = thread-&gt;<span class="built_in">getId</span>();</span><br><span class="line">            <span class="comment">// 将新线程对象放入线程集合中</span></span><br><span class="line">            threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(thread));</span><br><span class="line">            <span class="comment">// 启动新线程</span></span><br><span class="line">            threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">            <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">            idleThreadSize_++;</span><br><span class="line">            <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">            curThreadSize_++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回与任务关联的Future</span></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span> </span>{</span><br><span class="line">        <span class="comment">// 记录当前线程首次运行的时间</span></span><br><span class="line">        <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For死循环，为了实现在线程池结束时，所有任务必须执行完成，线程池才可以回收线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 等待获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让当前线程等待获取任务，使用While循环避免虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 如果任务列表为空，且线程池要结束运行，则回收当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">                    <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                    threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                    <span class="comment">// 唤醒等待线程池回收完毕的线程</span></span><br><span class="line">                    allExit_.<span class="built_in">notify_all</span>();</span><br><span class="line">                    <span class="comment">// 打印日志信息</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">"thread pool destroy, thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 线程池Cached模式的处理,由于Cached模式下有可能已经创建了很多的线程，但是空闲时间超过最大阀值，因此需要将多余的空闲线程回收掉</span></span><br><span class="line">                <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_) {</span><br><span class="line">                    std::cv_status waitResult = notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 需要区分超时返回，还是线程正常被唤醒返回</span></span><br><span class="line">                    <span class="keyword">if</span> (std::cv_status::timeout == waitResult) {</span><br><span class="line">                        <span class="keyword">auto</span> nowTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">                        <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(nowTime - lastTime);</span><br><span class="line">                        <span class="comment">// 当线程的空闲时间超过最大阀值，且当前线程池的线程数量大于初始线程数量，则开始回收线程池中的空闲线程</span></span><br><span class="line">                        <span class="keyword">if</span> (duration.<span class="built_in">count</span>() &gt; THREAD_MAX_IDLE_TIME &amp;&amp; curThreadSize_ &gt; initThreadSize_) {</span><br><span class="line">                            <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                            threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                            <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">                            idleThreadSize_--;</span><br><span class="line">                            <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">                            curThreadSize_--;</span><br><span class="line">                            <span class="comment">// 打印日志信息</span></span><br><span class="line">                            std::cout &lt;&lt; <span class="string">"idle thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                            <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 线程池Fixed模式的处理</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 等待任务队列不为空</span></span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新空闲线程数量（在当前线程执行任务之前）</span></span><br><span class="line">            idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从任务队列中获取需要执行的任务</span></span><br><span class="line">            Task task = taskQueue_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务从任务队列中移除</span></span><br><span class="line">            taskQueue_.<span class="built_in">pop</span>();</span><br><span class="line">            taskSize_--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 成功获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果获取了任务之后，任务队列依旧不为空，则继续通知其他线程执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (taskQueue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">                notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为刚获取了任务，任务队列肯定有空余位置（不满），通知用户提交任务到线程池</span></span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放互斥锁（在当前线程执行任务之前）</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前线程负责执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新空闲线程数量（在当前线程执行完任务之后）</span></span><br><span class="line">            idleThreadSize_++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新当前线程最后执行完任务的时间</span></span><br><span class="line">            lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池的运行状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> isPoolRuning_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;        <span class="comment">// 线程集合</span></span><br><span class="line">    PoolMode poolMode_;                                               <span class="comment">// 线程池的模式</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isPoolRuning_;                                   <span class="comment">// 表示线程池是否正在运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> initThreadSize_;                                           <span class="comment">// 初始的线程数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> idleThreadSize_;                                  <span class="comment">// 空闲线程的数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> curThreadSize_;                                   <span class="comment">// 当前线程池的线程数量</span></span><br><span class="line">    <span class="keyword">int</span> threadSizeMaxThreshHold_;                                     <span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;                               <span class="comment">// 类型重定义，使用Function类模板作为任务</span></span><br><span class="line">    std::queue&lt;Task&gt; taskQueue_;                                      <span class="comment">// 任务队列</span></span><br><span class="line">    std::<span class="keyword">atomic_uint</span> taskSize_;                                       <span class="comment">// 当前任务队列的任务数量</span></span><br><span class="line">    <span class="keyword">size_t</span> taskQueMaxThreshHold_;                                     <span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"></span><br><span class="line">    std::mutex taskQueMtx_;                                           <span class="comment">// 任务队列操作的互斥锁</span></span><br><span class="line">    std::condition_variable notFull_;                                 <span class="comment">// 表示任务队列不满，用于通知用户线程提交任务</span></span><br><span class="line">    std::condition_variable notEmpty_;                                <span class="comment">// 表示任务队列不空，用于通知线程池中的线程执行任务</span></span><br><span class="line">    std::condition_variable allExit_;                                 <span class="comment">// 表示等待线程池回收所有线程</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// THREAD_POOL_H</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> ULong = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算逻辑</span></span><br><span class="line"><span class="function">ULong <span class="title">sum</span><span class="params">(ULong begin, ULong end)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"execute task by thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程执行加法计算</span></span><br><span class="line">    ULong sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ULong i = begin; i &lt;= end; ++i) {</span><br><span class="line">        sum += i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回计算结果</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 线程池的工作模式</span></span><br><span class="line">    <span class="keyword">int</span> poolMode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 获取用户输入</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"请选择线程池的工作模式，0 - Fixed，1 - Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; poolMode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为非法输入</span></span><br><span class="line">        <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) {</span><br><span class="line">            <span class="comment">// 清除错误标志位</span></span><br><span class="line">            std::cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">// 丢弃错误输入</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"输入无效，请重新输入一个合法的数字！\n"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部作用域开始</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPool pool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// Fixed模式（固定大小线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_FIXED);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Fixed"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Cached模式（缓存线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">            pool.<span class="built_in">setThreadSizeMaxThreshHold</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程池（指定初始的线程数量）</span></span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储与任务关联的Future</span></span><br><span class="line">        std::vector&lt;std::future&lt;ULong&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">        ULong begin = <span class="number">0</span>;</span><br><span class="line">        ULong end = <span class="number">0</span>;</span><br><span class="line">        ULong step = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交多个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// 计算区间</span></span><br><span class="line">            begin = end + <span class="number">1</span>;</span><br><span class="line">            end = begin + step - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            std::future&lt;ULong&gt; result = pool.<span class="built_in">submitTask</span>(sum, begin, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储与任务关联的Future</span></span><br><span class="line">            results.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(result));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计任务执行结果</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取任务执行结果</span></span><br><span class="line">            ULong result = results[i].<span class="built_in">get</span>();</span><br><span class="line">            sum += result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出并行计算结果</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"==&gt; 计算结果：1 + 2 + ... + "</span> &lt;&lt; end &lt;&lt; <span class="string">" = "</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是Cached模式，则等待一段时间，触发线程池回收空闲线程</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">1</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）..."</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(THREAD_MAX_IDLE_TIME + <span class="number">5</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 局部作用域结束，线程池自动析构，回收线程池中的所有线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞主线程，直到用户按下任意键才结束程序</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 平台编译测试代码，生成并运行可执行测试程序（使用的 <code>g++</code> 版本是 <code>12.2.0</code>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-17-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++<span class="params"> -Iinclude</span> src/<span class="built_in">test</span>.cpp<span class="params"> -o</span> thread_pool_test<span class="params"> -pthread</span><span class="params"> -std</span>=c++17</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行测试程序</span></span><br><span class="line">./thread_pool_test</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Fixed 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Fixed</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">thread pool destroy, thread 480 exited.</span><br><span class="line">thread pool destroy, thread 11872 exited.</span><br><span class="line">thread pool destroy, thread 2620 exited.</span><br><span class="line">thread pool destroy, thread 9140 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Cached 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Cached</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15144 成功获取任务...</span><br><span class="line">execute task by thread 15144</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 20812 成功获取任务...</span><br><span class="line">execute task by thread 20812</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 3904 成功获取任务...</span><br><span class="line">execute task by thread 3904</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 15616 成功获取任务...</span><br><span class="line">execute task by thread 15616</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 9800 成功获取任务...</span><br><span class="line">execute task by thread 9800</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）...</span><br><span class="line">idle thread 15616 exited.</span><br><span class="line">idle thread 9800 exited.</span><br><span class="line">idle thread 480 exited.</span><br><span class="line">idle thread 15144 exited.</span><br><span class="line">thread pool destroy, thread 20864 exited.</span><br><span class="line">thread pool destroy, thread 11812 exited.</span><br><span class="line">thread pool destroy, thread 20812 exited.</span><br><span class="line">thread pool destroy, thread 3904 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><h5 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h5><div class="admonition warning"><p class="admonition-title">动态链接库说明</p><p>由于上面基于 C++ 17 实现的线程池，其核心源码全部都写在头文件中，也就是说 <code>thread_pool.h</code> 是纯 Header-Only（例如类模板 / 函数模板全部实现都在头文件中），因此该线程池项目是无法编译成动态链接库（比如 <code>.so</code>）的。如果一定要编译成动态链接库，可以将线程池的核心代码逻辑移植到 <code>.cpp</code> 源文件，然后再编译成动态链接库。由于篇幅有限，这里不再累述。</p></div><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>(1) 基于 C++ 11 / C++ 17 实现线程池，当线程池准备结束运行（销毁），需要等待线程池中所有线程退出时，发生线程死锁问题，导致应用进程无法正常退出。</li><li>(2) 基于 C++ 11 实现线程池，在 Windows 平台下可以正常运行，但在 Linux 平台下运行时自定义实现的信号量类型 Semaphore 会出现线程死锁问题（原因是 <code>condition_variable</code> 的析构函数为空导致，一旦 Result 对象比 Task 对象早被析构就会出现线程死锁）。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>这里提到的两个线程死锁问题，在上面给出的 C++ 11 / C++ 17 线程池代码中已经解决了。</p></div><h4 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h4><p>定位死锁问题时，通常可以通过 <code>gdb</code> 附加（<code>attach</code>）到正在运行的目标进程，然后使用以下命令进行分析：</p><ul><li>使用 <code>ps</code> 命令查找目标进程的 ID；</li><li>使用 <code>gdb attch &lt;pid&gt;</code> 命令附加到目标进程；</li><li>使用 <code>info threads</code> 命令查看当前进程中所有线程的状态及线程 ID；</li><li>使用 <code>thread &lt;tid&gt;</code> 命令切换到指定的线程；</li><li>使用 <code>bt</code> 命令查看当前线程的调用堆栈信息，判断其是否被阻塞、在等待互斥锁（<code>mutex</code>）、或处于循环等待状态；</li><li>重复以上操作，依次分析所有可疑线程的调用堆栈信息，找出多个线程相互等待资源的典型死锁原因。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看目标进程的 ID</span></span><br><span class="line">ps -aux|grep thread_pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 附加的目标进程</span></span><br><span class="line">$ gdb attach &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（查看目标进程中的所有线程）</span></span><br><span class="line">&gt; (gdb) info threads</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（切换到指定的线程）</span></span><br><span class="line">&gt; (gdb) threads &lt;tid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（查看当前线程的调用堆栈信息）</span></span><br><span class="line">&gt; (gdb) bt</span><br></pre></td></tr></tbody></table></figure><p>结合项目源码和线程之间的加锁、解锁逻辑，定位到具体发生死锁的代码片段后，可以进一步分析导致死锁的根本原因，常见的原因包括：</p><ul><li>多个线程交叉持有多个锁，且锁的获取顺序不一致；</li><li>忽略了可能抛异常或提前返回，导致某个线程未能正确释放锁；</li><li>加锁和等待条件变量的时机不当等；</li><li>多个资源需要同时加锁时，未采用统一锁策略（比如没有统一使用 <code>lock()</code> 或 <code>unique_lock</code>）。</li></ul><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>规范加锁顺序，避免循环依赖；</li><li>拆分锁或减少锁的粒度；</li><li>使用 <code>try_lock()</code> 等避免阻塞的锁操作；</li><li>引入超时机制，防止死锁的出现；</li><li>在合适的场景下，可以引入无锁并发编程模型（如基于 CAS 的算法），以提升性能并减少锁竞争带来的开销。</li></ul><h2 id="项目输出总结"><a href="#项目输出总结" class="headerlink" title="项目输出总结"></a>项目输出总结</h2><h3 id="应用到企业项目中"><a href="#应用到企业项目中" class="headerlink" title="应用到企业项目中"></a>应用到企业项目中</h3><ul><li>耗时任务处理</li><li>高并发高性能网络服务器</li><li> Master-Slave 线程模型（可用于并行计算）</li></ul><h3 id="输出到求职简历上"><a href="#输出到求职简历上" class="headerlink" title="输出到求职简历上"></a>输出到求职简历上</h3><ul><li><p><strong>项目名称</strong></p><ul><li>基于可变参数模板实现线程池</li></ul></li><li><p><strong>项目描述</strong></p><ul><li>基于可变参数模板和引用折叠原理，实现线程池 <code>submitTask</code> 接口，支持任意任务函数和任意参数的传递</li><li>使用 <code>future</code> 类型定制 <code>submitTask</code> 接口提交任务的返回值</li><li>使用 <code>map</code> 和 <code>queue</code> 容器管理线程对象和任务</li><li>基于条件变量 <code>condition_variable</code> 和互斥锁 <code>mutex</code> 实现任务提交线程和任务执行线程之间的通信机制</li><li>支持 Fixed 和 Cached 模式的线程池</li><li>……（自由发挥）</li></ul></li><li><p><strong>项目问题</strong></p><ul><li>遇到的问题<ul><li>基于 C++ 11 / C++ 17 实现线程池，当线程池准备结束运行（销毁），需要等待线程池中所有线程退出时，发生线程死锁问题，导致应用进程无法正常退出。</li><li>基于 C++ 11 实现线程池，在 Windows 平台下可以正常运行，但在 Linux 平台下运行时自定义实现的信号量类型会出现线程死锁问题（原因是 <code>condition_variable</code> 的析构函数为空导致，一旦 Result 对象比 Task 对象早被析构就会出现线程死锁）。</li></ul></li><li>问题的定位<ul><li>使用 <code>ps</code> 命令查找目标进程的 ID；</li><li>使用 <code>gdb attch &lt;pid&gt;</code> 命令附加到目标进程；</li><li>使用 <code>info threads</code> 命令查看当前进程中所有线程的状态及线程 ID；</li><li>使用 <code>thread &lt;tid&gt;</code> 命令切换到指定的线程；</li><li>使用 <code>bt</code> 命令查看当前线程的调用堆栈信息，判断其是否被阻塞、在等待互斥锁（<code>mutex</code>）、或处于循环等待状态；</li><li>重复以上操作，依次分析所有可疑线程的调用堆栈信息，找出多个线程相互等待资源的典型死锁原因。</li></ul></li><li>问题的解决<ul><li>结合项目源码和线程之间的加锁、解锁逻辑，定位到具体发生死锁的代码片段后，可以进一步分析导致死锁的根本原因，常见的原因包括：</li><li>(1) 多个线程交叉持有多个锁，且锁的获取顺序不一致。</li><li>(2) 忽略了可能抛异常或提前返回，导致某个线程未能正确释放锁。</li><li>(3) 加锁和等待条件变量的时机不当等。</li><li>(4) 多个资源需要同时加锁时，未采用统一锁策略（比如没有统一使用 <code>lock()</code> 或 <code>unique_lock</code>）。</li></ul></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/a2a7ad9b.html">C++ 多线程编程之一</a></li><li><a href="/posts/832c55b5.html">Java 之线程池使用详解</a></li><li><a href="/posts/17b04dfd.html">Java 线程死锁的定位与分析</a></li><li><a href="/posts/dc8f1477.html">如何估算 Java 线程池的大小与队列长度</a></li><li><a href="/posts/f7fd0987.html">Java 多线程编程之七队列、线程池、线程通信</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 手写一个线程池，并提供 C++ 11 和 C++ 17 两种版本的实现代码。</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SGI STL 内存池源码剖析</title>
    <link href="https://www.techgrow.cn/posts/712a574b.html"/>
    <id>https://www.techgrow.cn/posts/712a574b.html</id>
    <published>2025-04-18T13:55:33.000Z</published>
    <updated>2025-04-18T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/5bc5018f.html">Nginx 内存池源码剖析</a></li><li><a href="/posts/712a574b.html">SGI STL 内存池源码剖析</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将剖析 SGI STL 二级空间配置器中的内存池源码，并介绍内存池的底层设计和工作原理，最后移植 SGI STL 内存池的核心源码。值得一提的是，移植后的 C++ 代码兼容 Windows 和 Linux 平台。</p><div class="admonition note"><p class="admonition-title">C++ 常见的池</p><p>在 C++ 中有五大池，包括内存池、连接池、协程池、线程池、进程池。</p></div><span id="more"></span><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><ul><li><a href="../../../downloads/2025/05/sgi-stl.zip">SGI STL 源码下载</a></li></ul><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><ul><li><a href="#">《STL 源码剖析》 第二章 - 空间配置器（Allocator）</a></li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>C++ 中的 STL（Standard Template Library）是标准模板库，提供了一组通用的数据结构和算法，如向量（<code>vector</code>）、链表（<code>list</code>）、集合（<code>set</code>）、映射（<code>map</code>）、排序、查找等；基于模板实现，支持泛型编程，代码复用性高、效率也好。</p><h3 id="多种实现"><a href="#多种实现" class="headerlink" title="多种实现"></a>多种实现</h3><p>除了 C++ 自身提供的 STL 之外，常见的第三方 STL（标准模板库）实现有以下几种：</p><ul><li><p><strong>RW STL（Rogue Wave STL）</strong></p><ul><li>开发者：<ul><li>Rogue Wave Software 公司（后被 Perforce 收购）</li></ul></li><li>性质：<ul><li>商业版本的 C++ 标准模板库实现</li></ul></li><li>代表产品：<ul><li>作为 SourcePro C++ 产品的一部分提供（包含 STL、线程库、网络库、数据库访问库等）</li></ul></li><li>产品特点：<ul><li>遵循 ISO C++ 标准</li><li>跨平台，适配多种操作系统和编译器</li><li>提供高级调试、异常安全、多线程支持</li><li>可配置性强，适用于嵌入式和大型系统</li></ul></li><li>应用场景：<ul><li>金融系统、通信系统、嵌入式开发、航空航天、政府项目等对可靠性要求高的场景</li></ul></li></ul></li><li><p><strong> PJ STL（Dinkumware STL）</strong></p><ul><li>开发者：<ul><li>P. J. Plauger（C++ 标准委员会成员），其自己公司 Dinkumware 提供支持</li></ul></li><li>性质：<ul><li>商业版本的 C++ 标准模板库实现</li></ul></li><li>代表使用者：<ul><li>Microsoft Visual C++（尤其是 VC++ 6 及后续版本）默认使用 PJ STL</li></ul></li><li> 特点：<ul><li>遵循 ISO C++ 标准</li><li>接口稳定、实现清晰，强调工程实用性</li><li>提供 STL、C 标准库（如 <code>&lt;cmath&gt;</code>，<code>&lt;cstdlib&gt;</code>）、TR1 和部分 C++ 11 / 14 特性</li></ul></li><li>优势：<ul><li>商业支持</li><li>与微软编译器深度集成</li><li>重视可移植性和性能</li></ul></li><li>局限：<ul><li>并非开源，文档和源代码可见性有限</li></ul></li></ul></li><li><p><strong> HP STL（Hewlett-Packard STL）</strong></p><ul><li>开发者：<ul><li>Hewlett-Packard 公司（惠普实验室），由 Alexander Stepanov 及其团队在 HP（惠普）初步实现</li></ul></li><li>性质：<ul><li>STL 的原始实现，是 SGI STL 的前身</li></ul></li><li>历史意义：<ul><li>1994 年 Stepanov 在 HP Labs（惠普实验室）首次实现 STL，随后向 C++ 标准委员会提交</li><li>后由 SGI 改进并推广形成 SGI STL，逐渐成为业界学习模板编程的典范</li></ul></li><li>特点：<ul><li>结构清晰，贴近标准草案</li><li>强调通用算法和迭代器的分离设计</li><li>奠定了 STL 的基础架构，如容器、迭代器、算法的三大支柱</li></ul></li><li>应用与影响：<ul><li>虽然未被广泛部署于实际商业编译器中，但在学术界和标准委员会中具有开创性意义</li><li>是理解 STL 起源与设计哲学的关键资料</li></ul></li><li>现状：<ul><li>已不再维护，但源码与设计理念在 SGI STL 中得以继承和发扬</li></ul></li></ul></li><li><p><strong> SGI STL（Silicon Graphics STL）</strong></p><ul><li>开发者：<ul><li>Alexander Stepanov（STL 之父）、Meng Lee 等人在 SGI（Silicon Graphics Inc.）公司开发</li></ul></li><li>性质：<ul><li>最早公开发布的 STL 实现之一，并作为学习范例广泛传播</li></ul></li><li>特点：<ul><li>完全开源，源码可读性和学习性极强</li><li>强调泛型编程、模板技巧和性能优化</li><li>提供了 <code>allocator</code>、<code>traits</code>、<code>function object</code>、<code>iterator</code> 等先进设计</li></ul></li><li>贡献：<ul><li>为后来的标准库实现（如 GCC 的 libstdc++）提供了基础</li><li>推动了 STL 的工业化、模块化和标准化</li></ul></li><li>现状：<ul><li>虽然已经不再更新，但作为教学和研究材料仍具重要历史价值</li></ul></li></ul></li></ul><blockquote><p>第三方 STL 实现的总结对比表</p></blockquote><table><thead><tr><th>名称</th><th>开发者</th><th>是否开源</th><th>典型应用</th><th>特点描述</th></tr></thead><tbody><tr><td> RW STL</td><td>Rogue Wave Software</td><td>❌ 商业版</td><td>金融、嵌入式、政府、工业系统</td><td>工程化程度高，稳定性强，附带调试与多线程支持，属于 SourcePro C++ 一部分</td></tr><tr><td> PJ STL</td><td>P. J. Plauger / Dinkumware</td><td>❌ 商业版</td><td> Visual C++、商业工具链</td><td>工程稳健，兼容性好，被微软 Visual Studio 多版本采用</td></tr><tr><td> HP STL</td><td>Alexander Stepanov / HP</td><td>✅ 开源</td><td>教育、历史研究、标准演化</td><td> STL 的最早实现版本，设计哲学完整，影响了 SGI STL 和后续标准化进程</td></tr><tr><td> SGI STL</td><td>Alexander Stepanov / SGI</td><td>✅ 开源</td><td>教育、研究、GCC libstdc++ 原型</td><td>泛型编程示范，模板设计前沿，影响广泛</td></tr></tbody></table><h2 id="SGI-STL"><a href="#SGI-STL" class="headerlink" title="SGI STL"></a>SGI STL</h2><h3 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h3><h4 id="SGI-STL-是什么"><a href="#SGI-STL-是什么" class="headerlink" title="SGI STL 是什么"></a>SGI STL 是什么</h4><p>SGI STL 是由 Alexander Stepanov 和 Meng Lee 等人在 SGI（Silicon Graphics Inc.）公司开发的 C++ 标准模板库实现，最早出现在 1990 年代。这个库实现了 STL 的核心思想：泛型编程与容器 - 算法 - 迭代器模型。<strong>SGI STL 包含了一级空间配置器和二级空间配置器，其中一级空间配置器 <code>allocator</code> 采用 <code>malloc()</code> 和 <code>free()</code> 来管理内存，和 C++ 标准模板库（STL）中提供的 <code>allocator</code> 是一样的，但其二级空间配置器 <code>allocator</code> 采用了基于自由链表（Free List）原理的内存池机制来实现内存管理。具体来说，当申请的内存块超过 <code>128</code> 字节时，视之为 “足够大”，会调用一级空间配置器；当申请的内存块小于 <code>128</code> 字节时，视之为 “过小”，会调用二级空间配置器，采用复杂的内存池管理方式，这样可以避免小内存频繁申请和释放导致的内存碎片问题，同时提高效率。</strong></p><div class="admonition warning"><p class="admonition-title">STL 空间配置器的作用</p><ul><li>在 C++ STL 中，空间配置器（<code>allocator</code>）的作用主要有两种：</li><li>(1) 分离了对象的内存开辟（<code>allocate()</code>）和对象的构造（<code>construct()</code>）。</li><li>(2) 分离了对象的析构（<code>destroy()</code>）和对象的内存释放（<code>deallocate()</code>）。</li></ul></div><h4 id="SGI-STL-的主要特性"><a href="#SGI-STL-的主要特性" class="headerlink" title="SGI STL 的主要特性"></a>SGI STL 的主要特性</h4><ul><li>提供了 STL 的主要组件：<code>vector</code>、<code>list</code>、<code>map</code>、<code>set</code>、<code>algorithm</code>、<code>iterator</code> 等。</li><li>包含一些非标准扩展，例如：<ul><li><code>slist</code>（单向链表）</li><li><code>hash_map</code> / <code>hash_set</code>（后来的 <code>unordered_map</code> / <code>unordered_set</code> 的前身）</li></ul></li><li>代码高度模板化、效率高、注释详尽。</li><li>源码开放，很多 C++ 开发者都用它来学习 STL 的底层实现。</li></ul><h4 id="SGI-STL-的历史作用"><a href="#SGI-STL-的历史作用" class="headerlink" title="SGI STL 的历史作用"></a>SGI STL 的历史作用</h4><p>SGI STL 是 现代 C++ STL 的原型，其思想和实现对 C++ 98 标准 STL 的设计有极大影响。许多早期编译器，如 GCC、MSVC、Intel C++，都在某个时期采用过 SGI STL 或其变种（比如 STLport）。</p><div class="admonition note"><p class="admonition-title">今天还需要使用 SGI STL 吗</p><ul><li>通常不需要使用 SGI STL，因为现代 C++ 编译器都自带符合标准的 STL 实现，比如 GCC：libstdc++、Clang：libc++、MSVC：Dinkumware。</li><li>如果是为了学习 STL 的内部实现机制（底层原理），SGI STL 是一个非常好的教学资源；但在生产环境中，应该使用现代 C++ STL（标准模板库）。</li></ul></div><h4 id="SGI-STL-与-C-STL-的区别"><a href="#SGI-STL-与-C-STL-的区别" class="headerlink" title="SGI STL 与 C++ STL 的区别"></a>SGI STL 与 C++ STL 的区别</h4><table><thead><tr><th>项目</th><th> SGI STL</th><th>C++ STL（标准模板库）</th></tr></thead><tbody><tr><td>作者 / 出处</td><td> SGI 公司（如 STLport）</td><td>C++ 标准委员会</td></tr><tr><td>标准性</td><td>非正式实现，非标准的一些扩展</td><td>从 C++ 98 开始，成为标准 C++ 的一部分</td></tr><tr><td>扩展内容</td><td><code>hash_map</code>、<code>slist</code>、<code>rope</code> 等非标准组件</td><td>标准化容器如 <code>vector</code>、<code>deque</code>、<code>map</code>、<code>set</code> 等</td></tr><tr><td>可移植性</td><td>与平台、编译器耦合程度较高</td><td>作为标准模板库，各主流编译器都支持</td></tr><tr><td>现代兼容性</td><td>不支持 C++ 11 及以后的特性</td><td>现代 STL 持续演进（如 <code>move semantics</code>, <code>unordered_map</code>, <code>ranges</code> 等）</td></tr><tr><td>教育价值</td><td>非常适合学习 STL 实现机制</td><td>通常以黑箱方式使用</td></tr></tbody></table><h3 id="自由链表"><a href="#自由链表" class="headerlink" title="自由链表"></a>自由链表</h3><p>这里将介绍 SGI STL 二级空间配置器中自由链表的底层实现。</p><h4 id="自由链表是什么"><a href="#自由链表是什么" class="headerlink" title="自由链表是什么"></a>自由链表是什么</h4><p>自由链表是一种用于管理空闲内存块的链表结构。每个链表节点指向一个未被使用的内存块，便于快速分配和回收。在 SGI STL 的二级空间配置器中，自由链表有以下特点：</p><ul><li>每种固定大小的内存块（如 8 字节、16 字节、24 字节 …）都有一个对应的自由链表。</li><li>小对象内存块的复用：当用户释放内存时，并不会直接 <code>free()</code>，而是将内存放回对应的自由链表中，供后续复用。</li><li>分配内存时，优先从自由链表中取；只有自由链表为空时，才会从系统堆（Heap）分配一大块内存进行切分。</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>数量</td><td> 16 个自由链表（按 8 ~ 128 字节分为 16 类）</td></tr><tr><td>数据结构</td><td><code>union obj</code> 实现链表节点</td></tr><tr><td>分配策略</td><td>优先从自由链表取，否则从堆中批量 <code>refill()</code></td></tr><tr><td>回收策略</td><td>小块内存回收到对应的自由链表，大块内存直接释放</td></tr><tr><td>性能优势</td><td>避免频繁 <code>malloc</code> / <code>free</code>，显著减少内存碎片和内存开辟 / 释放的开销</td></tr></tbody></table><h4 id="自由链表的结构"><a href="#自由链表的结构" class="headerlink" title="自由链表的结构"></a>自由链表的结构</h4><p><img data-src="../../../asset/2025/04/sgi-stl-2.png"></p><h5 id="内存块粒度与分类"><a href="#内存块粒度与分类" class="headerlink" title="内存块粒度与分类"></a>内存块粒度与分类</h5><ul><li>内存块的粒度信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (__SUNPRO_CC) || defined (__GNUC__)</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_ALIGN = <span class="number">8</span>};            <span class="comment">// 小块内存的对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_MAX_BYTES = <span class="number">128</span>};      <span class="comment">// 二级空间配置器最大管理范围（128 字节）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_NFREELISTS = <span class="number">16</span>};      <span class="comment">// 自由链表的数量，计算方式：_MAX_BYTES / _ALIGN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>一共维护 16 个自由链表，每个自由链表负责管理一种字节大小的内存块：</li></ul><table><thead><tr><th>自由链表的下标</th><th>内存块的大小</th></tr></thead><tbody><tr><td> 0</td><td>8 字节</td></tr><tr><td> 1</td><td>16 字节</td></tr><tr><td> 2</td><td>24 字节</td></tr><tr><td>…</td><td>…</td></tr><tr><td>15</td><td>128 字节</td></tr></tbody></table><h5 id="自由链表节点结构"><a href="#自由链表节点结构" class="headerlink" title="自由链表节点结构"></a>自由链表节点结构</h5><ul><li>每个空闲内存块都可以看作是一个 <code>_Obj</code>，其中 <code>_M_free_list_link</code> 用来链接空闲内存块（最终形成自由链表）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span>    <span class="comment">// 下一个内存 chunk 块的地址</span></span><br><span class="line">    <span class="keyword">char</span> _M_client_data [<span class="number">1</span>];          <span class="comment">// 实际分配给用户的内存起始位置</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="自由链表的存储结构"><a href="#自由链表的存储结构" class="headerlink" title="自由链表的存储结构"></a>自由链表的存储结构</h5><ul><li>这个数组保存了每种块大小的链表头指针 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list [_NFREELISTS];  <span class="comment">// 16 个自由链表</span></span><br></pre></td></tr></tbody></table></figure><h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><ul><li>当调用 <code>allocate(n)</code>：<ul><li>如果 <code>n &gt; 128</code>，则交由一级空间配置器处理（直接调用 <code>malloc()</code> 分配内存）。</li><li>否则：<ul><li>(1) 将 <code>n</code> 向上对齐到 8 的倍数（实现内存对齐）。</li><li>(2) 找到对应的自由链表索引。</li><li>(3) 如果该链表非空，从中取一个满足大小的空闲内存块返回。</li><li>(4) 如果链表为空，调用 <code>refill()</code> 从堆上批量分配一大块内存（默认分配 2 x 20 个块），挂到自由链表上。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2025/04/sgi-stl-7.png"></p><h5 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h5><ul><li>当调用 <code>deallocate(p, n)</code>：<ul><li>如果 <code>n &gt; 128</code>，则交由一级空间配置器处理（直接调用 <code>free()</code> 释放内存）。</li><li>否则：<ul><li>(1) 将 <code>n</code> 向上对齐到 8 的倍数（实现内存对齐）。</li><li>(2) 找到对应的自由链表索引。</li><li>(3) 把块头强制转换为 <code>obj*</code>，插入到自由链表的头部（头插法）。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2025/04/sgi-stl-8.png"></p><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><p>在剖析 SGI STL 的内存池源码时，建议以 <code>vector</code> 容器的源码作为切入点，然后一步步分析一级和二级空间配置器的底层实现，如下图所示：</p><p><img data-src="../../../asset/2025/04/sgi-stl-3.png"></p><h4 id="空间配置器的相关定义"><a href="#空间配置器的相关定义" class="headerlink" title="空间配置器的相关定义"></a>空间配置器的相关定义</h4><ul><li><code>vector</code> 容器的定义 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> __STL_DEFAULT_ALLOCATOR (_Tp) &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> :</span> <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt; { }</span><br></pre></td></tr></tbody></table></figure><ul><li><code>vector</code> 容器的默认空间配置器是 <code>__STL_DEFAULT_ALLOCATOR ( _Tp)</code>，它是一个宏定义，如下：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __STL_DEFAULT_ALLOCATOR</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR (T) allocator<span class="meta-string">&lt; T &gt;</span>   <span class="comment">// 使用标准 STL allocator（一级空间配置器）</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR (T) alloc            <span class="comment">// 使用 SGI alloc（二级空间配置器）</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>从上面可以看到 <code>__STL_DEFAULT_ALLOCATOR</code> 通过宏控制有两种空间配置器实现，一种是 <code>allocator&lt;T&gt;</code>，另一种是 <code>alloc</code>，这两种分别就是 SGI STL 的一级空间配置器和二级空间配置器的实现 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span>           // 一级空间配置器内存管理类（底层通过 <span class="title">malloc</span> 和 <span class="title">free</span> 管理内存）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> {</span> }      <span class="comment">// 二级空间配置器内存管理类（底层通过自定义内存池实现内存管理）</span></span><br></pre></td></tr></tbody></table></figure><ul><li>SGI STL 的一级和二级空间配置器对比</li></ul><table><thead><tr><th>类型</th><th>实现类</th><th>内存管理机制</th><th>用途</th><th>源码位置</th></tr></thead><tbody><tr><td>一级空间配置器</td><td><code>__malloc_alloc_template</code></td><td><code>malloc() / free()</code></td><td>分配大块内存</td><td>定义在 <code>stl_alloc.h</code> 头文件，<a href="../../../asset/2025/04/sgi-stl-4.png">如图所示</a></td></tr><tr><td>二级空间配置器</td><td><code>__default_alloc_template</code></td><td>内存池机制</td><td>分配小块内存，其核心机制就是使用一组自由链表（Free List）来管理内存块，提高小对象（小于等于 128 字节）的内存分配效率，底层也是使用 <code>malloc() / free()</code> 分配和释放内存</td><td>定义在 <code>stl_alloc.h</code> 头文件，<a href="../../../asset/2025/04/sgi-stl-5.png">如图所示</a></td></tr></tbody></table><div class="admonition note"><p class="admonition-title">SGI STL 默认的空间配置器</p><p>从上面的 <code>vector</code> 容器源码可以发现，SGI STL 的每一个容器都已经指定其缺省的空间配置器为 <code>alloc</code>，即默认使用的是二级空间配置器 <code>__default_alloc_template</code>。</p></div><h4 id="重要类型和变量的定义"><a href="#重要类型和变量的定义" class="headerlink" title="重要类型和变量的定义"></a>重要类型和变量的定义</h4><p>在 SGI STL 的二级空间配置器（<code>__default_alloc_template</code>）中，有以下重要类型和变量定义，其底层的自由链表节点结构如下图所示：</p><p><img data-src="../../../asset/2025/04/sgi-stl-1.png"></p><ul><li>内存池的粒度信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (__SUNPRO_CC) || defined (__GNUC__)</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_ALIGN = <span class="number">8</span>};            <span class="comment">// 小块内存的对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_MAX_BYTES = <span class="number">128</span>};      <span class="comment">// 小块内存的最大字节数（128 字节）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_NFREELISTS = <span class="number">16</span>};      <span class="comment">// 自由链表的数量，计算方式：_MAX_BYTES / _ALIGN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>每一个内存 chunk 块的头信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span>     <span class="comment">// 下一个内存 chunk 块的地址</span></span><br><span class="line">    <span class="keyword">char</span> _M_client_data [<span class="number">1</span>];           <span class="comment">// 实际分配给用户的内存起始位置</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>组织所有自由链表的数组，数组的每一个元素的类型都是 <code>_Obj*</code>，全部初始化为 <code>0</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list [_NFREELISTS]; </span><br></pre></td></tr></tbody></table></figure><ul><li>记录内存 chunk 块的分配情况 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chunk allocation state.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="重要的辅助接口函数"><a href="#重要的辅助接口函数" class="headerlink" title="重要的辅助接口函数"></a>重要的辅助接口函数</h4><ul><li>将 <code>__bytes</code> 上调至最邻近的 8 的倍数（实现内存对齐）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up (<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>返回 <code>__bytes</code> 大小的 chunk 块位于自由链表数组中的索引 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index (<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理核心函数"><a href="#内存池管理核心函数" class="headerlink" title="内存池管理核心函数"></a>内存池管理核心函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配内存的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span> <span class="params">(<span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配新的 chunk 块，并将分配好的 chunk 块进行连接，添加到自由链表当中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* _S_refill (<span class="keyword">size_t</span> __n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配相应内存字节大小的 chunk 块</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc (<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 chunk 块归还到内存池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span> <span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池扩容/缩容函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span> <span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理总结说明"><a href="#内存池管理总结说明" class="headerlink" title="内存池管理总结说明"></a>内存池管理总结说明</h4><blockquote><p>SGI STL 对内存分配和内存释放的设计哲学</p></blockquote><ul><li>向 System Heap 要内存空间。</li><li>考虑多线程（Multi Threads）状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多 “小型区块内存” 可能造成的内存碎片（Fragment）问题</li></ul><blockquote><p>SGI STL 二级空间配置器中内存池的优点</p></blockquote><ul><li><p><strong>内存分配具有预留机制</strong></p><ul><li>对于每种特定字节大小的 chunk（内存块）分配，内存池并不会仅分配刚好所需的内存，而是会一次性申请较大一块内存，并将其划分为多个 chunk（比如 40 个）。其中一部分（20 个 chunk）立即用于分配，另一部分（20 个 chunk）作为备用，供后续相同字节大小的分配请求使用。更重要的是，如果其他字节大小的 chunk 分配失败，这部分备用内存也有可能被重新划分后用于其他字节大小的 chunk 分配请求，从而提升内存使用的灵活性与效率。</li></ul></li><li><p><strong>最大化利用碎片内存</strong></p><ul><li>在将一大块备用内存划分为若干 chunk 后，可能会剩下一小部分无法完整划分的内存碎片。SGI STL 会在后续分配中尽可能再次利用这些内存碎片，避免资源浪费，确保备用内存池被 “用得干干净净”。</li></ul></li><li><p><strong>具有健壮的回退机制</strong></p><ul><li>当某一特定字节大小的内存块分配失败时，二级空间配置器会遍历所有字节大小的自由链表，查找是否有可用的空闲 chunk 块可暂时 “借用”。如果发现其他链表中有满足需求的空闲 chunk 块，就会将其临时分配出去，以缓解当前内存分配压力。如果其他链表中没有满足需求的空闲 chunk 块可以借用，就会直接调用 <code>malloc()</code> 继续分配内存空间。</li></ul></li><li><p><strong>支持 OOM 回调机制</strong></p><ul><li>如果其他自由链表中没有空闲的 chunk 块可以借用，且调用 <code>malloc()</code> 分配内存失败，那么二级空间配置器将尝试调用用户预设的 <code>oom_handler</code> 回调函数（可以用于释放用户自定义的内存资源），以应对 <code>malloc()</code> 执行失败的情况（在死循环中处理）。若用户未设置 <code>oom_handler</code> 回调函数，则直接抛出 OOM（Out Of Memory）异常，提示内存分配失败，确保程序行为的可控性和安全性。</li></ul></li></ul><blockquote><p>SGI STL 一级和二级空间配置器的关系</p></blockquote><p><img data-src="../../../asset/2025/04/sgi-stl-9.png"></p><blockquote><p>SGI STL 内存池的的核心源码文件</p></blockquote><p><img data-src="../../../asset/2025/04/sgi-stl-6.png"></p><h3 id="源码移植"><a href="#源码移植" class="headerlink" title="源码移植"></a>源码移植</h3><p>这里将移植 SGI STL 二级空间配置器中的内存池代码，即单独抽出内存池的代码以复用，其中移植的代码主要位于 SGI STL 的 <code>stl_alloc.h</code> 头文件中。</p><h4 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h4><ul><li><code>allocator.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一级空间配置器，按字节分配大块内存</span></span><br><span class="line"><span class="comment">// 封装 malloc() 和 free() 来实现内存管理，可以设置发生 OOM 时释放内存的回调函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __result) {</span><br><span class="line">            <span class="comment">// 调用OOM处理流程</span></span><br><span class="line">            __result = _S_oom_malloc(__n);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(__p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存空间重分配</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __result) {</span><br><span class="line">            <span class="comment">// 调用OOM处理流程</span></span><br><span class="line">            __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的OOM处理函数，返回旧的处理函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in"><span class="keyword">void</span></span> (*__old)() = __malloc_alloc_oom_handler;</span><br><span class="line">        __malloc_alloc_oom_handler = __f;</span><br><span class="line">        <span class="keyword">return</span> (__old);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存空间开辟时的OOM处理流程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> *_S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存空间重分配时的OOM处理流程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> *_S_oom_realloc(<span class="keyword">void</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OOM回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="params">(*__malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)</span><span class="params">()</span> </span>= <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__malloc_alloc_template&lt;inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n) {</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span> *__result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环，不断尝试释放、申请、再释放、再申请...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) { <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); }</span><br><span class="line">        <span class="comment">// 调用OOM回调函数</span></span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        <span class="comment">// 再次尝试申请内存</span></span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__malloc_alloc_template&lt;inst&gt;::_S_oom_realloc(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> __n) {</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span> *__result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环，不断尝试释放、重分配、再释放、再重分配...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) { <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); }</span><br><span class="line">        <span class="comment">// 调用OOM回调函数</span></span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        <span class="comment">// 再次尝试内存重分配</span></span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定义类型</span></span><br><span class="line"><span class="keyword">using</span> malloc_alloc = __malloc_alloc_template&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级空间配置器，按字节分配小块内存</span></span><br><span class="line"><span class="comment">// 基于自由链表原理的内存池机制来实现内存管理</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__ret = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配大块内存（当字节数大于 128）</span></span><br><span class="line">        <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) {</span><br><span class="line">            <span class="comment">// 调用一级空间配置器分配大内存</span></span><br><span class="line">            __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 分配小块内存</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表的互斥锁</span></span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; __lock_instance(_S_free_list_mtx[_S_freelist_index(__n)]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取自由链表的头节点</span></span><br><span class="line">            _Obj *__result = *__my_free_list;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果头节点为空（即没有空闲的内存 chunk 块），则分配新的内存 chunk 块</span></span><br><span class="line">            <span class="keyword">if</span> (__result == <span class="literal">nullptr</span>) {</span><br><span class="line">                __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果有空闲的内存 chunk 块，则将其取出来，并维护自由链表的结构</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 将自由链表的头节点指向下一个内存 chunk 块</span></span><br><span class="line">                *__my_free_list = __result-&gt;_M_free_list_link;</span><br><span class="line">                __ret = __result;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> __ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> __n)</span> </span>{</span><br><span class="line">        <span class="comment">// 大块内存（当字节数大于 128）直接交由一级空间配置器释放掉</span></span><br><span class="line">        <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) {</span><br><span class="line">            malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 小块内存回收到自由链表</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">            _Obj *__q = (_Obj *) __p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表的互斥锁</span></span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; __lock_instance(_S_free_list_mtx[_S_freelist_index(__n)]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回收内存，将释放的小块内存插入到自由链表的头部（头插法）</span></span><br><span class="line">            __q-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = __q;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存池扩容 / 缩容</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__result;</span><br><span class="line">        <span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种情况：当新旧大小均超过最大内存池处理阈值是，直接调用系统的 realloc()</span></span><br><span class="line">        <span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) {</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">realloc</span>(__p, __new_sz));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种情况：当新旧内存块在内存池中的对齐后大小相等，则直接复用旧内存块</span></span><br><span class="line">        <span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) {</span><br><span class="line">            <span class="keyword">return</span> (__p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三种情况：需要执行内存重分配</span></span><br><span class="line">        __result = <span class="built_in">allocate</span>(__new_sz);    <span class="comment">// 申请新内存块（根据内存池策略）</span></span><br><span class="line">        __copy_sz = __new_sz &gt; __old_sz ? __old_sz : __new_sz;   <span class="comment">// 安全拷贝大小（取较小值）</span></span><br><span class="line">        <span class="built_in">memcpy</span>(__result, __p, __copy_sz);    <span class="comment">// 数据拷贝（仅拷贝有效内容）</span></span><br><span class="line">        <span class="built_in">deallocate</span>(__p, __old_sz);     <span class="comment">// 释放旧内存块（根据旧内存块的大小进行回收）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> {</span> _ALIGN = <span class="number">8</span> };            <span class="comment">// 小块内存的对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> {</span> _MAX_BYTES = <span class="number">128</span> };      <span class="comment">// 小块内存的最大字节数（128 字节）</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> {</span> _NFREELISTS = <span class="number">16</span> };      <span class="comment">// 自由链表的数量，计算方式：_MAX_BYTES / _ALIGN</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个内存 chunk 块的头信息</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> *_<span class="title">M_free_list_link</span>;</span>        <span class="comment">// 下一个内存 chunk 块的地址</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];                <span class="comment">// 实际分配给用户的内存起始位置</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录内存 chunk 块的分配情况</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *_S_start_free;     <span class="comment">// 整个内存池的起始位置，只在 _S_chunk_alloc() 中发生变化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *_S_end_free;       <span class="comment">// 整个内存池的结束位置，只在 _S_chunk_alloc() 中发生变化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组织所有自由链表的数组，数组的每一个元素的类型都是 _Obj*</span></span><br><span class="line">    <span class="keyword">static</span> _Obj *<span class="keyword">volatile</span> _S_free_list[_NFREELISTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有自由链表的互斥锁的数组（内存池基于自由链表实现，需要考虑线程安全问题，为每个自由链表添加一个互斥锁，降低锁的粒度）</span></span><br><span class="line">    <span class="keyword">static</span> std::mutex _S_free_list_mtx[_NFREELISTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 __bytes 上调至最邻近的 8 的倍数（实现内存对齐）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 __bytes 大小的 chunk 块位于自由链表数组中的索引</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的内存 chunk 块，并将分配好的 chunk 块进行连接，添加到自由链表当中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> *_S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配相应字节大小的内存 chunk 块</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span> &amp;__nobjs);</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员变量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;inst&gt;::_S_start_free = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;inst&gt;::_S_end_free = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line">std::mutex __default_alloc_template&lt;inst&gt;::_S_free_list_mtx[_NFREELISTS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;inst&gt;::_Obj *<span class="keyword">volatile</span> __default_alloc_template&lt;inst&gt;::_S_free_list[_NFREELISTS] = {<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">                                                                                                                     <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__default_alloc_template&lt;inst&gt;::_S_refill(<span class="keyword">size_t</span> __n) {</span><br><span class="line">    <span class="comment">// 一次性分配 20 个内存 chunk 块，但万一内存空间不足，获得的块数可能小于 20</span></span><br><span class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配多个指定大小的内存 chunk 块，参数 __nobjs 使用引用传递</span></span><br><span class="line">    <span class="keyword">char</span> *__chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line"></span><br><span class="line">    _Obj *<span class="keyword">volatile</span> *__my_free_list;</span><br><span class="line">    _Obj *__result;</span><br><span class="line">    _Obj *__current_obj;</span><br><span class="line">    _Obj *__next_obj;</span><br><span class="line">    <span class="keyword">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只获得一个内存 chunk 块，就直接分配给调用者使用，自由链表不会添加新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) {</span><br><span class="line">        <span class="keyword">return</span> (__chunk);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将分配到的多个内存 chunk 块添加到对应的自由链表中（即将各个 chunk 块串联起来）</span></span><br><span class="line">    __result = (_Obj *) __chunk;    <span class="comment">// 这个内存 chunk 返回给调用者</span></span><br><span class="line">    *__my_free_list = __next_obj = (_Obj *) (__chunk + __n);</span><br><span class="line">    <span class="keyword">for</span> (__i = <span class="number">1</span>;; __i++) {     <span class="comment">// 从 1 开始，因为第 0 个返回给调用者</span></span><br><span class="line">        __current_obj = __next_obj;</span><br><span class="line">        __next_obj = (_Obj *) ((<span class="keyword">char</span> *) __next_obj + __n);</span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) {</span><br><span class="line">            __current_obj-&gt;_M_free_list_link = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            __current_obj-&gt;_M_free_list_link = __next_obj;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (__result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span> &amp;__nobjs) {</span><br><span class="line">    <span class="keyword">char</span> *__result;</span><br><span class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;    <span class="comment">// 计算需要分配的总字节数</span></span><br><span class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;    <span class="comment">// 获取整个内存池剩余空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种情况：整个内存池的剩余空间完全可以满足需求</span></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) {</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 第二种情况：整个内存池的剩余空间不能满足全部需求，但至少能分配一个以上的内存 chunk 块</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) {</span><br><span class="line">        <span class="comment">// 更改为实际能够供应的内存 chunk 数</span></span><br><span class="line">        __nobjs = (<span class="keyword">int</span>) (__bytes_left / __size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 第三种情况：整个内存池的剩余空间不足一个内存 chunk 块大小</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 计算需要申请的内存总量：2倍需求 + 附加量（堆大小的1/16并向上对齐）</span></span><br><span class="line">        <span class="keyword">size_t</span> __bytes_to_get = <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试回收利用内存池的剩余碎片</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list = _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line">            <span class="comment">// 将剩余碎片插入到自由链表的头部（头插法）</span></span><br><span class="line">            ((_Obj *) _S_start_free)-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj *) _S_start_free;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请新的内存块并添加到内存池中</span></span><br><span class="line">        _S_start_free = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(__bytes_to_get);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  新的内存块申请失败处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == _S_start_free) {</span><br><span class="line">            <span class="keyword">size_t</span> __i;</span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list;</span><br><span class="line">            _Obj *__p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试从其他字节数更大的自由链表中查找可用内存块</span></span><br><span class="line">            <span class="comment">// 注意：不尝试从字节数更小的自由链表中查找，因为在多处理器环境中容易出现问题</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size; __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES; __i += (<span class="keyword">size_t</span>) _ALIGN) {</span><br><span class="line">                <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="comment">// 找到可用内存块</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">nullptr</span> != __p) {</span><br><span class="line">                    <span class="comment">// 调整自由链表以获取未使用的内存块</span></span><br><span class="line">                    *__my_free_list = __p-&gt;_M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="keyword">char</span> *) __p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="comment">// 递归调用自身，为了修正 __nobjs</span></span><br><span class="line">                    <span class="keyword">return</span> (_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// 注意：任何剩余碎片最终都会被加入到合适的自由链表中备用</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 所有自由链表都无可用内存时的最后处理手段</span></span><br><span class="line">            _S_end_free = <span class="literal">nullptr</span>;    <span class="comment">// 异常安全处理</span></span><br><span class="line">            _S_start_free = (<span class="keyword">char</span> *) malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);    <span class="comment">// 调用一级空间配置器分配内存（可能会抛出OOM异常）</span></span><br><span class="line">            <span class="comment">// 此处假设分配操作总会成功（要么抛出异常，要么解决问题）</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新内存池管理参数</span></span><br><span class="line">        _S_heap_size += __bytes_to_get;    <span class="comment">// 累计分配的内存总量</span></span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get;    <span class="comment">// 设置新的内存池结束位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用自身，为了修正 __nobjs（此时内存池已有新申请的内存块）</span></span><br><span class="line">        <span class="keyword">return</span> (_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定义类型</span></span><br><span class="line"><span class="keyword">using</span> default_alloc = __default_alloc_template&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间配置器的接口，符合 STL 规范，按元素的大小分配内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simple_alloc</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定义类型</span></span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">simple_alloc</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">simple_alloc</span><span class="params">(<span class="keyword">const</span> simple_alloc &amp;)</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _U, class _Other&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="title">simple_alloc</span><span class="params">(<span class="keyword">const</span> simple_alloc&lt;_U, _Other&gt; &amp;)</span> <span class="keyword">noexcept</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="literal">nullptr</span> : (T *) Alloc::<span class="built_in">allocate</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) Alloc::<span class="built_in">allocate</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) {</span><br><span class="line">            Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（利用可变参数模板 + 引用折叠 + 完美转发）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *__p, Args &amp;&amp;... args)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(__p) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *__p)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存析构对象</span></span><br><span class="line">        __p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"allocator.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deepCopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *source)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (source) {</span><br><span class="line">            name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(source) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name, source);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            name = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> age) : <span class="built_in">age</span>(age) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person(name, age)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">deepCopy</span>(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;other) : <span class="built_in">age</span>(other.age) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person(const Person&amp;)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">deepCopy</span>(other.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符</span></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Person &amp;other) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person&amp; operator=(const Person&amp;)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) {</span><br><span class="line">            <span class="comment">// 先释放原有内存</span></span><br><span class="line">            <span class="keyword">delete</span>[] name;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拷贝新数据</span></span><br><span class="line">            age = other.age;</span><br><span class="line">            <span class="built_in">deepCopy</span>(other.name);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; (name ? name : <span class="string">"[Unnamed]"</span>) &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试基础类型的内存分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 SGI STL 二级空间配置器</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>, simple_alloc&lt;<span class="keyword">int</span>, default_alloc&gt;&gt; vec1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">        vec1.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;item : vec1) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试自定义类型的内存分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用 SGI STL 二级空间配置器</span></span><br><span class="line">    vector&lt;Person, simple_alloc&lt;Person, default_alloc&gt;&gt; vec2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不想频繁触发容器扩容，可以强制指定容器的预留容量</span></span><br><span class="line">    <span class="comment">// vec2.reserve(5);</span></span><br><span class="line"></span><br><span class="line">    vec2.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">"Jim"</span>, <span class="number">18</span>));</span><br><span class="line">    vec2.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">"Peter"</span>, <span class="number">23</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec2.<span class="built_in">begin</span>(); it != vec2.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        it-&gt;<span class="built_in">display</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>测试代码运行的输出结果 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3 4 1 8 8 5 10 1 8 8 </span><br><span class="line">Person(name, age)           // 构造临时对象 Jim</span><br><span class="line">Person(const Person&amp;)       // push_back 时拷贝临时对象 Jim 进容器</span><br><span class="line">~Person()                   // 析构临时对象 Jim</span><br><span class="line">Person(name, age)           // 构造临时对象 Peter</span><br><span class="line">Person(const Person&amp;)       // push_back 时触发容器扩容后，拷贝容器已有元素 Jim 到新容器中</span><br><span class="line">Person(const Person&amp;)       // push_back 时触发容器扩容后，拷贝临时对象 Peter 到新容器中</span><br><span class="line">~Person()                   // 析构旧容器中的对象 Jim</span><br><span class="line">~Person()                   // 析构临时对象 Peter</span><br><span class="line">Name: Jim, Age: 18</span><br><span class="line">Name: Peter, Age: 23</span><br><span class="line">~Person()                   // 析构新容器中的对象 Jim</span><br><span class="line">~Person()                   // 析构新容器中的对象 Peter</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.51cto.com/u_16099355/10572558">容器内存分析 STL 容器内存分配</a></li><li><a href="https://www.cnblogs.com/wofeishenling/articles/17702398.html">SGI STL 二级空间配置器内存池源码</a></li><li><a href="https://www.cnblogs.com/fortunely/p/16219743.html">SGI STL 空间配置器 allocator /alloc</a></li><li><a href="https://blog.csdn.net/mmshixing/article/details/51672434">SGI STL 空间配置器 - 第二级空间配置器</a></li><li><a href="https://zhuanlan.zhihu.com/p/712899055">高效利用内存资源：掌握内存池设计与实现</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 SGI STL 内存池的底层源码。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="源码剖析" scheme="https://www.techgrow.cn/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>C++ 算法入门教程之一</title>
    <link href="https://www.techgrow.cn/posts/73b8af5d.html"/>
    <id>https://www.techgrow.cn/posts/73b8af5d.html</id>
    <published>2025-04-07T13:55:33.000Z</published>
    <updated>2025-04-07T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大数的加减法"><a href="#大数的加减法" class="headerlink" title="大数的加减法"></a>大数的加减法</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/mrqiuwen/article/details/127057549">C++ 实现大数加减法</a></li><li><a href="https://zhuanlan.zhihu.com/p/92141234">一文读懂大数加减乘除</a></li><li><a href="https://www.cnblogs.com/hello-nullptr/p/18536106">C++ 大整数相加的实现</a></li><li><a href="https://cloud.tencent.com/developer/article/1818199">大数加减乘除运算总结</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 常用的数据结构与算法。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 内存池源码剖析</title>
    <link href="https://www.techgrow.cn/posts/5bc5018f.html"/>
    <id>https://www.techgrow.cn/posts/5bc5018f.html</id>
    <published>2025-03-23T13:55:33.000Z</published>
    <updated>2025-03-23T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/5bc5018f.html">Nginx 内存池源码剖析</a></li><li><a href="/posts/712a574b.html">SGI STL 内存池源码剖析</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将剖析 Nginx 内存池的源码，并介绍内存池的底层设计和工作原理，最后基于 C++ 移植 Nginx 内存池的核心源码。值得一提的是，移植后的 C++ 代码兼容 Windows 和 Linux 平台。</p><div class="admonition note"><p class="admonition-title">C++ 常见的池</p><p>在 C++ 中有五大池，包括内存池、连接池、协程池、线程池、进程池。</p></div><span id="more"></span><h3 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h3><p>内存管理，是指软件运行时对计算机内存资源的分配和使用的技术。<strong>其最主要的目的是如何高效、快速地分配内存，并且在适当的时候释放和回收内存资源。</strong></p><h3 id="源码学习目标"><a href="#源码学习目标" class="headerlink" title="源码学习目标"></a>源码学习目标</h3><p>在剖析 Nginx 内存管理的源码之前，先思考以下几个问题：</p><ul><li>(1) Nginx 为什么要进行内存管理？</li><li>(2) Nginx 如何进行内存管理？</li><li>(3) Nginx 的内存管理解决了哪些问题？</li></ul><h2 id="Nginx-内存池"><a href="#Nginx-内存池" class="headerlink" title="Nginx 内存池"></a>Nginx 内存池</h2><h3 id="内存池的源码剖析"><a href="#内存池的源码剖析" class="headerlink" title="内存池的源码剖析"></a>内存池的源码剖析</h3><p>这里剖析的 Nginx 版本是 <code>1.12.2</code>，Nginx 内存池的核心源码主要位于 <code>ngx_palloc.h</code> 和 <code>ngx_palloc.c</code> 源文件中。</p><h4 id="重要类型和变量的定义"><a href="#重要类型和变量的定义" class="headerlink" title="重要类型和变量的定义"></a>重要类型和变量的定义</h4><ul><li>Nginx 内存池的粒度信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NGX_MAX_ALLOC_FROM_POOL should be (ngx_pagesize - 1), i.e. 4095 on x86. On Windows NT it decreases a number of locked pages in a kernel.</span></span><br><span class="line"><span class="comment">// 小块内存池单次分配的最大内存大小，不能超过 ngx_pagesize - 1，超过这个大小的内存不会从内存池中分配，而是通过 malloc() 之类的方式单独分配内存。</span></span><br><span class="line"><span class="comment">//ngx_pagesize 是系统页面大小（例如 x86 平台是 4096 字节），减 1 是为了确保对齐且不会跨页，最终小块内存池单次分配的最大内存大小为 4095 字节（x86 平台）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池的默认初始大小为 16KB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_DEFAULT_POOL_SIZE (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池分配时的对齐字节数为 16 字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_POOL_ALIGNMENT 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存的最小可接受大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MIN_POOL_SIZE ngx_align ((sizeof (ngx_pool_t) + 2 * sizeof (ngx_pool_large_t)), NGX_POOL_ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存分配时的对齐字节数，通常是 4 字节（32 位系统）或者 8 字节（64 位系统）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_ALIGNMENT sizeof (unsigned long)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Nginx 内存池的主结构体类型 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;         <span class="comment">// 小块内存池的数据头</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;       <span class="comment">// 小块内存分配的最大值</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;   <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;     <span class="comment">// 该指针挂接一个 ngx_chain_t 结构</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;     <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;   <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *log;       <span class="comment">// 内存分配相关的日志记录</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>小块内存的数据头信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">   u_char               *last;      <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">   u_char               *end;       <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">   <span class="keyword">ngx_pool_t</span>           *next;      <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">   <span class="keyword">ngx_uint_t</span>            failed;    <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">} <span class="keyword">ngx_pool_data_t</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>大块内存的类型定义 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">   <span class="keyword">ngx_pool_large_t</span>     *next;      <span class="comment">// 下一个大块内存</span></span><br><span class="line">   <span class="keyword">void</span>                 *alloc;     <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>清理操作的类型定义，包括一个清理回调函数、传给回调函数的数据和下一个清理操作的地址 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;    <span class="comment">// 清理回调函数的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>  <span class="title">ngx_pool_cleanup_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> {</span></span><br><span class="line">   ngx_pool_cleanup_pt   handler;   <span class="comment">// 函数指针，指向内存清理操作的回调函数</span></span><br><span class="line">   <span class="keyword">void</span>                 *data;      <span class="comment">// 传递给回调函数的参数</span></span><br><span class="line">   <span class="keyword">ngx_pool_cleanup_t</span>   *next;      <span class="comment">// 指向下一个清理操作</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="重要的内存池函数接口"><a href="#重要的内存池函数接口" class="headerlink" title="重要的内存池函数接口"></a>重要的内存池函数接口</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span> *<span class="title">ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span>;   <span class="comment">// 创建内存池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;    <span class="comment">// 销毁内存池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;      <span class="comment">// 重置内存池</span></span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理核心函数"><a href="#内存池管理核心函数" class="headerlink" title="内存池管理核心函数"></a>内存池管理核心函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> * <span class="title">ngx_palloc_small</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span>   <span class="comment">// 内存池分配小块内存的入口函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">ngx_palloc_block</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span>     <span class="comment">// 内存池分配新小块内存（在小块内存块空间不足时）</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">ngx_palloc_large</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span>     <span class="comment">// 内存池分配大块内存的入口函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">ngx_int_t</span> <span class="title">ngx_pfree</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span>     <span class="comment">// 内存池释放大块内存的入口函数</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="内存池的底层设计"><a href="#内存池的底层设计" class="headerlink" title="内存池的底层设计"></a>内存池的底层设计</h3><p>Nginx 中所有请求都单独对应一个内存池，在这个请求的过程中，所有涉及到内存分配的地方，都到该请求相关的内存池中处理，而中间不会去释放内存，内存池的生命周期与请求一样，请求完毕则直接回收内存。这样的好处在于：统一分配和统一释放，降低了内存泄露问题的出现。Nginx 的内存池设计分为两个部分：</p><ul><li>大块内存：超过 <code>max</code> 大小（默认 4095 字节）的内存分配，走大块内存分配，这部分内存管理由 <code>ngx_pool_large_t</code> 结构体负责。</li><li>小块内存：在 <code>ngx_pool_t</code> 链表中遍历符合要求的 <code>ngx_pool_t</code> 结构体，找到符合要求大小的 <code>pool</code> 直接返回，否则就申请新的小块内存 <code>pool</code>。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>小块内存在分配后不会被单独释放，而是在整个内存池销毁（<code>ngx_destroy_pool()</code>）时，通过 <code>free()</code> 一次性释放。</li><li>大块内存会在整个内存池重置（<code>ngx_reset_pool()</code>）或者整个内存池销毁（<code>ngx_destroy_pool()</code>）时被 <code>free()</code> 释放，但还可以手动调用 <code>ngx_pfree()</code> 单独释放。</li><li>小块内存的重用机制：Nginx 也有机制尝试在链表中查找可用内存块（并非永远只分配不回收），但它不做碎片整理或回收，只是简单地继续分配新的小块内存。</li></ul></div><h4 id="内存池结构设计"><a href="#内存池结构设计" class="headerlink" title="内存池结构设计"></a>内存池结构设计</h4><p>Nginx 采用内存池的结构设计来管理内存，而内存池是由若干固定大小的内存块组成的单向链表（如下图所示）。从图中可以看出来，内存池的头结点维护着内存池的总体信息，从头结点开始，可以访问内存池的小块内存（单向链表，由 <code>ngx_pool_data_t</code> 结构特维护），大块内存（单向链表，由 <code>ngx_pool_large_t</code> 结构特维护），以及抽象内存数据（单向链表，由 <code>ngx_pool_chain_t</code> 结构体维护）。</p><p><img data-src="../../../asset/2025/04/nginx-memory-4.png"></p><h4 id="ngx-pool-data-t"><a href="#ngx-pool-data-t" class="headerlink" title="ngx_pool_data_t"></a>ngx_pool_data_t</h4><p><code>ngx_pool_data_t</code> 结构体负责存储每个 <code>ngx_pool_t</code> 结构体的元数据：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">   u_char               *last;      <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">   u_char               *end;       <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">   <span class="keyword">ngx_pool_t</span>           *next;      <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">   <span class="keyword">ngx_uint_t</span>            failed;    <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">} <span class="keyword">ngx_pool_data_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/04/nginx-memory-pool-1.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p><code>failed</code> 成员的引入是为了避免某个 <code>pool</code> 虽然还有可用的内存空间，但是由于内存空间很小了，导致经常性的分配内存空间失败，当累计失败的次数达到某个阈值时，下一次再次查找内存就直接跳过这个 <code>pool</code>，直接去寻找内存池链表中的下一个 <code>pool</code>。在 <code>ngx_pool_s</code> 结构体中，<code>current</code> 指针会随着 <code>failed</code> 的增加而发生改变，如果 <code>current</code> 指向的内存池的 <code>failed</code> 达到了 <code>4</code> 的话，<code>current</code> 就会指向下一个内存池。</p></div><h4 id="ngx-pool-large-t"><a href="#ngx-pool-large-t" class="headerlink" title="ngx_pool_large_t"></a>ngx_pool_large_t</h4><p><code>ngx_pool_large_t</code> 结构体用于存储大内存块，这一块就比较简单粗暴了，直接调用 <code>malloc()</code> 分配一块大内存来使用，多个大内存块之间也是以链表形式来组织数据。正常情况下，这些大块内存会在整个内存池销毁时统一释放，比如在请求处理完毕后、连接断开后、Worker 进程（子进程）退出后会释放大块内存。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">   <span class="keyword">ngx_pool_large_t</span>     *next;      <span class="comment">// 下一个大块内存</span></span><br><span class="line">   <span class="keyword">void</span>                 *alloc;     <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>大块内存的分配请求不会直接在内存池上分配内存来满足，而是直接向操作系统申请一大块内存（底层直接调用 <code>malloc()</code> 分配内存），然后将这块内存挂到内存池头部的 <code>large</code> 指针下。内存池的作用在于解决小块内存池的频繁申请问题，对于这种大块内存，是可以忍受直接申请的。为什么大块内存分配后是挂在链表头部而不是尾部呢？根据程序局部性原理，最近分配的内存一般经常使用，挂在头部可以提高空闲内存块的查找效率。</p></div><h4 id="ngx-pool-t"><a href="#ngx-pool-t" class="headerlink" title="ngx_pool_t"></a>ngx_pool_t</h4><p><code>ngx_pool_t</code> 结构体用于表示一个内存池，内存池的内部以链表形式来组织数据。如下图：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;         <span class="comment">// 小块内存池的数据头</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;       <span class="comment">// 小块内存分配的最大值</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;   <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;     <span class="comment">// 该指针挂接一个 ngx_chain_t 结构</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;     <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;   <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *log;       <span class="comment">// 内存分配相关的日志记录</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/04/nginx-memory-pool-2.png"></p><p>需要注意的是：</p><ul><li>内存池内部以链表形式组织起来的，完成这个工作的就是前面的 <code>ngx_pool_data_t</code> 结构体的 <code>next</code> 成员。</li><li><code>current</code> 指针，用于表示当前该内存池在使用的 <code>pool</code> 指针。除了内存池链表的头结点之外，内存池链表其他节点的该指针无效。之所以需要这个指针，就是前面提到的，在某个内存池多次失效的情况下，下一次直接跳过该内存池查找内存空间，<code>current</code> 指针保存当前在内存池链表的哪一个内存池上面查找内存空间。</li><li><code>large</code> 指针，指向 <code>ngx_pool_large_t</code> 结构体，用于管理大块内存。</li></ul><h3 id="内存池的工作原理"><a href="#内存池的工作原理" class="headerlink" title="内存池的工作原理"></a>内存池的工作原理</h3><h4 id="内存池的创建"><a href="#内存池的创建" class="headerlink" title="内存池的创建"></a>内存池的创建</h4><ul><li>经过测试，Nginx 会为每个 Http 连接（Connection）创建大小为 <code>256</code> 字节的 <code>pool</code>，为每个请求（Request）创建大小为 <code>4096</code> 的 <code>pool</code>。</li><li>当客户端使用长连接向服务器请求资源时，Nginx 处理完 Request 后会释放 Request 对应的 <code>pool</code>，但不会立即释放 Connection 对应的 <code>pool</code>，而是等连接超时后再释放。</li><li>在一次简单的会话中（比如请求首页），从连接建立到连接关闭，至少有约 30 次的内存分配（调用 <code>ngx_palloc()</code>）。</li></ul><h4 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h4><ul><li><p><strong>小块内存的分配</strong></p><ul><li>对于小块内存的分配，Nginx 会首先尝试在当前小块内存池中查找是否存在足够的空闲内存空间。</li><li>如果当前小块内存池的可用内存不足以满足需求，Nginx 会尝试遍历该小块内存池的链表（即多个小块内存池），寻找可用的内存空间。</li><li>如果仍然找不到可用的内存空间，则会创建一个新的小块内存块，并将其添加到该小块内存池链表的尾部。</li><li><strong>小块内存的分配是按顺序进行的，不会进行回收，因此分配效率很高，适合频繁分配和释放内存的场景（比如 Web 服务器处理大量短连接）。</strong></li></ul></li><li><p><strong>大块内存的分配</strong></p><ul><li>对于大块内存的分配，当分配的内存大小超过小块内存分配的阈值（一般是 <code>4095</code> 字节，根据平台决定），Nginx 会直接调用 <code>malloc()</code> 申请一块大内存，并将该大块内存封装成一个 <code>ngx_pool_large_t</code> 节点，挂载到内存池的大块内存链表的头部。</li><li>这类内存块比较大、分配成本比较高，通常用于缓存大数据或模块中临时需要的较大资源。</li><li>由于<strong>小块内存使用的是顺序分配模型，而大块内存是从系统申请分配的</strong>，因此两者的管理方式不同，但最终都会在内存池销毁时（比如处理完 HTTP 请求、HTTP 连接关闭等）统一释放，确保资源不会泄漏。</li></ul></li></ul><h4 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h4><p>Nginx 从内存池分配内存的流程如下图所示：</p><p><img data-src="../../../asset/2025/04/nginx-memory-pool-3.png"></p><h4 id="内存池的销毁"><a href="#内存池的销毁" class="headerlink" title="内存池的销毁"></a>内存池的销毁</h4><ul><li><p>一个 Web Server 通常会持续不断地接收 Connection 和 Request，因此 Nginx 将内存池划分为不同的层级，包括进程级内存池、Connection 级内存池以及 Request 级内存池。具体来说，当创建一个 Worker 进程时，系统会为该 Worker 分配一个独立的内存池；当有新的 Connection 到来时，又会在该 Worker 的内存池基础上为该 Connection 分配一个新的内存池；当该 Connection 上接收到一个新的 Request 时，再在 Connection 的内存池中为该 Request 创建一个新的内存池。</p></li><li><p>这种分层次的内存池管理方式，使得在处理完一个 Request 后，可以一次性释放该 Request 的整个内存池；当 Connection 关闭时，可以释放该 Connection 对应的内存池；而当 Worker 进程退出时，其对应的内存池也会整体释放。通过这种机制，确保了内存既有分配，也能及时回收，避免了内存泄漏的问题。</p></li><li><p>从内存的分配与释放策略可以看出，Nginx 内存池的核心作用在于将多个小块内存的分配操作集中处理，并在适当的时机统一释放，从而避免频繁的小内存申请，降低内存碎片的产生，提升了系统的内存管理效率和性能。</p></li></ul><h3 id="内存池的源码测试"><a href="#内存池的源码测试" class="headerlink" title="内存池的源码测试"></a>内存池的源码测试</h3><p>这里将介绍如何编写代码测试 Nginx 内存池的 <code>ngx_destroy_pool()</code> 接口，并编译运行自定义的测代码。</p><h4 id="编译-Nginx-源码"><a href="#编译-Nginx-源码" class="headerlink" title="编译 Nginx 源码"></a>编译 Nginx 源码</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://nginx.org/download/nginx-1.12.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf nginx-1.12.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j4</span><br></pre></td></tr></tbody></table></figure><h4 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h4><p>在 Nginx 的源码目录下（比如 <code>nginx-1.12.2</code>），创建 C 源文件 <code>ngx_testpool.c</code>，其测试代码的内容如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nginx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_palloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误日志处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_log_error_core</span> <span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">stData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> {</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc1</span> <span class="params">(<span class="keyword">char</span> *p)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"free ptr mem!\n"</span>);</span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc2</span> <span class="params">(FILE *pf)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"close file!\n"</span>);</span><br><span class="line">    fclose (pf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span> *pool = ngx_create_pool (<span class="number">512</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_create_pool fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小块内存池分配内存</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = ngx_palloc (pool, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_palloc 128 bytes fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大块内存池分配内存</span></span><br><span class="line">    stData *p2 = ngx_palloc (pool, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_palloc 512 bytes fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p2-&gt;ptr = <span class="built_in">malloc</span> (<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (p2-&gt;ptr, <span class="string">"hello world"</span>);</span><br><span class="line">    p2-&gt;pfile = fopen (<span class="string">"data.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span> *c1 = ngx_pool_cleanup_add (pool, <span class="keyword">sizeof</span> (<span class="keyword">char</span> *));</span><br><span class="line">    c1-&gt;handler = cleanFunc1;</span><br><span class="line">    c1-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span> *c2 = ngx_pool_cleanup_add (pool, <span class="keyword">sizeof</span> (FILE *));</span><br><span class="line">    c2-&gt;handler = cleanFunc2;</span><br><span class="line">    c2-&gt;data = p2-&gt;pfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁内存池，步骤：(1) 调用所有的预置的清理函数 (2) 释放所有大块内存 (3) 释放小块内存池所有内存</span></span><br><span class="line">    ngx_destroy_pool (pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="运行测试代码"><a href="#运行测试代码" class="headerlink" title="运行测试代码"></a>运行测试代码</h4><ul><li>编译测试代码 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译测试代码（生成目标文件）</span></span><br><span class="line">gcc -c -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules -o ngx_testpool.o  ngx_testpool.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接测试代码（生成可执行文件）</span></span><br><span class="line">gcc -o ngx_testpool ngx_testpool.o objs/src/core/ngx_palloc.o objs/src/os/unix/ngx_alloc.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行文件</span></span><br><span class="line">./ngx_testpool</span><br></pre></td></tr></tbody></table></figure><ul><li>测试代码运行的输出结果 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close file!</span><br><span class="line">free ptr mem!</span><br></pre></td></tr></tbody></table></figure><h3 id="内存池的源码移植"><a href="#内存池的源码移植" class="headerlink" title="内存池的源码移植"></a>内存池的源码移植</h3><p>这里将介绍如何基于 C++ 移植 Nginx 内存池的核心源码，其中移植的代码主要位于 Nginx 的 <code>ngx_palloc.h</code> 和 <code>ngx_palloc.c</code> 源文件中。</p><div class="admonition note"><p class="admonition-title">提示</p><p>这里移植的 Nginx 版本是 <code>1.12.2</code>，完整的案例代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-project-nginx-pool">这里</a> 下载得到。</p></div><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><ul><li><code>ngx_mem_pool.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值 d 调整为临近数值 a 的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align (d, a) (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值 p 调整为临近数值 a 的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr (p, a) (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的内存全部初始化为 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memzero (buf, n) (void) memset (buf, 0, n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> u_char = <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ngx_uint_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理函数（回调函数）的类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理操作的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> {</span></span><br><span class="line">    ngx_pool_cleanup_pt handler;     <span class="comment">// 函数指针，指向内存清理操作的回调函数</span></span><br><span class="line">    <span class="keyword">void</span> *data;                      <span class="comment">// 传递给回调函数的参数</span></span><br><span class="line">    ngx_pool_cleanup_s *next;        <span class="comment">// 下一个清理函数，最终形成单向链表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大块内存的内存池的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">    ngx_pool_large_s *next;      <span class="comment">// 下一个大块内存，最终形成单向链表</span></span><br><span class="line">    <span class="keyword">void</span> *alloc;                 <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存的内存池的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_data_t</span> {</span></span><br><span class="line">    u_char *last;           <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">    u_char *end;            <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">    ngx_pool_s *next;       <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span> failed;      <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池的主结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span> d;              <span class="comment">// 小块内存池的头部信息</span></span><br><span class="line">    <span class="keyword">size_t</span> max;                     <span class="comment">// 小块内存分配的最大空间</span></span><br><span class="line">    ngx_pool_s *current;            <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    ngx_pool_large_s *large;        <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    ngx_pool_cleanup_s *cleanup;    <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个物理页面的默认大小（4KB）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_PAGESIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// 小块内存可分配的最大空间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MAX_ALLOC_FROM_POOL = NGX_PAGESIZE - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 内存池的默认初始大小（16KB）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_DEFAULT_POOL_SIZE = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// 内存池分配时的对齐字节数（16 字节）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_POOL_ALIGNMENT = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 小块内存的最小可接受大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MIN_POOL_SIZE = <span class="built_in">ngx_align</span> ((<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s) + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_large_s)), NGX_POOL_ALIGNMENT);</span><br><span class="line"><span class="comment">// 小块内存分配时的对齐字节数，通常是 4 字节（32 位系统）或者 8 字节（64 位系统）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_ALIGNMENT = <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ngx_mem_pool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span> (<span class="keyword">int</span> size = NGX_DEFAULT_POOL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ngx_mem_pool</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span> (<span class="keyword">const</span> ngx_mem_pool &amp;pool) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ngx_mem_pool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ngx_mem_pool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 从内存池中申请指定大小的内存，并考虑内存字节对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内存池中申请指定大小的内存，不考虑内存字节对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_pnalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 ngx_palloc 实现内存分配，并将内存初始化为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_pcalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_pfree</span> <span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作（回调）函数</span></span><br><span class="line">    <span class="function">ngx_pool_cleanup_s *<span class="title">ngx_pool_cleanup_add</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 创建指定大小的内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配小块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_small</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配大块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_large</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的小块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_block</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指向内存池的入口指针</span></span><br><span class="line">    ngx_pool_s *_pool;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ngx_mem_pool.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ngx_mem_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ngx_mem_pool::<span class="built_in">ngx_mem_pool</span> (<span class="keyword">int</span> size) {</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">ngx_create_pool</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (_pool == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span> (<span class="string">"create memory pool fail..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ngx_mem_pool::~<span class="built_in">ngx_mem_pool</span> () {</span><br><span class="line">    <span class="comment">// 销毁内存池</span></span><br><span class="line">    <span class="keyword">if</span> (_pool != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">ngx_destroy_pool</span> ();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定大小的内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt; NGX_MIN_POOL_SIZE) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"create memory pool fail, pool size too small"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存空间</span></span><br><span class="line">    _pool = (ngx_pool_s *) <span class="built_in">malloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (_pool == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小块内存池的头部信息</span></span><br><span class="line">    _pool-&gt;d.last = (u_char *) _pool + <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    _pool-&gt;d.end = (u_char *) _pool + size;</span><br><span class="line">    _pool-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    _pool-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小块内存分配的最大空间</span></span><br><span class="line">    size = size - <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    _pool-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    _pool-&gt;current = _pool;</span><br><span class="line">    _pool-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">    _pool-&gt;cleanup = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _pool;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内存池中申请指定大小的内存，并考虑内存字节对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="keyword">this</span>-&gt;_pool-&gt;max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span> (size, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内存池中申请指定大小的内存，不考虑内存字节对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_pnalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="keyword">this</span>-&gt;_pool-&gt;max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span> (size, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ngx_palloc 实现内存分配，并将内存初始化为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_pcalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">ngx_palloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (p) {</span><br><span class="line">        <span class="built_in">ngx_memzero</span> (p, size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配小块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_small</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span> </span>{</span><br><span class="line">    u_char *m;</span><br><span class="line">    ngx_pool_s *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">this</span>-&gt;_pool-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历小块内存池链表，查找有可用空间的小块内存</span></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (align) {</span><br><span class="line">            m = <span class="built_in">ngx_align_ptr</span> (m, NGX_ALIGNMENT);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) {</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当找不到有可用空间的小块内存，则直接分配新的小块内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_block</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配大块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_large</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span> n;</span><br><span class="line">    ngx_pool_large_s *large;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的大块内存</span></span><br><span class="line">    p = <span class="built_in">malloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历大块内存池链表，将新的大块内存添加到链表中</span></span><br><span class="line">    <span class="keyword">for</span> (large = <span class="keyword">this</span>-&gt;_pool-&gt;large; large; large = large-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">nullptr</span>) {</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    large = (ngx_pool_large_s *) <span class="built_in">ngx_palloc_small</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_large_s), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">free</span> (p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = <span class="keyword">this</span>-&gt;_pool-&gt;large;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配新的小块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_block</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    u_char *m;</span><br><span class="line">    <span class="keyword">size_t</span> psize;</span><br><span class="line">    ngx_pool_s *p, *_new;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的小块内存的大小</span></span><br><span class="line">    psize = (<span class="keyword">size_t</span>) (<span class="keyword">this</span>-&gt;_pool-&gt;d.end - (u_char *) <span class="keyword">this</span>-&gt;_pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的小块内存</span></span><br><span class="line">    m = (u_char *) <span class="built_in">malloc</span> (psize);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    _new = (ngx_pool_s *) m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的小块内存的头部信息</span></span><br><span class="line">    _new-&gt;d.end = m + psize;</span><br><span class="line">    _new-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    _new-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = <span class="built_in">ngx_align_ptr</span> (m, NGX_ALIGNMENT);</span><br><span class="line">    _new-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="keyword">this</span>-&gt;_pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) {</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p-&gt;d.next = _new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放大块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_pfree</span> <span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_reset_pool</span> <span class="params">()</span> </span>{</span><br><span class="line">    ngx_pool_s *p;</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置小块内存池链表中的第一块内存，实现后续小块内存的复用</span></span><br><span class="line">    p = <span class="keyword">this</span>-&gt;_pool;</span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置小块内存池链表中的第二块到最后一块内存，实现后续小块内存的复用</span></span><br><span class="line">    <span class="keyword">for</span> (p = p-&gt;d.next; p; p = p-&gt;d.next) {</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;current = <span class="keyword">this</span>-&gt;_pool;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_destroy_pool</span> <span class="params">()</span> </span>{</span><br><span class="line">    ngx_pool_s *p, *n;</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line">    ngx_pool_cleanup_s *c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用所有清理操作（回调）函数</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="keyword">this</span>-&gt;_pool-&gt;cleanup; c; c = c-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) {</span><br><span class="line">            c-&gt;<span class="built_in">handler</span> (c-&gt;data);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放小块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="keyword">this</span>-&gt;_pool, n = <span class="keyword">this</span>-&gt;_pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) {</span><br><span class="line">        <span class="built_in">free</span> (p);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加资源清理操作（回调）函数</span></span><br><span class="line"><span class="function">ngx_pool_cleanup_s *<span class="title">ngx_mem_pool::ngx_pool_cleanup_add</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    ngx_pool_cleanup_s *c;</span><br><span class="line"></span><br><span class="line">    c = (ngx_pool_cleanup_s *) <span class="built_in">ngx_palloc</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_cleanup_s));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) {</span><br><span class="line">        c-&gt;data = <span class="built_in">ngx_palloc</span> (size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        c-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到资源清理操作链表中（头插法）</span></span><br><span class="line">    c-&gt;next = <span class="keyword">this</span>-&gt;_pool-&gt;cleanup;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ngx_mem_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> {</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc1</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) arg;</span><br><span class="line">    cout &lt;&lt; <span class="string">"free ptr memory!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc2</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">    FILE *p = (FILE *) arg;</span><br><span class="line">    cout &lt;&lt; <span class="string">"close file!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">fclose</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="function">unique_ptr&lt;ngx_mem_pool&gt; <span class="title">pool</span> <span class="params">(<span class="keyword">new</span> ngx_mem_pool (<span class="number">256</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小块内存池分配内存</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = pool-&gt;<span class="built_in">ngx_palloc</span> (<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"ngx_palloc 128 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大块内存池分配内存</span></span><br><span class="line">    Data *p2 = (Data *) pool-&gt;<span class="built_in">ngx_palloc</span> (<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"ngx_palloc 512 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p2-&gt;ptr = (<span class="keyword">char</span> *) <span class="built_in">malloc</span> (<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2-&gt;ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"malloc 12 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span> (p2-&gt;ptr, <span class="string">"hello world"</span>);</span><br><span class="line">    p2-&gt;pfile = <span class="built_in">fopen</span> (<span class="string">"data.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    ngx_pool_cleanup_s *c1 = pool-&gt;<span class="built_in">ngx_pool_cleanup_add</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">char</span> *));</span><br><span class="line">    c1-&gt;handler = cleanFunc1;</span><br><span class="line">    c1-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    ngx_pool_cleanup_s *c2 = pool-&gt;<span class="built_in">ngx_pool_cleanup_add</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (FILE *));</span><br><span class="line">    c2-&gt;handler = cleanFunc2;</span><br><span class="line">    c2-&gt;data = p2-&gt;pfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存池由智能指针管理，程序运行结束后会自动销毁内存池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close file!</span><br><span class="line">free ptr memory!</span><br></pre></td></tr></tbody></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><blockquote><p>Nginx 为什么要进行内存管理？</p></blockquote><ul><li><p>Nginx 作为高性能 Web 服务器，在各个环节都必须考虑如何提高性能的问题，比如使用 <code>malloc()</code> 申请内存是很耗时的，这时候就需要优化内存的分配。</p></li><li><p>在使用系统的 <code>malloc()</code> 和 <code>free()</code> 面临几个问题：Web 服务器对内存的需求有大有小，系统运行久了会产生大量的内存碎片，最终造成内存操作更加耗时直到无可用内存，导致服务器宕机。</p></li></ul><blockquote><p>Nginx 如何进行内存管理？</p></blockquote><ul><li><p>Nginx 首先将内存池进行分级管理：包括进程级、连接级和请求级三个层次；随后再根据内存使用情况的不同，将内存池细分为三类：小块内存、大块内存以及自定义资源内存。</p></li><li><p>进程级内存池在通过 <code>Fork()</code> 创建 Worker 子进程时完成初始化。由于 <code>Fork()</code> 会复制父进程的数据段和堆栈段，因此每个子进程拥有独立的内存空间。根据 Web Server 的运行特点，当客户端建立连接时，会在函数 <code>void ngx_event_accept (ngx_event_t *ev)</code> 中创建连接级的内存池；当客户端发起请求时，会在函数 <code>void ngx_http_init_connection (ngx_connection_t *c)</code> 中创建请求级的内存池。</p></li><li><p>在处理 HTTP 请求的过程中，所有与该请求相关的内存分配操作都在对应连接的内存池中完成。根据实际需要的内存大小及资源类型，Nginx 会采用不同的分配策略：对于较小的内存块，采用顺序分配以提高效率；对于较大的内存块或特殊资源，则使用独立分配方式以便于管理。</p></li><li><p>当请求处理完成后，请求级的内存池会被整体释放；当连接超时或者断开时，连接级的内存池随之释放；当进程退出时，系统会释放进程占用的全部内存池资源。通过这种分级且分类型的内存管理机制，Nginx 有效提升了内存分配效率，降低了内存碎片率，同时确保了资源的可控释放和系统的高性能运行。</p></li></ul><blockquote><p>Nginx 的内存管理解决了哪些问题？</p></blockquote><ul><li><strong>简化了内存操作</strong>：程序员不必担心何时释放内存，当连接释放时，就回收该连接对应的内存池。</li><li><strong>避免了内存碎片</strong>：从外部内存碎片来看，采用一次性申请一个内存页，避免了外部内存碎片；从内部内存碎片来看，对大小内存申请分别管理，提高了内存利用率，避免了内部内存碎片。</li><li><strong>避免了内存泄露</strong>：在同一内存池上进行内存申请和回收，当连接关闭后，不存在没有被回收的内存，即可以避免内存泄漏问题。</li><li><strong>提高了内存访问效率</strong>：充分利用程序局部性原理，结合内存对齐和内存分页机制，有效提高了 CPU 访存的 Cache 命中率。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.kancloud.cn/digest/understandingnginx/202588">Nginx 内存池管理详解</a></li><li><a href="https://www.cnblogs.com/didiaoxiong/p/nginx_memory.html">Nginx 1.4.0 内存管理详解</a></li><li><a href="https://heapdump.cn/article/4444830">Nginx 内存分配与释放 — 堆 (内存池) 源码与原理</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Nginx 内存池的底层源码。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="源码剖析" scheme="https://www.techgrow.cn/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Debian 12 搭建 IPSec VPN 实现内网互连</title>
    <link href="https://www.techgrow.cn/posts/ec9b99f7.html"/>
    <id>https://www.techgrow.cn/posts/ec9b99f7.html</id>
    <published>2025-03-16T13:48:23.000Z</published>
    <updated>2025-03-16T13:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 Debian 12 如何基于 StrongSwan‌ 搭建 IPSec VPN，以此在多台 Linux 服务器（处于不同的数据中心 - IDC）之间实现内网通信。</p><h2 id="内网互连方案介绍"><a href="#内网互连方案介绍" class="headerlink" title="内网互连方案介绍"></a>内网互连方案介绍</h2><p>在多台 Linux 服务器（处于不同的数据中心 - IDC）之间实现内网互连，有以下几种方案：</p><ul><li><p>虚拟专用网络（Virtual Private Network - VPN）</p><ul><li>通过建立虚拟专用网络连接，将服务器与内网之间建立起安全的通信隧道，实现互通。可以使用软件或硬件设备来实现虚拟专用网络连接。</li></ul></li><li><p>隧道技术（Tunneling）</p><ul><li>使用隧道技术，将服务器的网络流量封装在内网的流量中传输，从而实现互通。常见的隧道技术有 SSH 隧道、GRE 隧道、IPSec 隧道等。</li></ul></li><li><p>NAT（Network Address Translation，网络地址转换）</p><ul><li>在内网中配置 NAT 设备，将服务器的私有 IP 地址映射为内网的公共 IP 地址，从而实现互通。</li></ul></li><li><p>配置防火墙规则</p><ul><li>在内网的防火墙中配置相应的规则，允许服务器与内网之间的通信。可以通过指定源 IP 地址、目标 IP 地址、端口等来限制通信。</li></ul></li></ul><span id="more"></span><h2 id="IPSec-VPN-的简单介绍"><a href="#IPSec-VPN-的简单介绍" class="headerlink" title="IPSec VPN 的简单介绍"></a>IPSec VPN 的简单介绍</h2><h3 id="IPSec-是什么"><a href="#IPSec-是什么" class="headerlink" title="IPSec 是什么"></a>IPSec 是什么</h3><p>IPSec 是虚拟私有网络（VPN）的一种连接协议，用于在服务器和客户端之间建立加密隧道，并传输敏感数据。它由两个阶段组成，第一阶段（Phrase 1， ph1），交换密钥建立连接，使用互联网密钥交换协议（ike）；ike 密钥交换协议有两个版本，分别是 IKEV1、IKEV2；第二阶段（Phrase 2， ph2），连接建立后对数据进行加密传输，使用封装安全载荷（ESP）协议。</p><h3 id="IKEV1-与-IKEV2"><a href="#IKEV1-与-IKEV2" class="headerlink" title="IKEV1 与 IKEV2"></a>IKEV1 与 IKEV2</h3><p>IKE 属于一种混合型协议，由 Internet 安全关联和密钥管理协议（ISAKMP）和两种密钥交换协议 OAKLEY 与 SKEME 组成。IKE 创建在由 ISAKMP 定义的框架上，沿用了 OAKLEY 的密钥交换模式以及 SKEME 的共享和密钥更新技术，还定义了它自己的两种密钥交换方式：主模式和积极模式（IKEV1 才有）。IKE 有两个版本，分别是 IKEV1 与 IKEV2。值得一提的是，IKEV2 不兼容 IKEV1，IKEV1 不支持认证，IKEV2 支持认证。IKEV2 支持 EAP 认证，支持 NAT 穿透，支持私密性、完整性、源认证。工作在 UDP 的 500 /4500 端口。NAT-T 用的是 UDP 4500 端口。</p><h3 id="OpenSwan-与-StrongSwan"><a href="#OpenSwan-与-StrongSwan" class="headerlink" title="OpenSwan 与 StrongSwan"></a>OpenSwan 与 StrongSwan</h3><p>Linux 系统有两种比较常见的 IPSec 实现，分别是 OpenSwan 与 StrongSwan，两者的主要区别如下：</p><ul><li><p>协议支持</p><ul><li>OpenSwan‌<ul><li>主要支持 ‌IKEV1‌ 协议，兼容旧版设备‌。</li><li>默认使用 ‌KLIPS‌ 内核模块实现 IPSec（需手动为旧内核打补丁），对 Linux <code>2.6.9+</code> 内核支持 NETKEY‌。</li></ul></li><li>StrongSwan‌<ul><li>专注 ‌IKEV2‌ 协议，安全性更高且简化配置流程‌。</li><li>原生支持 NETKEY 内核模块（无需额外补丁），对现代 Linux 内核（如 <code>4.x+</code>）兼容性更佳‌。</li></ul></li></ul></li><li><p>配置复杂度‌</p><ul><li>‌OpenSwan‌<ul><li>依赖 <code>ipsec.conf</code> 配置文件，需手动管理多参数（如 <code>protostack=netkey</code> 需显式声明）‌。</li><li>对 NAT 穿透支持较弱（旧内核需额外补丁）‌。</li></ul></li><li>‌StrongSwan‌<ul><li>使用模块化配置（如 <code>strongswan.conf</code>），支持动态加载插件（如 <code>charon</code> 进程管理 IKE）‌。</li><li>内置 ‌NAT-Traversal‌ 功能，适配复杂网络环境更便捷‌。</li></ul></li></ul></li><li><p>维护与扩展性‌</p><ul><li>‌OpenSwan‌<ul><li>社区维护停滞，新版 Linux 发行版（如 Debian 12、Ubuntu <code>22.04+</code>）默认移除了 ‌OpenSwan‌ 的支持‌。</li><li>适合需兼容老旧设备的场景‌。</li></ul></li><li>‌StrongSwan‌<ul><li>项目持续更新，支持 ‌X.509 证书认证‌、‌EAP 扩展认证‌等现代安全机制‌。</li><li>使用 C 语言编写，提供线程池优化，大大提升多连接场景下的协商效率‌。</li></ul></li></ul></li><li><p>性能表现‌</p><ul><li>OpenSwan‌<ul><li>在低带宽场景下性能稳定，但加密转发带宽受限（实测最高约 700 Mbps）‌。</li></ul></li><li>StrongSwan‌<ul><li>通过优化加密算法（如 AES-NI 加速）和线程池技术，转发性能更高（实测带宽可达 1 Gbps+）‌。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">适用场景总结</p><ul><li>‌OpenSwan‌：需兼容旧版设备（如 Linux <code>2.4</code> 内核）、使用 IKEV1 协议的场景‌。</li><li>StrongSwan‌：现代网络环境、需要 IKEV2 协议、高安全认证及性能优化的场景‌。</li></ul></div><h2 id="IPSec-VPN-实现内网互连"><a href="#IPSec-VPN-实现内网互连" class="headerlink" title="IPSec VPN 实现内网互连"></a>IPSec VPN 实现内网互连</h2><p>由于 Debian 12 的 Linux 内核版本是 <code>6.x</code>，因此这里选择基于 StrongSwan‌ 搭建 IPSec VPN，以此在多台 Linux 服务器（处于不同的数据中心 - IDC）之间实现内网通信。各服务器的网络信息如下所示：</p><table><thead><tr><th>服务器</th><th>公网 IP</th><th> 内网 IP</th><th> 备注</th></tr></thead><tbody><tr><td>服务器一</td><td> 101.53.225.204</td><td>10.0.8.9</td><td> 云服务器</td></tr><tr><td>服务器二</td><td> 49.135.225.57</td><td>10.0.20.6</td><td> 云服务器</td></tr></tbody></table><h3 id="准备工作执行"><a href="#准备工作执行" class="headerlink" title="准备工作执行"></a>准备工作执行</h3><p>在两台 Debian 服务器上，分别执行以下操作，为后续安装和配置 IPSec VPN 做准备。</p><ul><li>安装工具软件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新软件索引</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装工具软件</span></span><br><span class="line">sudo apt install -y wget curl telnet tcpdump net-tools vim -y</span><br></pre></td></tr></tbody></table></figure><ul><li>更改系统配置 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑系统配置文件，更改或添加以下配置内容</span></span><br><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 允许转发，默认值是 0</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.ipv6.conf.all.forwarding = 1</span><br><span class="line"></span><br><span class="line"># 关闭重定向，防止恶意用户可以使用 IP 重定向来修改远程主机中的路由表</span><br><span class="line">net.ipv4.conf.all.accept_redirects = 0</span><br><span class="line">net.ipv4.conf.all.send_redirects = 0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用系统配置更改生效</span></span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></tbody></table></figure><ul><li>防火墙开放端口 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 UFW　防火墙</span></span><br><span class="line">sudo apt install -y ufw</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 TCP 22 端口（SSH）</span></span><br><span class="line">sudo ufw allow 22/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 UDP 500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 500/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 UDP 4500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 4500/udp</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用 UFW 防火墙</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙所有已开放的端口</span></span><br><span class="line">sudo ufw verbose</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加路由表规则（可选操作），通过 iptables 修改出站流量的源 IP，匹配云服务器 NAT 映射规则，否则服务器之间的网络可能会不通</span></span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由表规则添加后，若希望删除掉它，可以执行以下命令</span></span><br><span class="line">sudo iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>为了方便后续配置 IPSec VPN 和排查问题，可以先暂时不配置防火墙，也就是可以等 IPSec VPN 正常工作后再配置防火墙。</li><li>IPSec VPN 默认监听在 UDP 的 <code>500</code> 和 <code>4500</code> 两个端口，其中 UDP <code>500</code> 是用于 IKE 密钥交换协商，UDP <code>4500</code> 是用于 NAT 穿透。</li></ul></div><h3 id="服务器一配置"><a href="#服务器一配置" class="headerlink" title="服务器一配置"></a>服务器一配置</h3><h4 id="安装-StrongSwan"><a href="#安装-StrongSwan" class="headerlink" title="安装 StrongSwan"></a>安装 StrongSwan</h4><ul><li>安装 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 StrongSwan 服务</span></span><br><span class="line">sudo apt install -y strongswan strongswan-charon strongswan-libcharon libstrongswan libcharon-extra-plugins</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启 StrongSwan 服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>备份 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/ipsec.conf /etc/ipsec.conf.bak</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">        charondebug="all"</span><br><span class="line"></span><br><span class="line">conn %default                             # 配置ike默认参数</span><br><span class="line">        ikelifetime=1440m                 # ike协议的SA生命周期</span><br><span class="line">        keylife=60m                       # IPSec连接的密钥生命周期为60分钟</span><br><span class="line">        rekeymargin=3m                    # 3分钟过后密钥生命周期结束后重新生成密钥</span><br><span class="line">        keyingtries=0                     # 密钥交换期间允许最大的重试次数为0次</span><br><span class="line">        keyexchange=ikev1                 # IPSec连接使用IKE协议的版本</span><br><span class="line">        authby=secret                     # 使用预共享密钥认证方式</span><br><span class="line">    </span><br><span class="line">conn ipsecvpn                             # 创建ipsecvpn</span><br><span class="line">        leftid=101.53.225.204             # 本地网关设备的标识</span><br><span class="line">        left=101.53.225.204               # 本地网关设备的公网IP地址，如果使用本地网关的私网IP地址建立IPSec-VPN连接，则本项需配置为本地网关设备的私网IP地址</span><br><span class="line">        leftsubnet=10.0.8.0/22            # 本地设备的内网网段</span><br><span class="line">        right=49.135.225.57               # 远端设备的出口网关的公网IP地址</span><br><span class="line">        rightsubnet=10.0.20.0/22          # 远端设备的内网网段</span><br><span class="line">        auto=start                        # 主模式</span><br><span class="line">        type=tunnel                       # 隧道模式</span><br><span class="line">        ike=3des-md5-modp1024             # IKE使用3des-md5-modp1024加密套件</span><br><span class="line">        esp=3des-md5                      # esp使用3des-md5加密套件</span><br><span class="line">        forceencaps=yes                   # 强制使用NAT-T封装，即使NAT-T不是必需的</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>强烈建议加上配置 <code>forceencaps=yes</code>，因为这在云服务器（如阿里云、腾讯云）场景下特别重要，因为它们的公网 IP 可能是 NAT 映射的地址。为了适配 NAT 场景，还可以添加 <code>nat-ikev1-method=natd</code> 配置。</li></ul></div><ul><li>配置 IPSec 预共享密钥 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.secrets</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">101.53.225.204 49.135.225.57 : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">%any : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><h4 id="启动-StrongSwan"><a href="#启动-StrongSwan" class="headerlink" title="启动 StrongSwan"></a>启动 StrongSwan</h4><ul><li>启动 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启 StrongSwan 服务</span></span><br><span class="line">systemctl restart strongswan-starter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 StrongSwan 服务的运行状态</span></span><br><span class="line">systemctl status strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>启动 IPSec 服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新加载 IPSec 配置文件</span></span><br><span class="line">ipsec reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 IPSec 服务</span></span><br><span class="line">ipsec restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动名称为 ipsecvpn 的 IPSec 连接（这里暂时不会启动成功，因为另一台服务器还没有配置 IPSec）</span></span><br><span class="line">ipsec up ipsecvpn </span><br></pre></td></tr></tbody></table></figure><h4 id="关闭-StrongSwan"><a href="#关闭-StrongSwan" class="headerlink" title="关闭 StrongSwan"></a>关闭 StrongSwan</h4><ul><li>若 StrongSwan 服务无法正常启动，可以使用以下命令先关闭 IPSec 和 StrongSwan 服务，然后再重新启动服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭名称为 ipsecvpn 的 IPSec 连接</span></span><br><span class="line">sudo ipsec down ipsecvpn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 IPSec 服务</span></span><br><span class="line">sudo ipsec stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 StrongSwan 服务</span></span><br><span class="line">sudo systemctl stop strongswan-starter</span><br></pre></td></tr></tbody></table></figure><h3 id="服务器二配置"><a href="#服务器二配置" class="headerlink" title="服务器二配置"></a>服务器二配置</h3><h4 id="安装-StrongSwan-1"><a href="#安装-StrongSwan-1" class="headerlink" title="安装 StrongSwan"></a>安装 StrongSwan</h4><ul><li>安装 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 StrongSwan 服务</span></span><br><span class="line">sudo apt install -y strongswan strongswan-charon strongswan-libcharon libstrongswan libcharon-extra-plugins</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启 StrongSwan 服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>备份 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/ipsec.conf /etc/ipsec.conf.bak</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">        charondebug="all"</span><br><span class="line"></span><br><span class="line">conn %default                             # 配置ike默认参数</span><br><span class="line">        ikelifetime=1440m                 # ike协议的SA生命周期</span><br><span class="line">        keylife=60m                       # IPSec连接的密钥生命周期为60分钟</span><br><span class="line">        rekeymargin=3m                    # 3分钟过后密钥生命周期结束后重新生成密钥</span><br><span class="line">        keyingtries=0                     # 密钥交换期间允许最大的重试次数为0次</span><br><span class="line">        keyexchange=ikev1                 # IPSec连接使用IKE协议的版本</span><br><span class="line">        authby=secret                     # 使用预共享密钥认证方式</span><br><span class="line">    </span><br><span class="line">conn ipsecvpn                             # 创建ipsecvpn</span><br><span class="line">        leftid=49.135.225.57              # 本地网关设备的标识</span><br><span class="line">        left=49.135.225.57                # 本地网关设备的公网IP地址，如果使用本地网关的私网IP地址建立IPSec-VPN连接，则本项需配置为本地网关设备的私网IP地址</span><br><span class="line">        leftsubnet=10.0.8.0/22            # 本地设备的内网网段</span><br><span class="line">        right=101.53.225.204              # 远端设备的出口网关的公网IP地址</span><br><span class="line">        rightsubnet=10.0.20.0/22          # 远端设备的内网网段</span><br><span class="line">        auto=start                        # 主模式</span><br><span class="line">        type=tunnel                       # 隧道模式</span><br><span class="line">        ike=3des-md5-modp1024             # IKE使用3des-md5-modp1024加密套件</span><br><span class="line">        esp=3des-md5                      # esp使用3des-md5加密套件</span><br><span class="line">        forceencaps=yes                   # 强制使用NAT-T封装，即使NAT-T不是必需的</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>强烈建议加上配置 <code>forceencaps=yes</code>，因为这在云服务器（如阿里云、腾讯云）场景下特别重要，因为它们的公网 IP 可能是 NAT 映射的地址。为了适配 NAT 场景，还可以添加 <code>nat-ikev1-method=natd</code> 配置。</li></ul></div><ul><li>配置 IPSec 预共享密钥 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.secrets</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">49.135.225.57 101.53.225.204 : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">%any : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><h4 id="启动-StrongSwan-1"><a href="#启动-StrongSwan-1" class="headerlink" title="启动 StrongSwan"></a>启动 StrongSwan</h4><ul><li>启动 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启 StrongSwan 服务</span></span><br><span class="line">systemctl restart strongswan-starter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 StrongSwan 服务的运行状态</span></span><br><span class="line">systemctl status strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>启动 IPSec 服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新加载 IPSec 配置文件</span></span><br><span class="line">ipsec reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 IPSec 服务</span></span><br><span class="line">ipsec restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动名称为 ipsecvpn 的 IPSec 连接</span></span><br><span class="line">ipsec up ipsecvpn </span><br></pre></td></tr></tbody></table></figure><p>当两台服务器都执行 <code>ipsec up ipsecvpn</code> 命令后，就会一直检测对方服务器是否正常启动 IPSec，如果正常启动，它们自己会互相连接成功，如下图所示（<strong>图片来源自网络，仅供参考</strong>）：</p><p><img data-src="../../../asset/2025/03/ipsec-vpn-1.png"></p><h4 id="关闭-StrongSwan-1"><a href="#关闭-StrongSwan-1" class="headerlink" title="关闭 StrongSwan"></a>关闭 StrongSwan</h4><ul><li>若 StrongSwan 服务无法正常启动，可以使用以下命令先关闭 IPSec 和 StrongSwan 服务，然后再重新启动服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭名称为 ipsecvpn 的 IPSec 连接</span></span><br><span class="line">sudo ipsec down ipsecvpn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 IPSec 服务</span></span><br><span class="line">sudo ipsec stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 StrongSwan 服务</span></span><br><span class="line">sudo systemctl stop strongswan-starter</span><br></pre></td></tr></tbody></table></figure><h3 id="验证-VPN-连接"><a href="#验证-VPN-连接" class="headerlink" title="验证 VPN 连接"></a>验证 VPN 连接</h3><ul><li>在服务一查看 IPSec 的运行状态，如下图所示（<strong>图片来源自网络，仅供参考</strong>）：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 IPSec 的运行状态</span></span><br><span class="line">sudo ipsec statusall</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/03/ipsec-vpn-3.png"></p><ul><li>在服务二查看 IPSec 的运行状态，如下图所示（<strong>图片来源自网络，仅供参考</strong>）：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 IPSec 的运行状态</span></span><br><span class="line">sudo ipsec statusall</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/03/ipsec-vpn-2.png"></p><h2 id="IPSec-VPN-常见配置问题"><a href="#IPSec-VPN-常见配置问题" class="headerlink" title="IPSec VPN 常见配置问题"></a>IPSec VPN 常见配置问题</h2><h3 id="UDP-500-端口无法正常通信"><a href="#UDP-500-端口无法正常通信" class="headerlink" title="UDP 500 端口无法正常通信"></a>UDP 500 端口无法正常通信</h3><blockquote><p>问题描述</p></blockquote><p>在服务器一（<code>101.53.225.204</code>）中，执行 <code>systemctl status strongswan-starter</code> 命令查看 StrongSwan 服务的运行状态，出现以下错误信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mar 25 21:38:49 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br><span class="line">Mar 25 21:39:02 debian charon[274510]: 11[IKE] sending retransmit 3 of request message ID 0, seq 1</span><br><span class="line">Mar 25 21:39:02 debian charon[274510]: 11[NET] sending packet: from 101.53.225.204[500] to 49.135.225.57[500] (248 bytes)</span><br><span class="line">Mar 25 21:39:02 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br><span class="line">Mar 25 21:39:26 debian charon[274510]: 12[IKE] sending retransmit 4 of request message ID 0, seq 1</span><br><span class="line">Mar 25 21:39:26 debian charon[274510]: 12[NET] sending packet: from 101.53.225.204[500] to 49.135.225.57[500] (248 bytes)</span><br><span class="line">Mar 25 21:39:26 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br><span class="line">Mar 25 21:40:08 debian charon[274510]: 13[IKE] sending retransmit 5 of request message ID 0, seq 1</span><br><span class="line">Mar 25 21:40:08 debian charon[274510]: 13[NET] sending packet: from 101.53.225.204[500] to 49.135.225.57[500] (248 bytes)</span><br><span class="line">Mar 25 21:40:08 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br></pre></td></tr></tbody></table></figure><blockquote><p>问题分析</p></blockquote><p>分析错误信息可得知，可能是服务器二（<code>49.135.225.57</code>）的 UDP <code>500</code> 端口不能正常访问导致。</p><blockquote><p>问题解决</p></blockquote><ul><li><strong>(1)</strong> 在服务器二中，检查 IPSec VPN 是否有正常监听 UDP <code>500</code> 和 UDP <code>4500</code> 端口。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查端口监听</span></span><br><span class="line">netstat -ulnp | grep -E <span class="string">'500|4500'</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(2)</strong> 在服务器二中，若 Debian 系统有启用 UFW 防火墙，则需要开放 UDP <code>500</code> 和 UDP <code>4500</code> 端口。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 UDP 500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 500/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 UDP 4500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 4500/udp</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(3)</strong> 在服务器二中，使用 <code>tcpdump</code> 工具检测 UDP <code>500</code> 和 UDP <code>4500</code> 端口是否有接收到进站的流量。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any -nn udp port 500 or udp port 4500</span><br></pre></td></tr></tbody></table></figure><ul><li>若 <code>tcpdump</code> 工具没有检测到进站的流量，那么在服务器一中，可以执行以下命令手动发送数据包，以此检测服务器二 UDP <code>500</code> 端口的可达性。当提示 “Connection refused” 或 “Network is unreachable”，则说明 UDP <code>500</code> 端口未开放，需要检查防火墙配置。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -u -z -v 49.135.225.57 500</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(4)</strong> 在服务器一中，检查网络接口是否绑定了公网 IP。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show eth0</span><br></pre></td></tr></tbody></table></figure><ul><li>若在上述命令的输出中，‌没有显示公网 IP <code>101.53.225.204</code>，则可能需要通过云服务商控制台将该 IP 绑定到服务器的弹性网卡（如 <code>eth0</code>）‌。若公网 IP 是通过 NAT 映射（如云服务器弹性 IP），则需要确保 NAT 规则正确配置。</li><li>若公网流量需要通过特定网关（非默认内网网关），则需要在服务器一中添加静态路由，其中 <code>&lt;公网网关IP&gt;</code> 需替换为云服务商提供的公网网关地址（例如 <a href="../../../asset/2025/03/ipsec-vpn-4.png">VPN 网关</a>），详细教程请看 <a href="https://cloud.tencent.com/developer/article/1505715">这里</a>。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加静态路由</span></span><br><span class="line">ip route add 49.135.225.57/32 via &lt;公网网关IP&gt; dev eth0</span><br></pre></td></tr></tbody></table></figure><ul><li>验证路由是否生效，在服务器一中执行以下命令后，预期输出应该包含公网接口（如 <code>dev eth0</code>）和正确网关。若仍指向内网网关，则需要调整路由优先级或联系云服务商检查底层网络配置‌。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取路由表记录</span></span><br><span class="line">ip route get 49.135.225.57</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(5)</strong> 两台服务器分别调整 StrongSwan 配置，尝试显式指定源 IP（公网 IP），避免自动选择内网 IP。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conn ipsecvpn                             # 创建ipsecvpn</span><br><span class="line">        leftid=101.53.225.204             # 本地网关设备的标识</span><br><span class="line">        left=101.53.225.204               # 本地网关设备的公网IP地址，如果使用本地网关的私网IP地址建立IPSec-VPN连接，则本项需配置为本地网关设备的私网IP地址</span><br><span class="line">        leftsubnet=10.0.8.0/22            # 本地设备的内网网段</span><br><span class="line">        leftsourceip=101.53.225.204       # 本地设备的源IP（公网IP）</span><br><span class="line">        ......</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(6)</strong> 若上述步骤都无法定位或者解决问题，那么可以查看 IPSec 的运行状态和 StrongSwan 的日志信息来进一步定位问题。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 IPSec 的运行状态</span></span><br><span class="line">sudo ipsec statusall</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 StrongSwan 的所有日志信息</span></span><br><span class="line">journalctl -u strongswan-starter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者只查看 StrongSwan 的最新日志信息</span></span><br><span class="line">journalctl -u strongswan-starter --no-pager | tail -n 30</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="IPSec-VPN-技术科普"><a href="#IPSec-VPN-技术科普" class="headerlink" title="IPSec VPN 技术科普"></a>IPSec VPN 技术科普</h3><ul><li><a href="https://www.cnblogs.com/longlyseul/p/16966471.html">IPSec 技术详解</a></li><li><a href="https://developer.jdcloud.com/article/2535">IPSec VPN 原理介绍</a></li></ul><h3 id="IPSec-VPN-网络性能测试"><a href="#IPSec-VPN-网络性能测试" class="headerlink" title="IPSec VPN 网络性能测试"></a>IPSec VPN 网络性能测试</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/27363937370">StrongSwan 配置 IPSec VPN 的性能测试</a></li></ul><h3 id="OpenSwan-搭建-IPSec-VPN"><a href="#OpenSwan-搭建-IPSec-VPN" class="headerlink" title="OpenSwan 搭建 IPSec VPN"></a>OpenSwan 搭建 IPSec VPN</h3><ul><li><a href="https://blog.csdn.net/qq_36833548/article/details/130375242">OpenSwan 安装和简单配置</a></li><li><a href="https://blog.csdn.net/weixin_49816179/article/details/133150477">CentOS VPN 隧道技术实战</a></li><li><a href="https://bbs.sangfor.com.cn/forum.php?mod=viewthread&amp;tid=96195">OpenSwan 实现 IPSec VPN 野蛮模式对接</a></li><li><a href="https://www.liuchunhua.me/post/network/03sitetositevpn/site2sitevpn/">基于 OpenSwan 在 AWS 上构建高可用 VPN</a></li><li><a href="https://github.com/LCTT/TranslateProject/blob/master/published/201411/How%20to%20create%20a%20site-to-site%20IPsec%20VPN%20tunnel%20using%20Openswan%20in%20Linux.md">Openswan 搭建站点到站点的 IPsec VPN 隧道</a></li><li><a href="https://apple4us.com/2010/setting-up-l2tp-vpn-on-debian-ubuntu">如何在 Debian / Ubuntu 服务器上架设 L2TP / IPSec VPN</a></li></ul><h3 id="StrongSwan-搭建-IPSec-VPN"><a href="#StrongSwan-搭建-IPSec-VPN" class="headerlink" title="StrongSwan 搭建 IPSec VPN"></a>StrongSwan 搭建 IPSec VPN</h3><ul><li><a href="https://blog.csdn.net/qq_54100121/article/details/137450215">Debian 配置 IPSec VPN</a></li><li><a href="https://juejin.cn/post/7216604612404707386">Debian L2TP IPSec 服务器搭建</a></li><li><a href="https://blog.51cto.com/niubdada/5037222">CentOS 7.9 使用 StrongSwan 搭建 IPSec VPN</a></li><li><a href="https://cloud.tencent.com/developer/article/1505715">在 CentOS 上使用 StrongSwan 搭建 IPSec VPN 服务</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要记录 Debian 12 如何搭建 IPSec VPN 来实现多台服务器之间的内网通信。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
    <category term="网络安全" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器网络性能测试</title>
    <link href="https://www.techgrow.cn/posts/97085038.html"/>
    <id>https://www.techgrow.cn/posts/97085038.html</id>
    <published>2025-03-16T13:48:23.000Z</published>
    <updated>2025-03-16T13:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍 Linux 服务器的网络性能测试方法，可以根据测试后的数据判断网络性能。服务器的网络性能受多种因素的影响，例如：实例的物理距离、服务器的性能、操作系统参数等，请结合实际情况判断。</p><span id="more"></span><h2 id="安装测试工具"><a href="#安装测试工具" class="headerlink" title="安装测试工具"></a>安装测试工具</h2><p>分别登录服务器、客户端，按以下步骤在服务器和客户端上安装 iperf3 工具。</p><div class="admonition warning"><p class="admonition-title">注意</p><p>在测试环境搭建和测试时都需要保证自己拥有系统的 <code>root</code> 用户权限。</p></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.jdcloud.com/cn/virtual-private-cloud/vpc-performance-test">Linux 服务器网络性能测试</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要记录 Linux 服务器如何进行网络测试。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="网络安全" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 一键搭建 OpenVPN 服务器</title>
    <link href="https://www.techgrow.cn/posts/86c906bc.html"/>
    <id>https://www.techgrow.cn/posts/86c906bc.html</id>
    <published>2025-03-14T12:43:29.000Z</published>
    <updated>2025-03-14T12:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着工作的多样化，办公场地也不局限于公司，有些时候往往需要在家或者公共场所（远程办公）访问公司的内网服务器资源，出于网络安全考虑，互联网不能直接访问公司的内网资源，常见解决方案就是部署 VPN 服务器。本文基于 OpenVPN 搭建 VPN 服务器，搭建好之后可以使用 OpenVPN 客户端连接 VPN 服务器，这样就可以安全地访问 VPN 服务器的内网资源。</p><span id="more"></span><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><ul><li><a href="https://github.com/hwdsl2/setup-ipsec-vpn">hwdsl2/setup-ipsec-vpn</a></li><li><a href="https://github.com/hwdsl2/openvpn-install/tree/master">hwdsl2/openvpn-install</a></li></ul><h3 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h3><blockquote><p>运维面板的高权限风险  </p></blockquote><p>运维面板通常拥有极高的权限，一旦被非法访问，攻击者几乎可以完全控制服务器，安全风险极高。以下是几种常见的 Web 面板及其权限范围：  </p><ul><li><code>宝塔面板</code>：拥有服务器 <code>root</code> 权限，可对系统进行完全控制。  </li><li><code>Portainer</code>：掌管 Docker 的管理权限，能够管理所有容器和镜像。  </li><li><code>Proxmox VE</code>：具备对服务器的完整控制权，包括虚拟机和存储管理。  </li><li><code>phpMyAdmin</code>：负责 MySQL 数据库的管理，拥有数据库的完全操作权限。  </li></ul><blockquote><p>运维面板的安全脆弱性  </p></blockquote><ul><li>一些 Web 面板需要开放公网访问，例如宝塔面板，它引入了多种鉴权和防护机制，能够在一定程度上抵御攻击。然而，历史上仍然发生过多次严重安全漏洞事件。  </li><li>大多数 Web 面板的鉴权方式较为简单，通常只是一个 Web 登录框，防护强度较低。甚至部分面板并未考虑公网访问的安全性，例如 Portainer 官方明确表示其内置鉴权机制不适用于生产环境，并强烈不建议将其直接暴露在公网。</li><li>因此，如果这些鉴权机制较弱的 Web 面板直接开放到公网，将存在极大的安全隐患。  </li></ul><blockquote><p>基于 VPN 的安全防护  </p></blockquote><ul><li>VPN 是一种企业级的成熟加密通信技术，本文推荐使用 开源的 OpenVPN，其代码公开透明，安全性经过长期验证。通过在 Web 面板外层套一层 VPN，不论服务本身的安全性如何，整体访问环境都能得到有效保护。</li><li>使用 VPN 保护 Web 面板的访问是最便捷且安全的方案。其原理十分简单：对于不希望暴露在公网的服务（如高权限管理面板、私人 Web 服务），可以使用防火墙或安全组阻止外网访问。然后，部署一个 VPN 服务器，使管理者在连接 VPN 后，仿佛置身于服务器的内网环境，从而安全访问这些服务。  </li></ul><div class="admonition note"><p class="admonition-title">OpenVPN 的应用场景</p><ul><li>个人出差办公需要访问公司内网的服务器。</li><li>公司不同地区之间建立安全的网络通信（比如 IDC 与 IDC 之间安全通信）。</li></ul></div><h2 id="OpenVPN-服务器部署"><a href="#OpenVPN-服务器部署" class="headerlink" title="OpenVPN 服务器部署"></a>OpenVPN 服务器部署</h2><p>这里使用的是 <a href="https://github.com/hwdsl2/openvpn-install">OpenVPN 自动安装脚本</a>，大家可能认为脚本安装并不能保证安全性。但实际上，OpenVPN 的安全性是由 RSA 技术提供的，安装脚本每次安装都会现场生成 RSA 密钥，安全性是有保障的。使用脚本只是方便部署操作，对于个人应用场景，脚本提供的默认设置已经足够使用。该脚本支持 Ubuntu、Debian、AlmaLinux、Rocky Linux、CentOS、Fedora 系统。特别注意，如果使用的是虚拟化容器，则需要给容器开启 TUN/TAP。</p><h3 id="下载安装脚本"><a href="#下载安装脚本" class="headerlink" title="下载安装脚本"></a>下载安装脚本</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/hwdsl2/openvpn-install/master/openvpn-install.sh -O openvpn.sh</span><br></pre></td></tr></tbody></table></figure><h3 id="运行安装脚本"><a href="#运行安装脚本" class="headerlink" title="运行安装脚本"></a>运行安装脚本</h3><ul><li>使用 <code>root</code> 权限运行脚本，并使用默认选项自动安装（<strong>不推荐</strong>）OpenVPN 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --auto</span><br></pre></td></tr></tbody></table></figure><ul><li>或者使用自定义选项进行交互式安装（<strong>强烈推荐</strong>），自定义选项包括：VPN 服务器的域名、协议（TCP/UDP）和端口、VPN 客户端的 DNS 服务器以及第一个客户端的名称 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>当安装脚本执行成功后，会在运行目录下自动生成一个 <code>客户端名.ovpn</code> 的文件（默认是 <code>client.ovpn</code>），该文件就是 OpenVPN 客户端的连接配置文件，将其下载到本地，然后导入到 OpenVPN 客户端就可以连接 OpenVPN 服务器。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>执行 <code>openvpn.sh</code> 安装脚本后，会从 GitHub 下载相应的文件资源；如果安装脚本执行失败，可能是网络访问 GitHub 较慢导致的，建议再次尝试执行安装脚本。</p></div><h3 id="防火墙开放端口"><a href="#防火墙开放端口" class="headerlink" title="防火墙开放端口"></a>防火墙开放端口</h3><ul><li>当云服务器有外部防火墙（比如安全组），则需要手动调整安全组的配置，也就是开放安全组对应的协议和对应的端口，具体的协议和端口请根据上面的安装选项来配置。</li><li>当 Linux 服务器内有防火墙（比如 <code>UFW</code>），则需要手动调整安全组的配置，也就是开放安全组对应的协议和对应的端口，具体的协议和端口请根据上面的安装选项来配置。</li><li>比如，使用 <code>openvpn.sh --auto</code> 命令自动安装 OpenVPN 服务器后（基于默认安装选项），云服务器的安全组或者 Linux 服务器的防火墙都需要开放 UDP 协议的 <code>1194</code> 端口。<ul><li>Debian 开放 OpenVPN 端口：<code>sudo ufw allow 1194/udp</code></li><li>CentOS 开放 OpenVPN 端口：<code>sudo firewall-cmd --zone=public --permanent --add-port=1194/udp</code></li></ul></li></ul><h2 id="OpenVPN-的日常管理"><a href="#OpenVPN-的日常管理" class="headerlink" title="OpenVPN 的日常管理"></a>OpenVPN 的日常管理</h2><ul><li>安装脚本提供了以下命令行参数，可以用于管理 OpenVPN 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看脚本的参数</span></span><br><span class="line">sudo bash openvpn.sh --<span class="built_in">help</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Usage: bash openvpn.sh [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">  --addclient [client name]      add a new client</span><br><span class="line">  --exportclient [client name]   export configuration for an existing client</span><br><span class="line">  --listclients                  list the names of existing clients</span><br><span class="line">  --revokeclient [client name]   revoke an existing client</span><br><span class="line">  --uninstall                    remove OpenVPN and delete all configuration</span><br><span class="line">  -y, --yes                      assume "yes" as answer to prompts when revoking a client or removing OpenVPN</span><br><span class="line">  -h, --help                     show this help message and exit</span><br><span class="line"></span><br><span class="line">Install options (optional):</span><br><span class="line"></span><br><span class="line">  --auto                         auto install OpenVPN using default or custom options</span><br><span class="line">  --listenaddr [IPv4 address]    IPv4 address that OpenVPN should listen on for requests</span><br><span class="line">  --serveraddr [DNS name or IP]  server address, must be a fully qualified domain name (FQDN) or an IPv4 address</span><br><span class="line">  --proto [TCP or UDP]           protocol for OpenVPN (TCP or UDP, default: UDP)</span><br><span class="line">  --port [number]                port for OpenVPN (1-65535, default: 1194)</span><br><span class="line">  --clientname [client name]     name for the first OpenVPN client (default: client)</span><br><span class="line">  --dns1 [DNS server IP]         primary DNS server for clients (default: Google Public DNS)</span><br><span class="line">  --dns2 [DNS server IP]         secondary DNS server for clients</span><br><span class="line"></span><br><span class="line">To customize options, you may also run this script without arguments.</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 OpenVPN 客户端 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --listclients</span><br></pre></td></tr></tbody></table></figure><ul><li>移除指定的 OpenVPN 客户端 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --revokeclient client_name</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 OpenVPN 客户端 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --addclient client_name</span><br></pre></td></tr></tbody></table></figure><ul><li>卸载 OpenVPN 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --uninstall</span><br></pre></td></tr></tbody></table></figure><blockquote><p>为了日后更方便地执行安装脚本来管理 OpenVPN 服务器，可以将安装脚本移动到 Linux 系统的 <code>bin</code> 目录下，如下所示：</p></blockquote><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移动脚本文件</span></span><br><span class="line">sudo mv openvpn.sh /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权脚本文件</span></span><br><span class="line">sudo chmod 744 /usr/<span class="built_in">local</span>/bin/openvpn.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以后可以在任意目录下执行脚本</span></span><br><span class="line">sudo openvpn.sh --<span class="built_in">help</span></span><br></pre></td></tr></tbody></table></figure><h2 id="OpenVPN-客户端安装"><a href="#OpenVPN-客户端安装" class="headerlink" title="OpenVPN 客户端安装"></a>OpenVPN 客户端安装</h2><h3 id="各平台安装-GUI-客户端"><a href="#各平台安装-GUI-客户端" class="headerlink" title="各平台安装 GUI 客户端"></a>各平台安装 GUI 客户端</h3><ul><li>(1) <a href="https://openvpn.net/client/">OpenVPN 客户端</a> 在 Windows、macOS、iOS、Android 和 Linux 上均可用，macOS 用户还可以使用 Tunnelblick 作为 OpenVPN 客户端。</li><li>(2) OpenVPN 客户端要连接 OpenVPN 服务器，首先将生成的 <code>客户端名.ovpn</code> 文件安全地下载到本地设备，然后打开 OpenVPN 客户端程序，并导入 OpenVPN 客户端的配置文件（比如 <code>client.ovpn</code>）。</li><li>(3) 当 OpenVPN 服务器需要管理 OpenVPN 客户端时，可以再次运行安装脚本，比如，查看所有 OpenVPN 客户端：<code>sudo bash openvpn.sh --listclients</code>。</li></ul><h3 id="CentOS-7-安装-GUI-客户端"><a href="#CentOS-7-安装-GUI-客户端" class="headerlink" title="CentOS 7 安装 GUI 客户端"></a>CentOS 7 安装 GUI 客户端</h3><p>值得一提的是，如果 Centos 7 不需要使用 GUI 客户端，那么可以直接官方提供的 OpenVPN 3，也就是基于命令行的方式连接 OpenVPN 服务器。</p><ul><li>关闭 SELINUX</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一（临时关闭）</span></span><br><span class="line">sudo setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二（永久关闭，需要重启系统）</span></span><br><span class="line">sudo vi /etc/selinux/config</span><br><span class="line">SELINUX=disabled             <span class="comment"># 找到 SELINUX 这一行，并将其值改为 disabled</span></span><br></pre></td></tr></tbody></table></figure><ul><li>安装客户端（GUI）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install NetworkManager-openvpn</span><br><span class="line">sudo yum install NetworkManager-openvpn-gnome</span><br></pre></td></tr></tbody></table></figure><ul><li>导入 <code>.ovpn</code> 文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) 系统菜单栏导航到 settings -&gt; network -&gt; 点击 VPN 旁边的 + 号 -&gt; Import form file</span><br><span class="line">(2) 选择本地的 .ovpn 配置文件，NetworkManager 会自动识别 VPN 客户端的连接方式（比如使用 OpenVPN）</span><br><span class="line">(3) 如果有用户密码，需要在 User key password 输入框中填写用户密码</span><br><span class="line">(4) 如果有用户密码，密码保存方式选择：Store the password for all users（点击选择用户密码输入框右边那两个小人图标），否则容易出现某种奇怪的密码读取问题</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>一键安装 OpenVPN 服务器</p><ul><li><a href="https://blog.csdn.net/weixin_53391173/article/details/134180734">轻松搭建 OpenVPN 服务器</a></li><li><a href="https://blog.csdn.net/lemon_TT/article/details/136375983">OpenVPN 服务器的安装与使用</a></li><li><a href="https://www.zouht.com/3573.html">通过 OpenVPN 安全地进行服务器运维</a></li></ul></li><li><p>手动安装 OpenVPN 服务器</p><ul><li><a href="https://blog.csdn.net/qq_37510195/article/details/130777785">CentOS 搭建 OpenVPN 服务器</a></li><li><a href="https://www.cnblogs.com/cheyunhua/p/17516732.html">CentOS 7 安装 OpenVPN - 超详细</a></li></ul></li><li><p> Docker 安装 OpenVPN 服务器</p><ul><li><a href="https://cloud.tencent.com/developer/article/1953132">Docker 搭建虚拟专用网（VPN）</a></li></ul></li><li><p>CentOS 7 安装 OpenVPN 客户端</p><ul><li><a href="https://developer.baidu.com/article/details/3282576">CentOS 7 安装 OpenVPN 客户端</a></li><li><a href="https://zhuanlan.zhihu.com/p/637668940">Centos 7 安装 OpenVPN 客户端（GUI）</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Linux 系统一键搭建 OpenVPN 服务器。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="网络安全" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装 Sentinel Dashboard 单机</title>
    <link href="https://www.techgrow.cn/posts/592ca43f.html"/>
    <id>https://www.techgrow.cn/posts/592ca43f.html</id>
    <published>2025-03-13T12:05:42.000Z</published>
    <updated>2025-03-13T12:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍如何使用 Docker 和 Docker-Compose 安装 Sentinel Dashboard（单机）。</p><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li><a href="https://github.com/alibaba/Sentinel">Sentinel 官方项目</a></li><li><a href="https://github.com/alibaba/Sentinel/wiki">Sentinel 官方文档</a></li><li><a href="https://hub.docker.com/r/herodotus/sentinel-dashboard">Sentinel Dashboard 镜像（支持持久化）</a></li><li><a href="https://hub.docker.com/r/bladex/sentinel-dashboard">Sentinel Dashboard 镜像（不支持持久化）</a></li></ul><span id="more"></span><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><ul><li>拉取镜像 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bladex/sentinel-dashboard:1.8.8</span><br></pre></td></tr></tbody></table></figure><ul><li>启动容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name sentinel -d -p 8858:8858  bladex/sentinel-dashboard:1.8.8</span><br></pre></td></tr></tbody></table></figure><h3 id="Docker-Compose-安装"><a href="#Docker-Compose-安装" class="headerlink" title="Docker-Compose 安装"></a>Docker-Compose 安装</h3><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sentinel-dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bladex/sentinel-dashboard:1.8.8</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sentinel-dashboard</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8858</span><span class="string">:8858</span></span><br></pre></td></tr></tbody></table></figure><h3 id="测试-Sentinel-Dashboard"><a href="#测试-Sentinel-Dashboard" class="headerlink" title="测试 Sentinel Dashboard"></a>测试 Sentinel Dashboard</h3><p>启动 Sentinel Dashboard 容器后，浏览器通过 <code>http://127.0.0.1:8858/</code> 可以访问控制台管理页面，默认登录用户和密码分别是 <code>sentinel /sentinel</code>。</p><h3 id="Sentinel-Dashboard-持久化"><a href="#Sentinel-Dashboard-持久化" class="headerlink" title="Sentinel Dashboard 持久化"></a>Sentinel Dashboard 持久化</h3><p>Sentinel Dashboard 的流量控制规则默认存储在内存中，重启后会丢失配置规则。若希望通过 Sentinel Dashboard 界面将流量控制规则存储到 Nacos，或者将微服务的流量监控数据持久化存储到 Influxdb 时序数据库，可以使用 Dante Cloud 发布的 <a href="https://hub.docker.com/r/herodotus/sentinel-dashboard">Sentinel Dashboard 镜像</a>。</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sentinel-dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">herodotus/sentinel-dashboard:1.8.8</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sentinel-dashboard</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SENTINEL_ADMIN_USERNAME:</span> <span class="string">sentinel</span></span><br><span class="line">      <span class="attr">SENTINEL_ADMIN_PASSWORD:</span> <span class="string">sentinel</span></span><br><span class="line">      <span class="attr">INFLUXDB_URL:</span> <span class="string">http://127.0.0.1:8086</span></span><br><span class="line">      <span class="attr">INFLUXDB_USERNAME:</span> <span class="string">influx</span></span><br><span class="line">      <span class="attr">INFLUXDB_PASSWORD:</span> <span class="string">influx</span></span><br><span class="line">      <span class="attr">INFLUXDB_DATABASE:</span> <span class="string">sentinel</span></span><br><span class="line">      <span class="attr">NACOS_SERVER_ADDRESS:</span> <span class="string">http://127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">NACOS_CONFIG_DATA_ID_SUFFIX:</span> <span class="string">flow-rules</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8858:8858"</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Dante Cloud 发布的 Sentinel Dashboard 镜像，时序数据存储支持 Influxdb <code>v1.x</code> 版本，Nacos 目前仅支持 <code>v2.x</code> 版本。默认使用 Sentinel Dashboard 原有内存方式存储，可通过配置参数动态开启或者关闭 Influxdb 和 Nacos 存储机制。</p></div>]]></content>
    
    
    <summary type="html">本文主要介绍如何使用 Docker 安装 Sentinel Dashboard 单机。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>UFW 导致 Docker 容器无法使用 IP 访问宿主机</title>
    <link href="https://www.techgrow.cn/posts/9fc5e76e.html"/>
    <id>https://www.techgrow.cn/posts/9fc5e76e.html</id>
    <published>2025-03-13T12:05:42.000Z</published>
    <updated>2025-03-13T12:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>Debian 服务器的内网 IP（宿主机 IP） 是 <code>192.16.1.5</code>，启用了 UFW 防火墙，并且服务器上运行着两个 Docker 容器。</li><li>假设用 <code>-p 8080:80</code> 参数启动了容器 A 内的服务，在容器 B 内的服务通过宿主机 IP（<code>192.16.1.5:8080</code>）访问容器 A 的服务，发现无法正常访问。</li></ul><span id="more"></span><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>Debian 启用 UFW 防火墙后，Docker 容器可能无法使用宿主机的 IP 地址相互通信。这是因为 Docker 默认会直接修改 <code>iptables</code> 规则，而这些规则可能与 UFW 的配置产生冲突，导致通信受阻。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>关闭 UFW 防火墙，这是最简单的方案，但也是最危险的方案。因为服务器将失去 UFW 防火墙的保护，容易受到恶意攻击。</p><h3 id="解决方法二"><a href="#解决方法二" class="headerlink" title="解决方法二"></a>解决方法二</h3><p>自定义 Docker 桥接网络，并添加 UFW 防火墙规则允许 Docker 桥接网络与宿主机互相通信。</p><ul><li>定义 Docker 桥接网络，同时指定自定义网络的子网范围 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">user-biz:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">clay/user-biz:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">user-biz</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">cloud_default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">173.18</span><span class="number">.0</span><span class="number">.05</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">order-biz:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">clay/order-biz:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">order-biz</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9090</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">cloud_default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">173.18</span><span class="number">.0</span><span class="number">.06</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">cloud_default:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud_default</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">173.18</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br></pre></td></tr></tbody></table></figure><ul><li>或者手动创建 Docker 桥接网络，同时指定自定义网络的子网范围，并在容器启动时指定桥接网络 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker network create --driver bridge --subnet 173.18.0.0/16 cloud_default</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name user-biz -p 8080:80 --network cloud_default --ip 173.18.0.05 clay/user-biz:latest</span><br><span class="line">sudo docker run -d --name order-biz -p 9090:80 --network cloud_default --ip 173.18.0.06 clay/order-biz:latest</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Docker 桥接网络的 IP 分配情况 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect network cloud_default</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">"d268549f1335d1078c3692e1208a0376eb403a920a176642983f2eb0f64f4b61": {</span><br><span class="line">    "Name": "user-biz",</span><br><span class="line">    "EndpointID": "8d5cba4fe76a69b4169e6266ca2d3a5cbd9be84fdcf0e7f4f3ab6a05c2825a1f",</span><br><span class="line">    "MacAddress": "8e:40:19:99:af:49",</span><br><span class="line">    "IPv4Address": "173.18.0.05/16",</span><br><span class="line">    "IPv6Address": ""</span><br><span class="line">},</span><br><span class="line">"f83453e8d515e58a1c5a68c7957835ed82cece7104129dba1fcb604bb1215d8a": {</span><br><span class="line">    "Name": "order-biz",</span><br><span class="line">    "EndpointID": "8899737f0c54cfb3f4fac0f9effaeaf318eb12e8d0d4988fff399a2d94e9be0b",</span><br><span class="line">    "MacAddress": "72:6e:1b:a8:15:26",</span><br><span class="line">    "IPv4Address": "173.18.0.06/16",</span><br><span class="line">    "IPv6Address": ""</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 UFW 防火墙规则（使用 CIDR 表示法），允许 Docker 桥接网络与宿主机互相通信。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow from 173.18.0.0/16</span><br><span class="line">sudo ufw allow out to 173.18.0.0/16</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/shihan175/article/details/131058696">Docker 容器无法使用 IP 访问宿主机</a></li><li><a href="https://www.cnblogs.com/codedingzhen/p/18371798">解决 Docker 和 UFW 的网络冲突问题</a></li><li><a href="https://juejin.cn/post/7307857575507836966">解决 UFW 和 Docker 的冲突问题</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何解决 Docker 容器无法使用 IP 访问宿主机的问题。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固进阶之三</title>
    <link href="https://www.techgrow.cn/posts/bd9d2710.html"/>
    <id>https://www.techgrow.cn/posts/bd9d2710.html</id>
    <published>2025-03-02T13:55:33.000Z</published>
    <updated>2025-03-02T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-11-的-function-类模板"><a href="#C-11-的-function-类模板" class="headerlink" title="C++ 11 的 function 类模板"></a>C++ 11 的 function 类模板</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p><code>function</code> 是 C++ 11 引入的一个类模板，用于存储任何可以调用的目标（如普通函数、函数指针、函数对象、Lambda 表达式等），并通过统一的接口进行调用。它能够封装和管理函数，允许将函数作为对象传递和存储，位于 <code>&lt;functional&gt;</code> 头文件中，常用于回调和高阶函数。</p><ul><li><p>使用说明</p><ul><li>用函数类型实例化 <code>function</code> 类模板</li><li>通过 <code>function</code> 类模板调用 <code>operator()</code> 函数的时候，需要根据函数类型传入相应的参数</li></ul></li><li><p>使用特点</p><ul><li>通过类型擦除技术存储任意可调用对象（普通函数、Lambda 表达式、仿函数、成员函数指针等），无需关心具体类型，仅需关注调用签名‌</li><li>编译时会检查参数和返回类型是否匹配，避免了传统函数指针的类型不安全问题‌</li></ul></li><li><p>使用场景</p><ul><li>事件回调</li><li>作为函数参数传递可调用对象</li><li>存储 Lambda 表达式</li></ul></li></ul><h3 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h3><p>C 语言中的函数指针与 C++ 的 <code>function</code> 类模板的对比如下：</p><table><thead><tr><th>特性</th><th>函数指针 (C 语言)</th><th><code>function</code> 类模板 (C++)</th></tr></thead><tbody><tr><td> 灵活性</td><td>只能指向具有匹配签名的函数</td><td>可以封装多种类型的可调用对象 (函数、Lambda、函数对象)</td></tr><tr><td> 状态管理</td><td>不支持状态封装</td><td>支持状态封装（如 Lambda 表达式和函数对象）</td></tr><tr><td>类型安全</td><td>不提供额外的类型安全</td><td>提供类型安全检查</td></tr><tr><td>性能开销</td><td>较低</td><td>可能有较高的内存和性能开销</td></tr><tr><td>多态性</td><td>不支持多态</td><td>支持多态</td></tr></tbody></table><p>C 语言中的函数指针与 C++ 的 <code>function</code> 类模板的区别如下：</p><ul><li><p>基本概念</p><ul><li>函数指针（C 语言）<ul><li>函数指针是一个变量，用于存储函数的地址。通过该指针，可以间接调用对应的函数。</li><li>C 语言中的函数指针需要显式指定函数签名（返回值类型和参数类型）。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 是 C++ 11 引入的类模板，提供了一种通用的、类型安全的方式来存储、传递和调用可调用对象（如普通函数、函数指针、Lambda 表达式、函数对象等）。</li><li>它可以封装多种不同类型的可调用对象，并且允许它们通过统一的接口被调用。</li></ul></li></ul></li><li><p>灵活性和类型支持</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针只能指向具有相同函数签名（参数类型和返回类型）的函数。</li><li>不支持封装函数对象、Lambda 表达式等其他类型的可调用对象。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 支持多种类型的可调用对象，包括普通函数、函数指针、Lambda 表达式、函数对象等。</li><li>它的模板参数可以适配任意函数签名，支持更加灵活的调用。</li><li>还支持捕获外部状态的 Lambda 表达式，或者包含状态的函数对象。</li></ul></li></ul></li><li><p>状态管理</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针无法封装额外的状态信息，指向的仅仅是一个函数。</li><li>如果需要管理状态（如在函数调用前后执行某些操作），必须依赖外部的代码来实现。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 可以封装状态信息。例如，Lambda 表达式和函数对象可以拥有成员变量和成员函数，允许在调用时使用封装的状态。</li><li>这种能力使得 <code>function</code> 在处理回调和事件处理时更具优势。</li></ul></li></ul></li><li><p>类型安全</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针本身类型是静态的，编译时要求函数签名必须匹配，但它不提供额外的类型安全检查，错误的使用可能导致未定义行为。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 是类型安全的，编译时会检查存储的可调用对象是否与声明的函数签名一致。</li><li>C++ 编译器提供了类型安全的保证，避免了函数签名不匹配带来的错误。</li></ul></li></ul></li><li><p>内存管理和性能</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针直接存储函数的地址，不涉及额外的内存分配，因此它的性能开销较小。</li><li>由于没有额外的封装，也没有多态或状态的管理，性能上较为高效。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 需要进行额外的内存分配和类型擦除（Type Erasure）。对于 Lambda 表达式和函数对象，它会封装一个通用的接口，这可能带来额外的性能开销。</li><li>但是，它的灵活性和类型安全是 <code>function</code> 的优势。</li></ul></li></ul></li><li><p>多态和扩展性</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针没有多态性。它们只是简单地指向某个函数，无法支持运行时多态。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 支持通过函数对象、Lambda 表达式和虚拟函数等方式实现运行时多态，提供了更大的灵活性。</li><li>它可以封装复杂的行为，例如结合面向对象编程中的继承和多态来实现不同的回调机制。</li></ul></li></ul></li></ul><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello1</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello2</span><span class="params">(string str)</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// function 函数对象类型</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; function1 = hello1;</span><br><span class="line">    <span class="built_in">function1</span>();</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; function2 = hello2;</span><br><span class="line">    <span class="built_in">function2</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; function3 = sum;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="built_in">function3</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"total = "</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function 函数对象类型 + Lambda 表达式</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; function4 = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) {<span class="keyword">return</span> a + b; };</span><br><span class="line">    <span class="keyword">int</span> total2 = <span class="built_in">function4</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"total2 = "</span> &lt;&lt; total2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello peter</span><br><span class="line">total = 3</span><br><span class="line">total2 = 8</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 通过 function 函数对象类型，调用类的成员函数</span></span><br><span class="line">    Test t;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(Test*, string)&gt; function1 = &amp;Test::hello;</span><br><span class="line">    <span class="built_in">function1</span>(&amp;t, <span class="string">"peter"</span>);</span><br><span class="line">    <span class="built_in">function1</span>(&amp;<span class="built_in">Test</span>(), <span class="string">"peter"</span>);    <span class="comment">// 或者使用临时变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br><span class="line">hello peter</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码三"><a href="#案例代码三" class="headerlink" title="案例代码三"></a>案例代码三</h4><p>使用 <code>function</code> 函数对象类型来实现图书管理系统的菜单列表选择功能。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doShowAllBooks</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"查看所有书籍"</span> &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBorrowBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"借书"</span> &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBackBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"还书"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doQueryBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"查询书籍"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoginOut</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"注销"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="keyword">int</span>, function&lt;<span class="keyword">void</span>()&gt;&gt; actionMap;</span><br><span class="line">actionMap.<span class="built_in">insert</span>({ <span class="number">1</span>, doShowAllBooks });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">2</span>, doBorrowBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">3</span>, doBackBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">4</span>, doQueryBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">5</span>, doLoginOut });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"\n-------------------"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"1. 查看所有书籍"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"2. 借书"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"3. 还书"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"4. 查询书籍"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"5. 注销"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"-------------------"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"请选择: "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测输入是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (!(cin &gt;&gt; choice)) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入数字无效，请重新输入!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 清除错误状态</span></span><br><span class="line">            cin.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">// 丢弃错误输入</span></span><br><span class="line">            cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = actionMap.<span class="built_in">find</span>(choice);</span><br><span class="line">        <span class="keyword">if</span> (it == actionMap.<span class="built_in">end</span>()) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入数字无效，请重新输入!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        it-&gt;<span class="built_in">second</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="案例代码一-1"><a href="#案例代码一-1" class="headerlink" title="案例代码一"></a>案例代码一</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有一个参数且不带返回值的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 模板类的特化，支持特定的函数签名 R(ARG)</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG 代表参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ARG&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg 传递给存储函数的参数</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG arg)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 hello 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = hello;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 hello</span></span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二-1"><a href="#案例代码二-1" class="headerlink" title="案例代码二"></a>案例代码二</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有两个参数且带返回值的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG1, ARG2)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 模板类的特化，支持特定的函数签名 R(ARG1, ARG2)</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG1 代表第一个参数类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG2 代表第二个参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ARG1, <span class="keyword">typename</span> ARG2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG1, ARG2)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG1, ARG2) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG1, ARG2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line"><span class="comment">     * @param pfunc 指向函数的指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg1 传递给存储函数的第一个参数</span></span><br><span class="line"><span class="comment">     * @param arg2 传递给存储函数的第二个参数</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG1 arg1, ARG2 arg2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg1, arg2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 sum 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func1 = sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 sum</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">func1</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result: "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: 8</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码三-1"><a href="#案例代码三-1" class="headerlink" title="案例代码三"></a>案例代码三</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有不同数量参数（可变参数列表）的函数，避免编写多个模板类的特例化。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG...)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief myfunction 模板类的特化，支持可变长参数列表</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG 代表参数列表（可以是任意数量的参数类型）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ... ARG&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG...)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG...) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line"><span class="comment">     * @param pfunc 指向函数的指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg 传递给存储函数的参数列表</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG... arg)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg...);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 hello 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = hello;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 hello</span></span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 sum函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func2 = sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func2 调用 sum</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">func2</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result: "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br><span class="line">result: 7</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的-bind-绑定器"><a href="#C-11-的-bind-绑定器" class="headerlink" title="C++ 11 的 bind 绑定器"></a>C++ 11 的 bind 绑定器</h2><h3 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h3><h4 id="bind-的概念"><a href="#bind-的概念" class="headerlink" title="bind 的概念"></a>bind 的概念</h4><p><code>bind</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的一个工具，用于创建可调用对象（Callable Object），它可以将函数与部分参数进行绑定，并返回一个新的可调用对象，方便后续调用。</p><ul><li><p>主要作用</p><ul><li>固定部分参数：可以预先绑定部分参数，简化后续调用的接口。</li><li>调整参数顺序：可以自定义参数的传递顺序，使函数调用更加灵活。</li><li>与标准库配合：可以与 <code>function</code>、<code>thread</code>、STL 算法等一起使用，提高程序的灵活性。</li></ul></li><li><p>关键点</p><ul><li><code>bind</code> 返回一个可调用对象（函数对象），类似于 Lambda 表达式。</li><li><code>placeholders::_1, placeholders::_2, ...</code> 代表占位符（最多可以有 20 个），表示绑定器调用时需要提供的参数。</li><li>适用于普通函数、类成员函数、仿函数（函数对象）等。</li></ul></li><li><p>使用场景</p><ul><li>配合 <code>function</code> 类模板使用，用于回调管理。</li><li>与 <code>thread</code> 配合，用于传递类成员函数。</li><li>在 STL 算法中自定义比较或筛选规则。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>尽管 <code>bind</code> 功能强大，但在 C++ 11 之后，Lambda 表达式在大多数情况下更加直观，建议优先使用 Lambda 表达式。</p></div><h4 id="bind1st-与-bind2nd-的概念"><a href="#bind1st-与-bind2nd-的概念" class="headerlink" title="bind1st 与 bind2nd 的概念"></a>bind1st 与 bind2nd 的概念</h4><p><code>bind1st</code> 和 <code>bind2nd</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的函数适配器，用于对二元（两个参数）函数对象进行绑定，使其成为一元（单参数）函数对象。这两个函数适配器用于旧版 C++（C++ 98 / C++ 03），在 C++ 11 及更新版本中已被 <code>bind</code> 取代。</p><ul><li><code>bind1st</code>：绑定二元（两个参数）函数对象的第一个参数，生成一个新的一元函数对象，该函数对象接收原函数的第二个参数作为输入。</li><li><code>bind2nd</code>：绑定二元（两个参数）函数对象的第二个参数，生成一个新的一元函数对象，该函数对象接收原函数的第一个参数作为输入。</li></ul><h3 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="bind-与-function-基础使用"><a href="#bind-与-function-基础使用" class="headerlink" title="bind 与 function 基础使用"></a><code>bind</code> 与 <code>function</code> 基础使用</h4><p>这里主要演示如何使用 C++ 11 中的 <code>bind</code> 和 <code>function</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 例子一，绑定拥有一个参数的普通函数</span></span><br><span class="line">    <span class="built_in">bind</span>(hello, <span class="string">"Hello Bind!"</span>)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子二，绑定拥有两个参数的普通函数</span></span><br><span class="line">    <span class="keyword">int</span> result1 = <span class="built_in">bind</span>(sum, <span class="number">3</span>, <span class="number">5</span>)();</span><br><span class="line">    cout &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子三，绑定类成员函数</span></span><br><span class="line">    <span class="keyword">int</span> result2 = <span class="built_in">bind</span>(&amp;Test::sum, <span class="built_in">Test</span>(), <span class="number">5</span>, <span class="number">9</span>)();</span><br><span class="line">    cout &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子四，使用参数占位符绑定（最多可以有20个参数占位符）</span></span><br><span class="line">    <span class="built_in">bind</span>(hello, placeholders::_1)(<span class="string">"Hello Rust!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子五，使用 function 类模板实现 bind 绑定器的复用</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = <span class="built_in">bind</span>(hello, placeholders::_1);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"Hello Python"</span>);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"Hello Golang"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子六，使用参数占位符 + function 类模板进行绑定</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; func2 = <span class="built_in">bind</span>(sum, <span class="number">6</span>, placeholders::_1);    <span class="comment">// 绑定 6 作为第一个参数，第二个参数则手动传入</span></span><br><span class="line">    <span class="keyword">int</span> result3 = <span class="built_in">func2</span>(<span class="number">5</span>);     <span class="comment">// 输出 11，相当于 sum(6, 5)</span></span><br><span class="line">    cout &lt;&lt; result3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hello Bind!</span><br><span class="line">8</span><br><span class="line">14</span><br><span class="line">Hello Rust!</span><br><span class="line">Hello Python</span><br><span class="line">Hello Golang</span><br><span class="line">11</span><br></pre></td></tr></tbody></table></figure><h4 id="bind-与-function-实现线程池"><a href="#bind-与-function-实现线程池" class="headerlink" title="bind 与 function 实现线程池"></a><code>bind</code> 与 <code>function</code> 实现线程池</h4><p>这里简单使用 C++ 11 的 <code>bind</code> 和 <code>function</code> 来模拟实现线程池。特别注意，下述代码中的 <code>ThreadPool::startPool()</code> 会调用 <code>join()</code> 来阻塞等待所有子线程执行完成，即线程池运行一次后就会结束，不能重复使用，而且也没有使用到任务队列来优化线程池。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Thread</span>(function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; func, <span class="keyword">int</span> id) : _func(func), _id(id) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(_func, _id)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; _func;</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程池</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">        <span class="comment">// 释放堆上的资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _pool.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">delete</span> _pool[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建自定义的线程对象，并放入容器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="comment">// 使用 bind 绑定器</span></span><br><span class="line">            _pool.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="keyword">this</span>, placeholders::_1), i));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _handler.<span class="built_in">push_back</span>(_pool[i]-&gt;<span class="built_in">start</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子线程执行完成</span></span><br><span class="line">        <span class="keyword">for</span> (thread &amp;t : _handler) {</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Thread *&gt; _pool;</span><br><span class="line">    vector&lt;thread&gt; _handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runInThread() 成员函数充当线程函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runInThread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call runInThread! id: "</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">startPool</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call runInThread! id: 0</span><br><span class="line">call runInThread! id: 2</span><br><span class="line">call runInThread! id: 5</span><br><span class="line">call runInThread! id: 9</span><br><span class="line">call runInThread! id: 6</span><br><span class="line">call runInThread! id: 8</span><br><span class="line">call runInThread! id: 1</span><br><span class="line">call runInThread! id: 7</span><br><span class="line">call runInThread! id: 4</span><br><span class="line">call runInThread! id: 3</span><br></pre></td></tr></tbody></table></figure><h4 id="bind1st-与-bind2nd-基础使用"><a href="#bind1st-与-bind2nd-基础使用" class="headerlink" title="bind1st 与 bind2nd 基础使用"></a><code>bind1st</code> 与 <code>bind2nd</code> 基础使用</h4><p>这里主要演示如何使用旧版 C++ 提供的 <code>bind1st</code> 与 <code>bind2nd</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showContainer</span><span class="params">(Container &amp;con)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历容器并打印元素</span></span><br><span class="line">    <span class="keyword">typename</span> Container::iterator it = con.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; it != con.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序，greater 是二元函数对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 70 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind1st 绑定 greater 的第一个参数，使其始终为 70，让 greater(70, x) 变成一元函数对象，等价于 f(x) = (70 &gt; x)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind2nd 绑定 less 的第二个参数，使其始终为 70，让 less(x, 70) 变成一元函数对象，等价于 f(x) = (x &lt; 70)</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator it = find_if(vec.begin(), vec.end(), bind2nd(less&lt;int&gt;(), 70));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 70 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"================================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">20 67 35 49 100 43 28 63 71 46 </span><br><span class="line">20 28 35 43 46 49 63 67 71 100 </span><br><span class="line">100 71 67 63 49 46 43 35 28 20 </span><br><span class="line">================================</span><br><span class="line">76 88 70 53 82 84 42 38 91 64 </span><br><span class="line">91 88 84 82 76 70 64 53 42 38 </span><br><span class="line">找到小于 70 的第一个元素：64</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 C++ 11 及更新版本中，<code>bind1st</code> 和 <code>bind2nd</code> 已被 <code>bind</code> 取代，示例代码如下：</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 3 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind 绑定 greater 的第一个参数，等价于 f(x) = (3 &gt; x)</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>)&gt; predicate = <span class="built_in">bind</span>(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">3</span>, placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind 绑定 less 的第二个参数，等价于 f(x) = (x &lt; 3)</span></span><br><span class="line">    <span class="comment">// function&lt;bool(int)&gt; predicate = bind(less&lt;int&gt;(), placeholders::_1, 3);</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), predicate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 3 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 3 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 C++ 11 及更新版本中，可以使用 Lambda 表达式（更现代的 C++ 方式）来实现，示例代码如下：</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 3 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x) { <span class="keyword">return</span> x &lt; <span class="number">3</span>; });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 3 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 3 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><h4 id="bind1st-与-bind2nd-底层原理"><a href="#bind1st-与-bind2nd-底层原理" class="headerlink" title="bind1st 与 bind2nd 底层原理"></a><code>bind1st</code> 与 <code>bind2nd</code> 底层原理</h4><h5 id="模拟实现-bind1st-的功能"><a href="#模拟实现-bind1st-的功能" class="headerlink" title="模拟实现 bind1st 的功能"></a>模拟实现 bind1st 的功能</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象（一元函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">my_bind1st</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，比如：my_bind1st(greater&lt;int&gt;(), 5)</span></span><br><span class="line">    _my_bind1st(Compare comp, <span class="keyword">const</span> T &amp;first) : _comp(comp), _first(first) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;second)</span> </span>{</span><br><span class="line">        <span class="comment">// 底层调用的仍然是二元（两个参数）函数对象</span></span><br><span class="line">        <span class="keyword">return</span> _comp(_first, second);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _comp;</span><br><span class="line">    T _first;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定器（模拟 bind1st 的实现）</span></span><br><span class="line"><span class="comment">// 绑定二元（两个参数）函数对象的第一个参数，生成一个新的一元函数对象，该函数对象接收原函数的第二个参数作为输入</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_my_bind1st&lt;Compare, T&gt; <span class="title">my_bind1st</span><span class="params">(Compare comp, <span class="keyword">const</span> T &amp;first)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> _my_bind1st&lt;Compare, T&gt;(comp, first);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*first)) {</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">9</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 5 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 my_bind1st 绑定 greater 的第一个参数，使其始终为 5，让 greater(5, x) 变成一元函数对象，等价于 f(x) = (5 &gt; x)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">my_bind1st</span>(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 5 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 5 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><h5 id="模拟实现-bind2nd-的功能"><a href="#模拟实现-bind2nd-的功能" class="headerlink" title="模拟实现 bind2nd 的功能"></a>模拟实现 bind2nd 的功能</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象（一元函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">my_bind2nd</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，比如：my_bind2nd(less&lt;int&gt;(), 5)</span></span><br><span class="line">    _my_bind2nd(Compare comp, <span class="keyword">const</span> T &amp;second) : _comp(comp), _second(second) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;first)</span> </span>{</span><br><span class="line">        <span class="comment">// 底层调用的仍然是二元（两个参数）函数对象</span></span><br><span class="line">        <span class="keyword">return</span> _comp(first, _second);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _comp;</span><br><span class="line">    T _second;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定器（模拟 bind2nd 的实现）</span></span><br><span class="line"><span class="comment">// 绑定二元（两个参数）函数对象的第二个参数，生成一个新的一元函数对象，该函数对象接收原函数的第一个参数作为输入</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_my_bind2nd&lt;Compare, T&gt; <span class="title">my_bind2nd</span><span class="params">(Compare comp, <span class="keyword">const</span> T &amp;second)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> _my_bind2nd&lt;Compare, T&gt;(comp, second);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*first)) {</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">9</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 5 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 my_bind2nd 绑定 less 的第二个参数，使其始终为 5，让 less(x, 5) 变成一元函数对象，等价于 f(x) = (x &lt; 5)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">my_bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 5 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 5 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的-Lambda-表达式"><a href="#C-11-的-Lambda-表达式" class="headerlink" title="C++ 11 的 Lambda 表达式"></a>C++ 11 的 Lambda 表达式</h2><h3 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>C++ 11 的 Lambda 表达式（Lambda Expressions）是一种用于定义匿名函数对象的简洁语法，使得代码更加简洁、灵活。其强大的变量捕获、类型推导和灵活性，使其在现代 C++ 开发中被广泛使用。</p><ul><li><p>Lambda 表达式的语法</p><ul><li><code>[capture](parameter_list) -&gt; return_type {function_body}</code>，即 <code>[捕获外部变量](形参列表) -&gt; 返回类型 {操作代码}</code></li><li><code>capture</code>（捕获列表）：定义 Lambda 访问外部变量的方式（比如：按值或按引用）。<ul><li><code>[]</code>：表示不捕获任何外部变量</li><li><code>[this]</code>：表示捕获外部的 <code>this</code> 指针。</li><li><code>[=]</code>：表示以传值的方式捕获外部的所有变量。</li><li><code>[&amp;]</code>：表示以传引用的方式捕获外部的所有变量。</li><li><code>[=, &amp;a]</code>：表示以传值的方式捕获外部的所有变量，但是 <code>a</code> 变量以传引用的方式捕获。</li><li><code>[a, b]</code>：表示以传值的方式捕获外部的 <code>a</code> 和 <code>b</code> 变量。</li><li><code>[a, &amp;b]</code>：表示以传值的方式捕获外部的 <code>a</code> 变量，以传引用的方式捕获外部的 <code>b</code> 变量。</li></ul></li><li><code>parameter_list</code>（形参列表）：类似普通函数的参数。</li><li><code>return_type</code>（返回类型）：可省略，通常编译器可自动推导。</li><li><code>function_body</code>（函数体）：Lambda 实现的具体逻辑。</li></ul></li><li><p>Lambda 表达式的适用场景</p><ul><li>STL 算法的回调（如 <code>std::for_each</code>）</li><li>多线程编程（如 <code>std::thread</code>）</li><li>回调函数（如事件处理）</li><li>临时函数对象（避免定义冗长的 <code>struct</code>）</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Lambda 表达式的本质</p><p>C++ Lambda 表达式的本质是匿名的函数对象（Functor），即 没有名字的类的实例。C++ 编译器在编译 Lambda 时，会自动生成一个匿名类，并在其中重载 operator () 函数，从而使其行为类似于函数。值得一提的是，C++ Lambda 不是单纯的 “匿名函数”，而是一个匿名类的实例，即匿名的函数对象。</p></div><h3 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="Lambda-的核心特性"><a href="#Lambda-的核心特性" class="headerlink" title="Lambda 的核心特性"></a>Lambda 的核心特性</h4><ul><li>变量捕获（按值或按引用）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda1 = [x, &amp;y]() -&gt; <span class="keyword">void</span> { y = x + y; }; <span class="comment">// x 按值捕获，y 按引用捕获</span></span><br><span class="line"><span class="built_in">lambda1</span>();</span><br><span class="line">cout &lt;&lt; y;  <span class="comment">// 输出 30</span></span><br></pre></td></tr></tbody></table></figure><ul><li>省略返回类型 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);  <span class="comment">// 输出 8</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>mutable</code> 关键字修改按值捕获的变量 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> modify = [a]() <span class="keyword">mutable</span> -&gt; <span class="keyword">int</span> { a *= <span class="number">2</span>; <span class="keyword">return</span> a; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">modify</span>() &lt;&lt; endl; <span class="comment">// 输出 10</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 原变量 a 仍然是 5</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>function</code> 进行存储 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 输出 5</span></span><br></pre></td></tr></tbody></table></figure><ul><li>作为 STL 算法的回调 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">void</span> { cout &lt;&lt; item * <span class="number">2</span> &lt;&lt; <span class="string">" "</span>; }); <span class="comment">// 输出 2 4 6 8 10</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>若希望在 Lambda 表达式中不指定返回类型，那么可以省略 <code>-&gt; return_type</code>，比如：<code>auto add = [](int a, int b) { return a + b; };</code></p></div><h4 id="Lambda-的基础使用"><a href="#Lambda-的基础使用" class="headerlink" title="Lambda 的基础使用"></a>Lambda 的基础使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印容器</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">void</span> { cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>; });</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> { <span class="keyword">return</span> a &gt; b; });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印容器</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">void</span> { cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>; });</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 5 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">bool</span> { <span class="keyword">return</span> item &lt; <span class="number">50</span>; });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者简写</span></span><br><span class="line">    <span class="comment">// auto it = find_if(vec.begin(), vec.end(), [](int item) { return item &lt; 50; });</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 50 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">91 18 37 28 55 86 50 47 66 52 </span><br><span class="line">91 86 66 55 52 50 47 37 28 18 </span><br><span class="line">找到小于 50 的第一个元素：47</span><br></pre></td></tr></tbody></table></figure><h4 id="Lambda-的应用实践"><a href="#Lambda-的应用实践" class="headerlink" title="Lambda 的应用实践"></a>Lambda 的应用实践</h4><p>这里主要介绍 Lambda 表达式的各种应用实战场景。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : _a(a), _b(b) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用 function 存储 Lambda 表达式</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    map[<span class="number">0</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">    map[<span class="number">1</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a - b; };</span><br><span class="line">    map[<span class="number">2</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a * b; };</span><br><span class="line">    map[<span class="number">3</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a / b; };</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"30 + 15 = "</span> &lt;&lt; map[<span class="number">0</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"30 - 15 = "</span> &lt;&lt; map[<span class="number">1</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"30 * 15 = "</span> &lt;&lt; map[<span class="number">2</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"30 / 15 = "</span> &lt;&lt; map[<span class="number">3</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 智能指针自定义删除器</span></span><br><span class="line">    unique_ptr&lt;FILE, function&lt;<span class="built_in"><span class="keyword">void</span></span>(FILE *)&gt;&gt; <span class="built_in">ptr1</span>(<span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>), [](FILE *p) -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="built_in">fclose</span>(p);</span><br><span class="line">        cout &lt;&lt; <span class="string">"Closed File"</span> &lt;&lt; endl;</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 优先级队列自定义元素排序规则</span></span><br><span class="line">    <span class="keyword">using</span> FUNC = function&lt;<span class="built_in"><span class="keyword">bool</span></span>(Data &amp;, Data &amp;)&gt;;</span><br><span class="line">    priority_queue&lt;Data, vector&lt;Data&gt;, FUNC&gt; <span class="built_in">queue</span>([](Data &amp;data1, Data &amp;data2) {</span><br><span class="line">        <span class="keyword">return</span> data1.<span class="built_in">getA</span>() &lt; data2.<span class="built_in">getA</span>();</span><br><span class="line">    });</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">18</span>, <span class="number">25</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">15</span>, <span class="number">23</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">19</span>, <span class="number">28</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) {</span><br><span class="line">        Data data = queue.<span class="built_in">top</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; data.<span class="built_in">getA</span>() &lt;&lt; <span class="string">", b = "</span> &lt;&lt; data.<span class="built_in">getB</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">30 + 15 = 45</span><br><span class="line">30 - 15 = 15</span><br><span class="line">30 * 15 = 450</span><br><span class="line">30 / 15 = 2</span><br><span class="line">----------------</span><br><span class="line">Closed File</span><br><span class="line">----------------</span><br><span class="line">a = 19, b = 28</span><br><span class="line">a = 18, b = 25</span><br><span class="line">a = 15, b = 23</span><br><span class="line">a = 10, b = 20</span><br><span class="line">----------------</span><br></pre></td></tr></tbody></table></figure><h4 id="Lambda-的底层原理"><a href="#Lambda-的底层原理" class="headerlink" title="Lambda 的底层原理"></a>Lambda 的底层原理</h4><p>C++ Lambda 表达式的本质是匿名的函数对象（Functor），即 没有名字的类的实例。C++ 编译器在编译 Lambda 时，会自动生成一个匿名类，并在其中重载 <code>operator()</code> 函数，从而使其行为类似于函数。值得一提的是，C++ Lambda 不是单纯的 “匿名函数”，而是一个匿名类的实例，即匿名的函数对象。</p><ul><li><p>Lambda 是一个匿名类的实例</p><ul><li>编译器会为 Lambda 生成一个 匿名类，该类重载了 <code>operator()</code> 以实现调用操作。</li><li>这个匿名类的实例（匿名函数对象）即 Lambda 本身。</li></ul></li><li><p>Lambda 具有函数对象的性质</p><ul><li>Lambda 可以像普通函数一样被调用。</li><li>如果 Lambda 捕获了外部变量（如 <code>auto func = [x](int y) -&gt; int { return x + y; };</code>），那么编译器会为该匿名类生成成员变量来存储 <code>x</code>，并在 <code>operator()</code> 函数中使用这些成员变量。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">void</span>&gt;</span><br><span class="line">class MyLambda1 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda1</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T <span class="built_in"><span class="keyword">operator</span></span>()() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> func1 = []() -&gt; <span class="keyword">void</span> { cout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl; };</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    MyLambda1&lt;&gt; t1;</span><br><span class="line">    <span class="built_in">t1</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLambda2</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda2</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> fun2 = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun2</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    MyLambda2&lt;<span class="keyword">int</span>&gt; t2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">t2</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">void</span>&gt;</span><br><span class="line">class MyLambda3 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : _a(a), _b(b) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="built_in"><span class="keyword">operator</span></span>()() <span class="keyword">const</span> {</span><br><span class="line">        <span class="comment">// 交换两个变量的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = _a;</span><br><span class="line">        _a = _b;</span><br><span class="line">        _b = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值传递，并没有真正交换两个变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> func3 = [a, b]() <span class="keyword">mutable</span> -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">func3</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    <span class="function">MyLambda3&lt;<span class="keyword">int</span>&gt; <span class="title">t3</span><span class="params">(a, b)</span></span>;    <span class="comment">// 按值传递，并没有真正交换两个变量的值</span></span><br><span class="line">    <span class="built_in">t3</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">void</span>&gt;</span><br><span class="line">class MyLambda4 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda4</span>(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b) : _a(a), _b(b) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="built_in"><span class="keyword">operator</span></span>()() <span class="keyword">const</span> {</span><br><span class="line">        <span class="comment">// 交换两个变量的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = _a;</span><br><span class="line">        _a = _b;</span><br><span class="line">        _b = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> &amp;_a;</span><br><span class="line">    <span class="keyword">int</span> &amp;_b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按引用传递，可以真正交换两个变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> func4 = [&amp;a, &amp;b]() <span class="keyword">mutable</span> -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">func4</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    <span class="function">MyLambda4&lt;<span class="keyword">int</span>&gt; <span class="title">t4</span><span class="params">(a, b)</span></span>;    <span class="comment">// 按引用传递，可以真正交换两个变量的值</span></span><br><span class="line">    <span class="built_in">t4</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">----------------</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">----------------</span><br><span class="line">a = 10, b = 30</span><br><span class="line">a = 10, b = 30</span><br><span class="line">----------------</span><br><span class="line">a = 30, b = 10</span><br><span class="line">a = 10, b = 30</span><br><span class="line">----------------</span><br></pre></td></tr></tbody></table></figure><blockquote><p>验证 Lambda 表达式是函数对象</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> lambda = [](<span class="keyword">int</span> x) { <span class="keyword">return</span> x * <span class="number">2</span>; };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 是一个匿名类的实例</span></span><br><span class="line">    cout &lt;&lt; std::boolalpha;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Lambda 是对象吗？ "</span> &lt;&lt; boolalpha &lt;&lt; is_object&lt;<span class="keyword">decltype</span>(lambda)&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 具有 operator() 函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Lambda(5) = "</span> &lt;&lt; <span class="built_in">lambda</span>(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lambda 是对象吗？ true</span><br><span class="line">Lambda(5) = 10</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固进阶之二</title>
    <link href="https://www.techgrow.cn/posts/2288a106.html"/>
    <id>https://www.techgrow.cn/posts/2288a106.html</id>
    <published>2025-02-19T13:55:33.000Z</published>
    <updated>2025-02-19T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-11-的核心特性"><a href="#C-11-的核心特性" class="headerlink" title="C++ 11 的核心特性"></a>C++ 11 的核心特性</h2><ul><li><p>关键字和语法</p><ul><li><code>auto</code>：可以根据右值推导出右值的类型，然后左边变量的类型就可以知道了。</li><li><code>nullptr</code>：空指针，给指针专用（能够和整数进行区别）。</li><li><code>foreach</code>：通过 <code>for (int num : arr) { }</code> 语法可以遍历数组、容器等。</li><li>右值引用（<code>T &amp;&amp;</code>），还有 <code>move()</code> 移动语义函数和 <code>forward()</code> 完美转发函数。</li><li>模板新特性：<code>type... A</code> 表示可变参数模板。</li></ul></li><li><p>绑定器和函数对象</p><ul><li><code>function</code>：函数类模板，用于存储任何可以调用的目标（如普通函数、函数指针、函数对象、Lambda 表达式等），并通过统一的接口进行调用。</li><li><code>bind</code>：绑定器，用于创建可调用对象，可以将函数与部分参数进行绑定，并返回一个新的可调用对象，方便后续调用。</li><li>Lambda 表达式：用于定义匿名函数对象的简洁语法，拥有强大的变量捕获、类型推导和灵活性，可以使得代码更加简洁、灵活。</li></ul></li><li><p>智能指针</p><ul><li><code>shared_ptr</code>：带引用计数的智能指针，允许多个指针共享同一资源。</li><li><code>weak_ptr</code>：通常用于避免 <code>shared_ptr</code> 智能指针之间的循环引用问题。</li></ul></li><li><p>容器</p><ul><li><code>array</code>：一个固定大小的数组封装，比原生 C 语言数组更安全，支持 STL 的特性，如迭代器、<code>size()</code> 等。</li><li><code>unordered_map</code>：基于哈希表的键值对存储，比 <code>map（基于红黑树）</code> 的查找速度更快，平均时间复杂度是 <code>O(1)</code>。</li><li><code>unordered_set</code>：基于哈希表的集合，插入、查找速度更快。</li><li><code>forward_list</code>：单向链表，比 <code>list（基于双向链表）</code> 更节省内存。</li></ul></li></ul><h2 id="C-11-的右值引用"><a href="#C-11-的右值引用" class="headerlink" title="C++ 11 的右值引用"></a>C++ 11 的右值引用</h2><h3 id="重现模拟实现字符串类的问题"><a href="#重现模拟实现字符串类的问题" class="headerlink" title="重现模拟实现字符串类的问题"></a>重现模拟实现字符串类的问题</h3><p>下述代码模拟实现了 C++ 中的 <code>string</code> 类，但是 <code>main()</code> 函数调用 <code>getString()</code> 函数的效率会非常低。第一个原因是，<code>getString()</code> 函数在调用结束时，返回了一个 MyString 对象，这会调用一次拷贝构造函数来拷贝 <code>tmpStr</code> 对象。第二个原因是，在 <code>main()</code> 函数中，将 <code>getStriing()</code> 函数的返回值赋值了给 <code>str2</code> 对象，这会调用赋值运算符重载函数，也就是又拷贝了一次数据。<a href="../../../asset/2025/02/cxx-custom-string-1.png">点击</a> 查看完整分析图解。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">getString</span><span class="params">(MyString &amp;str)</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tmpStr</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"aaaaaaa"</span>)</span></span>;</span><br><span class="line">    MyString str2;</span><br><span class="line">    str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">    cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str1 对象</span><br><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str2 对象</span><br><span class="line">MyString(const char *p = nullptr)       // getString() 函数中构造 tmpStr 对象</span><br><span class="line">MyString(const MyString &amp;str)           // getString() 函数返回执行结果值时，调用拷贝构造函数来拷贝 tmpStr 对象给 main() 函数栈帧上的临时对象</span><br><span class="line">~MyString()                             // 析构 getString() 函数中的 tmpStr 对象</span><br><span class="line">operator=(const MyString &amp;str)          // main() 函数中，执行赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数栈帧上的临时对象，临时对象的生存周期是所在语句</span><br><span class="line">aaaaaaa             </span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str1 对象</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">operator=(const MyString &amp;str)</span><br><span class="line">~MyString()</span><br><span class="line">aaaaaaa</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="解决模拟实现字符串类的问题"><a href="#解决模拟实现字符串类的问题" class="headerlink" title="解决模拟实现字符串类的问题"></a>解决模拟实现字符串类的问题</h3><p>为了解决上述模拟实现字符串类时，多次拷贝内存数据导致运行效率低的问题，可以使用带右值引用参数的拷贝构造函数和赋值运算符重载函数来解决。</p><h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h4><h5 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h5><ul><li><p>左值引用与右值引用的介绍</p><ul><li><code>左值</code>：有名称、有内存</li><li><code>右值</code>：没名称（临时量）、没内存</li></ul></li><li><p>左值引用与右值引用的区别</p><ul><li>左值引用和右值引用的主要区别在于它们可以绑定的值类别，左值引用只能绑定到左值，而右值引用只能绑定到右值。</li><li>右值引用引入了 <code>move</code> 移动语义，使得 C++ 可以更高效地处理临时对象。</li><li>在泛型编程中，可以通过函数模板的类型推导来同时处理左值引用和右值引用，从而实现参数的 <code>forward</code> 完美转发。</li></ul></li></ul><h5 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ......(省略)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;        <span class="comment">// 左值：有名称、有内存，右值：没名称（临时量）、没内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp; b = a;        <span class="comment">// 可以将左值绑定到左值引用上</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; c = a;    // 无法将左值绑定到右值引用上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; d = <span class="number">20</span>;      <span class="comment">// 可以将右值绑定到右值引用上</span></span><br><span class="line">    <span class="comment">// int&amp; c = 20;    // 无法将右值绑定到左值引用上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int&amp;&amp; f = d;    // 无法将左值绑定到右值引用上，因为右值引用变量本身就是左值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyString&amp; s = MyString("aaa");   // 错误写法</span></span><br><span class="line">    MyString&amp;&amp; s = <span class="built_in">MyString</span>(<span class="string">"aaa"</span>);     <span class="comment">// 正确写法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用右值引用解决问题"><a href="#使用右值引用解决问题" class="headerlink" title="使用右值引用解决问题"></a>使用右值引用解决问题</h4><div class="admonition note"><p class="admonition-title">提示</p><ul><li>(1) 右值引用参数常用于减少内存数据的拷贝，比如在带右值引用参数的拷贝构造函数和赋值运算符重载函数中使用。</li><li>(2) 在带右值引用参数的拷贝构造函数和赋值运算符重载函数中，该右值引用参数接收的都是临时对象。</li></ul></div><h5 id="案例代码-1"><a href="#案例代码-1" class="headerlink" title="案例代码"></a>案例代码</h5><p>这里使用带右值引用参数的拷贝构造函数和赋值运算符重载函数，来解决在模拟实现 C++ 字符串类时，多次拷贝内存数据导致运行效率低的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">getString</span><span class="params">(MyString&amp; str)</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tmpStr</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码一"><a href="#测试代码一" class="headerlink" title="测试代码一"></a>测试代码一</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"aaaaaaa"</span>)</span></span>;</span><br><span class="line">    MyString str2;</span><br><span class="line">    str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">    cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str1 对象</span><br><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str2 对象</span><br><span class="line">MyString(const char *p = nullptr)       // getString() 函数中构造 tmpStr 对象</span><br><span class="line">MyString(MyString&amp;&amp; str)                // getString() 函数返回执行结果值时，调用带右值引用参数的拷贝构造函数来拷贝 tmpStr 对象给 main() 函数栈帧上的临时对象（使用浅拷贝提高运行效率）</span><br><span class="line">~MyString()                             // 析构 getString() 函数中的 tmpStr 对象</span><br><span class="line">operator=(MyString&amp;&amp; str)               // main() 函数中，执行带右值引用参数的赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 str2 对象（使用浅拷贝提高运行效率）</span><br><span class="line">~MyString()                             // 析构 main() 函数栈帧上的临时对象</span><br><span class="line">aaaaaaa             </span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str1 对象</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">================ test01() ================</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">operator=(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">aaaaaaa</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码二"><a href="#测试代码二" class="headerlink" title="测试代码二"></a>测试代码二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"Hello "</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">str2</span><span class="params">(<span class="string">"World!"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    MyString str3 = str1 + str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">---------------------------------</span><br><span class="line">Hello World!</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">Hello World!</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码三"><a href="#测试代码三" class="headerlink" title="测试代码三"></a>测试代码三</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    MyString str1 = <span class="string">"aaa"</span>;</span><br><span class="line">    vector&lt;MyString&gt; v1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(str1); <span class="comment">// 调用的是带左值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是带右值引用参数的拷贝构造函数 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 中，无论是 Debug 模式，还是 Release 模式，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">----------------------------------</span><br><span class="line">MyString(const MyString &amp;str)</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的移动语义与完美转发"><a href="#C-11-的移动语义与完美转发" class="headerlink" title="C++ 11 的移动语义与完美转发"></a>C++ 11 的移动语义与完美转发</h2><h3 id="基础案例代码"><a href="#基础案例代码" class="headerlink" title="基础案例代码"></a>基础案例代码</h3><h4 id="自定义字符串类"><a href="#自定义字符串类" class="headerlink" title="自定义字符串类"></a>自定义字符串类</h4><p>自定义一个 MyString 字符串类，模拟实现　C++ 的 <code>string</code> 字符串类，主要使用带右值引用参数的拷贝构造函数和赋值运算符重载函数来减少内存数据的拷贝次数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义-Vector-容器类"><a href="#自定义-Vector-容器类" class="headerlink" title="自定义 Vector 容器类"></a>自定义 Vector 容器类</h4><p>自定义一个 Vector 容器类，模拟实现　C++ 的 <code>vector</code> 容器，主要实现了 <code>vector</code>　容器的空间分配器、迭代器。值得一提的是，由于篇幅有限，这里虽然解决迭代器失效的问题，但是并没有解决容器扩容（执行插入操作）后导致迭代器失效的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt; *pvec = <span class="literal">nullptr</span>, T *p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base *itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt; *_pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T *p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T *p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator *cur = <span class="literal">nullptr</span>, Iterator_Base *next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator *_cur;</span><br><span class="line">        Iterator_Base *_next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T *start, T *end)</span> </span>{</span><br><span class="line">        Iterator_Base *cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base *next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义-Vector-类存在的问题"><a href="#自定义-Vector-类存在的问题" class="headerlink" title="自定义 Vector 类存在的问题"></a>自定义 Vector 类存在的问题</h4><p>使用上面自定义的 Vecotr 容器类执行以下测试代码后，发现执行 <code>vector.push_back(MyString("bbb"));</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，这会导致多拷贝一份内存数据，从而影响程序的执行效率。值得一提的是，这里希望调用的是 MyString 类带右值引用参数的拷贝构造函数，因为该带右值引用参数的拷贝构造函数使用的是浅拷贝，可以减少内存数据的拷贝次数。至于具体的解决方案，可以使用下面介绍的 C++ 移动语义（<code>move</code>）来实现。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const MyString &amp;str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="move-移动语义"><a href="#move-移动语义" class="headerlink" title="move 移动语义"></a>move 移动语义</h3><h4 id="move-移动语义的概念"><a href="#move-移动语义的概念" class="headerlink" title="move 移动语义的概念"></a>move 移动语义的概念</h4><p>C++ 中的移动语义是引入于 C++ 11 的一种特性，它通过引入移动构造函数和移动赋值运算符，允许程序以更高效的方式管理资源，尤其是在避免不必要的拷贝操作时。移动语义的核心是利用右值引用（<code>T&amp;&amp;</code>）和标准库中的 <code>std::move</code>，使对象的资源从一个对象转移到另一个对象（比如将左值类型强转为右值类型），而不是拷贝，从而提高程序性能。</p><ul><li><p>移动语义的主要作用</p><ul><li>高效资源转移：避免资源分配和释放的重复工作。</li><li>减少拷贝：通过转移所有权来减少对象的拷贝。</li><li>提高程序性能：尤其适用于内存密集型和资源管理复杂的程序。</li></ul></li><li><p>移动语义的使用场景</p><ul><li>减少临时对象的开销（如函数返回大对象）。</li><li>避免深拷贝（如容器中的数据转移）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="https://blog.csdn.net/chenmi123321/article/details/144334601">C++ 的 移动语义 move</a></li><li><a href="https://zhuanlan.zhihu.com/p/602543410">理解现代 C++ 中的移动语义</a></li></ul></div><h4 id="move-移动语义的使用"><a href="#move-移动语义的使用" class="headerlink" title="move 移动语义的使用"></a>move 移动语义的使用</h4><p>在<a href="/posts/e302ad63.html#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E5%AE%B9%E5%99%A8%E7%B1%BB">上面</a>自定义的 Vector 容器类中，为了解决执行 <code>vector.push_back(MyString("bbb"))</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，从而导致多拷贝一份内存数据的问题，可以使用 C++ 中的 <code>move</code> 移动语义来解决。</p><ul><li>更改的核心代码<ul><li>重载 <code>Allocator::construct()</code> 函数，分别用于接收左值引用参数和右值引用参数，并使用 <code>move</code> 移动语义将左值类型强转为右值类型</li><li>重载 <code>Vector::push_back()</code> 函数，分别用于接收左值引用参数和右值引用参数，并使用 <code>move</code> 移动语义将左值类型强转为右值类型 </li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收左值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收右值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, T&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="comment">// move 是移动语义，可以将左值类型强转为右值类型</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(<span class="built_in">move</span>(val));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收左值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收右值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="comment">// move 是移动语义，可以将左值类型强转为右值类型</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, <span class="built_in">move</span>(val));</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt;* pvec = <span class="literal">nullptr</span>, T* p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base* itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* _ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt;* _pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T* p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T* p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T* _last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* cur = <span class="literal">nullptr</span>, Iterator_Base* next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T* _ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* start, T* end)</span> </span>{</span><br><span class="line">        Iterator_Base* cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base* next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="forward-完美转发"><a href="#forward-完美转发" class="headerlink" title="forward 完美转发"></a>forward 完美转发</h3><p>虽然使用 C++ 11 提供的 <code>move</code> 移动语义，可以解决在执行 <code>vector.push_back(MyString("bbb"));</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，从而导致多拷贝一份内存数据的问题。但是，这样每次都需要定义两个重载函数来分别接收左值引用参数和右值引用参数，这就显得比较繁琐。为了使 C++ 代码更简洁，可以使用 C++ 11 提供的 <code>forward</code> 完美转发来实现同样的功能。</p><h4 id="forward-完美转发的概念"><a href="#forward-完美转发的概念" class="headerlink" title="forward 完美转发的概念"></a>forward 完美转发的概念</h4><p>完美转发（Perfect Forwarding）是 C++ 11 中引入的一种编程技巧，其目的是在编写泛型函数时能够保留参数的类型和值类别（左值或右值），从而实现更为高效且准确地传递参数。通过使用右值引用和模板类型推导，完美转发允许在函数中以原始参数的形式将参数传递给其他函数，而不会发生不必要的拷贝操作，从而提高性能。完美转发在很多场合都非常有用，尤其是在设计泛型库和需要高效参数传递的场景。以下是一些常见的完美转发应用场景：</p><ul><li>(1) 委托构造函数：完美转发可以在构造函数之间传递参数，避免不必要的拷贝操作，从而提高性能。</li><li>(2) 可变参数模板函数：完美转发可以用于实现可接受任意数量和类型参数的函数，如实现一个通用的元组或 <code>bind()</code> 函数。</li><li>(3) 智能指针：完美转发在智能指针的实现中也有重要作用，例如 <code>unique_ptr</code> 和 <code>shared_ptr</code> 中的构造函数和 <code>make()</code> 函数等。</li><li>(4) 函数包装器：完美转发可以用于实现函数包装器，使包装后的函数能够正确处理所有类型的参数，包括右值引用。例如 <code>function</code> 的实现。</li><li>(5) 资源管理类：通过完美转发，可以使资源管理类（如锁管理类、线程池等）能够更方便地处理各种资源。</li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="https://blog.csdn.net/haokan123456789/article/details/134980411">C++ 之 forward 完美转发</a></li><li><a href="https://www.cnblogs.com/5iedu/p/11324772.html">C++ 的 forward 完美转发</a></li><li><a href="https://zhuanlan.zhihu.com/p/710953400">深度解析 C++ 完美转发的实现原理与应用</a></li></ul></div><h4 id="forward-完美转发的使用"><a href="#forward-完美转发的使用" class="headerlink" title="forward 完美转发的使用"></a>forward 完美转发的使用</h4><ul><li>在<a href="/posts/e302ad63.html#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E5%AE%B9%E5%99%A8%E7%B1%BB">上面</a>自定义的 Vector 容器类中，更改以下地方：<ul><li>更改 <code>Allocator::construct()</code> 函数，接收右值引用参数，并使用函数模板的类型推导 + 引用折叠 + <code>forward</code> 完美转发来识别左值类型和右值类型。</li><li>重载 <code>Vector::push_back()</code> 函数，接收右值引用参数，并使用函数模板的类型推导 + 引用折叠 + <code>forward</code> 完美转发来识别左值类型和右值类型。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收右值引用参数）</span></span><br><span class="line">    <span class="comment">// 基于函数模板的类型推导 + 引用折叠</span></span><br><span class="line">    <span class="comment">// T &amp; + Ty &amp;&amp;  = T &amp;</span></span><br><span class="line">    <span class="comment">// T &amp;&amp; + Ty &amp;&amp;  = T &amp;&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, Ty&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="comment">// forward 是完美转发，可以识别左值类型和右值类型</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(forward&lt;Ty&gt;(val));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收右值引用参数）</span></span><br><span class="line">    <span class="comment">// 基于函数模板的类型推导 + 引用折叠</span></span><br><span class="line">    <span class="comment">// T &amp; + Ty &amp;&amp;  = T &amp;</span></span><br><span class="line">    <span class="comment">// T &amp;&amp; + Ty &amp;&amp;  = T &amp;&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="comment">// forward 是完美转发，可以识别左值类型和右值类型</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, forward&lt;Ty&gt;(val));</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt;* pvec = <span class="literal">nullptr</span>, T* p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base* itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* _ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt;* _pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T* p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T* p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T* _last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* cur = <span class="literal">nullptr</span>, Iterator_Base* next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T* _ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* start, T* end)</span> </span>{</span><br><span class="line">        Iterator_Base* cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base* next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固进阶之四</title>
    <link href="https://www.techgrow.cn/posts/6e5acd18.html"/>
    <id>https://www.techgrow.cn/posts/6e5acd18.html</id>
    <published>2025-02-18T13:55:33.000Z</published>
    <updated>2025-02-18T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-的智能指针"><a href="#C-的智能指针" class="headerlink" title="C++ 的智能指针"></a>C++ 的智能指针</h2><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="/posts/dbff2af9.html#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">C++ 智能指针使用教程</a></li></ul></div><h3 id="智能指针的几种常见类型"><a href="#智能指针的几种常见类型" class="headerlink" title="智能指针的几种常见类型"></a>智能指针的几种常见类型</h3><p>在 C++ 中，智能指针的类型有以下几种：</p><ul><li>(1) 带引用计数的智能指针：<code>shared_ptr</code></li><li>(2) 不带引用计数的智能指针：<code>auto_ptr</code>、<code>scoped_ptr</code>、<code>unique_ptr</code></li><li>(3) 特殊的智能指针：<code>weak_ptr</code>（不增加引用计数，可以用于避免 <code>shared_ptr</code> 发生循环引用）</li></ul><table><thead><tr><th>智能指针</th><th>所有权</th><th>带引用计数</th><th>适用场景</th><th>核心特性</th></tr></thead><tbody><tr><td><code>auto_ptr</code></td><td>独占（拷贝时转移）</td><td>否</td><td>⚠ 已废弃，建议改用 <code>unique_ptr</code></td><td>独占所有权，在复制或赋值时会转移所有权，导致原指针变为空（<code>nullptr</code>）</td></tr><tr><td><code>scoped_ptr</code></td><td>独占</td><td>否</td><td>生命周期受限于作用域，适用于简单的场景，避免资源泄漏</td><td>独占所有权，不可复制或赋值，不支持移动语义，即不可以使用 <code>std::move()</code> 函数转移所有权</td></tr><tr><td><code>unique_ptr</code></td><td>独占</td><td>否</td><td>资源独占，生命周期明确</td><td>独占所有权，不可复制（拷贝构造和赋值），但可以移动（移动构造和移动赋值），即支持使用 <code>std::move()</code> 函数转移所有权</td></tr><tr><td><code>shared_ptr</code></td><td>共享</td><td>是</td><td>资源共享，生命周期不固定</td><td>共享所有权（允许多个智能指针管理同一个资源）</td></tr><tr><td><code>weak_ptr</code></td><td>观察 <code>shared_ptr</code></td><td>否</td><td>避免 <code>shared_ptr</code> 发生循环引用</td><td>不增加引用计数，用于避免 <code>shared_ptr</code> 发生循环引用，可以通过 <code>lock()</code> 函数转换为 <code>shared_ptr</code></td></tr></tbody></table><h3 id="不带引用计数的智能指针"><a href="#不带引用计数的智能指针" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h3><h4 id="auto-ptr-智能指针"><a href="#auto-ptr-智能指针" class="headerlink" title="auto_ptr 智能指针"></a>auto_ptr 智能指针</h4><h5 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h5><p><code>auto_ptr</code> 是 C++ 98 引入的智能指针，具有独占所有权，在复制或赋值时会转移所有权，导致原指针变为空（<code>nullptr</code>）。它可以自动释放资源，但由于容易导致空指针问题，在 C++ 11 被弃用，推荐使用 <code>unique_ptr</code> 或 <code>shared_ptr</code> 代替。<code>auto_ptr</code> 的核心特性如下：</p><ul><li><p>独占所有权（所有权转移）：  </p><ul><li>不能有多个 <code>auto_ptr</code> 共享同一资源。</li><li>复制或赋值时，所有权会从原指针转移到新指针，原指针会变为空（<code>nullptr</code>）。</li></ul></li><li><p>自动释放资源：  </p><ul><li>在 <code>auto_ptr</code> 离开作用域时，会自动调用 <code>delete</code> 释放资源，防止内存泄漏。</li></ul></li><li><p>已被 C++ 11 弃用：  </p><ul><li>由于所有权转移容易导致空指针问题，<code>auto_ptr</code> 在 C++ 11 中已经被 <code>unique_ptr</code> 或者 <code>shared_ptr</code> 取代。</li></ul></li></ul><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>))</span></span>;   <span class="comment">// ptr1 拥有这个动态分配的 int(20)</span></span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;          <span class="comment">// 可复制，ptr1 的所有权被 ptr2 接管，ptr1 变为空</span></span><br><span class="line">    *ptr2 = <span class="number">10</span>;                        <span class="comment">// 通过 ptr2 修改资源的值</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;          // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;             <span class="comment">// 正常输出 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>))</span></span>;   <span class="comment">// ptr1 拥有这个动态分配的 int(20)</span></span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;   <span class="comment">// 可赋值，ptr2 拥有这个动态分配的 int(30)</span></span><br><span class="line">    ptr2 = ptr1;                       <span class="comment">// ptr1 的所有权被 ptr2 接管，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;          // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;             <span class="comment">// 正常输出 20</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="scoped-ptr-智能指针"><a href="#scoped-ptr-智能指针" class="headerlink" title="scoped_ptr 智能指针"></a>scoped_ptr 智能指针</h4><h5 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h5><p><code>scoped_ptr</code> 是 Boost 库提供的一种简单智能指针，独占所有权，不可复制或赋值，不支持移动语义，即不可以使用 <code>std::move()</code> 函数转移所有权，在离开作用域时自动释放资源。类似于 <code>unique_ptr</code>，但不支持移动语义，适用于 RAII（资源管理即初始化） 场景。在 C++ 11 之后，推荐使用 <code>unique_ptr</code> 代替。<code>scoped_ptr</code> 的核心特性如下：</p><ul><li><p>独占所有权：</p><ul><li>只能有一个 <code>scoped_ptr</code> 拥有资源，不可复制或赋值。</li></ul></li><li><p>自动释放资源：  </p><ul><li>离开作用域时自动调用 <code>delete</code> 释放资源，防止内存泄漏。</li></ul></li><li><p>不支持移动语义：  </p><ul><li>不能使用 <code>std::move()</code> 函数转移所有权（但相比 <code>unique_ptr</code>，功能更简单）。</li></ul></li><li><p>适用于 RAII（资源管理即初始化）：  </p><ul><li>适合管理动态分配的对象，确保作用域结束时资源被释放。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>阅读 <code>scoped_ptr</code> 的底层源码，可以发现它的拷贝构造函数和赋值运算符重载函数都被 <code>delete</code> 掉，所以它才不支持复制或赋值（转移）。</p></div><h5 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// boost::scoped_ptr&lt;int&gt; ptr2(ptr1);       // 编译出错，不可复制</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = ptr1;     // 编译出错，不可赋值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// boost::scoped_ptr&lt;int&gt; ptr2(move(ptr1));       // 编译出错，不支持移动构造</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = move(ptr1);      // 编译出错，不支持移动赋值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="unique-ptr-智能指针"><a href="#unique-ptr-智能指针" class="headerlink" title="unique_ptr 智能指针"></a>unique_ptr 智能指针</h4><h5 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h5><p><code>unique_ptr</code> 是 C++ 11 引入的智能指针，独占所有权，不可复制（拷贝构造和赋值），但可以移动（移动构造和移动赋值），即支持使用 <code>std::move()</code> 函数转移所有权。它在离开作用域时自动释放资源，适用于 RAII（资源管理即初始化），是 <code>auto_ptr</code> 和 <code>scoped_ptr</code> 的现代替代方案。<code>unique_ptr</code> 的核心特性如下：</p><ul><li><p>独占所有权：  </p><ul><li>只能有一个 <code>unique_ptr</code> 拥有同一资源，不可复制。</li></ul></li><li><p>支持移动语义：  </p><ul><li>可通过 <code>std::move()</code> 函数转移所有权。</li></ul></li><li><p>自动释放资源：</p><ul><li>离开作用域时自动调用 <code>delete</code> 释放资源，防止内存泄漏。</li></ul></li><li><p>支持自定义删除器：  </p><ul><li>可指定自定义删除器，如 <code>std::default_delete</code> 或 Lambda。</li></ul></li><li><p>轻量且性能优越：  </p><ul><li>不会有额外的引用计数（相比 <code>shared_ptr</code> 而言），适用于 RAII 管理单一对象。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>阅读 <code>unique_ptr</code> 的底层源码，可以发现它使用了带右值引用参数的拷贝构造函数和赋值运算符重载函数，所以它才可以通过 <code>std::move()</code> 函数转移所有权。</li></ul></div><h5 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;int&gt; ptr2(ptr1);         // 编译出错，不可复制</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = ptr1;                         // 编译出错，不可赋值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(move(ptr1))</span></span>;      <span class="comment">// 支持移动构造，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    ptr2 = <span class="built_in">move</span>(ptr1);                     <span class="comment">// 支持移动赋值，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="带引用计数的智能指针"><a href="#带引用计数的智能指针" class="headerlink" title="带引用计数的智能指针"></a>带引用计数的智能指针</h3><p>C++ 11 带引用计数的智能指针允许多个指针共享同一个资源。当最后一个指向资源的智能指针被销毁时，资源才会被释放。它通过引用计数来跟踪有多少个智能指针指向同一资源，确保资源在不再使用时自动释放，避免内存泄漏。</p><ul><li>C++ 11 带引用计数的智能指针有两种，分别是：<ul><li><code>shared_ptr</code>：强引用智能指针，可以改变资源的引用计数</li><li><code>weak_ptr</code>：弱引用智能指针，不会改变资源的引用计数，主要用于避免 <code>shared_ptr</code> 智能指针的循环引用</li></ul></li></ul><h4 id="shared-ptr-智能指针"><a href="#shared-ptr-智能指针" class="headerlink" title="shared_ptr 智能指针"></a>shared_ptr 智能指针</h4><h5 id="概念介绍-3"><a href="#概念介绍-3" class="headerlink" title="概念介绍"></a>概念介绍</h5><p><code>shared_ptr</code> 是 C++ 11 引入的智能指针，允许多个指针共享同一资源。它通过引用计数来跟踪有多少个指针指向同一对象，当最后一个指向该资源的 <code>shared_ptr</code> 被销毁时，资源会自动释放。适用于需要多个所有者共享同一资源的场景，即需要多个智能指针管理同一个资源。<code>shared_ptr</code> 的核心特性如下：</p><ul><li>共享所有权<ul><li>多个 <code>shared_ptr</code> 可以同时指向同一对象，共享资源的所有权。</li></ul></li><li>引用计数<ul><li>每个 <code>shared_ptr</code> 内部维护一个引用计数，表示当前有多少个指针引用该资源。</li></ul></li><li>自动管理内存<ul><li>当引用计数归零时，资源被自动释放。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>shared_ptr</code> 的引用计数是和对象是分开存储在堆上的。引用计数并不是存在被管理对象中，而是存储在由 <code>shared_ptr</code> 内部管理的一个独立控制块（Control Block）中（<a href="../../../asset/2025/04/cxx-interview-1.jpeg">如图所示</a>）。</li><li>这种设计可以支持多个指针共享对象的同时，又能独立于对象本体跟踪引用和生命周期。</li></ul></div><h5 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h5><ul><li><code>shared_ptr</code> 的引用计数是和对象默认是分开存储在堆上的。引用计数并不是存在被管理对象中，而是存储在由 <code>shared_ptr</code> 内部管理的一个独立控制块（Control Block）中。</li><li>这种设计可以支持多个指针共享对象的同时，又能独立于对象本体跟踪引用和生命周期，如下图所示：</li></ul><p><img data-src="../../../asset/2025/04/cxx-make-shared.png"></p><p>在创建 <code>shared_ptr</code> 智能指针时，建议使用 <code>make_shared()</code> 函数来创建，而不是直接 <code>new</code>，其原因如下：</p><ul><li><p>使用 <code>make_shared()</code> 函数</p><ul><li>写法：<code>shared_ptr&lt;Person&gt; sp1 = make_shared&lt;Person&gt;();</code></li><li>只进行一次内存分配（对象和控制块在同一块内存中），可以减少开销。</li><li>资源的内存分配和 <code>shared_ptr</code> 创建是原子操作，可以避免内存泄漏和异常安全问题。</li></ul></li><li><p>使用 <code>new</code> 关键字</p><ul><li>写法：<code>shared_ptr&lt;Person&gt; sp1(new Person());</code></li><li>需要进行两次内存分配（一次是给对象，另一次是给 <code>shared_ptr</code> 的控制块），性能稍低。</li><li><code>new</code> 和 <code>shared_ptr</code> 绑定是分离的，如果 <code>shared_ptr</code> 还没成功创建，但 <code>new</code> 已经分配内存，这可能会导致内存泄漏。</li></ul></li></ul><h5 id="使用案例-3"><a href="#使用案例-3" class="headerlink" title="使用案例"></a>使用案例</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Using Person"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr sp1，并管理 Person 对象</span></span><br><span class="line">    shared_ptr&lt;Person&gt; sp1 = make_shared&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不建议这样写</span></span><br><span class="line">    <span class="comment">// shared_ptr&lt;Person&gt; sp1(new Person());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印引用计数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Reference count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建一个 shared_ptr sp2，共享 sp1 的资源</span></span><br><span class="line">        shared_ptr&lt;Person&gt; sp2 = sp1;</span><br><span class="line">        <span class="comment">// 打印引用计数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"Reference count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 访问资源</span></span><br><span class="line">        sp2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    } <span class="comment">// 作用域结束后，sp2 自动析构，引用计数减少</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印引用计数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Reference count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person()</span><br><span class="line">Reference count: 1</span><br><span class="line">Reference count: 2</span><br><span class="line">Using Person</span><br><span class="line">Reference count: 1</span><br><span class="line">~Person()</span><br></pre></td></tr></tbody></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>在 C++ 中使用 <code>shared_ptr</code> 时，推荐使用 <code>make_shared()</code> 直接代替使用 <code>new</code> 操作符，主要原因如下：</p><ul><li><p><strong>异常安全</strong></p><ul><li>当使用 <code>new</code> 创建对象并传递给 <code>shared_ptr</code> 构造函数时，若函数参数的求值顺序不确定，可能导致内存泄漏。例如：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(shared_ptr&lt;T&gt;(<span class="keyword">new</span> T), <span class="built_in">some_function</span>());</span><br></pre></td></tr></tbody></table></figure></li><li>在上述代码中，若 <code>new T</code> 先执行，接着 <code>some_function()</code> 抛出异常，此时 <code>new T</code> 分配的内存尚未被 <code>shared_ptr</code> 接管，会导致内存泄漏。而 <code>make_shared()</code> 会将对象的构造与控制块的内存分配合并为原子操作，避免了这一问题。</li></ul></li><li><p><strong>性能优化</strong></p><ul><li><code>make_shared()</code> 会一次性分配内存，同时存储对象和控制块（包含引用计数、弱引用计数等）。而通过 <code>new</code> 构造 <code>shared_ptr</code> 时，需要进行两次内存分配（对象和控制块各一次），增加了额外开销。</li><li><code>make_shared()</code> 可以减少内存分配次数，提升了性能，尤其在频繁创建 <code>shared_ptr</code> 时效果显著。</li></ul></li><li><p><strong>内存碎片</strong></p><ul><li>对象和控制块连续存储在同一内存块中，提高了缓存局部性，可能减少内存碎片，尤其对小对象更有利。</li></ul></li><li><p><strong>代码简洁</strong></p><ul><li><code>make_shared()</code> 语法更简洁，无需显式使用 <code>new</code>，避免了手动管理裸指针的风险。例如：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = make_shared&lt;T&gt;();       <span class="comment">// 清晰且安全</span></span><br><span class="line"><span class="keyword">auto</span> ptr = shared_ptr&lt;T&gt;(<span class="keyword">new</span> T);   <span class="comment">// 需要显式处理new</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>尽管 <code>make_shared()</code> 的优势非常明显，但在以下场景仍需直接使用 <code>new</code>：</li><li><strong>(1) 自定义删除器</strong>：<code>make_shared()</code> 不支持指定自定义删除器。</li><li><strong>(2) 对象和控制块的内存分离存储</strong>：若希望对象内存（而非控制块）在引用计数归零时立即释放（而不需要等待所有 <code>weak_ptr</code> 释放），需使用 <code>new</code> 并手动构造 <code>shared_ptr</code>。</li></ul></div><h3 id="较为特殊的智能指针"><a href="#较为特殊的智能指针" class="headerlink" title="较为特殊的智能指针"></a>较为特殊的智能指针</h3><h4 id="weak-ptr-智能指针"><a href="#weak-ptr-智能指针" class="headerlink" title="weak_ptr 智能指针"></a>weak_ptr 智能指针</h4><h5 id="weak-ptr-的概念介绍"><a href="#weak-ptr-的概念介绍" class="headerlink" title="weak_ptr 的概念介绍"></a>weak_ptr 的概念介绍</h5><p><code>weak_ptr</code> 是 C++ 11 的智能指针之一，主要用于避免 <code>shared_ptr</code> 智能指针之间的循环引用问题。它是 <code>shared_ptr</code> 智能指针的弱引用，不会增加引用计数，不能直接访问资源，但可以通过 <code>lock()</code> 函数将其转换为 <code>shared_ptr</code> 智能指针来访问资源。当资源已被释放时，<code>lock()</code> 函数会返回空指针，可用于判断对象是否仍然存在。<code>weak_ptr</code> 的核心特性如下：</p><ul><li>不增加引用计数<ul><li>只持有 <code>shared_ptr</code> 智能指针的弱引用，不影响对象生命周期。  </li></ul></li><li>防止循环引用<ul><li>可以解决 <code>shared_ptr</code> 智能指针循环引用导致的内存泄漏问题。</li></ul></li><li>检查资源状态<ul><li>可以通过 <code>expired()</code> 函数判断资源是否仍然存在。</li></ul></li><li>访问资源<ul><li>可以通过 <code>lock()</code> 函数转换为 <code>shared_ptr</code> 智能指针，若资源已释放，则返回空指针。</li></ul></li><li>可重置与交换<ul><li>支持使用 <code>reset()</code> 函数释放关联，还支持使用 <code>swap()</code> 函数交换指针内容。</li></ul></li></ul><h5 id="模拟-shared-ptr-循环引用问题"><a href="#模拟-shared-ptr-循环引用问题" class="headerlink" title="模拟 shared_ptr 循环引用问题"></a>模拟 shared_ptr 循环引用问题</h5><p>本节将演示在使用 <code>shared_ptr</code> 智能指针时，怎样才会发生循环引用的问题。在下述代码中，会发生智能指针循环引用的问题，最终导致堆上的对象 A 和 对象 B 无法正常析构（释放内存资源），最终导致内存泄漏，详细的分析图解请看 <a href="../../../asset/2025/02/cxx_shared_pointer_1.png">这里</a>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟 shared_ptr 智能指针发生循环引用的问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;B&gt; _ptrB;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;A&gt; _ptrA;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">ptrA</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">ptrB</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会造成智能指针的循环引用，导致程序结束运行后资源无法正常被析构（释放内存空间）</span></span><br><span class="line">    ptrA-&gt;_ptrB = ptrB;</span><br><span class="line">    ptrB-&gt;_ptrA = ptrA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印智能指针的引用计数</span></span><br><span class="line">    cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ptrB.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h5 id="解决-shared-ptr-循环引用问题"><a href="#解决-shared-ptr-循环引用问题" class="headerlink" title="解决 shared_ptr 循环引用问题"></a>解决 shared_ptr 循环引用问题</h5><p>为了解决 <code>shared_ptr</code> 智能指针使用不当导致的循环引用问题，可以在定义对象的时候，使用强引用智能指针（<code>shared_ptr</code>）；而在引用对象的时候，使用弱引用智能指针（<code>weak_ptr</code>）。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解決 shared_ptr 智能指针的循环引用问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 B 的存在，但未定义 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">A</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用对象时，使用弱引用智能指针 (weak_ptr)</span></span><br><span class="line">weak_ptr&lt;B&gt; _ptrB;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">B</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用对象时，使用弱引用智能指针 (weak_ptr)</span></span><br><span class="line">weak_ptr&lt;A&gt; _ptrA;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 定义对象时，使用强引用智能指针 (shared_ptr)</span></span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">ptrA</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;B&gt; <span class="title">ptrB</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不会造成智能指针循环引用的问题</span></span><br><span class="line">ptrA-&gt;_ptrB = ptrB;</span><br><span class="line">ptrB-&gt;_ptrA = ptrA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印智能指针的引用计数</span></span><br><span class="line">cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ptrB.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></tbody></table></figure><h5 id="weak-ptr-访问对象资源"><a href="#weak-ptr-访问对象资源" class="headerlink" title="weak_ptr 访问对象资源"></a>weak_ptr 访问对象资源</h5><p><code>weak_ptr</code> 智能指针是 <code>shared_ptr</code> 智能指针的弱引用，不会增加引用计数，不能直接访问资源，但可以通过 <code>lock()</code> 函数转换为 <code>shared_ptr</code> 智能指针来访问资源。当资源已被释放时，<code>lock()</code> 函数会返回空指针，可用于判断对象是否仍然存在。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weak_ptr 通过 lock() 函数访问对象资源</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 B 的存在，但未定义 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 func 方法的存在，但未定义 func 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用对象时，使用弱引用智能指针</span></span><br><span class="line">    weak_ptr&lt;B&gt; _ptrB;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 func 方法的存在，但未定义 func 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用对象时，使用弱引用智能指针</span></span><br><span class="line">    weak_ptr&lt;A&gt; _ptrA;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::func</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"A::func()"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 必须将弱引用智能指针转换为强引用智能指针，这样才能访问被管理对象的资源</span></span><br><span class="line">    shared_ptr&lt;B&gt; ptrB = _ptrB.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (ptrB != <span class="literal">nullptr</span>) {</span><br><span class="line">        ptrB-&gt;<span class="built_in">func</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::func</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"B::func()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义对象时，使用强引用智能指针</span></span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">ptrA</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">ptrB</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里不会造成智能指针循环引用的问题</span></span><br><span class="line">    ptrA-&gt;_ptrB = ptrB;</span><br><span class="line">    ptrA-&gt;<span class="built_in">func</span>();</span><br><span class="line">    ptrB-&gt;_ptrA = ptrA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印智能指针的引用计数</span></span><br><span class="line">    cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ptrB.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">A::func()</span><br><span class="line">B::func()</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></tbody></table></figure><h3 id="自定义智能指针的删除器"><a href="#自定义智能指针的删除器" class="headerlink" title="自定义智能指针的删除器"></a>自定义智能指针的删除器</h3><h4 id="删除器的概念介绍"><a href="#删除器的概念介绍" class="headerlink" title="删除器的概念介绍"></a>删除器的概念介绍</h4><p>C++ 智能指针的删除器（Deleter）是一个可自定义的回调函数，用于在智能指针释放资源时自动执行自定义的删除操作。</p><ul><li><code>unique_ptr</code> 智能指针的删除器可以是函数指针或仿函数（函数对象），允许自定义释放方式，例如调用 <code>delete[]</code> 代替 <code>delete</code>。  </li><li><code>shared_ptr</code> 智能指针的删除器可以确保所有引用计数归零后执行自定义删除操作。  </li></ul><h4 id="删除器的使用场景"><a href="#删除器的使用场景" class="headerlink" title="删除器的使用场景"></a>删除器的使用场景</h4><p>在以下使用情况下，C++ 需要自定义智能指针的删除器。</p><ul><li>(1) 使用非 <code>new</code> 分配的资源。当对象的创建方式不是 <code>new</code>，不能用默认 <code>delete</code> 释放时，需要自定义删除器。例如，使用 <code>malloc()</code> 分配的内存必须用 <code>free()</code> 释放。  </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>, <span class="title">decltype</span><span class="params">(&amp;free)</span>&gt; <span class="title">ptr</span><span class="params">((<span class="keyword">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)), free)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 管理文件、网络、数据库等系统资源。智能指针默认用 <code>delete</code> 释放资源，但某些系统资源（如文件、数据库连接、网络套接字）需要调用特定 API 释放资源。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(&amp;fclose)</span>&gt; <span class="title">file</span><span class="params">(fopen(<span class="string">"data.txt"</span>, <span class="string">"w"</span>), fclose)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 数组（<code>new[]</code>）资源的正确释放。默认的 <code>unique_ptr</code> 只调用 <code>delete</code>，而不是 <code>delete[]</code>，所以管理动态数组时，需要自定义删除器。  </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>[], <span class="title">void</span><span class="params">(*)</span><span class="params">(<span class="keyword">int</span>*)</span>&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span>* p) { <span class="keyword">delete</span>[] p; })</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>; <span class="comment">// C++ 11 允许直接用 unique_ptr&lt;int[]&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 需要额外的清理操作。对象释放时，需要额外的清理步骤，比如日志记录、计数等。  </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customDeleter</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Deleting pointer: "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>, <span class="title">decltype</span><span class="params">(&amp;customDeleter)</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>), customDeleter)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(5) 使用 <code>shared_ptr</code> 时需要优化删除器大小。<code>shared_ptr</code> 允许自定义删除器，但它需要存储删除器对象，因此通常使用函数对象（仿函数）或 Lambda 来优化删除器大小。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDeleter</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>* p)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Deleting shared ptr: "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>), CustomDeleter())</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> deleter = [](<span class="keyword">int</span>* p) { <span class="keyword">delete</span> p; };</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>), deleter)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除器的使用案例"><a href="#删除器的使用案例" class="headerlink" title="删除器的使用案例"></a>删除器的使用案例</h4><h5 id="删除器的案例代码一"><a href="#删除器的案例代码一" class="headerlink" title="删除器的案例代码一"></a>删除器的案例代码一</h5><p>通过模板类单独定义了两个函数对象（仿函数），来实现 <code>unique_ptr</code> 智能指针的删除器。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数组的删除器（函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayDeleter</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * arrayPtr)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"Deleting array pointer"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (arrayPtr != <span class="literal">nullptr</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] arrayPtr;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义文件的删除器（函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileDeleter</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* filePtr)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"Deleting file pointer"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (filePtr != <span class="literal">nullptr</span>) {</span><br><span class="line"><span class="built_in">fclose</span>(filePtr);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 创建一个智能指针管理整型数组，并指定删除器</span></span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>, ArrayDeleter&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个智能指针管理文件，并指定删除器</span></span><br><span class="line">unique_ptr&lt;FILE, FileDeleter&lt;FILE&gt;&gt; <span class="built_in">ptr2</span>(<span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deleting file pointer</span><br><span class="line">Deleting array pointer</span><br></pre></td></tr></tbody></table></figure><h5 id="删除器的案例代码二"><a href="#删除器的案例代码二" class="headerlink" title="删除器的案例代码二"></a>删除器的案例代码二</h5><p>在上述的案例代码一中，通过模板类单独定义了两个函数对象（仿函数）来实现智能指针的删除器，这略显得冗余，因为删除器在定义之后只使用了一次。为了使代码更简洁，可以使用 Lambda 表达式来定义智能指针的删除器。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 创建一个智能指针管理整型数组，并通过Lambda表达指定删除器</span></span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>, function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>*)&gt;&gt; <span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>], [](<span class="keyword">int</span>* p) {</span><br><span class="line">cout &lt;&lt; <span class="string">"Deleting array pointer by lambda"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个智能指针管理文件，并通过Lambda表达指定删除器</span></span><br><span class="line">unique_ptr&lt;FILE, function&lt;<span class="built_in"><span class="keyword">void</span></span>(FILE*)&gt;&gt; <span class="built_in">ptr2</span>(<span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>), [](FILE* p) {</span><br><span class="line">cout &lt;&lt; <span class="string">"Deleting file pointer by lambda"</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">fclose</span>(p);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deleting file pointer by lambda</span><br><span class="line">Deleting array pointer by lambda</span><br></pre></td></tr></tbody></table></figure><h5 id="删除器的案例代码三"><a href="#删除器的案例代码三" class="headerlink" title="删除器的案例代码三"></a>删除器的案例代码三</h5><p>除了上面介绍的删除器定义方式之外，还可以使用函数指针作为 <code>unique_ptr</code> 智能指针的删除器。通过 <code>std::decltype()</code> 来获取 <code>arrayDeleter()</code> 函数的类型，并将其作为 <code>unique_ptr</code> 智能指针的删除器类型。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayDeleter</span><span class="params">(<span class="keyword">int</span>* ptr)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Deleting array pointer: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个智能指针管理文件，并通过函数指针指定删除器</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>, <span class="title">decltype</span><span class="params">(&amp;arrayDeleter)</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], arrayDeleter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效写法之一</span></span><br><span class="line">    <span class="comment">// using DeleterType = void(*)(int*);  // 明确指定删除器类型</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int, DeleterType&gt; ptr(new int[100], arrayDeleter);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效写法之二</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int(10), arrayDeleter);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deleting array pointer: 000001B05684F800</span><br></pre></td></tr></tbody></table></figure><h3 id="多线程访问共享对象的问题"><a href="#多线程访问共享对象的问题" class="headerlink" title="多线程访问共享对象的问题"></a>多线程访问共享对象的问题</h3><p>在多个线程同时访问同一个对象（共享对象）时，往往会产生线程安全问题，下面将介绍如何使用 C++ 11 的 <code>shared_ptr</code> 与 <code>weak_ptr</code> 智能指针来解决线程安全问题。</p><h4 id="thread-detach-介绍"><a href="#thread-detach-介绍" class="headerlink" title="thread::detach() 介绍"></a>thread::detach () 介绍</h4><p>这里先简单介绍一下 <code>thread::detach()</code> 函数，有助于理解后面给出的多线程案例代码。</p><ul><li><p><code>thread::detach()</code> 函数的作用</p><ul><li><code>detach()</code> 提供了一种非阻塞方式来运行线程</li><li>线程一旦 <code>detach()</code>，就会变成守护线程（Daemon Thread），独立于 <code>thread</code> 对象运行。</li><li><code>thread</code> 对象与底层线程资源分离，<code>thread</code> 对象销毁时不会影响已分离的线程。</li><li>适用于不需要等待线程结束的场景，例如后台任务或日志记录等。</li></ul></li><li><p><code>thread::detach()</code> 函数的注意事项</p><ul><li><code>不要访问已销毁的资源</code>：调用 <code>detach()</code> 后，线程对象的生命周期由操作系统管理，后续不能再通过 <code>thread</code> 访问它，否则会导致未定义行为。</li><li><code>避免主线程提前退出</code>：<code>main()</code> 退出时，所有仍在运行的分离线程会被终止，这可能导致任务未完成或资源泄漏。</li><li><code>不能 detach() 两次</code>：如果 <code>thread</code> 已经 <code>detach()</code>，再次调用 <code>detach()</code> 会导致错误。</li></ul></li><li><p><code>thread::detach()</code> 与 <code>thread::join()</code> 的区别</p><ul><li><code>join()</code>：阻塞主线程，直到子线程执行完毕，适用于必须等待子线程完成的任务（如并行计算）。</li><li><code>detach()</code>：让子线程独立运行，主线程不会等待它执行完毕，适用于不关心子线程何时完成的任务（如日志记录、异步 I/O 任务）。</li></ul></li></ul><h4 id="线程安全问题的产生"><a href="#线程安全问题的产生" class="headerlink" title="线程安全问题的产生"></a>线程安全问题的产生</h4><p>下述这段 C++ 代码会产生线程安全问题，因为主线程和子线程同时访问共享对象 Task，但是主线程在子线程访问共享对象 Task 之前，将共享对象析构掉，这会导致子线程在后续访问共享对象时产生不可预知的行为。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全问题的产生</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"invoke Task::run()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executTask</span><span class="params">(Task *task)</span> </span>{</span><br><span class="line">    <span class="comment">// 子线程等待 5 秒</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="comment">// 执行任务方法</span></span><br><span class="line">    task-&gt;<span class="built_in">run</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Task *task = <span class="keyword">new</span> <span class="built_in">Task</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(executTask, task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将子线程与 thread 对象分离，使其在后台独立运行，直到子线程执行完毕</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程在子线程调用 Task::run() 函数之前析构 Task 对象（共享对象），这样就会产生线程安全问题</span></span><br><span class="line">    <span class="keyword">delete</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待子线程执行完成</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="线程安全问题的解决"><a href="#线程安全问题的解决" class="headerlink" title="线程安全问题的解决"></a>线程安全问题的解决</h4><p>这里利用 <code>weak_ptr</code> 智能指针可以观察 <code>shared_ptr</code> 智能指针状态的特性，来解决多线程访问共享对象的线程安全问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全问题的解决</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"invoke Task::run()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executTask</span><span class="params">(weak_ptr&lt;Task&gt; wp)</span> </span>{</span><br><span class="line">    <span class="comment">// 子线程等待 5 秒</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子线程访问共享对象时，先检查共享对象是否存活</span></span><br><span class="line">    shared_ptr&lt;Task&gt; sp = wp.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (sp != <span class="literal">nullptr</span>) {</span><br><span class="line">        sp-&gt;<span class="built_in">run</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Failed to invoke Task:run()"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建强引用智能指针</span></span><br><span class="line">        shared_ptr&lt;Task&gt; task = make_shared&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(executTask, weak_ptr&lt;Task&gt;(task))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子线程与 thread 对象分离，使其在后台独立运行，直到子线程执行完毕</span></span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 共享对象 task 出了作用域后会自动释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待子线程执行完成</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task()</span><br><span class="line">~Task()</span><br><span class="line">Failed to invoke Task:run()</span><br></pre></td></tr></tbody></table></figure><h3 id="智能指针的模拟实现"><a href="#智能指针的模拟实现" class="headerlink" title="智能指针的模拟实现"></a>智能指针的模拟实现</h3><p>本节将使用 C++ 的类模板来简单模拟实现智能指针。</p><div class="admonition note"><p class="admonition-title">提示</p><p>智能指针的本质是利用栈上的对象出了作用域（比如函数作用域）后自动析构的特性，以此来实现资源的自动释放。</p></div><h4 id="不带引用计数的智能指针-1"><a href="#不带引用计数的智能指针-1" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h4><p>本节将使用类模板、右值引用、移动语义（<code>move</code> ）来简单模拟实现 C++ 11 中的 <code>unique_ptr</code> 智能指针。</p><div class="admonition note"><p class="admonition-title">扩展阅读</p><p>更多关于 C++ 11 右值引用和移动语义（<code>move</code> ）的介绍请看 <a href="/posts/e302ad63.html">这里</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现不带引用计数的智能指针，类似 unique_ptr 智能指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSmartPtr</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(T *ptr)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~CSmartPtr()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式删除带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式删除带左值引用参数的赋值运算符重载函数</span></span><br><span class="line">    CSmartPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数，支持移动构造（即支持 move 移动语义）</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(CSmartPtr&lt;T&gt; &amp;&amp;src) <span class="keyword">noexcept</span> : _ptr(src._ptr) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(CSmartPtr&lt;T&gt; &amp;&amp;src)"</span> &lt;&lt; endl;</span><br><span class="line">        src._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载函数，支持移动赋值（即支持 move 移动语义）</span></span><br><span class="line">    CSmartPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(CSmartPtr&lt;T&gt; &amp;&amp;src) <span class="keyword">noexcept</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr&lt;T&gt; &amp;operator=(CSmartPtr&lt;T&gt; &amp;&amp;src)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 避免自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先存储当前的指针，避免删除自己后 src._ptr 变为 nullptr</span></span><br><span class="line">        T *old_ptr = _ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转移所有权</span></span><br><span class="line">        _ptr = src._ptr;</span><br><span class="line">        src._ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放旧资源</span></span><br><span class="line">        <span class="keyword">delete</span> old_ptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// * 运算符重载函数</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() {</span><br><span class="line">        <span class="keyword">if</span> (!_ptr) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"Dereferencing a null pointer!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -&gt; 运算符重载函数</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() {</span><br><span class="line">        <span class="keyword">if</span> (!_ptr) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"Accessing member of a null pointer!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有权，不删除对象</span></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">        T *temp = _ptr;</span><br><span class="line">        _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">        <span class="comment">// 避免 delete 自己的对象</span></span><br><span class="line">        <span class="keyword">if</span> (_ptr == ptr) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">        _ptr = ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始指针</span></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// CSmartPtr&lt;int&gt; ptr2(ptr1);         // 编译出错，不可复制</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = ptr1;                         // 编译出错，不可赋值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(move(ptr1))</span></span>;      <span class="comment">// 支持移动构造，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    ptr2 = <span class="built_in">move</span>(ptr1);                     <span class="comment">// 支持移动赋值，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 30</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> *rawPtr = p1.<span class="built_in">release</span>();             <span class="comment">// p1 不再管理该资源</span></span><br><span class="line">    <span class="keyword">delete</span> rawPtr;                          <span class="comment">// 需要手动释放</span></span><br><span class="line"></span><br><span class="line">    CSmartPtr&lt;<span class="keyword">int</span>&gt; p2;</span><br><span class="line">    p2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>));                 <span class="comment">// 重新分配资源</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="built_in">test05</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">C++ 11 及更高版本中的特殊成员函数行为</p><ul><li>如果用户通过右值引用参数声明了移动构造函数或移动赋值运算符重载函数，而没有显式声明拷贝构造函数或赋值运算符重载函数（带左值引用参数），则：</li><li>(1) 拷贝构造函数（带左值引用参数）会被隐式删除（<code>= delete</code>）。</li><li>(2) 赋值运算符重载函数（带左值引用参数）会被隐式删除（<code>= delete</code>）。</li></ul></div><table><thead><tr><th><strong>是否定义了用户自定义的…</strong></th><th><strong> 默认拷贝构造</strong></th><th><strong>默认拷贝赋值</strong></th><th><strong>默认移动构造</strong></th><th><strong>默认移动赋值</strong></th></tr></thead><tbody><tr><td>没有移动构造和移动赋值</td><td>✅ 自动生成</td><td>✅ 自动生成</td><td>❌ <strong>不会自动生成</strong></td><td>❌ <strong>不会自动生成</strong></td></tr><tr><td><strong>定义了移动构造或移动赋值</strong></td><td>❌ <strong>隐式删除</strong></td><td>❌ <strong>隐式删除</strong></td><td>✅ 存在</td><td>✅ 存在</td></tr></tbody></table><h4 id="带引用计数的智能指针-1"><a href="#带引用计数的智能指针-1" class="headerlink" title="带引用计数的智能指针"></a>带引用计数的智能指针</h4><p>本节将使用类模板来简单模拟实现 C++ 11 中的 <code>shared_ptr</code> 智能指针，暂时不考虑线程安全问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现带引用计数的智能指针（不考虑线程安全问题），类似 shared_ptr 智能指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefCount</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RefCount</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr) {</span><br><span class="line">        <span class="comment">// 在堆上初始化引用计数，为了让智能指针在复制或赋值时共享同一个引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RefCount</span>() {</span><br><span class="line">        <span class="comment">// 释放堆上的引用计数</span></span><br><span class="line">        <span class="keyword">delete</span> _count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数自增</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increDef</span><span class="params">()</span> </span>{</span><br><span class="line">        ++(*_count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数自减</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decreRef</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (*_count &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> --(*_count);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前引用计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> *_count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;        <span class="comment">// 指向资源的指针</span></span><br><span class="line">    <span class="keyword">int</span> *_count;    <span class="comment">// 指向堆上存储的引用计数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSmartPtr</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(T* ptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 初始化引用计数对象</span></span><br><span class="line">        _refCount = <span class="keyword">new</span> RefCount&lt;T&gt;(_ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~CSmartPtr()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 减少引用计数，并且当引用计数为零时，才释放智能指针管理的资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _refCount-&gt;<span class="built_in">decreRef</span>()) {</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _refCount;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;src) : _ptr(src._ptr), _refCount(src._refCount) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(const CSmartPtr&lt;T&gt;&amp; src)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 增加引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (_ptr != <span class="literal">nullptr</span>) {</span><br><span class="line">            _refCount-&gt;<span class="built_in">increDef</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载函数</span></span><br><span class="line">    CSmartPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;src) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr&lt;T&gt; operator=(const CSmartPtr&lt;T&gt;&amp; src)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 避免自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放旧的资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _refCount-&gt;<span class="built_in">decreRef</span>()) {</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _refCount;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共享新的资源</span></span><br><span class="line">        _ptr = src._ptr;</span><br><span class="line">        _refCount = src._refCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加引用计数</span></span><br><span class="line">        _refCount-&gt;<span class="built_in">increDef</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// * 运算符重载函数</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() {</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -&gt; 运算符重载函数</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() {</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;                   <span class="comment">// 指向资源的指针</span></span><br><span class="line">    RefCount&lt;T&gt; *_refCount;    <span class="comment">// 指向资源引用计数对象的指针</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age = <span class="number">0</span>) : _age(age) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person(int age)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"age: "</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 测试多个智能指针管理同一个对象资源</span></span><br><span class="line">    <span class="function">CSmartPtr&lt;Person&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">20</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="function">CSmartPtr&lt;Person&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;   <span class="comment">// 可复制</span></span><br><span class="line">        ptr2-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">        CSmartPtr&lt;Person&gt; ptr3;</span><br><span class="line">        ptr3 = ptr2;                    <span class="comment">// 可赋值</span></span><br><span class="line">        ptr3-&gt;<span class="built_in">print</span>();</span><br><span class="line">    } <span class="comment">// 出了作用域后，ptr2、ptr3 析构，但不影响 ptr1，也不影响对象资源的析构</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"Leaving inner scope..."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ptr1-&gt;<span class="built_in">print</span>();  <span class="comment">// 仍然有效</span></span><br><span class="line"></span><br><span class="line">} <span class="comment">// 出了作用域后，ptr1 析构，并析构对象资源</span></span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Person(int age)</span><br><span class="line">CSmartPtr(T* ptr)</span><br><span class="line">CSmartPtr(const CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">age: 20</span><br><span class="line">CSmartPtr(T* ptr)</span><br><span class="line">CSmartPtr&lt;T&gt; operator=(const CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">age: 20</span><br><span class="line">~CSmartPtr()</span><br><span class="line">~CSmartPtr()</span><br><span class="line">Leaving inner scope...</span><br><span class="line">age: 20</span><br><span class="line">~CSmartPtr()</span><br><span class="line">~Person()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Debian 12 安装 Docker 与 Docker-Compose</title>
    <link href="https://www.techgrow.cn/posts/a19ep68d.html"/>
    <id>https://www.techgrow.cn/posts/a19ep68d.html</id>
    <published>2025-02-11T13:18:02.000Z</published>
    <updated>2025-02-11T13:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://www.docker.com/">Docker 官网</a></li><li><a href="https://hub.docker.com/">Docker Hub 官网</a></li><li><a href="https://docs.docker.com/">Docker 官方文档</a></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="卸载已有软件"><a href="#卸载已有软件" class="headerlink" title="卸载已有软件"></a>卸载已有软件</h3><p>卸载已安装的 Docker，避免对后续的安装步骤产生影响。</p><span id="more"></span><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载旧版本，包括有关的配置文件</span></span><br><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保证卸载干净</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">sudo rm -rf /etc/docker</span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /usr/libexec/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br><span class="line">sudo rm -rf /etc/apt/keyrings</span><br></pre></td></tr></tbody></table></figure><h3 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></tbody></table></figure><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><h3 id="添加存储库"><a href="#添加存储库" class="headerlink" title="添加存储库"></a>添加存储库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥</span></span><br><span class="line">sudo curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Docker 的 APT 存储库</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian <span class="subst">$(lsb_release -cs)</span> stable"</span> | tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 APT 索引</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></tbody></table></figure><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装最新版本的 Docker</span></span><br><span class="line">sudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>Docker Buildx 是 Docker 官方推出的一款增强型构建工具，旨在简化和优化多架构容器映像的构建流程。它整合了 QEMU 模拟器和多平台构建能力，使得开发者可以在单一的构建过程中同时为多个平台（如 x86、ARM 等）构建容器映像，极大地提高了构建效率和开发体验。</p></div><h3 id="Docker-启动"><a href="#Docker-启动" class="headerlink" title="Docker 启动"></a>Docker 启动</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启动 Docker</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Docker 的运行状态</span></span><br><span class="line">sudo systemctl status docker</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">普通用户使用 Docker 命令</p><p>如果希望让非 <code>root</code> 用户也能使用 Docker 命令，可以将该用户添加到 <code>docker</code> 用户组，比如 <code>sudo usermod -aG docker your-user-name</code>。</p></div><h3 id="Docker-配置源"><a href="#Docker-配置源" class="headerlink" title="Docker 配置源"></a>Docker 配置源</h3><p>由于 Docker Hub 存在不可抗拒因素，导致在国内无法访问，因此需要配置 Docker 使用国内镜像源。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建配置目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">{</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">     <span class="string">"https://ustc-edu-cn.mirror.aliyuncs.com"</span>,</span><br><span class="line">     <span class="string">"https://mirror.iscas.ac.cn"</span>,</span><br><span class="line">     <span class="string">"https://docker.nju.edu.cn"</span>,</span><br><span class="line">     <span class="string">"https://docker.m.daocloud.io"</span>,</span><br><span class="line">     <span class="string">"https://ccr.ccs.tencentyun.com"</span>,</span><br><span class="line">     <span class="string">"https://dockerhub.timeweb.cloud"</span></span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使配置文件生效</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 Docker</span></span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Docker 的运行状态</span></span><br><span class="line">sudo systemctl status docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Docker 的运行信息</span></span><br><span class="line">sudo docker info</span><br></pre></td></tr></tbody></table></figure><h3 id="Docker-验证安裝"><a href="#Docker-验证安裝" class="headerlink" title="Docker 验证安裝"></a>Docker 验证安裝</h3><p>验证是否正确安装了 Docker，以下命令将下载一个测试镜像并在容器中运行它，容器在运行时将输出一条参考消息并退出</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></tbody></table></figure><h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker-Compose"></a>安装 Docker-Compose</h2><div class="admonition note"><p class="admonition-title">提示</p><p>推荐使用第二种方式（基于 <code>curl</code> 命令）进行安装，因为可以指定具体安装哪个版本的 Docker-Compose，而且后期升级维护也更方便。</p></div><h3 id="第一种安装方式"><a href="#第一种安装方式" class="headerlink" title="第一种安装方式"></a>第一种安装方式</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Docker-Compose 插件</span></span><br><span class="line">sudo apt install -y docker-compose-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 Docker-Compose 插件</span></span><br><span class="line">sudo docker compose version</span><br></pre></td></tr></tbody></table></figure><h3 id="第二种安装方式"><a href="#第二种安装方式" class="headerlink" title="第二种安装方式"></a>第二种安装方式</h3><p>这里除了可以使用 <code>curl</code> 命令来下载 Docker-Compose 的二进制包，还可以在 <a href="https://github.com/docker/compose/releases">GitHub Releases</a> 上面手动下载对应的文件，然后上传到目标服务器。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.29.1/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件授权</span></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证下载</span></span><br><span class="line">sudo docker-compose -v</span><br></pre></td></tr></tbody></table></figure><h2 id="常见安装问题"><a href="#常见安装问题" class="headerlink" title="常见安装问题"></a>常见安装问题</h2><h3 id="info-命令输出警告信息"><a href="#info-命令输出警告信息" class="headerlink" title="info 命令输出警告信息"></a>info 命令输出警告信息</h3><ul><li>问题描述：当 Docker 安装完成之后，执行 <code>docker info</code> 命令，发现有以下警告信息存在：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WARNING: No cpu cfs quota support</span><br><span class="line">WARNING: No cpu cfs period support</span><br><span class="line">WARNING: No cpu shares support</span><br><span class="line">WARNING: No cpuset support</span><br><span class="line">WARNING: No io.weight support</span><br><span class="line">WARNING: No io.weight (per device) support</span><br><span class="line">WARNING: No io.max (rbps) support</span><br><span class="line">WARNING: No io.max (wbps) support</span><br><span class="line">WARNING: No io.max (riops) support</span><br><span class="line">WARNING: No io.max (wiops) support</span><br></pre></td></tr></tbody></table></figure><ul><li>解决办法：重启 Debian 服务器，让系统重新加载 <code>cgroup</code> 规则</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="/posts/57bca56f.html">Docker 介绍与安装</a></li><li><a href="/posts/b31f4d18.html">Docker-Compose 安装与使用</a></li><li><a href="https://blog.csdn.net/weixin_49187218/article/details/136935982">Debian 11 上安装 Docker</a></li><li><a href="https://blog.csdn.net/qq_30818545/article/details/124514016">Debian11 之 Docker 稳定版本安装</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Debian 12 如何安装 Docker 与 Docker-Compose。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固进阶之一</title>
    <link href="https://www.techgrow.cn/posts/e302ad63.html"/>
    <id>https://www.techgrow.cn/posts/e302ad63.html</id>
    <published>2025-02-08T13:55:33.000Z</published>
    <updated>2025-02-08T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-对象深入探索"><a href="#C-对象深入探索" class="headerlink" title="C++ 对象深入探索"></a>C++ 对象深入探索</h2><h3 id="对象的构造与析构"><a href="#对象的构造与析构" class="headerlink" title="对象的构造与析构"></a>对象的构造与析构</h3><h4 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">10</span>) : _a(a) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(int)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;t) : _a(t._a) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = t._a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    Test t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Test t3 = t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `Test t4(30);`</span></span><br><span class="line">    <span class="comment">// Test(30) 通常会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 但是，如果用临时对象去拷贝构造新对象，那么临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化</span></span><br><span class="line">    Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 1 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用赋值运算符重载函数</span></span><br><span class="line">    t4 = t2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// Test(20) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    t4 = <span class="built_in">Test</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 2 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// (Test)20 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t4 = Test(20);`，这里要求 Test 类拥有 int 类型的构造函数</span></span><br><span class="line">    t4 = (Test) <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 3 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// 会隐式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t4 = Test(20);`，这里要求 Test 类拥有 int 类型的构造函数</span></span><br><span class="line">    t4 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 4 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// (Test)20 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 当临时对象出了所在语句，会立刻被析构，同时指针 p 会成为野指针</span></span><br><span class="line">    <span class="comment">// 结论：使用指针变量指向临时对象是不安全的</span></span><br><span class="line">    Test *p = &amp;<span class="built_in">Test</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// (Test)20 会显式生成临时对象，临时对象的生存周期是所在函数</span></span><br><span class="line">    <span class="comment">// 但是，这里的临时对象出了所在语句，不会立刻被析构，而是直到出了函数作用域才会被析构</span></span><br><span class="line">    <span class="comment">// 在函数作用域内，ref 引用会一直有效</span></span><br><span class="line">    <span class="comment">// 结论：使用引用变量指向临时对象是安全的</span></span><br><span class="line">    Test &amp;ref = <span class="built_in">Test</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 1 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--------- 1 ---------</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">Test(int)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test()</span><br><span class="line">--------- 2 ---------</span><br><span class="line">Test(int)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test()</span><br><span class="line">--------- 3 ---------</span><br><span class="line">Test(int)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test()</span><br><span class="line">--------- 4 ---------</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">Test(int)</span><br><span class="line">~Test()</span><br><span class="line">Test(int)</span><br><span class="line">--------- 1 ---------</span><br><span class="line">~Test()</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h4><div class="admonition note"><p class="admonition-title">提示</p><p>在 C++ 中，最先析构的对象，往往都是最后析构的，即符合 "先构造后析构" 的规则（类似栈的 "先进后出"），这规则同样适用于类成员属性的构造和析构。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">5</span>, <span class="keyword">int</span> b = <span class="number">5</span>) : _a(a), _b(b) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test("</span> &lt;&lt; a &lt;&lt; <span class="string">", "</span> &lt;&lt; b &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test("</span> &lt;&lt; <span class="keyword">this</span>-&gt;_a &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="keyword">this</span>-&gt;_b &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;t) : _a(t._a), _b(t._b) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = t._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = t._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Test t3 = t2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 1 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `Test t4(30, 30);`</span></span><br><span class="line">    <span class="comment">// Test(30, 30) 通常会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 但是，如果用临时对象去拷贝构造新对象，那么临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化</span></span><br><span class="line">    <span class="comment">// 这里定义的局部静态变量，只在程序结束的时候才会被析构</span></span><br><span class="line">    <span class="keyword">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 2 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// Test(40, 40) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// (Test)(50, 50) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t2 = Test(50);`，这里要求 Test 类拥有对应的构造函数</span></span><br><span class="line">    t2 = (Test) (<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// 60 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t2 = Test(60);`，这里要求 Test 类拥有对应的构造函数</span></span><br><span class="line">    t2 = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 3 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    Test *p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用（两次）普通构造函数</span></span><br><span class="line">    Test *p2 = <span class="keyword">new</span> Test[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 4 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// Test(80, 80) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 当临时对象出了所在语句，会立刻被析构，同时指针 p 会成为野指针</span></span><br><span class="line">    <span class="comment">// 结论：使用指针变量指向临时对象是不安全的</span></span><br><span class="line">    Test *p3 = &amp;<span class="built_in">Test</span>(<span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// Test(90, 90) 会显式生成临时对象，临时对象的生存周期是所在函数</span></span><br><span class="line">    <span class="comment">// 但是，这里的临时对象出了所在语句，不会立刻被析构，而是直到出了函数作用域才会被析构</span></span><br><span class="line">    <span class="comment">// 在函数作用域内，ref 引用会一直有效</span></span><br><span class="line">    <span class="comment">// 结论：使用引用变量指向临时对象是安全的</span></span><br><span class="line">    Test &amp;p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 5 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用析构函数</span></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用（两次）析构函数</span></span><br><span class="line">    <span class="keyword">delete</span>[] p2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 6 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个执行（t1 是最先构造的，而且又是最后析构）</span></span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个执行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ start main()============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ end main()============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个执行</span></span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Test(10, 10)</span><br><span class="line">Test(100, 100)</span><br><span class="line"></span><br><span class="line">============ start main()============</span><br><span class="line"></span><br><span class="line">============ test01() ============</span><br><span class="line">Test(20, 20)</span><br><span class="line">Test(const Test&amp; t)</span><br><span class="line">--------- 1 ---------</span><br><span class="line">Test(30, 30)</span><br><span class="line">--------- 2 ---------</span><br><span class="line">Test(40, 40)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test(40, 40)</span><br><span class="line">Test(50, 5)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test(50, 5)</span><br><span class="line">Test(60, 5)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test(60, 5)</span><br><span class="line">--------- 3 ---------</span><br><span class="line">~Test(20, 20)</span><br><span class="line">~Test(60, 5)</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">Test(70, 70)</span><br><span class="line">Test(5, 5)</span><br><span class="line">Test(5, 5)</span><br><span class="line">--------- 4 ---------</span><br><span class="line">Test(80, 80)</span><br><span class="line">~Test(80, 80)</span><br><span class="line">Test(90, 90)</span><br><span class="line">--------- 5 ---------</span><br><span class="line">~Test(70, 70)</span><br><span class="line">~Test(5, 5)</span><br><span class="line">~Test(5, 5)</span><br><span class="line">--------- 6 ---------</span><br><span class="line">~Test(90, 90)</span><br><span class="line"></span><br><span class="line">============ end main()============</span><br><span class="line">~Test(30, 30)</span><br><span class="line">~Test(100, 100)</span><br><span class="line">~Test(10, 10)</span><br></pre></td></tr></tbody></table></figure><h2 id="C-函数调用深入探索"><a href="#C-函数调用深入探索" class="headerlink" title="C++ 函数调用深入探索"></a>C++ 函数调用深入探索</h2><h3 id="案例代码一-1"><a href="#案例代码一-1" class="headerlink" title="案例代码一"></a>案例代码一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">10</span>) : _ma(a) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(int a)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ma = t._ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ma = t._ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _ma;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObject</span><span class="params">(Test t)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> value = t.<span class="built_in">getData</span>();</span><br><span class="line">    <span class="function">Test <span class="title">tmp</span><span class="params">(value)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Test t1;</span><br><span class="line">    Test t2;</span><br><span class="line">    t2 = <span class="built_in">getObject</span>(t1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下（详细分析图解请看<a href="../../../asset/2025/02/cxx-method-invoke.png">这里</a>）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Test(int a)                 // main() 函数中构造 t1 对象</span><br><span class="line">Test(int a)                 // main() 函数中构造 t2 对象</span><br><span class="line">Test(const Test&amp; t)         // getObject() 函数中拷贝构造 t 对象</span><br><span class="line">Test(int a)                 // getObject() 函数中构造 tmp 对象</span><br><span class="line">Test(const Test&amp; t)         // getObject() 函数返回执行结果值时，调用拷贝构造函数来拷贝 tmp 对象给 main() 函数栈帧上的临时对象</span><br><span class="line">~Test()                     // 析构 getObject() 函数中的 tmp 对象</span><br><span class="line">~Test()                     // 析构 getObject() 函数中的 t 对象</span><br><span class="line">operator=(const Test&amp; t)    // main() 函数中，执行赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 t2 对象</span><br><span class="line">~Test()                     // 析构 main() 函数栈帧上的临时对象，临时对象的生存周期是所在语句</span><br><span class="line">~Test()                     // 析构 main() 函数中的 t2 对象</span><br><span class="line">~Test()                     // 析构 main() 函数中的 t1 对象</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码二-1"><a href="#案例代码二-1" class="headerlink" title="案例代码二"></a>案例代码二</h3><ul><li><p>上述 <a href="/posts/bd9d2710.html#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80-1">案例一</a> 的代码执行效率比较低，主要原因有以下几个：</p><ul><li>第一个原因：<code>getObject()</code> 函数的参数是按值传递，而不是按引用传递，这会多调用一次拷贝构造函数。</li><li>第二个原因：在 <code>getObject()</code> 函数中先构造了一个 <code>tmp</code> 对象，然后再作为函数的返回值，这会多调用一次构造函数。</li><li>第三个原因：在 <code>main()</code> 函数中，将临时对象赋值给 <code>t2</code> 对象，这会多调用一次赋值运算符重载函数。</li></ul></li><li><p>C++ 对象的优化原则</p><ul><li>(1) 函数参数传递的过程中，对象应该优先按引用传递，而不是按值传递。</li><li>(2) 函数调用结果返回对象的时候，应该优先返回一个临时对象，而不要返回一个定义过的对象。</li><li>(3) 当函数返回值是对象的时候，优先按初始化的方式来接收返回值，而不是按赋值的方式来接收返回值。<ul><li>换言之，尽量使用临时对象去拷贝构造新对象，因为这样临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化。</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">10</span>) : _ma(a) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(int a)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ma = t._ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ma = t._ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _ma;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObject</span><span class="params">(Test &amp;t)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> value = t.<span class="built_in">getData</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>(value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Test t1;</span><br><span class="line">    Test t2 = <span class="built_in">getObject</span>(t1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test(int a)                 // main() 函数中构造 t1 对象</span><br><span class="line">Test(int a)                 // main() 函数中构造 t2 对象（使用临时对象去拷贝构造新对象时，临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化）</span><br><span class="line">~Test()                     // 析构 main() 函数中的 t2 对象</span><br><span class="line">~Test()                     // 析构 main() 函数中的 t1 对象</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 多线程编程之一</title>
    <link href="https://www.techgrow.cn/posts/a2a7ad9b.html"/>
    <id>https://www.techgrow.cn/posts/a2a7ad9b.html</id>
    <published>2025-02-07T13:55:33.000Z</published>
    <updated>2025-02-07T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="C-核心概念"><a href="#C-核心概念" class="headerlink" title="C++ 核心概念"></a>C++ 核心概念</h2><h3 id="互斥锁的介绍"><a href="#互斥锁的介绍" class="headerlink" title="互斥锁的介绍"></a>互斥锁的介绍</h3><ul><li><code>mutex</code><ul><li>使用语法（<code>mtx.lock();</code>、<code>mtx.unlock();</code>）。</li><li>最基础的互斥量类型（原始锁），用于保护共享资源，防止多个线程并发访问共享资源。</li><li>如果在某个程序分支或异常路径中忘了执行 <code>mtx.unlock()</code>，就容易导致线程死锁。</li><li><code>mutex</code> 不支持同一个线程重复对其加锁，即无法用于实现递归锁（可重入锁）。</li><li>如果希望实现递归锁（可重入锁），可以使用 <code>recursive_mutex</code> 来替代。<code>recursive_mutex</code> 支持同一个线程对 <code>mutex</code> 重复加锁，每次加锁都需要对应的解锁。</li></ul></li></ul><span id="more"></span><ul><li><p><code>lock_guard</code></p><ul><li>使用语法（<code>lock_guard&lt;mutex&gt; lock(_mutex);</code>）。</li><li>一种轻量级的锁管理类，它在构造时自动加锁，在析构时自动释放锁（RAII 技术），适合在指定作用域内自动管理锁。</li><li>作用域结束时自动解锁，不可以手动解锁（无法提前释放锁）。</li><li><code>lock_guard</code> 和 <code>recursive_mutex</code> 搭配使用，可以实现递归锁（可重入锁）。</li><li>比 <code>unique_lock</code> 更轻量级，性能更好（因为没有 <code>unlock ()</code> 之类的额外操作）。</li><li><code>lock_guard</code> 不能作为函数参数的类型或者函数返回值的类型，只能用在简单的临界区代码段的互斥操作中。</li></ul></li><li><p><code>unique_lock</code></p><ul><li>使用语法（<code>unique_lock&lt;mutex&gt; lock(_mutex);</code>）。</li><li>一种更灵活的锁管理类，它在构造时自动加锁，在析构时自动释放锁（RAII 技术）。</li><li>可以手动解锁（<code>lock.unlock()</code>）。</li><li>可以延迟加锁（<code>unique_lock&lt;mutex&gt; lock(_mutex, defer_lock);</code>）。</li><li>可以移动赋值（<code>unique_lock</code> 可被转移，但 <code>lock_guard</code> 不能被转移）。</li><li><code>unique_lock</code> 和 <code>recursive_mutex</code> 搭配使用，可以实现递归锁（可重入锁）。</li><li>通常与 <code>condition_variable</code> 一起配合使用，因为 <code>condition_variable::wait()</code> 函数需要传入 <code>unique_lock</code> 参数（不能使用 <code>lock_guard</code>）。</li></ul></li></ul><blockquote><p>对比表格</p></blockquote><table><thead><tr><th>特性</th><th><code>mutex</code></th><th><code>lock_guard</code></th><th><code>unique_lock</code></th></tr></thead><tbody><tr><td>是否自动管理锁</td><td>❌ 否</td><td>✅ 是（RAII）</td><td>✅ 是（RAII）</td></tr><tr><td>是否可解锁再加锁</td><td>✅ 是</td><td>❌ 否</td><td>✅ 是</td></tr><tr><td>是否可延迟加锁</td><td>❌ 否</td><td>❌ 否</td><td>✅ 是</td></tr><tr><td>支持条件变量（CV）</td><td>❌ 否</td><td>❌ 否</td><td>✅ 是（推荐配合使用）</td></tr><tr><td>资源占用</td><td>最低</td><td>低</td><td>略高（但更灵活）</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">总结</p><ul><li>如果需要手动控制解锁，建议使用 <code>unique_lock</code>。</li><li>如果只需要简单加锁 / 解锁，建议使用 <code>lock_guard</code>，效率更高。</li></ul></div><h3 id="unique-lock-的作用"><a href="#unique-lock-的作用" class="headerlink" title="unique_lock 的作用"></a>unique_lock 的作用</h3><p><code>unique_lock</code> 是 C++ 标准库 <code>mutex</code> 的 RAII（资源获取即初始化）封装，用于自动管理互斥锁。当执行 <code>unique_lock&lt;mutex&gt; lock(_mutex);</code> 时：</p><ul><li>当前线程尝试获取 <code>mutex</code> 锁（如果其他线程已经持有锁，则当前线程会阻塞等待，直到锁被释放）。</li><li>一旦成功获取锁，在 <code>lock</code> 对象的生命周期内，当前线程独占访问受保护的资源。</li><li>当 <code>lock</code> 对象销毁时（如作用域结束），<code>mutex</code> 会自动解锁，从而可以避免死锁或资源泄露。</li></ul><h3 id="condition-variable-的作用"><a href="#condition-variable-的作用" class="headerlink" title="condition_variable 的作用"></a>condition_variable 的作用</h3><ul><li><p>核心概念</p><ul><li><code>condition_variable</code> 是 C++ 11 提供的一种线程间同步工具，用于线程等待某个条件满足，并在条件满足时被其他线程唤醒。</li><li><code>condition_variable</code> 常与 <code>mutex</code> 和 <code>unique_lock</code> 一起搭配使用，可用于实现线程间等待通知机制，类似 Java 中的 <code>wait / notify</code>。</li></ul></li><li><p>注意事项</p><ul><li>等待时必须传入一把锁（如 <code>mutex</code>），否则 <code>wait()</code> 会报错。</li><li><strong>执行 <code>wait()</code> 后，线程会挂起等待，同时释放锁，被唤醒后重新获取锁。</strong></li><li>推荐使用带 <code>Predicate（断言）</code> 的 <code>wait()</code>，防止虚假唤醒。</li><li><code>notify_one()</code> 要在修改共享状态之后再调用，否则会错过通知。</li><li>常配合 <code>unique_lock</code> 一起使用，因为 <code>unique_lock</code> 比 <code>lock_guard</code> 更灵活（支持手动解锁、延迟加锁等）。</li></ul></li><li><p>适用场景</p><ul><li>生产者 / 消费者模型</li><li>线程间通知与协作</li><li>线程等待某种条件成立（如队列不为空）</li></ul></li><li><p>基本操作</p></li></ul><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td><code>wait(lock)</code></td><td>线程挂起等待，同时释放锁，被唤醒后重新获取锁。</td></tr><tr><td><code>wait(lock, predicate)</code></td><td>等待直到条件成立，否则继续阻塞，可以防止虚假唤醒。等待期间释放锁，被唤醒后重新获取锁。</td></tr><tr><td><code>notify_one()</code></td><td>唤醒一个等待中的线程。</td></tr><tr><td><code>notify_all()</code></td><td>唤醒所有等待中的线程。</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">什么是虚假唤醒</p><ul><li>虚假唤醒是指线程在没有收到 Notify（通知）或没有满足条件的情况下意外醒来。</li><li>换言之，线程在 <code>wait()</code> 处本应该阻塞，但它自己突然 "醒了"，而并没有任何线程调用 <code>notify_one()</code> 或 <code>notify_all()</code> 触发它醒来，也没有任何共享条件真正发生变化。</li><li>虚假唤醒不是 Bug，它是操作系统 / CPU 实现层面允许的行为。主要原因有：(1) 出于性能或调度策略考虑，某些系统可能让线程偶尔 "意外醒来"；(2) 多线程调度可能出现不可预知的唤醒；(3) 这在 POSIX 线程规范（pthread）和 C++ 标准中都是被允许的。</li></ul></div><h2 id="C-多线程编程"><a href="#C-多线程编程" class="headerlink" title="C++ 多线程编程"></a>C++ 多线程编程</h2><p>这里介绍的是 C++ 语言级别的多线程编程，支持跨平台编译与运行。值得一提的是，现代 C++ 语言层面的多线程编程使用的是 <code>thread</code>，而其底层的实现依旧是区分不同平台的，比如：Windows 平台使用的是 <code>createThread</code>，Linux 平台使用的是 <code>pthread_create</code>。</p><div class="admonition note"><p class="admonition-title">C++ 多线程编程的核心技术</p><ul><li>thread / mutex / condition_variable</li><li>unique_lock / lock_guard</li><li>atomic（基于 CAS 的原则类型）</li><li>sleep_for</li></ul></div><h3 id="thread-的使用"><a href="#thread-的使用" class="headerlink" title="thread 的使用"></a>thread 的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadHandler1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 线程睡眠5秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"run thread handler 1"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadHandler2</span><span class="params">(<span class="keyword">int</span> seconds)</span> </span>{</span><br><span class="line">    <span class="comment">// 线程睡眠</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(seconds));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"run thread handler 2"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个线程对象，参数传入一个线程函数，线程会自动启动</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadHandler1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者指定线程函数的参数</span></span><br><span class="line">    <span class="comment">// std::thread t1(threadHandler2, 5);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待子线程结束，然后再继续往下执行</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者将子线程设置为分离线程，这样主线程就不需要等待子线程结束；当主线程结束，所有子线程都自动结束（终止运行）</span></span><br><span class="line">    <span class="comment">// t1.detach();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run thread handler 1</span><br></pre></td></tr></tbody></table></figure><h3 id="实现线程间的互斥"><a href="#实现线程间的互斥" class="headerlink" title="实现线程间的互斥"></a>实现线程间的互斥</h3><p>这里将使用 <code>std::mutex</code> 与 <code>std::lock_guard</code> 来模拟车站三个售票窗口同时售票，要求每张票只能卖一次。</p><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>std::lock_guard</code> 与 <code>std::unique_lock</code> 都是 C++ 标准库 <code>std::mutex</code> 的 RAII（资源获取即初始化）封装，用于自动管理互斥锁（如自动解锁）。</li><li><code>std::lock_guard</code> 支持在作用域结束时自动解锁，但不可以手动解锁，比 <code>std::unique_lock</code> 更轻量级，性能更好。</li><li><code>std::unique_lock</code> 支持自动 / 手动解锁、延迟加锁、移动赋值等，通常与 <code>std::condition_variable</code> 搭配使用。</li></ul></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line">std::mutex _mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 车站一共有 100 张车票</span></span><br><span class="line"><span class="keyword">int</span> ticketCount = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 获取互斥锁（支持在作用域结束时自动解锁）</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双重检测</span></span><br><span class="line">        <span class="keyword">if</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 执行业务逻辑</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"售票窗口 "</span> &lt;&lt; id &lt;&lt; <span class="string">" 卖出第 "</span> &lt;&lt; ticketCount &lt;&lt; <span class="string">" 张车票"</span> &lt;&lt; std::endl;</span><br><span class="line">            ticketCount--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> threadCount = <span class="number">3</span>;</span><br><span class="line">    std::list&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动三个售票子线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) {</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(sellTicket, i));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待三个售票子线程执行结束</span></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; t : threads) {</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"所有售票窗口已经结束售票"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">售票窗口 0 卖出第 100 张车票</span><br><span class="line">售票窗口 0 卖出第 99 张车票</span><br><span class="line">售票窗口 0 卖出第 98 张车票</span><br><span class="line">售票窗口 0 卖出第 97 张车票</span><br><span class="line">......</span><br><span class="line">售票窗口 1 卖出第 4 张车票</span><br><span class="line">售票窗口 1 卖出第 3 张车票</span><br><span class="line">售票窗口 2 卖出第 2 张车票</span><br><span class="line">售票窗口 2 卖出第 1 张车票</span><br><span class="line">所有售票窗口已经结束售票</span><br></pre></td></tr></tbody></table></figure><h3 id="实现线程间的同步通信"><a href="#实现线程间的同步通信" class="headerlink" title="实现线程间的同步通信"></a>实现线程间的同步通信</h3><p>这里实现生产者 / 消费者线程模型，使用了 <code>std::thread</code>、<code>std::mutex</code>、<code>std::unique_lock</code>、<code>std::condition_variable</code>。主要模拟实现生产者线程生产一条数据，消费者线程就立刻消费一条数据，两个线程一直交替执行。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex _mutex;                <span class="comment">// 互斥锁</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; _queue;           <span class="comment">// 共享数据队列</span></span><br><span class="line">condition_variable _cv;      <span class="comment">// 条件变量</span></span><br><span class="line"><span class="keyword">atomic_bool</span> _finish(<span class="literal">false</span>);  <span class="comment">// 控制标志（用于终止程序）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!_finish) {</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，且等待期间会自动释放锁，当收到通知或满足条件（可以避免虚假唤醒）时，才会重新获得互斥锁并继续执行</span></span><br><span class="line">        _cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> _queue.<span class="built_in">empty</span>(); });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟生产时间</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">rand</span>() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        _queue.<span class="built_in">push</span>(item);</span><br><span class="line">        cout &lt;&lt; <span class="string">"生产: "</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者</span></span><br><span class="line">        _cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!_finish) {</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，且等待期间会自动释放锁，当收到通知或满足条件（可以避免虚假唤醒）时，才会重新获得互斥锁并继续执行</span></span><br><span class="line">        _cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> !_queue.<span class="built_in">empty</span>(); });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟消费时间</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> item = _queue.<span class="built_in">front</span>();</span><br><span class="line">        _queue.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"消费: "</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知生产者</span></span><br><span class="line">        _cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动生产者和消费者线程</span></span><br><span class="line">    <span class="function">thread <span class="title">producer</span><span class="params">(produce)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">consumer</span><span class="params">(consume)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程运行 60 秒</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">60</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置终止标志</span></span><br><span class="line">    _finish = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有线程，确保它们能结束</span></span><br><span class="line">    _cv.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待生产者和消费者线程结束</span></span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">生产: 98</span><br><span class="line">消费: 98</span><br><span class="line">生产: 635</span><br><span class="line">消费: 635</span><br><span class="line">生产: 318</span><br><span class="line">消费: 318</span><br><span class="line">生产: 513</span><br><span class="line">消费: 513</span><br><span class="line">生产: 413</span><br><span class="line">消费: 413</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><h2 id="C-原子类型"><a href="#C-原子类型" class="headerlink" title="C++ 原子类型"></a>C++ 原子类型</h2><div class="admonition note"><p class="admonition-title">提示</p><p>CAS（比较与交换）是一种轻量级、不需要加锁的线程同步机制，可用于防止多个线程同时读写共享变量时发生数据竞争。值得一提的是，C++ 原子类型的底层都是基于 CAS 实现的。</p></div><h3 id="atomic-原子类型的概念"><a href="#atomic-原子类型的概念" class="headerlink" title="atomic 原子类型的概念"></a>atomic 原子类型的概念</h3><ul><li><p>核心概念</p><ul><li><code>std::atomic&lt;T&gt;</code> 是 C++ 11 引入的一个模板类，用于实现线程安全的原子操作。它的本质是：对变量的读写不可被中断，不需要加锁（基于 CAS），但又是线程安全的。</li><li>在多线程编程中，如果两个线程同时读写一个普通变量（如 <code>int</code>），就可能产生竞态条件。使用 <code>std::atomic</code> 可以避免这种问题，而不需要显式使用 <code>mutex</code> 互斥锁。</li><li><code>std::atomic</code> 本身就已经保证了原子性、内存可见性和有序性（默认情况下），不需要也不应该再搭配 <code>volatile</code> 一起使用。</li><li>为了使用方便，C++ 标准库为常用的原始类型提供了特定的类型别名，例如：<ul><li><code>std::atomic_int</code> 是 <code>std::atomic&lt;int&gt;</code> 的类型别名。</li><li><code>std::atomic_bool</code> 是 <code>std::atomic&lt;bool&gt;</code> 的类型别名。</li><li>其他类似的别名还有 <code>std::atomic_char</code>、<code>std::atomic_long</code> 等。</li></ul></li></ul></li><li><p>支持的类型</p><ul><li>基本类型：<code>int</code>、<code>bool</code>、<code>char</code>、<code>float</code> 等。</li><li>用户自定义的类型，但该类型必须是平凡可复制的（Trivially Copyable）。这意味着该类型的对象可以通过简单的内存复制进行复制，比如通过 <code>memcpy</code> 这样的操作进行复制，而无需调用构造函数或者赋值运算符。</li></ul></li><li><p>支持的操作</p><ul><li>原子读写：<code>load()</code> / <code>store()</code></li><li>自增自减：<code>++</code>、<code>--</code>、<code>fetch_add()</code>、<code>fetch_sub()</code></li><li>比较并交换（CAS）：<code>compare_exchange_strong()</code> / <code>compare_exchange_weak()</code></li></ul></li><li><p>使用注意事项</p><ul><li><code>std::atomic</code> 不支持拷贝赋值（复制是被禁用的）。</li><li>默认是顺序一致性（<code>memory_order_seq_cst</code>），内存可见性是有保障的。</li><li>支持内存顺序优化（高级用法），包括 <code>memory_order_relaxed</code>、<code>acquire</code>、<code>release</code> 等。</li></ul></li></ul><blockquote><p>volatile 能干什么？它和 atomic 是一回事吗？</p></blockquote><p><strong>特别注意，<code>volatile</code> 与 <code>std::atomic</code> 不是一回事！<code>volatile</code> 在 C++ 里的作用和你想的不太一样。</strong></p><table><thead><tr><th>功能</th><th><code>std::atomic</code></th><th><code>volatile</code></th></tr></thead><tbody><tr><td>保证原子性？</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>保证内存可见性？</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>保证编译器不优化读写？</td><td>✅是（控制更强）</td><td>✅是（仅编译器层面）</td></tr><tr><td>多线程同步安全？</td><td>✅ 是</td><td>❌ 否</td></tr></tbody></table><ul><li>结论：<ul><li><code>volatile</code> 只告诉编译器 “不要优化这个变量的访问”。</li><li><code>volatile</code> 不会保证线程间同步，不会保证缓存刷新，不会保证乱序执行的控制。</li><li>所以，在 C++ 多线程编程里，<code>volatile</code> 基本没用（少数平台 / 驱动除外）。</li></ul></li></ul><h3 id="atomic-原子类型的使用"><a href="#atomic-原子类型的使用" class="headerlink" title="atomic 原子类型的使用"></a>atomic 原子类型的使用</h3><p>这里将演示如何使用基于 CAS 操作的 <code>atomic</code> 原子类型，比如 <code>atomic_int</code> 和 <code>atomic_bool</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="keyword">atomic_int</span> _count(<span class="number">0</span>);</span><br><span class="line">std::<span class="keyword">atomic_bool</span> _isReady(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">taskHandler</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!_isReady) {</span><br><span class="line">        <span class="comment">// 线程出让当前的 CPU 时间片，等待下一次调度的执行</span></span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">        _count++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::list&lt;std::thread&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个子线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        list.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(taskHandler));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待几秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    _isReady = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有子线程执行结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        (*it).<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"_count = "</span> &lt;&lt; _count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_count = 1000</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的多线程编程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 实现 MySQL 数据库连接池</title>
    <link href="https://www.techgrow.cn/posts/993ae2e0.html"/>
    <id>https://www.techgrow.cn/posts/993ae2e0.html</id>
    <published>2025-01-28T13:55:33.000Z</published>
    <updated>2025-02-03T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/c942e1de.html">C++ 使用 API 连接 MySQL 数据库</a></li><li><a href="/posts/993ae2e0.html">基于 C++ 实现 MySQL 数据库连接池</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 C/C++ 项目中，为了提高 MySQL Server 的访问效率，基于 C++ 11 实现数据库连接池，并使用 MySQL Connector/C++ 库。</p><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>为了解决 MySQL 数据库（基于 C/S 设计）的访问瓶颈，除了在服务器端增加缓存服务器缓存常用的数据之外（例如 Redis），还可以增加连接池，来提高 MySQL Server 的访问效率。在高并发情况下，大量的 TCP 三次握手、MySQL Server 连接认证、MySQL Server 关闭连接回收资源和 TCP 四次挥手所耗费的性能时间也是很明显的，增加连接池就是为了减少这一部分的性能损耗。在市场上比较流行的连接池包括 C3P0、Apache DBCP、HikariCP、阿里巴巴的 Druid 连接池，它们对于短时间内大量的数据库增删改查操作性能的提升是很明显的，但是它们有一个共同点就是，全部都是由 Java 实现的。</p><span id="more"></span><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><ul><li>单例模式</li><li> Lambda 表达式</li><li>队列容器 <code>queue</code></li><li>智能指针 <code>shared_ptr</code></li><li>基于 CAS 的原子基础类型</li><li> MySQL 数据库编程（基于 MySQL Connector/C++）</li><li>C++ 11 的多线程编程，包括线程互斥、线程同步通信等</li><li>生产者 - 消费者线程模型的实现，基于 <code>mutex</code>、<code>unique_lock</code>、<code>condition_variable</code></li></ul><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><p>本文使用的各软件版本如下所示：</p><table><thead><tr><th>软件</th><th>版本</th></tr></thead><tbody><tr><td> C++</td><td><code>11</code></td></tr><tr><td>Boost</td><td><code>1_78_0</code></td></tr><tr><td>MySQL Connector/C++</td><td><code>1.1.13</code></td></tr><tr><td>G++（GCC）</td><td><code>4.8.5</code></td></tr><tr><td>CMake</td><td><code>3.25.1</code></td></tr><tr><td>MySQL</td><td><code>5.7.33</code></td></tr><tr><td>Clion</td><td><code>2019.3</code></td></tr><tr><td>Linux</td><td><code>CentOS 7.9</code></td></tr></tbody></table><h3 id="兼容平台"><a href="#兼容平台" class="headerlink" title="兼容平台"></a>兼容平台</h3><ul><li>(1) 有关 MySQL 数据库编程、多线程编程、线程互斥、线程同步通信、智能指针、设计模式、容器等等技术在 C++ 语言层面都可以直接实现；<strong>因此，数据库连接池代码是同时兼容 Windows 和 Linux 平台的，只是不同平台的 CMake 配置稍微有一点区别。</strong></li><li><strong>(2) 由于 MySQL 在 Linux 平台上使用得比较多，因此默认选择在 Linux 平台上进行开发，并使用 CMake 和 GCC 直接编译运行项目。</strong></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-Boost"><a href="#安装-Boost" class="headerlink" title="安装 Boost"></a>安装 Boost</h3><ul><li>由于 MySQL Connector/C++ 依赖了 Boost，因此本地 Linux 系统需要安装 Boost。建议从 <a href="https://www.boost.org/users/download/">Boost 官网</a> 下载 Boost 的源码压缩包，然后使用 <code>root</code> 用户手动编译安装 Boost，此方式适用于绝大多数 Linux 系统，如下所示：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">$ wget https://boostorg.jfrog.io/artifactory/main/release/1.78.0/<span class="built_in">source</span>/boost_1_78_0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压文件</span></span><br><span class="line">$ tar -xvf boost_1_78_0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line">$ <span class="built_in">cd</span> boost_1_78_0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建</span></span><br><span class="line">$ sudo ./bootstrap.sh --prefix=/usr/<span class="built_in">local</span>/boost</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装（耗时非常长）</span></span><br><span class="line">$ sudo ./b2 install --prefix=/usr/<span class="built_in">local</span>/boost --with=all</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-MySQL-Connector-C"><a href="#安装-MySQL-Connector-C" class="headerlink" title="安装 MySQL Connector/C++"></a>安装 MySQL Connector/C++</h3><ul><li>(1) Linux 平台上，可以在 <a href="https://dev.mysql.com/downloads/connector/cpp/">MySQL 官网</a> 直接下载 <code>1.1.13</code> 版本的 MySQL Connector/C++，下载完成后直接解压文件。</li><li>(2) 将解压得到的 <code>include</code> 和 <code>lib</code> 目录拷贝到数据库连接池项目中，然后配置 CMake 加载 MySQL Connector/C++ 的头文件和动态链接库即可。</li></ul><h2 id="连接池的功能介绍"><a href="#连接池的功能介绍" class="headerlink" title="连接池的功能介绍"></a>连接池的功能介绍</h2><p>连接池一般包含了数据库连接所用的 IP 地址、Port 端口号、用户名和密码以及其它的性能参数，例如初始连接数、最大连接数、最大空闲时间、连接超时时间等。本项目是基于 C++ 语言实现的连接池，主要也是实现以上几个所有连接池都支持的通用基础功能，其余连接池更多的扩展功能，可以自行实现。</p><ul><li><p>初始连接数（initSize）：</p><ul><li>表示连接池事先会和 MySQL Server 创建 initSize 个数的 connection 连接，当应用发起 MySQL 访问时，不用再创建和 MySQL Server 新的连接，直接从连接池中获取一个可用的连接就可以，使用完成后，并不去释放 connection，而是把当前 connection 再归还到连接池当中。</li></ul></li><li><p>最大连接数（maxSize）:</p><ul><li>当并发访问 MySQL Server 的请求增多时，初始连接数已经不够使用了，此时会根据新的请求数量去创建更多的连接给应用去使用，但是新创建的连接数量上限是 maxSize，不能无限制地创建连接，因为每一个连接都会占用一个 socket 资源。一般连接池和服务器程序是部署在一台主机上的，如果连接池占用过多的 socket 资源，那么服务器就不能接收太多的客户端请求了。当这些连接使用完成后，再次归还到连接池当中来维护。</li></ul></li><li><p>最大空闲时间（maxIdleTime）：</p><ul><li>当访问 MySQL 的并发请求多了以后，连接池里面的连接数量会动态增加，上限是 maxSize 个，当这些连接用完再次归还到连接池当中。如果在指定的 maxIdleTime 里面，这些新增加的连接都没有被再次使用过，那么新增加的这些连接资源就要被回收掉，只需要保持初始连接数 initSize 个连接就可以了。</li></ul></li><li><p>连接超时时间（connectionTimeout）:</p><ul><li>当 MySQL 的并发请求量过大，连接池中的连接数量已经到达 maxSize 了，而此时没有空闲的连接可供使用，那么此时应用无法从连接池获取连接，它通过阻塞的方式获取连接的等待时间如果超过 connectionTimeout 时间，则获取连接失败，无法访问数据库。</li></ul></li></ul><h2 id="连接池的功能设计"><a href="#连接池的功能设计" class="headerlink" title="连接池的功能设计"></a>连接池的功能设计</h2><ul><li><p>C++ 源文件的功能划分</p><ul><li><code>MysqlConnection.h</code> 和 <code>MysqlConnection.cpp</code>：数据库增删改查的代码实现</li><li><code>MysqlConnectionPool.h</code> 和 <code>MysqlConnectionPool.cpp</code>：连接池的代码实现</li></ul></li><li><p>连接池的实现主要包含了以下功能</p><ul><li>(1) 连接池只需要一个实例，所以 ConnectionPool 以单例模式进行设计。</li><li>(2) 应用可以从 ConnectionPool 中获取 MySQL 的连接 Connection。</li><li>(3) 空闲连接 Connection 全部存储在一个线程安全的 Connection 队列中，使用互斥锁来保证队列的线程安全。</li><li>(4) 如果 Connection 队列为空，应用还需要再获取连接，此时需要动态创建连接，最大的连接数量是 maxSize。</li><li>(5) 当队列中空闲连接的存活时间超过 maxIdleTime 后，连接就要被释放掉，只保留初始的 initSize 个连接就可以，这个功能需要放在独立的线程中去完成（定时扫描连接）。</li><li>(6) 如果 Connection 队列为空，而且当前已创建的连接的数量已达到上限 maxSize，则应用需要等待 connectionTimeout 时间。如果应用还是获取不到空闲的连接，则获取连接失败；此处从 Connection 队列获取空闲连接时，可以使用带超时时间的 <code>mutex</code> 互斥锁来实现连接超时时间。</li><li>(7) 应用获取的连接用 <code>shared_ptr</code> 智能指针来管理，并用 Lambda 表达式定制连接释放的功能（不真正释放连接，而是将连接归还到 Connection 队列中）。</li><li>(8) 连接的生产和连接的消费采用生产者 - 消费者线程模型来设计，使用了线程间的同步通信机制、条件变量和互斥锁。</li></ul></li></ul><h2 id="连接池的代码实现"><a href="#连接池的代码实现" class="headerlink" title="连接池的代码实现"></a>连接池的代码实现</h2><h3 id="连接池的项目结构"><a href="#连接池的项目结构" class="headerlink" title="连接池的项目结构"></a>连接池的项目结构</h3><p><img data-src="../../../asset/2025/02/cxx-mysql-connection-pool-arch.png"></p><ul><li><code>bin</code> 目录：存放 CMake 编译生成可执行文件</li><li><code>config</code> 目录：存放数据库连接池的配置文件</li><li><code>src</code> 目录：存放数据库连接池的 C++ 源文件</li><li><code>include</code> 目录：存放数据库连接池的 C++ 头文件</li><li><code>sql</code> 目录：存放 MySQL 数据库初始化的 SQL 脚本</li><li><code>script</code> 目录：存放 Linux 平台自动编译构建项目的 Shell 脚本</li><li><code>libs</code> 目录：存放项目依赖的第三方静态库和动态链接库</li><li><code>mysql-connector</code> 目录：存放 MySQL Connector/C++ 的头文件和动态链接库（Linux 平台），如下所示：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql-connector</span><br><span class="line">├── include</span><br><span class="line">│&nbsp;&nbsp; ├── cppconn</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── build_config.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── config.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── connection.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── datatype.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── driver.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── exception.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── metadata.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── parameter_metadata.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── prepared_statement.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── resultset.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── resultset_metadata.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── sqlstring.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── statement.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── variant.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── version_info.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── warning.h</span><br><span class="line">│&nbsp;&nbsp; ├── mysql_connection.h</span><br><span class="line">│&nbsp;&nbsp; ├── mysql_driver.h</span><br><span class="line">│&nbsp;&nbsp; └── mysql_error.h</span><br><span class="line">└── lib</span><br><span class="line">    ├── libcrypto.so -&gt; libcrypto.so.1.1</span><br><span class="line">    ├── libcrypto.so.1.1</span><br><span class="line">    ├── libmysqlcppconn.so -&gt; libmysqlcppconn.so.7</span><br><span class="line">    ├── libmysqlcppconn.so.7 -&gt; libmysqlcppconn.so.7.1.1.13</span><br><span class="line">    ├── libmysqlcppconn.so.7.1.1.13</span><br><span class="line">    ├── libssl.so -&gt; libssl.so.1.1</span><br><span class="line">    └── libssl.so.1.1</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>MySQL Connector/C++ 库的使用教程请看 <a href="/posts/c942e1de.html">这里</a>。</li></ul></div><h3 id="连接池的配置参数"><a href="#连接池的配置参数" class="headerlink" title="连接池的配置参数"></a>连接池的配置参数</h3><p>数据库连接池的配置参数格式是 <code>key=value</code>，默认存放在 <code>config</code> 目录下的 <code>mysql.ini</code> 文件中，其配置内容如下所示：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接地址</span></span><br><span class="line"><span class="attr">host</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">3306</span></span><br><span class="line"><span class="comment"># 用户名</span></span><br><span class="line"><span class="attr">username</span>=root</span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line"><span class="attr">password</span>=<span class="number">123456</span></span><br><span class="line"><span class="comment"># 数据库</span></span><br><span class="line"><span class="attr">dbname</span>=cxx_study</span><br><span class="line"><span class="comment"># 初始连接数</span></span><br><span class="line"><span class="attr">initSize</span>=<span class="number">10</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maxSize</span>=<span class="number">100</span></span><br><span class="line"><span class="comment"># 最大空闲时间（单位秒）</span></span><br><span class="line"><span class="attr">maxIdleTime</span>=<span class="number">5</span></span><br><span class="line"><span class="comment"># 连接超时时间（单位毫秒）</span></span><br><span class="line"><span class="attr">connectionTimeout</span>=<span class="number">500</span></span><br></pre></td></tr></tbody></table></figure><h3 id="连接池的-CMake-配置"><a href="#连接池的-CMake-配置" class="headerlink" title="连接池的 CMake 配置"></a>连接池的 CMake 配置</h3><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 CMake 的版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第三方库的目录路径</span></span><br><span class="line"><span class="keyword">set</span>(PATH_TO_BOOST /usr/local/boost)</span><br><span class="line"><span class="keyword">set</span>(PATH_TO_MYSQL_CONNECTOR ./libs/mysql-connector)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目信息</span></span><br><span class="line"><span class="keyword">project</span>(db_connection_pool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 C++ 的版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定构建输出的目录</span></span><br><span class="line"><span class="keyword">set</span>(PROJECT_BINARY_DIR <span class="variable">${PROJECT_SOURCE_DIR}</span>/build)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">${PROJECT_SOURCE_DIR}</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义目标，每次编译之前清理可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(clean_bin ALL</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_COMMAND}</span> -E remove_directory <span class="variable">${EXECUTABLE_OUTPUT_PATH}</span></span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_COMMAND}</span> -E <span class="keyword">make_directory</span> <span class="variable">${EXECUTABLE_OUTPUT_PATH}</span></span><br><span class="line">        COMMENT <span class="string">"Cleaning bin directory before build"</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义命令，每次编译之前拷贝 MySQL 配置文件到可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">        <span class="keyword">TARGET</span> clean_bin</span><br><span class="line">        POST_BUILD</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_COMMAND}</span> -E copy_if_different</span><br><span class="line">        <span class="variable">${CMAKE_SOURCE_DIR}</span>/config/mysql.ini</span><br><span class="line">        <span class="variable">${EXECUTABLE_OUTPUT_PATH}</span>/mysql.ini</span><br><span class="line">        COMMENT <span class="string">"Copying mysql.ini to bin directory before build"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入项目里的头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${PROJECT_SOURCE_DIR}</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索项目里的源文件，并将文件名保存到 MAIN_SOURCES 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">${PROJECT_SOURCE_DIR}</span>/src MAIN_SOURCES)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入第三方库的头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${PATH_TO_BOOST}</span>/<span class="keyword">include</span> <span class="variable">${PATH_TO_MYSQL_CONNECTOR}</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定项目里静态库和动态链接库的目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">${PATH_TO_BOOST}</span>/lib <span class="variable">${PATH_TO_MYSQL_CONNECTOR}</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的名称和项目里的所有源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">${PROJECT_NAME}</span>_test <span class="variable">${MAIN_SOURCES}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译参数，比如包括链接库文件：pthread、ssl、crypto、boost</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"-lpthread -lssl -lcrypto -lboost_system -lboost_filesystem"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接项目里的静态库和动态链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">${PROJECT_NAME}</span>_test ssl.so crypto.so mysqlcppconn.so)</span><br></pre></td></tr></tbody></table></figure><h3 id="连接池的-C-头文件"><a href="#连接池的-C-头文件" class="headerlink" title="连接池的 C++ 头文件"></a>连接池的 C++ 头文件</h3><ul><li><code>public.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LOG(format, ...) printf(format, __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LOG(format, ...) printf(format, ##__VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>MysqlConnection.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MySQL 增删改查操作的定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql_connection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/driver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/exception.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/resultset.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/statement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/prepared_statement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> chrono::system_clock::time_point time_point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 数据库操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlConnection</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MysqlConnection</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MysqlConnection</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;ResultSet&gt; <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *query, <span class="keyword">const</span> vector&lt;string&gt; parameters)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">const</span> string host, <span class="keyword">const</span> string username, <span class="keyword">const</span> string password, <span class="keyword">const</span> string dbname)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refreshAliveTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getAliveTime</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _host;                           <span class="comment">// MySQL 连接地址</span></span><br><span class="line">    string _username;                       <span class="comment">// MySQL 用户名</span></span><br><span class="line">    string _password;                       <span class="comment">// MySQL 密码</span></span><br><span class="line">    string _dbname;                         <span class="comment">// MySQL 数据库</span></span><br><span class="line">    Driver *_driver;                        <span class="comment">// MySQL 驱动</span></span><br><span class="line">    Connection *_connection;                <span class="comment">// MySQL 连接</span></span><br><span class="line">    time_point _aliveTime;                  <span class="comment">// 记录连接进入空闲状态后的起始存活时间点</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>MysqlConnectionPool.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MySQL 连接池的定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnection.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 连接池类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlConnectionPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MysqlConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断连接池是否已关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isClosed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接池中的连接数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接池单例</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MysqlConnectionPool *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 MySQL 连接</span></span><br><span class="line">    <span class="function">shared_ptr&lt;MysqlConnection&gt; <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="built_in">MysqlConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MysqlConnectionPool</span>(<span class="keyword">const</span> MysqlConnectionPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    MysqlConnectionPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MysqlConnectionPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">loadConfigFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产 MySQL 连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描多余的空闲连接，并释放连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scanIdleConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">static</span> MysqlConnectionPool *INSTANCE;</span><br><span class="line"></span><br><span class="line">    string _host;             <span class="comment">// MySQL 连接地址</span></span><br><span class="line">    string _username;         <span class="comment">// MySQL 用户名</span></span><br><span class="line">    string _password;         <span class="comment">// MySQL 密码</span></span><br><span class="line">    string _dbname;           <span class="comment">// MySQL 数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _initSize;            <span class="comment">// 初始连接数</span></span><br><span class="line">    <span class="keyword">int</span> _maxSize;             <span class="comment">// 最大连接数</span></span><br><span class="line">    <span class="keyword">int</span> _maxIdleTime;         <span class="comment">// 最大空闲时间（单位秒）</span></span><br><span class="line">    <span class="keyword">int</span> _connectionTimeout;   <span class="comment">// 连接超时时间（单位毫秒）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">atomic_int</span> _connectionCount;                 <span class="comment">// MySQL 连接的总数量</span></span><br><span class="line">    queue&lt;MysqlConnection *&gt; _connectionQueue;   <span class="comment">// 存储 MySQL 连接的队列</span></span><br><span class="line">    mutex _queueMutex;                           <span class="comment">// 维护 MySQL 连接队列线程安全的互斥锁</span></span><br><span class="line">    condition_variable _cv;                      <span class="comment">// 条件变量，用于连接生产者线程和连接消费者线程之间的通信</span></span><br><span class="line">    <span class="keyword">atomic_bool</span> _closed;                         <span class="comment">// 连接池是否已关闭</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="连接池的-C-源文件"><a href="#连接池的-C-源文件" class="headerlink" title="连接池的 C++ 源文件"></a>连接池的 C++ 源文件</h3><ul><li><code>MysqlConnection.cpp</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnection.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">MysqlConnection::<span class="built_in">MysqlConnection</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MysqlConnection::~<span class="built_in">MysqlConnection</span>() {</span><br><span class="line">    <span class="comment">// 关闭数据连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection &amp;&amp; !<span class="keyword">this</span>-&gt;_connection-&gt;<span class="built_in">isClosed</span>()) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;_connection-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;_connection = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// LOG("# DE<span class="doctag">BUG:</span> %s\n", "Closed mysql connection");</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行任何 SQL 语句，返回一个 bool 值，表明执行该 SQL 语句是否返回了 ResultSet</span></span><br><span class="line"><span class="comment">// 如果执行后第一个结果是 ResultSet，则返回 true，否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnection::execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="function">unique_ptr&lt;Statement&gt; <span class="title">statement</span><span class="params">(<span class="keyword">this</span>-&gt;_connection-&gt;createStatement())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (statement) {</span><br><span class="line">                <span class="keyword">return</span> statement-&gt;<span class="built_in">execute</span>(sql);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE</span></span><br><span class="line"><span class="comment">// 函数的返回值是一个整数，指示受影响的行数，对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，返回值总为零</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MysqlConnection::executeUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="function">unique_ptr&lt;Statement&gt; <span class="title">statement</span><span class="params">(<span class="keyword">this</span>-&gt;_connection-&gt;createStatement())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (statement) {</span><br><span class="line">                <span class="keyword">return</span> statement-&gt;<span class="built_in">executeUpdate</span>(sql);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 SQL 的预编译机制，执行查询单个结果集（ResultSet）的 SQL 语句，例如 SELECT 语句</span></span><br><span class="line"><span class="function">unique_ptr&lt;ResultSet&gt; <span class="title">MysqlConnection::query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql, <span class="keyword">const</span> vector&lt;string&gt; parameters)</span> </span>{</span><br><span class="line">    unique_ptr&lt;ResultSet&gt; resultSet = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="function">unique_ptr&lt;PreparedStatement&gt; <span class="title">statement</span><span class="params">(<span class="keyword">this</span>-&gt;_connection-&gt;prepareStatement(sql))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (statement) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> iterator = parameters.<span class="built_in">cbegin</span>(); iterator != parameters.<span class="built_in">cend</span>(); iterator++) {</span><br><span class="line">                    index++;</span><br><span class="line">                    statement-&gt;<span class="built_in">setString</span>(index, (*iterator).<span class="built_in">c_str</span>());</span><br><span class="line">                }</span><br><span class="line">                resultSet.<span class="built_in">reset</span>(statement-&gt;<span class="built_in">executeQuery</span>());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> resultSet;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接 MySQL 数据库</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnection::connect</span><span class="params">(<span class="keyword">const</span> string host, <span class="keyword">const</span> string username, <span class="keyword">const</span> string password, <span class="keyword">const</span> string dbname)</span> </span>{</span><br><span class="line">    <span class="comment">// 初始化MySQL的连接信息</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_host = <span class="string">"tcp://"</span> + host;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_username = username;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_password = password;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_dbname = dbname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获取数据库驱动，返回的是单例对象，由 MySQL Connector/C++ 管理，不需要手动释放资源（delete）</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_driver = <span class="built_in">get_driver_instance</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;_driver) {</span><br><span class="line">            <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to load mysql _driver"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接MySQL实例</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_connection = _driver-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;_host.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;_username.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;_password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to connect mysql server"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 设置默认数据库</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_connection-&gt;<span class="built_in">setSchema</span>(<span class="keyword">this</span>-&gt;_dbname.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="comment">// LOG("# DE<span class="doctag">BUG:</span> %s\n", "Inited mysql connection");</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnection::refreshAliveTime</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;_aliveTime = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取连接的空闲存活时间（单位毫秒）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">MysqlConnection::getAliveTime</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    chrono::milliseconds active_timestamp_ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(<span class="keyword">this</span>-&gt;_aliveTime.<span class="built_in">time_since_epoch</span>());</span><br><span class="line">    chrono::milliseconds now_timestamp_ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>());</span><br><span class="line">    <span class="keyword">return</span> now_timestamp_ms.<span class="built_in">count</span>() - active_timestamp_ms.<span class="built_in">count</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>MysqlConnectionPool.cpp</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnectionPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = boost::filesystem;</span><br><span class="line"></span><br><span class="line">MysqlConnectionPool::<span class="built_in">MysqlConnectionPool</span>() : _connectionCount(<span class="number">0</span>), _closed(<span class="literal">false</span>) {</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">loadConfigFile</span>()) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to load config file mysql.ini"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始化数量的 MySQL 连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;_initSize; i++) {</span><br><span class="line">        MysqlConnection *connection = <span class="keyword">new</span> <span class="built_in">MysqlConnection</span>();</span><br><span class="line">        <span class="comment">// 连接数据库</span></span><br><span class="line">        <span class="keyword">bool</span> connected = connection-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;_host, <span class="keyword">this</span>-&gt;_username, <span class="keyword">this</span>-&gt;_password, <span class="keyword">this</span>-&gt;_dbname);</span><br><span class="line">        <span class="comment">// 判断是否连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (connected) {</span><br><span class="line">            <span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span><br><span class="line">            connection-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line">            <span class="comment">// 入队操作</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">push</span>(connection);</span><br><span class="line">            <span class="comment">// 计数器加一</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_connectionCount++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后台启动 MySQL 连接的生产者线程</span></span><br><span class="line">    <span class="function">thread <span class="title">produce</span><span class="params">(bind(&amp;MysqlConnectionPool::produceConnection, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">    produce.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后台启动一个扫描线程，定时扫描多余的空闲连接，并释放连接</span></span><br><span class="line">    <span class="function">thread <span class="title">scan</span><span class="params">(bind(&amp;MysqlConnectionPool::scanIdleConnection, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">    scan.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">MysqlConnectionPool::~<span class="built_in">MysqlConnectionPool</span>() {</span><br><span class="line">    <span class="comment">// 关闭连接池，释放所有连接</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MysqlConnectionPool *<span class="title">MysqlConnectionPool::getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnectionPool::loadConfigFile</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 配置文件的路径</span></span><br><span class="line">    fs::path configPath = fs::<span class="built_in">current_path</span>().<span class="built_in">concat</span>(<span class="string">"/mysql.ini"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    FILE *file = <span class="built_in">fopen</span>(configPath.<span class="built_in">c_str</span>(), <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s %s\n"</span>, configPath.<span class="built_in">c_str</span>(), <span class="string">"file is not exist"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">"======== mysql.ini ========\n"</span>)</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">feof</span>(file)) {</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">fgets</span>(buffer, <span class="number">1024</span>, file);</span><br><span class="line">        string line = buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置格式：username=root</span></span><br><span class="line">        <span class="keyword">int</span> index = line.<span class="built_in">find</span>(<span class="string">'='</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无效配置项</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> endIndex = line.<span class="built_in">find</span>(<span class="string">'\n'</span>, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理配置项</span></span><br><span class="line">        string key = line.<span class="built_in">substr</span>(<span class="number">0</span>, index);</span><br><span class="line">        string value = line.<span class="built_in">substr</span>(index + <span class="number">1</span>, endIndex - index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="string">"host"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_host = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"username"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_username = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"password"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_password = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"dbname"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_dbname = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"initSize"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_initSize = <span class="built_in">stoi</span>(value);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"maxSize"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_maxSize = <span class="built_in">stoi</span>(value);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"maxIdleTime"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_maxIdleTime = <span class="built_in">stoi</span>(value);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"connectionTimeout"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_connectionTimeout = <span class="built_in">stoi</span>(value);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"%s=%s\n"</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">"======== mysql.ini ========\n\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnectionPool::close</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 判断连接池是否已关闭</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关闭状态</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>())) {</span><br><span class="line">        <span class="comment">// 获取队头的连接</span></span><br><span class="line">        MysqlConnection *phead = <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 出队操作</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 计数器减一</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_connectionCount--;</span><br><span class="line">        <span class="comment">// 释放连接占用的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span> phead;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnectionPool::isClosed</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_closed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MysqlConnectionPool::getSize</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_connectionCount;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;MysqlConnection&gt; <span class="title">MysqlConnectionPool::getConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Connection pool has closed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 While 循环来避免线程虚假唤醒</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 如果连接队列为空，则等待指定的时间</span></span><br><span class="line">        cv_status status = <span class="keyword">this</span>-&gt;_cv.<span class="built_in">wait_for</span>(lock, chrono::<span class="built_in">milliseconds</span>(<span class="keyword">this</span>-&gt;_connectionTimeout));</span><br><span class="line">        <span class="keyword">if</span> (cv_status::timeout == status) {</span><br><span class="line">            <span class="comment">// 如果等待超时，再次判断连接队列是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to get connection, queue is empty"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队头的连接，并返回智能指针，同时自定义智能指针释放资源的方式，将连接归还到队列中</span></span><br><span class="line">    <span class="function">shared_ptr&lt;MysqlConnection&gt; <span class="title">sp</span><span class="params">(<span class="keyword">this</span>-&gt;_connectionQueue.front(), [&amp;](MysqlConnection *pcon) -&gt; <span class="keyword">void</span> {</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 获取互斥锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        unique_lock&lt;mutex&gt; lock(<span class="keyword">this</span>-&gt;_queueMutex);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span></span></span><br><span class="line"><span class="params"><span class="function">        pcon-&gt;refreshAliveTime();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 入队操作（将连接归还到队列中）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span>-&gt;_connectionQueue.push(pcon);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 计数器加一</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span>-&gt;_connectionCount++;</span></span></span><br><span class="line"><span class="params"><span class="function">    })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器减一</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_connectionCount--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 如果连接队列为空，则通知生产线程生产连接</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnectionPool::produceConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 While 循环来避免线程虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (!(<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>())) {</span><br><span class="line">            <span class="comment">// 如果连接队列不为空，生产者线程进入等待状态</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当连接数量没有达到上限，继续创建新的连接</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connectionCount &lt; <span class="keyword">this</span>-&gt;_maxSize) {</span><br><span class="line">            MysqlConnection *connection = <span class="keyword">new</span> <span class="built_in">MysqlConnection</span>();</span><br><span class="line">            <span class="comment">// 连接数据库</span></span><br><span class="line">            <span class="keyword">bool</span> connected = connection-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;_host, <span class="keyword">this</span>-&gt;_username, <span class="keyword">this</span>-&gt;_password, <span class="keyword">this</span>-&gt;_dbname);</span><br><span class="line">            <span class="comment">// 判断是否连接成功</span></span><br><span class="line">            <span class="keyword">if</span> (connected) {</span><br><span class="line">                <span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span><br><span class="line">                connection-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line">                <span class="comment">// 入队操作</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">push</span>(connection);</span><br><span class="line">                <span class="comment">// 计数器加一</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionCount++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者线程可以消费连接了</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnectionPool::scanIdleConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="comment">// 模拟定时扫描连接的效果</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="keyword">this</span>-&gt;_maxIdleTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 While 循环来避免线程虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;_connectionCount &lt;= <span class="keyword">this</span>-&gt;_initSize) {</span><br><span class="line">            <span class="comment">// 如果当前的连接总数量小于等于初始连接数量，扫描线程进入等待状态</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前的连接总数量是否大于初始连接数量</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;_connectionCount &gt; <span class="keyword">this</span>-&gt;_initSize) {</span><br><span class="line">            <span class="comment">// 扫描队头的连接是否超过最大空闲时间</span></span><br><span class="line">            MysqlConnection *phead = <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (phead-&gt;<span class="built_in">getAliveTime</span>() &gt;= <span class="keyword">this</span>-&gt;_maxIdleTime) {</span><br><span class="line">                <span class="comment">// 出队操作</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 计数器减一</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionCount--;</span><br><span class="line">                <span class="comment">// 释放连接占用的内存空间</span></span><br><span class="line">                <span class="keyword">delete</span> phead;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 如果队头的连接没有超过最大空闲时间，那么其他连接肯定也没有超过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化单例对象</span></span><br><span class="line">MysqlConnectionPool *MysqlConnectionPool::INSTANCE = <span class="keyword">new</span> <span class="built_in">MysqlConnectionPool</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="连接池的代码测试"><a href="#连接池的代码测试" class="headerlink" title="连接池的代码测试"></a>连接池的代码测试</h2><div class="admonition note"><p class="admonition-title">提示</p><p>本文的所有 C++ 代码都已经在 Linux 平台下编译并测试通过（基于 Clion 与 G++ 编译器），由于笔者的技术水平有限，暂时无法保证代码没有潜在的 Bug，因此所有 C++ 代码仅供学习参考。</p></div><ul><li>用于创建测试数据库的 SQL 语句 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `cxx_study`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `cxx_study` <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> UTF8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line">USE `cxx_study`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 创建数据库表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `properties`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `properties` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `KEY` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `<span class="keyword">VALUE</span>` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `REMARK` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">27</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 往数据库表插入数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_number'</span>, <span class="string">'430'</span>, <span class="string">'Limit Number'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_balance'</span>, <span class="string">'929.32'</span>, <span class="string">'Limit Balance'</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>用于测试的 C++ 代码（<code>test.cpp</code>）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnection.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnectionPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQuerySingleThread</span><span class="params">()</span> </span>{</span><br><span class="line">    MysqlConnection *connection = <span class="keyword">new</span> <span class="built_in">MysqlConnection</span>();</span><br><span class="line">    connection-&gt;<span class="built_in">connect</span>(<span class="string">"192.168.56.112:3307"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>, <span class="string">"cxx_study"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个线程查询记录</span></span><br><span class="line">    <span class="keyword">const</span> string querySql = <span class="string">"select * from properties where `KEY` = ?"</span>;</span><br><span class="line">    unique_ptr&lt;ResultSet&gt; result = connection-&gt;<span class="built_in">query</span>(querySql.<span class="built_in">c_str</span>(), {<span class="string">"test_limit_number"</span>});</span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Query: "</span> &lt;&lt; querySql &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span> (result-&gt;<span class="built_in">next</span>()) {</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getInt</span>(<span class="string">"ID"</span>) &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"KEY"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"VALUE"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"REMARK"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> connection;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testConnectionPoolSingleThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> string insertSql = <span class="string">"INSERT INTO `properties` (`KEY`, `VALUE`, `REMARK`) VALUES ('test_limit_price', '30.5', 'Limit Price')"</span>;</span><br><span class="line">    MysqlConnectionPool *pool = MysqlConnectionPool::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个线程插入多条记录</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1500</span>; i++) {</span><br><span class="line">        shared_ptr&lt;MysqlConnection&gt; connection = pool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">executeUpdate</span>(insertSql.<span class="built_in">c_str</span>());</span><br><span class="line">        cout &lt;&lt; <span class="string">"Insert "</span> &lt;&lt; i &lt;&lt; <span class="string">" record, current pool size: "</span> &lt;&lt; pool-&gt;<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计执行耗时</span></span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>, milli&gt; elapsed_time = end_time - start_time;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Total Times: "</span> &lt;&lt; elapsed_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pool;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testConnectionPoolMultiThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num_threads = <span class="number">15</span>;</span><br><span class="line">    thread threads[num_threads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> string insertSql = <span class="string">"INSERT INTO `properties` (`KEY`, `VALUE`, `REMARK`) VALUES ('test_limit_price', '30.5', 'Limit Price')"</span>;</span><br><span class="line">    MysqlConnectionPool *pool = MysqlConnectionPool::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个线程插入多条记录</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) {</span><br><span class="line">        threads[i] = <span class="built_in">thread</span>([&amp;, i]() {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">100</span>; n++) {</span><br><span class="line">                shared_ptr&lt;MysqlConnection&gt; connection = pool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">                connection-&gt;<span class="built_in">executeUpdate</span>(insertSql.<span class="built_in">c_str</span>());</span><br><span class="line">                cout &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; i &lt;&lt; <span class="string">", current pool size: "</span> &lt;&lt; pool-&gt;<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) {</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计执行耗时</span></span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>, milli&gt; elapsed_time = end_time - start_time;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Total Times: "</span> &lt;&lt; elapsed_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一段时间，触发数据库连接池回收空闲连接</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Waiting to collect idle connection..."</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"Pool final size: "</span> &lt;&lt; pool-&gt;<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pool;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 不使用数据库连接池，单个线程查询记录</span></span><br><span class="line">    <span class="comment">// testQuerySingleThread();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数据库连接池，单个线程插入多条记录</span></span><br><span class="line">    <span class="comment">// testConnectionPoolSingleThread();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数据库连接池，多个线程插入多条记录</span></span><br><span class="line">    <span class="built_in">testConnectionPoolMultiThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞主线程，直到用户按下任意键才结束程序</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>编译测试代码，生成并运行可执行测试程序 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-db-connection-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译构建生成可执行测试程序</span></span><br><span class="line">cmake -S . -B build &amp;&amp; cmake --build build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行测试程序</span></span><br><span class="line">./bin/db_connection_pool_test</span><br></pre></td></tr></tbody></table></figure><h2 id="连接池的调试技巧"><a href="#连接池的调试技巧" class="headerlink" title="连接池的调试技巧"></a>连接池的调试技巧</h2><p>在开发数据库连接池项目的时候，会经常出现问题，也就是 MySQL API 调用出错，提示 Insert、Delete、Update 等操作执行失败，或者连接 MySQL Server 失败等，很多人不知道遇到这个问题该怎么办？</p><h3 id="MySQL-C-API-调试"><a href="#MySQL-C-API-调试" class="headerlink" title="MySQL C API 调试"></a>MySQL C API 调试</h3><p>当使用的是 <a href="/posts/c942e1de.html#MySQL-C-API-%E4%BB%8B%E7%BB%8D">MySQL C API</a>（Connector/C）库，可以使用以下两个函数打印出错时的提示信息：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>int mysql_errno(MYSQL *)</code></td><td>返回上次调用的 MySQL 函数的错误编号。</td></tr><tr><td><code>const char* mysql_error(MYSQL *)</code></td><td>返回上次调用的 MySQL 函数的错误消息。</td></tr></tbody></table><p>无论是 Insert 错误还是其它错误，都可以在代码上通过添加 <code>mysql_error</code> 函数打印错误提示信息（如下所示）。一般通过查看提示就可以知道是什么错误了，例如权限问题，但大部分都是细节错误，比如字段不对、类型不对、表名不对等。</p><p><img data-src="../../../asset/2025/02/cxx-mysql-debug.png"></p><h3 id="MySQL-Connector-C-调试"><a href="#MySQL-Connector-C-调试" class="headerlink" title="MySQL Connector/C++ 调试"></a>MySQL Connector/C++ 调试</h3><p>当使用的是 <a href="/posts/c942e1de.html#MySQL-Connector-C-%E4%BB%8B%E7%BB%8D">MySQL Connector/C++</a>（JDBC-Style API）库，可以通过异常来获取错误信息：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="function">unique_ptr&lt;sql::Connection&gt; <span class="title">conn</span><span class="params">(driver-&gt;connect(<span class="string">"tcp://127.0.0.1:3306"</span>, <span class="string">"user"</span>, <span class="string">"password"</span>))</span></span>;</span><br><span class="line">    conn-&gt;<span class="built_in">setSchema</span>(<span class="string">"test_db"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;sql::Statement&gt; <span class="title">stmt</span><span class="params">(conn-&gt;createStatement())</span></span>;</span><br><span class="line">    stmt-&gt;<span class="built_in">execute</span>(<span class="string">"INVALID SQL STATEMENT"</span>); <span class="comment">// 故意执行错误的 SQL</span></span><br><span class="line">} <span class="built_in"><span class="keyword">catch</span></span> (sql::SQLException &amp;e) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"Error Code: "</span> &lt;&lt; e.<span class="built_in">getErrorCode</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"SQL State: "</span> &lt;&lt; e.<span class="built_in">getSQLState</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Message: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过 <code>e.getErrorCode()</code> 获取错误码，<code>e.getSQLState()</code> 获取 SQL 状态码，而 <code>e.what()</code> 获取详细的错误信息。</p><div class="admonition note"><p class="admonition-title">提示</p><p>如果使用的是 MySQL X DevAPI，错误提示信息同样可以通过异常处理来获取得到。</p></div><h2 id="MySQL-的参数调整"><a href="#MySQL-的参数调整" class="headerlink" title="MySQL 的参数调整"></a>MySQL 的参数调整</h2><p>以下命令可以查看和设置 MySQL Server 所支持的最大连接数，当超过 <code>max_connections</code> 数量的连接，MySQL Server 会直接拒绝。因此，在使用数据库连接池增加 MySQL 连接数量的时候，MySQL Server 的 <code>max_connections</code> 参数也要适当地进行调整，以适配数据库连接池的最大连接数（<code>maxSize</code>），否则会大大影响数据库连接池的运行效果。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询MySQL的最大连接数</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">'max_connections'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全局设置MySQL的最大连接数（立即生效，但数据库重启后失效）</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_connections <span class="operator">=</span> <span class="number">200</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="连接池的压力测试"><a href="#连接池的压力测试" class="headerlink" title="连接池的压力测试"></a>连接池的压力测试</h2><p>验证数据库的插入操作所花费的时间，第一次测试使用普通的数据库访问操作，第二次测试使用带连接池的数据库访问操作，对比两次操作同样数据量所花费的时间，性能压力测试结果如下：</p><table><thead><tr><th>数据量</th><th>未使用连接池所花费时间</th><th>使用连接池所花费时间</th></tr></thead><tbody><tr><td> 1000</td><td> 单线程：1891ms，四线程：497ms</td><td> 单线程：1079ms，四线程：408ms</td></tr><tr><td>5000</td><td> 单线程：10033ms，四线程：2361ms</td><td> 单线程: 5380ms，四线程：2041ms</td></tr><tr><td>10000</td><td> 单线程：19403ms，四线程：4589ms</td><td> 单线程：10522ms，四线程：4034ms</td></tr></tbody></table><h2 id="连接池的代码下载"><a href="#连接池的代码下载" class="headerlink" title="连接池的代码下载"></a>连接池的代码下载</h2><ul><li>数据库连接池项目的完整代码（包括 MySQL Connector/C++ 的头文件和动态链接库）可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-project-db-connection-pool">这里</a> 下载得到，由于笔者的技术水平有限，暂时无法保证代码没有潜在的 Bug，因此所有 C++ 代码仅供学习参考。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/a2a7ad9b.html">C++ 多线程编程之一</a></li><li><a href="/posts/841eca80.html">Linux 系统编程之四多线程编程</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 如何实现 MySQL 数据库连接池。</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
</feed>
