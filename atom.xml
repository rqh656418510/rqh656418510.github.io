<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术空间</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2025-11-01T13:55:33.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 C++ 手写 Muduo 高性能网络库</title>
    <link href="https://www.techgrow.cn/posts/dbb10768.html"/>
    <id>https://www.techgrow.cn/posts/dbb10768.html</id>
    <published>2025-11-01T13:55:33.000Z</published>
    <updated>2025-11-01T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写 Muduo 高性能网络库</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将改造 C++ 高性能网络库 <a href="https://github.com/chenshuo/muduo">Muduo</a>，比如去掉 Boost 依赖，并使用 C++ 11 进行代码重构，重点是学习 Muduo 的底层设计思想。</p><span id="more"></span><h3 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h3><ul><li>1、理解阻塞、非阻塞、同步、异步</li><li> 2、理解 Unix/Linux 上的五种 I/O 模型</li><li> 3、epoll 的原理以及优势</li><li> 4、深刻理解 Reactor 模型</li><li> 5、从开源 C++ 网络库 Muduo，学习优秀的代码设计</li><li> 6、掌握基于事件驱动和事件回调的 epoll + 线程池的面向对象编程</li><li> 7、通过深入理解 Muduo 源码，加深对于相关项目的深刻理解</li><li> 8、改造 Muduo，不依赖 Boost，使用 C++ 11 进行代码重构</li></ul><h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><p>在开发高性能的网路库之前，要求先掌握以下前置知识：</p><ul><li>1、TCP 协议和 UDP 协议</li><li> 2、Linux 的 TCP 网络编程和 UDP 网络编程</li><li> 3、I/O 多路复用编程，包括 select、poll、epoll 库的使用</li><li> 4、Linux 的多线程编程（<code>pthread</code>）、进程和线程模型</li><li> 5、C++ 20 标准新加入的协程支持</li></ul><div class="admonition note"><p class="admonition-title">推荐阅读的书籍</p><p>《UNIX 环境高级编程》、《Linux 高性能服务器编程》、《 Linux 多线程服务端编程 - 使用 Muduo C++ 网络库》《鸟哥的 Linux 私房菜》</p></div><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><table><thead><tr><th>软件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>11</code></td><td>C++ 标准的版本</td></tr><tr><td> G++（GCC）</td><td><code>12.2.0</code></td><td>建议使用 <code>9</code> 版本的 G++（GCC） 编译器</td></tr><tr><td> CMake</td><td><code>3.25.1</code></td><td>C/C++ 项目构建工具</td></tr><tr><td> Linux</td><td><code>Debian 12</code></td><td>Muduo 库不支持 Windows 平台</td></tr><tr><td> Visual Studio Code</td><td><code>1.100.2</code></td><td>使用 VSCode 远程开发特性</td></tr></tbody></table><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="阻塞、非阻塞、同步、异步"><a href="#阻塞、非阻塞、同步、异步" class="headerlink" title="阻塞、非阻塞、同步、异步"></a>阻塞、非阻塞、同步、异步</h3><div class="admonition note"><p class="admonition-title">提示</p><ul><li>下面提到的 "I/O 操作" 并不局限于网络 I/O，而是一个广义的 I/O 概念，它既包含网络 I/O（Socket 读写），也包含磁盘 I/O（文件读写）等所有涉及内核态与用户态之间数据交换的操作。</li><li>I/O 模型（如阻塞、非阻塞、同步、异步）更多用于讨论网络 I/O，原因是磁盘 I/O 的异步化由操作系统内核自动管理（页缓存 + 异步调度），应用层很少直接干预。</li></ul></div><ul><li><p>同步与异步的区别</p><ul><li>同步：<ul><li>请求方 A 发起 I/O 调用后，由 A 自身完成数据的读写；</li><li>无论阻塞与否，A 都要亲自执行读写操作。</li></ul></li><li>异步：<ul><li>请求方 A 发起 I/O 调用后，仅仅发出请求，并由操作系统内核来完成数据的读写；</li><li>A 不需要等待操作完成，可以继续做其他事情；当操作系统内核完成读写操作后，会通过回调、事件通知等机制通知 A 结果。</li></ul></li></ul></li><li><p>阻塞与非阻塞的区别</p><ul><li>阻塞：<ul><li>调用未完成前，调用线程会一直等待；</li></ul></li><li>非阻塞：<ul><li>调用立即返回，即使操作未完成，也会返回错误码或状态提示（例如 <code>EAGAIN</code>）。</li></ul></li></ul></li><li><p>典型的一次 I/O 操作可以分为两个阶段</p><ul><li>数据准备（阶段一）：该阶段取决于系统 I/O 操作的就绪状态，即数据是否已经可以被读写<ul><li>阻塞：调用会等待数据准备好后再继续执行。</li><li>非阻塞：调用会立即返回，无论数据是否就绪。</li></ul></li><li>数据读写（阶段二）：该阶段取决于应用程序与操作系统内核之间的交互方式<ul><li>同步：由应用程序主动完成数据的读写，将数据从内核缓冲区拷贝到用户空间（或反之）。</li><li>异步：由操作系统内核完成数据的读写，并在操作完成后通知应用程序。</li></ul></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">总结</p><ul><li>同步 / 异步区分的是谁来完成 I/O 操作（调用方自己还是操作系统内核来完成数据读写）。</li><li>阻塞 / 非阻塞区分的是调用方等待的方式（是否挂起等待处理结果）。</li></ul></div><blockquote><p><strong>常见的四种 I/O 模型</strong></p></blockquote><table><thead><tr><th>I/O 模型</th><th>数据准备阶段</th><th>数据读写阶段</th><th>调用方行为</th><th>示例说明</th></tr></thead><tbody><tr><td>同步阻塞</td><td>阻塞等待数据准备好</td><td>调用方执行读写</td><td>整个过程会阻塞当前线程</td><td><code>int size = recv(fd, buf, 1024, 0);</code>（若无数据则阻塞等待）</td></tr><tr><td>同步非阻塞</td><td>非阻塞轮询数据准备好</td><td>调用方执行读写</td><td>调用立即返回，但需要反复尝试调用</td><td>设置 <code>O_NONBLOCK</code>，多次调用 <code>recv()</code> 检查是否有数据可读</td></tr><tr><td>异步阻塞</td><td>阻塞等待事件完成</td><td>操作系统内核完成读写</td><td>等待通知，但数据读写由操作系统内核完成</td><td>例如 Windows <code>OVERLAPPED</code> I/O + <code>GetOverlappedResult</code> 阻塞等待</td></tr><tr><td>异步非阻塞</td><td>非阻塞提交请求</td><td>操作系统内核完成读写并通知</td><td>完全不阻塞，结果通过回调 / 事件返回</td><td>例如 Linux <code>aio_read()</code> 或 <code>io_uring</code> 提交请求后立即返回</td></tr></tbody></table><blockquote><p><strong>陈硕大神的原话：在处理 I/O 的时候，阻塞和非阻塞都是同步 I/O，只有使用了特殊的 API 才是异步 I/O（如下图所示）。</strong></p></blockquote><p><img data-src="../../../asset/2025/11/cplusplus-muduo-1.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li><code>select</code> / <code>poll</code> / <code>epoll</code> 本身只是事件就绪通知机制，它们并不直接完成数据读写，调用它们的线程仍然需要自己去 <code>read()</code> 或 <code>write()</code> 数据。</li><li>因此，从严格意义上看，它们属于同步 I/O 实现方式，因为最终的 I/O 读写（即数据读写）（即数据读写）是由调用线程自己完成的。</li><li>但它们提供了非阻塞的事件等待，使得线程可以同时监听多个 <code>fd</code>，而不用一个线程阻塞在一个 <code>fd</code> 上。</li><li>真正的异步 I/O 实现，在 Linux 上需要使用 <code>aio_*</code> 系列系统函数或者使用 <code>io_uring</code>。</li></ul></div><h3 id="Unix-Linux-的五种-I-O-模型"><a href="#Unix-Linux-的五种-I-O-模型" class="headerlink" title="Unix/Linux 的五种 I/O 模型"></a>Unix/Linux 的五种 I/O 模型</h3><p>Unix/Linux 支持以下五种 I/O 模型：</p><table><thead><tr><th>I/O 模型</th><th>阻塞 / 非阻塞</th><th>事件通知方式</th><th>适用场景</th></tr></thead><tbody><tr><td>阻塞 I/O</td><td> 阻塞</td><td>同步返回</td><td>简单程序，低并发</td></tr><tr><td>非阻塞 I/O</td><td> 非阻塞</td><td>轮询</td><td>少量 I/O，CPU 可支撑</td></tr><tr><td> I/O 多路复用</td><td>阻塞或非阻塞</td><td>操作系统内核返回就绪事件列表</td><td>高并发网络服务器</td></tr><tr><td>信号驱动 I/O</td><td> 非阻塞</td><td>信号</td><td>小规模异步通知</td></tr><tr><td>异步 I/O</td><td> 非阻塞</td><td>回调 / 事件</td><td>高并发、对延迟敏感场景</td></tr></tbody></table><blockquote><p><strong>阻塞 I/O（Blocking I/O）</strong></p></blockquote><ul><li>特征：应用程序调用 I/O 函数后，如果数据未就绪，调用线程会被阻塞，直到数据准备完成。</li><li>优点：编程实现简单、逻辑直观。</li><li>缺点：线程无法同时处理多个 I/O，吞吐量受限。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-2.png"></p><blockquote><p><strong>非阻塞 I/O（Non-Blocking I/O）</strong></p></blockquote><ul><li>特征：I/O 调用立即返回，即使数据未就绪也不会阻塞。应用程序需要通过轮询（Polling）或循环检查，目的是不断检测数据是否已经就绪，以便及时进行数据读写操作。</li><li>优点：单线程可以处理多个 I/O。</li><li>缺点：轮询会浪费 CPU 资源，逻辑较复杂。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-3.png"></p><blockquote><p><strong>I/O 多路复用（I/O Multiplexing）</strong></p></blockquote><ul><li>典型机制：<code>select</code>、<code>poll</code>、<code>epoll</code>。</li><li>特征：单个线程可以同时监听多个 <code>fd</code>，通过操作系统内核返回就绪事件列表，再进行读写操作。</li><li>优点：高效管理大量并发连接，避免轮询浪费。</li><li>缺点：处理非常大量 <code>fd</code> 时，某些实现（如 <code>select</code>、<code>poll</code>）效率有限。</li><li>注意：在 I/O 多路复用中，复用的线程而不是 TCP 连接。由于最终的 I/O 读写（即数据读写）是由调用线程自己完成的，因此从严格意义上看，I/O 多路复用属于同步 I/O 实现方式。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-4.png"></p><blockquote><p><strong>信号驱动 I/O（Signal-Driven I/O）</strong></p></blockquote><ul><li>特征：应用程序注册信号处理函数（如 <code>SIGIO</code>），当 <code>fd</code> 可读或可写时，操作系统内核发送信号通知。</li><li>优点：异步通知，无需轮询。</li><li>缺点：信号处理复杂，信号丢失或竞态问题较多，不易大规模使用。</li><li>注意：操作系统内核在第一个阶段（数据准备）是异步，在第二个阶段（数据读写）是同步；与非阻塞 I/O 的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统 API 的调用次数，提高了效率。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-5.png"></p><blockquote><p><strong>异步 I/O（Asynchronous I/O）</strong></p></blockquote><ul><li>特征：应用程序发起 I/O 调用后，立即返回；当数据准备好后，由操作系统内核完成数据读写；当数据读写操作完成后，通过信号、回调函数或事件机制通知应用程序。</li><li>优点：真正的异步，高效利用 CPU，可处理大量并发 I/O。</li><li>缺点：编程复杂，Linux 支持有限（传统 AIO 对网络 I/O 支持不好，<code>io_uring</code> 是新方案）。</li><li>注意：这是真正的异步 I/O 实现，在 Linux 上需要使用 <code>aio_*</code> 系列系统函数或者使用 <code>io_uring</code>，Node.js 采用了该 I/O 模型。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-6.png"></p><h3 id="优秀的网络服务器设计"><a href="#优秀的网络服务器设计" class="headerlink" title="优秀的网络服务器设计"></a>优秀的网络服务器设计</h3><p>在这个 CPU 多核时代，服务端网络编程如何选择线程模型呢？赞同 <code>libev</code> 作者的观点：”one loop perthread is usually a good model”，这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的 Event Loop， 然后每个线程运行一个 Event Loop 就行了（当然，线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。</p><hr><p>Event Loop 是 Non-Blocking 网络编程的核心，可以简单理解为 Non-Blocking + epoll + thread-pool 的结合。在实际应用中，Non-Blocking 几乎总是与 I/O Multiplexing 一起使用，原因有以下两点：</p><ul><li>实际上没有人会采用轮询（Busy-Polling）方式不断检查某个 Non-Blocking I/O 操作是否完成，因为这会严重浪费 CPU 资源。</li><li>I/O Multiplexing 通常无法与 Blocking I/O 一起使用，因为在 Blocking I/O 中，<code>accept()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code> 等调用都有可能阻塞当前线程，从而导致线程无法继续处理其他 Socket 上的 I/O 事件。</li></ul><p><strong>所以，当日常提到 Non-Blocking I/O 时，实际上指的是 Non-Blocking + I/O Multiplexing 的组合，如何单独使用其中任意一种，都无法很好地实现高效的网络 I/O。</strong></p><div class="admonition note"><p class="admonition-title">epoll + fork 不如 epoll + pthread 吗？</p><p>答案肯定是否定的，强大的 Nginx 服务器采用了 epoll + fork 模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个 fork 网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的服务器惊群现象，功能十分强大。</p></div><h3 id="Reactor-网络-I-O-模型"><a href="#Reactor-网络-I-O-模型" class="headerlink" title="Reactor 网络 I/O 模型"></a>Reactor 网络 I/O 模型</h3><div class="admonition note"><p class="admonition-title">维基百科对 Reactor 的描述</p><p>The reactor design pattern is an event handling pattern for handling service requestsdelivered concurrently to a service handler by one or more inputs. The service handlerthen demultiplexes the incoming requests and dispatches them synchronously to theassociated request handlers. 翻译后：Reactor（反应器）设计模式是一种事件处理模式，用于处理由一个或多个输入并发传递到服务处理器的服务请求。然后，服务处理器对传入的请求进行多路分解，并同步地将它们分派给相应的请求处理器。</p></div><ul><li><p>Reactor 是一种基于事件驱动（Event Driven）的网络 I/O 模型，核心思想是：</p><ul><li>主线程（或 I/O 线程）通过 I/O 多路复用（I/O Multiplexing）机制（如 <code>select</code>、<code>poll</code>、<code>epoll</code>），监听多个连接的 I/O 事件。</li><li>当某个事件就绪后，再分发（Dispatch）给对应的事件处理器（EventHandler）进行处理。</li></ul></li><li><p>Reactor 虽然是网络 I/O 模型，但它通常与线程模型结合使用：</p><ul><li>单线程 Reactor：所有 I/O 事件的监听与处理都在同一个线程中完成。</li><li>多线程 Reactor：I/O 事件的监听与业务处理分离，通常用线程池来处理业务逻辑。</li><li>主从 Reactor：主 Reactor 负责连接建立，从 Reactor 负责 I/O 读写（即数据读写），结合多线程提升并发性能。</li></ul></li><li><p>Reactor 的五大核心组件</p><table><thead><tr><th>核心组件</th><th>作用</th></tr></thead><tbody><tr><td> Event（事件）</td><td>表示 I/O 事件的抽象，如连接建立、可读、可写等，用于描述发生了什么类型的网络事件。</td></tr><tr><td>Demultiplexer（事件分离器）</td><td>负责监听并检测多个 I/O 事件的就绪状态（通常由 <code>select</code>、<code>poll</code>、<code>epoll</code> 等系统调用实现），并将已就绪的事件返回给 Reactor。</td></tr><tr><td>Reactor（反应堆）</td><td>事件分发器，负责从 Demultiplexer 获取就绪事件，并将事件分发给对应的 EventHandler 处理。</td></tr><tr><td>EventHandler（事件处理器）</td><td>负责具体的事件处理逻辑，如读、写、连接、业务处理等，是应用层的回调逻辑。</td></tr><tr><td>Acceptor（连接接收器）</td><td>负责监听服务器端口并接收新的客户端连接，在多 Reactor 模型中通常独立运行，仅负责建立连接并将连接交给子 Reactor 处理。</td></tr></tbody></table></li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-7.png"></p><ul><li>Muduo 库的 Multiple Reactors 模型如下图所示：</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-8.png"></p><h3 id="I-O-多路复用技术概述"><a href="#I-O-多路复用技术概述" class="headerlink" title="I/O 多路复用技术概述"></a>I/O 多路复用技术概述</h3><blockquote><p><strong>跨平台特性的对比</strong></p></blockquote><table><thead><tr><th>技术</th><th>是否支持跨平台</th><th>支持的平台</th><th>特点</th></tr></thead><tbody><tr><td><code>select</code></td><td>✅ 广泛跨平台</td><td> Linux / macOS / BSD / Windows / Unix</td><td> 最老的接口，POSIX 标准定义</td></tr><tr><td><code>poll</code></td><td>⚠️ 类 Unix 跨平台（不支持 Windows）</td><td>Linux /macOS/ BSD / Solaris 等</td><td><code>select</code> 的改进版 ，无 <code>fd</code> 数量限制</td></tr><tr><td><code>epoll</code></td><td>❌ Linux 独有</td><td>仅 Linux（2.6+）</td><td>高性能 I/O 多路复用技术</td></tr><tr><td><code>kqueue</code></td><td>❌ BSD/macOS 独有</td><td> FreeBSD / macOS / NetBSD / OpenBSD</td><td><code>epoll</code> 的 BSD 对应物</td></tr></tbody></table><blockquote><p><strong>select 与 poll 的缺点</strong></p></blockquote><p>I/O 多路复用技术 <code>select</code> 有以下缺点：</p><ul><li><p>(1) 文件描述符数量限制：</p><ul><li>单个进程可监视的文件描述符数量存在上限，通常为 1024（可修改）。但由于 <code>select</code> 采用轮询扫描方式检查文件描述符，随着监视数量的增加，性能会明显下降。</li><li>在 Linux 内核头文件中有如下定义：<code>#define __FD_SETSIZE 1024</code>。</li></ul></li><li><p>(2) 内核与用户空间的数据拷贝开销大：</p><ul><li>每次调用 <code>select</code> 都需要在内核空间与用户空间之间复制大量的文件描述符集合，这会造成显著的性能开销。</li></ul></li><li><p>(3) 结果集遍历效率低：</p><ul><li><code>select</code> 返回的是一个包含所有文件描述符的数组，应用程序需要遍历整个数组才能判断哪些描述符处于就绪状态，效率较低。</li></ul></li><li><p>(4) 水平触发机制（Level Trigger）：</p><ul><li><code>select</code> 采用水平触发方式，如果应用程序没有及时处理已就绪的文件描述符，那么在后续的每次 <code>select</code> 调用中，这些描述符仍会被重复通知。</li></ul></li></ul><p>I/O 多路复用技术 <code>poll</code> 跟 <code>select</code> 相比，使用链表来保存文件描述符，不再受文件描述符数量上限的限制，但仍然存在与 <code>select</code> 相同的其他三个缺点（数据拷贝开销大、结果集遍历效率低、水平触发），这里不再累述。</p><div class="admonition warning"><p class="admonition-title">select 无法支持高并发连接</p><p>以 <code>select</code> 为例，若服务器需支持 100 万并发连接，在 <code>__FD_SETSIZE</code> 为 1024 的情况下，至少需要创建约 1000 个进程才能满足要求。如此不仅会带来大量的进程上下文切换开销，还会因频繁的内核空间 / 用户空间句柄拷贝与数组遍历操作，导致系统性能急剧下降。因此，基于 <code>select</code> 模型的服务器要实现百万级并发几乎是不可能的。</p></div><blockquote><p><strong>epoll 的原理以及优势</strong></p></blockquote><p>设想这样一个场景：有 100 万个客户端同时与一个服务器进程保持 TCP 连接，但在任意时刻，通常只有几百到上千个连接是活跃的（这也是现实中最常见的情况）。如何高效地支撑如此庞大的并发连接呢？在 <code>select</code> / <code>poll</code> 时代，服务器每次调用都需要将这 100 万个连接的文件描述符从用户态复制到内核态，让内核轮询这些套接字上是否有事件发生；轮询完成后，再将结果从内核态复制回用户态，供应用程序继续遍历处理。这种方式带来了巨大的内存拷贝和遍历开销，因此基于 <code>select</code> / <code>poll</code> 通常只能处理几千个并发连接。</p><hr><p><code>epoll</code> 的设计思想与 <code>select</code> 完全不同，因此它们的缺点在 <code>epoll</code> 中已不复存在。<code>epoll</code> 在 Linux 内核中引入了一种专用的事件管理机制，通过红黑树（用于管理所有已注册的文件描述符）和就绪链表（用于管理已触发事件的文件描述符）来组织事件，大幅降低了事件查找和分发的开销，使大规模并发连接的事件管理更加高效。</p><ul><li>(1) <code>epoll_create()</code>：创建一个 <code>epoll</code> 对象（内核在 <code>epoll</code> 文件系统中为该对象分配资源）。</li><li>(2) <code>epoll_ctl()</code>：向 <code>epoll</code> 对象中添加、修改或删除需要监听的套接字（例如 100 万个 TCP 连接）。</li><li>(3) <code>epoll_wait()</code>：等待并收集有事件发生的文件描述符。</li></ul><p>其中 <code>epoll_create()</code> 在内核上创建的 <code>eventpoll</code> 结构如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> {</span></span><br><span class="line">    ....(省略)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 红黑树的根节点，这颗树中存储着所有添加到 epoll 中的需要监控的事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 双链表中则存放着将要通过 epoll_wait() 返回给用户的满足条件的事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line"></span><br><span class="line">    ....(省略)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>得益于这种设计，只需在服务器启动时创建一次 <code>epoll</code> 对象，然后在连接建立或关闭时动态地添加或移除对应的套接字即可。更重要的是，<code>epoll_wait()</code> 的调用效率极高：</p><ul><li>它不需要在每次调用时复制所有文件描述符。</li><li>内核也无需遍历全部连接，而是通过回调机制主动将就绪的文件描述符加入到就绪队列中。</li></ul><p>因此，<code>epoll</code> 能够在单进程中轻松支撑数十万甚至上百万级的并发连接，这正是它区别于 <code>select</code> / <code>poll</code> 的根本优势所在。</p><blockquote><p><strong>epoll 的 LT 模式与 ET 模式</strong></p></blockquote><p><code>epoll</code> 支持 LT（水平触发）与 ET（边缘触发），而 <code>select</code>、<code>poll</code> 在设计上只支持 LT（水平触发），没有 ET（边缘触发）的概念。</p><ul><li><p>LT 模式（Level Triggered，水平触发）</p><ul><li>语义：只要 <code>fd</code> 上有数据未被读取完，就会一直被 <code>epoll</code> 通知。</li><li>特点：更 “宽松”，即使一次没读完，下次还会被提醒。</li><li>行为示例：<ul><li>缓冲区有 100 字节可读；</li><li>应用程序只读了 60 字节；</li><li>下次 <code>epoll_wait()</code> 还会再次返回该 <code>fd</code>。</li></ul></li><li>优点：编程简单、不易漏数据。</li><li>缺点：频繁触发，效率略低。</li></ul></li><li><p>ET 模式（Edge Triggered，边缘触发）</p><ul><li>语义：只有当状态发生变化（从无到有）时才触发一次事件。</li><li>特点：仅在 “边缘” 通知，比如缓冲区从空变为非空。</li><li>行为示例：<ul><li>缓冲区变为可读时触发；</li><li>应用程序必须一次性读完所有数据（直到返回 <code>EAGAIN</code>）；</li><li>如果应用程序没读完，下次不会再收到通知。</li></ul></li><li>优点：减少系统调用次数，效率高。</li><li>缺点：编程复杂，稍有疏忽就可能会 “丢事件”。</li></ul></li><li><p>Muduo 采用的是 LT（水平触发）模式</p><ul><li>不会丢失数据或者消息<ul><li>应用程序没有读取完数据，内核是会不断上报数据的</li></ul></li><li>低延迟处理<ul><li>每次读数据只需要一次系统调用，照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息</li></ul></li><li>跨平台处理<ul><li>像 <code>select</code> 一样可以跨平台使用</li></ul></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/717586901">深入分析 Muduo 网络库核心代码</a></li><li><a href="https://zhuanlan.zhihu.com/p/683396341">Muduo 库核心代码及优秀编程细节剖析</a></li><li><a href="https://www.ituring.com.cn/article/504549">从抄书到开源之巅：章亦春的程序人生</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 开发一款高性能网络库（Muduo）。</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 与 Dubbo 的 SPI 机制介绍</title>
    <link href="https://www.techgrow.cn/posts/ef54a41c.html"/>
    <id>https://www.techgrow.cn/posts/ef54a41c.html</id>
    <published>2025-10-12T15:42:35.000Z</published>
    <updated>2025-10-12T15:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Java-SPI-机制"><a href="#Java-SPI-机制" class="headerlink" title="Java SPI 机制"></a>Java SPI 机制</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>Java 原生支持 SPI 机制，具体介绍如下：</p><ul><li><strong>核心概念</strong><ul><li> SPI（Service Provider Interface）是一种服务发现机制。</li><li>SPI 的核心思想是定义一个接口，由多个实现类提供不同的实现方式，在系统运行时根据配置或者默认策略，动态加载并使用具体的实现类。</li><li>SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样就可以在运行时，动态为接口替换实现类。</li></ul></li></ul><span id="more"></span><ul><li><p><strong>工作原理</strong></p><ul><li>(1) 接口与实现类<ul><li>假设有一个接口 <code>A</code>，它有多个实现类：<code>A -&gt; A1、A2、A3</code>。</li></ul></li><li>(2) 配置实现类<ul><li>可以在配置文件中指定接口 <code>A</code> 对应使用哪个实现类。</li></ul></li><li>(3) 运行时加载<ul><li>程序启动时，会读取配置文件，根据配置信息找到对应的实现类，实例化并使用该对象。</li></ul></li><li>(4) Java 原生 SPI 机制<ul><li> Java 原生 SPI 机制的使用要求：<ul><li>在 <code>resources/META-INF/services/</code> 目录下，创建一个与接口全限定名相同的文件，例如：<code>resources/META-INF/services/com.example.service.A</code></li><li>文件内容的格式是一行一个实现类的全限定名（可以有多行，即支持多个不同的实现类），例如：<code>com.example.service.impl.A1</code>。</li><li>运行时通过 <code>ServiceLoader</code> 等工具扫描依赖的 Jar 包，在其中查找该文件，并加载指定的实现类，比如：<code>ServiceLoader&lt;HelloService&gt; loader = ServiceLoader.load(HelloService.class);</code></li></ul></li></ul></li></ul></li><li><p><strong>应用场景</strong></p><ul><li>SPI 机制常用于插件式扩展。</li><li>比如：如果你在开发一个框架，可以通过 SPI 让外部开发者编写插件，扩展框架的功能，而不必修改框架的源码。</li></ul></li><li><p><strong>典型案例</strong></p><ul><li>JDBC<ul><li>Java 标准库只定义了一套 JDBC 接口，并没有真正的实现。</li><li>数据库厂商（如 MySQL、Oracle）会提供自己的实现，并通过 SPI 机制声明在 <code>resources/META-INF/services/</code> 目录中。</li><li>运行时，Java 会根据项目引入的数据库驱动 Jar 包，自动找到对应的 JDBC 实现类。</li></ul></li></ul></li></ul><h2 id="Dubbo-SPI-机制"><a href="#Dubbo-SPI-机制" class="headerlink" title="Dubbo SPI 机制"></a>Dubbo SPI 机制</h2><h3 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>Dubbo 借鉴了 SPI 思想，但没有直接使用 Java 原生的 SPI 机制，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 <code>ExtensionLoader</code> 类中，通过 <code>ExtensionLoader</code> 类可以加载指定的实现类。</p><ul><li><p><strong>工作原理</strong></p><ul><li>(1) 接口声明<ul><li>在 Dubbo 中，如果某个接口需要支持 SPI 扩展，就会加上 <code>@SPI</code> 注解，比如 <code>Protocol</code> 接口：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="meta">@SPI("dubbo")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Adaptive</span></span><br><span class="line">   &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Adaptive</span></span><br><span class="line">   &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载实现类</span></span><br><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></tbody></table></figure></li><li><code>@SPI("dubbo")</code> 表示默认实现是 <code>dubbo</code>。</li><li><code>@Adaptive</code> 表示该方法会生成代理逻辑，运行时根据参数动态选择实现类。</li></ul></li><li>(2) 实现类配置<ul><li> Dubbo 在自己 Jar 包中的 <code>resources/META-INF/dubbo/internal/</code> 路径下提供了一个配置文件，文件名是接口的全限定名，比如：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</span><br></pre></td></tr></tbody></table></figure></li><li>配置文件的内容是 <code>key=实现类的全限定名</code>，key 对应 <code>@SPI</code> 注解中的扩展名称，比如：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class="line">http=com.alibaba.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class="line">hessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>(3) 默认实现加载<ul><li>如果用户没有配置扩展，Dubbo 会根据 <code>@SPI("dubbo")</code> 的默认值 <code>dubbo</code>，从配置文件中加载对应的实现类 <code>DubboProtocol</code>。</li><li>这也是 Dubbo 默认使用 Dubbo 协议作为 RPC 通信协议的原因。</li></ul></li><li>(4) 动态切换实现类<ul><li>在 <code>Protocol</code> 接口中，有两个方法加了 <code>@Adaptive</code> 注解。</li><li>Dubbo 会在运行时生成代理类，在代理方法内部根据传入的 URL 参数的 <code>protocol</code> 值决定使用哪个实现类。</li><li>如果 URL 参数中没指定协议，就用默认的 <code>dubbo</code>；如果指定了其他值（如 <code>http</code>），则加载对应的实现类。</li></ul></li></ul></li><li><p><strong>实现特点</strong></p><ul><li>微内核 + 可插拔：保留一个接口和多个实现，运行时可替换。</li><li>组件化：如 <code>Protocol</code> 负责 RPC 调用，可以替换为自定义的 RPC 组件。</li><li>动态扩展：可通过 URL 参数或配置文件，在运行时动态切换实现类。</li><li>增强的 SPI：相比 Java 原生的 SPI 机制，Dubbo 的实现支持：<ul><li>支持指定默认的实现类（<code>@SPI</code> 注解的默认值）</li><li>运行时动态选择实现类（<code>@Adaptive</code>）</li><li>接口定义（扩展点）自动生成代理类</li></ul></li></ul></li><li><p><strong>使用总结</strong></p><ul><li>Dubbo SPI 本质上是一个运行时可扩展、可替换的组件机制。</li><li>Dubbo 大量核心组件（如 <code>Protocol</code>、<code>Cluster</code>、<code>Registry</code> 等）都是用这种 SPI 机制实现扩展的。</li><li>通过 <code>@SPI</code> 注解 + 配置文件来确定默认的实现类，通过 <code>@Adaptive</code> 注解 + URL 参数来实现动态切换实现类。</li><li>Dubbo 的 SPI 文件路径和 Java SPI 的不一样，核心目录是 <code>resources/META-INF/dubbo/接口全限定名</code>，Dubbo 内部使用的扩展目录是 <code>resources/META-INF/dubbo/internal/接口全限定名</code>，文件内容是 <code>key=实现类的全限定名</code>。</li></ul></li></ul><h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h3><p>Dubbo SPI 机制加载扩展的核心步骤：</p><ul><li>(1) 读取并解析配置文件</li><li> (2) 缓存所有扩展实现类</li><li> (3) 基于用户执行的扩展名，实例化对应的扩展实现类</li><li> (4) 执行扩展实例属性的 IOC 注入（基于 <code>Setter</code> 注入），以及实例化扩展的包装类，实现 AOP 特性</li></ul><p>Dubbo SPI 机制加载扩展的整个流程：</p><p><img data-src="../../../asset/2025/09/dubbo-spi-1.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/source/dubbo-spi/">Dubbo 官方文档 - SPI 源码分析</a></li><li><a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/dubbo-spi/">Dubbo 官方文档 - 扩展点开发指南</a></li><li><a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/">Dubbo 官方文档 - 部分重点 SPI 使用说明</a></li><li><a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/">Dubbo 官方文档 - SPI 插件扩展点使用手册</a></li><li><a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/spi/">Dubbo 官方文档 - 自定义 SPI 扩展的基本步骤</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Java 与 Dubbo 的 SPI 机制。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Java" scheme="https://www.techgrow.cn/tags/Java/"/>
    
    <category term="RPC" scheme="https://www.techgrow.cn/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之八</title>
    <link href="https://www.techgrow.cn/posts/723af70c.html"/>
    <id>https://www.techgrow.cn/posts/723af70c.html</id>
    <published>2025-10-08T13:12:19.000Z</published>
    <updated>2025-10-08T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h3><h4 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h4><h5 id="Volume-的概述"><a href="#Volume-的概述" class="headerlink" title="Volume 的概述"></a>Volume 的概述</h5><p>Volume（卷）是 Pod 中可被多个容器共同访问的共享目录。Kubernetes 的 Volume 定义在 Pod 上，并可由该 Pod 内的多个容器挂载到各自的文件路径下。Volume 的生命周期与 Pod 相同，但独立于容器的生命周期。当容器终止或重启时，Volume 中的数据不会丢失。在使用 Volume 时，Pod 需要指定 Volume 的类型和内容（<code>volumes</code> 字段），以及在容器中挂载的位置（<code>volumeMounts</code> 字段）。Kubernetes 支持多种类型的 Volume，包括：<code>emptyDir</code>、<code>hostPath</code>、<code>gcePersistentDisk</code>、<code>awsElasticBlockStore</code>、<code>nfs</code>、<code>iscsi</code>、<code>flocker</code>、<code>glusterfs</code>、<code>rbd</code>、<code>cephfs</code>、<code>gitRepo</code>、<code>secret</code>、<code>persistentVolumeClaim</code>、<code>downwardAPI</code>、<code>azureFile</code>、<code>azureDisk</code>、<code>vsphereVolume</code>、<code>quobyte</code>、<code>portworxVolume</code>、<code>scaleIO</code> 等。</p><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Kubernetes 中，Volume 是定义在 Pod 层级上的，而不是容器层级的。这意味着同一个 Pod 内的多个容器可以通过挂载同一个 Volume 来共享数据。几乎所有类型的 Volume（如 <code>emptyDir</code>、<code>hostPath</code>、<code>nfs</code>、<code>configMap</code>、<code>secret</code> 等）都支持在同一个 Pod 内被多个容器同时访问和使用。</p></div><h5 id="emptyDir-的使用"><a href="#emptyDir-的使用" class="headerlink" title="emptyDir 的使用"></a>emptyDir 的使用</h5><p><code>emptyDir</code> 类型的 Volume 会在 Pod 被调度到某个节点（宿主机）时创建，Pod 内的所有容器都可以读写该目录中的数据。一旦 Pod 被删除或从该节点（宿主机）迁移，<code>emptyDir</code> 中的数据会被永久清除。因此，<code>emptyDir</code> 可以理解为本地存储，通常用于存放临时数据，例如 Web 服务器的日志文件或应用运行时的临时目录。<code>emptyDir</code> 类型的 Volume 的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">docker.io/nazarpc/webserver</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/cache</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">      <span class="attr">emptyDir:</span> {}</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>配置字段</th><th>说明</th></tr></thead><tbody><tr><td><code>volumeMounts</code></td><td>用于将 Pod 中定义的 Volume 挂载到容器内的指定路径。</td></tr><tr><td><code>emptyDir: {}</code></td><td>表示创建一个临时目录，当 Pod 删除或迁移时，该目录中的数据会被永久清除。</td></tr></tbody></table><h5 id="hostPath-的使用"><a href="#hostPath-的使用" class="headerlink" title="hostPath 的使用"></a>hostPath 的使用</h5><p><code>hostPath</code> 类型的 Volume 允许容器访问所在宿主机上的指定目录。例如，当需要运行一个访问 Docker 系统目录的容器时，可以将宿主机的 <code>/var/lib/docker</code> 目录挂载为一个 <code>hostPath</code> 类型的 Volume；或者在容器中运行 cAdvisor 时，可以将 <code>/dev/cgroups</code> 目录挂载为 <code>hostPath</code> Volume。需要注意的是，当 Pod 从当前宿主机上删除或迁移时，<code>hostPath</code> 中的数据不会被删除，但也不会随 Pod 一同迁移到新的宿主机上。此外，由于不同宿主机的文件系统结构和内容可能存在差异，相同的 Pod 在不同宿主机上使用 <code>hostPath</code> 时，可能会出现不同的行为。<code>hostPath</code> 类型的 Volume 的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">docker.io/nazarpc/webserver</span></span><br><span class="line">      <span class="comment"># 指定在容器中挂载路径</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test-data</span></span><br><span class="line">  <span class="comment"># 指定所提供的存储卷</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">      <span class="comment"># 宿主机上的目录</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="comment"># 宿主机上的目录路径</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/data</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>配置字段</th><th>说明</th></tr></thead><tbody><tr><td><code>volumeMounts</code></td><td>定义容器内部的挂载路径 <code>/test-data</code>。</td></tr><tr><td><code>volumes.hostPath.path</code></td><td>指定宿主机上对应的物理目录 <code>/data</code>。</td></tr><tr><td><code>hostPath</code></td><td>该类型的卷允许容器直接访问宿主机上的文件系统资源。</td></tr></tbody></table><h5 id="nfs-的使用"><a href="#nfs-的使用" class="headerlink" title="nfs 的使用"></a>nfs 的使用</h5><p><code>nfs</code> 类型的 Volume 允许将已有的 NFS（Network File System，网络文件系统）存储挂载到 Pod 中，这样同一个 Pod 内的多个容器就可以共享使用。通过 NFS，可以让不同节点上的 Pod 访问同一个远程存储目录，从而实现跨主机的数据共享与持久化。与 <code>emptyDir</code> 或 <code>hostPath</code> 不同，<code>nfs</code> 的数据存储在远程服务器上，不会因 Pod 或节点的重建、迁移而丢失，非常适合需要共享存储或持久化数据的场景，比如数据库、缓存或日志存储。<code>nfs</code> 类型的 Volume 的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">          <span class="comment"># 应用的镜像</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="comment"># 应用的内部端口</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-6379</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ALLOW_EMPTY_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">"yes"</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">REDIS_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">"redis"</span></span><br><span class="line">          <span class="comment"># 持久化挂载位置（容器内路径）</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-persistent-storage</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">      <span class="comment"># 定义存储卷</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-persistent-storage</span></span><br><span class="line">          <span class="attr">nfs:</span>                             <span class="comment"># 使用 NFS 网络存储</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.112</span>        <span class="comment"># NFS 服务器的 IP 地址</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/k8s-nfs/redis/data</span>      <span class="comment"># NFS 服务器上的共享目录</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>配置字段</th><th>说明</th></tr></thead><tbody><tr><td><code>revisionHistoryLimit: 2</code></td><td>仅保留最近 2 个历史版本的 ReplicaSet。</td></tr><tr><td><code>mountPath: /data</code></td><td>容器内 Redis 的数据存储路径。</td></tr><tr><td><code>nfs</code></td><td>通过 NFS 网络存储提供持久化数据目录。</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Kubernetes 集群中，如果需要使用 <code>nfs</code> 类型的 Volume（卷），则需要先在所有集群节点上分别手动安装 NFS 客户端，否则 Volume（卷）会无法正常挂载。比如，CentOS 系统安装 NFS 客户端，可以使用命令 <code>sudo yum install -y nfs-utils</code>。</p></div><h4 id="PV-与-PVC"><a href="#PV-与-PVC" class="headerlink" title="PV 与 PVC"></a>PV 与 PVC</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li><p>(1) 在 Kubernetes 中，存储管理是计算管理中的一个重要问题。为此，Kubernetes 提供了 PersistentVolume（PV）子系统，为用户和管理员提供了一个抽象层，用于屏蔽底层存储实现的复杂性，并通过统一的 API 管理存储资源的使用。该子系统引入了两个新的 API 资源：PersistentVolume（PV） 和 PersistentVolumeClaim（PVC）。</p></li><li><p>(2) PersistentVolume（PV）是由集群管理员预先配置的一块网络存储，它是集群级别的资源，就像节点（Node）一样。PV 可以看作是一种容量插件（类似于 Volume），但其生命周期独立于使用它的任何 Pod。PV 对象中包含了底层存储实现的详细信息，例如 NFS、iSCSI，或特定云服务提供商的存储系统。</p></li><li><p>(3) PersistentVolumeClaim（PVC）是用户发起的存储资源请求，类似于 Pod 对节点资源的使用。Pod 消耗节点资源（如 CPU、内存），而 PVC 消耗 PV 资源。用户可以在 PVC 中指定所需的存储大小以及访问模式（例如：单次读写或多次只读）。</p></li><li><p>(4) 虽然 PVC 让用户能够以抽象的方式使用存储资源，但在实际应用中，不同场景往往对存储有不同的特性需求（如性能、可靠性、备份策略等）。为满足这种灵活性，Kubernetes 提供了 StorageClass 资源。StorageClass 允许管理员定义存储的 “类别”，用以描述不同类型的存储服务。不同的存储类可以对应不同的服务质量（QoS）等级、备份策略或其他由管理员定义的策略。Kubernetes 本身并不限定这些类别的具体含义，这一概念在其他系统中有时被称为 “存储配置文件（Profile）”。</p></li><li><p>(5) 在实际使用中，PVC 与 PV 通常是一一对应的，PVC 会自动绑定到满足其需求的 PV 上，从而实现持久化存储的自动化管理。</p></li></ul><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>PersistentVolume（PV）是集群中的资源，PersistentVolumeClaim（PVC）是用户对这些资源的请求并充当对资源的检查。PV 与 PVC 之间的交互遵循下面的生命周期阶段：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Provisioning → Binding → Using → Releasing → Recycling</span><br></pre></td></tr></tbody></table></figure><ul><li><p>(1) Provisioning（供应 / 准备）</p><ul><li>通过集群外的存储系统或者云平台来提供持久化存储支持，有两类方式：<ul><li>静态提供（Static）：集群管理员事先创建若干 PV，并在每个 PV 中描述底层真实存储的详细信息（例如 NFS、iSCSI、云盘等）。这些 PV 以资源对象存在于 Kubernetes API 中，供用户通过 PVC 消费。</li><li>动态提供（Dynamic）：当没有现成的、满足 PVC 要求的静态 PV 时，Kubernetes 可以基于 StorageClass 自动为 PVC 动态创建 PV（即动态配置卷）。要使用动态提供：<ul><li>PVC 必须指定某个 <code>storageClassName</code>（或者使用默认 StorageClass）。</li><li>对应的 StorageClass 必须已由管理员创建并配置好相应的 Provisioner（即外部存储插件）。</li><li>如果 PVC 明确请求一个不存在的类，则视为禁用动态配置（不会触发动态 Provisioning）。</li></ul></li></ul></li></ul></li><li><p>(2) Binding（绑定）</p><ul><li>用户创建 PVC 并在其中指定所需的容量和访问模式（Access Modes）。</li><li>Kubernetes 会查找符合 PVC 要求的 PV，并将其绑定（Bind）到该 PVC。</li><li>在找到合适的 PV 之前，PVC 处于未绑定（Pending）状态。</li></ul></li><li><p>(3) Using（使用）</p><ul><li>一旦 PVC 与 PV 绑定，用户可以在 Pod 的 <code>volumes</code> 中使用 PVC，就像使用普通 Volume 一样，Pod 内的容器可以通过 <code>volumeMounts</code> 挂载并访问该存储卷。</li></ul></li><li><p>(4) Releasing（释放）</p><ul><li>当用户删除 PVC（释放对存储的请求）时，PV 会进入 Released（已释放）状态。</li><li>注意：被释放的 PV 上可能仍然保留有先前使用者的数据。在这种状态下，如果不对数据做处理，该 PV 通常不能直接被新的 PVC 使用（取决于回收策略）。</li></ul></li><li><p>(5) Recycling（回收）</p><ul><li>PV 上可以设置回收策略，用于指定在 PVC 删除后如何处理底层存储资源，常见策略包括：<ul><li>Retain（保留）：默认回收策略，保留底层存储与数据，管理员需手动处理（例如备份或清理），然后手动将 PV 重新配置为可供新的 PVC 使用。</li><li>Delete（删除）：删除 PV 对象，并同时删除外部存储资源（删除操作需要底层存储插件支持）。</li><li>Recycle（回收）：旧版本 Kubernetes 支持（现已废弃），对底层卷执行简单的清理（比如 <code>rm -rf /thevolume/*</code>），清理后该 PV 可再次被新的 PVC 使用（回收操作需要相应插件支持或实现）。</li></ul></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">总结</p><ul><li><strong>PV 是集群级别的存储资源，生命周期独立于单个 Pod。</strong></li><li><strong>PVC 是对 PV 的请求，用于记录存储容量与存储访问模式等需求。</strong></li><li>生命周期的完整流程为：准备（静态 / 动态）→ 绑定 → 使用 → 释放 → 回收 / 删除 / 保留，回收策略由 PV 的 <code>reclaimPolicy</code> 决定，管理员需要根据实际场景选择合适策略并配置相应的 StorageClass / Provisioner。</li></ul></div><h5 id="PV-的类型"><a href="#PV-的类型" class="headerlink" title="PV 的类型"></a>PV 的类型</h5><p>在 Kubernetes 中，PersistentVolume（PV）的类型有以下几种：</p><table><thead><tr><th>PV 类型</th><th>说明</th></tr></thead><tbody><tr><td> GCEPersistentDisk</td><td> 使用 Google Compute Engine 提供的持久磁盘（Persistent Disk）作为存储卷。</td></tr><tr><td>AWSElasticBlockStore</td><td> 使用 AWS 的 EBS（Elastic Block Store）卷作为存储卷。</td></tr><tr><td>AzureFile</td><td> 使用 Azure File 存储（基于 SMB 协议）作为共享文件卷。</td></tr><tr><td>AzureDisk</td><td> 使用 Azure 的托管磁盘（Managed Disk）或非托管磁盘作为块存储卷。</td></tr><tr><td>FC (Fibre Channel)</td><td> 通过光纤通道（Fibre Channel）协议连接的块存储设备。</td></tr><tr><td>FlexVolume</td><td> 可扩展的卷插件机制，允许用户通过外部驱动程序自定义存储挂载逻辑。</td></tr><tr><td>Flocker</td><td> 已弃用的存储方案，原用于容器与外部数据卷的动态关联。</td></tr><tr><td>NFS</td><td> 使用网络文件系统（Network File System，NFS）协议挂载远程共享存储，支持多容器共享访问。</td></tr><tr><td>iSCSI</td><td> 通过 iSCSI 协议访问远程块存储设备。</td></tr><tr><td>RBD (Ceph Block Device)</td><td> 使用 Ceph 提供的 RADOS 块设备（RBD）作为存储卷。</td></tr><tr><td>CephFS</td><td> 使用 Ceph 提供的分布式文件系统（CephFS）作为共享文件卷。</td></tr><tr><td>Cinder (OpenStack block storage)</td><td> 使用 OpenStack 的 Cinder 服务提供的块存储。</td></tr><tr><td>Glusterfs</td><td> 使用 GlusterFS 提供的分布式文件系统存储，支持多节点共享访问。</td></tr><tr><td>VsphereVolume</td><td> 使用 VMware vSphere 平台提供的虚拟磁盘（vmdk）作为存储卷。</td></tr><tr><td>Quobyte Volumes</td><td> 使用 Quobyte 提供的分布式文件系统作为存储卷。</td></tr><tr><td>HostPath</td><td> 将宿主机上的目录或文件挂载到 Pod 中（仅适用于单节点测试环境，不支持集群环境）。</td></tr><tr><td>Portworx Volumes</td><td> 使用 Portworx 存储解决方案提供的高可用分布式块存储。</td></tr><tr><td>ScaleIO Volumes</td><td> 使用 Dell EMC 的 ScaleIO（现 PowerFlex）分布式块存储。</td></tr><tr><td>StorageOS</td><td> 使用 StorageOS 提供的容器原生分布式存储系统。</td></tr></tbody></table><h5 id="PV-的阶段状态"><a href="#PV-的阶段状态" class="headerlink" title="PV 的阶段状态"></a>PV 的阶段状态</h5><p>在 Kubernetes 中，PersistentVolume（PV）的生命周期会经历多个阶段（Phase），用于描述其当前的使用状态。PV 的阶段状态有以下几个：</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td> Available</td><td>PV 资源尚未被任何 PVC（PersistentVolumeClaim）绑定，可供新的 Claim 使用。</td></tr><tr><td>Bound</td><td>PV 已经成功绑定到某个 PVC，正在被使用。</td></tr><tr><td>Released</td><td> 与该 PV 绑定的 PVC 已被删除，卷已释放但尚未被回收，此时卷中的数据可能仍然存在。</td></tr><tr><td>Failed</td><td>PV 自动回收失败，需要管理员手动干预或清理。</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><ul><li>PV 的状态转换是由 Kubernetes 控制器自动管理的。</li><li>如果存储类（StorageClass）指定回收策略为保留（<code>reclaimPolicy: Retain</code>），那么在 PVC 删除后 PV 会保持 <code>Released</code> 状态，需管理员手动处理。</li></ul></div><h5 id="PV-的使用案例"><a href="#PV-的使用案例" class="headerlink" title="PV 的使用案例"></a>PV 的使用案例</h5><div class="admonition note"><p class="admonition-title">提示</p><p>本节将演示在 Kubernetes 集群中，如何配合使用 PV + PVC + Pod，使用的 PV 类型是 <code>nfs</code>。</p></div><h6 id="创建-PV"><a href="#创建-PV" class="headerlink" title="创建 PV"></a>创建 PV</h6><ul><li>通过 YAML 文件（比如 <code>pv-demo.yaml</code>）创建 5 个 PersistentVolume（PV），类型都为 <code>nfs</code>，但存储大小各不相同，是否可读也不相同（<strong>请自行更改 NFS 服务器的 IP 地址，并在 NFS 服务器上提前创建好相应的共享目录</strong>）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv001</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.188</span>       <span class="comment"># NFS 服务器的 IP 地址</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/volumes/v1</span>      <span class="comment"># NFS 服务器上的共享目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv002</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv002</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.188</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/volumes/v2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv003</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv003</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.188</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/volumes/v3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv004</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv004</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.188</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/volumes/v4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv005</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv005</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">15Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.188</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/volumes/v5</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件（比如 <code>pv-demo.yaml</code>）中定义的 PV 对象 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> pv-demo.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 PV</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pv</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">pv001   2Gi        RWO,RWX        Retain           Available                                   17s</span><br><span class="line">pv002   3Gi        RWO            Retain           Available                                   17s</span><br><span class="line">pv003   5Gi        RWO,RWX        Retain           Available                                   17s</span><br><span class="line">pv004   10Gi       RWO,RWX        Retain           Available                                   17s</span><br><span class="line">pv005   15Gi       RWO,RWX        Retain           Available                                   17s</span><br></pre></td></tr></tbody></table></figure><h6 id="创建-PVC-并绑定-PV"><a href="#创建-PVC-并绑定-PV" class="headerlink" title="创建 PVC 并绑定 PV"></a>创建 PVC 并绑定 PV</h6><ul><li>通过 YAML 文件（比如 <code>pvc-demo.yaml</code>）创建一个 PersistentVolumeClaim（PVC），需要 6G 存储空间，所以不会匹配上面的 <code>pv001</code>、<code>pv002</code>、<code>pv003</code></li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">6Gi</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>配置字段</th><th>含义</th></tr></thead><tbody><tr><td><code>namespace</code></td><td>PVC 所在命名空间为 <code>default</code>。</td></tr><tr><td><code>accessModes</code></td><td>设置访问模式，这里为 <code>ReadWriteMany</code>，表示允许多个节点同时读写。</td></tr><tr><td><code>resources.requests.storage</code></td><td>申请的存储大小，这里为 <code>6Gi</code>。</td></tr></tbody></table><ul><li>创建或更新 YAML 文件（比如 <code>pvc-demo.yaml</code>）中定义的 PVC 对象 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> pvc-demo.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 PVC</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pvc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME    STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">mypvc   Bound    pv004    10Gi       RWO,RWX                       5s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 PV</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pv</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM           STORAGECLASS   REASON   AGE</span><br><span class="line">pv001   2Gi        RWO,RWX        Retain           Available                                           4m11s</span><br><span class="line">pv002   3Gi        RWO            Retain           Available                                           4m11s</span><br><span class="line">pv003   5Gi        RWO,RWX        Retain           Available                                           4m11s</span><br><span class="line">pv004   10Gi       RWO,RWX        Retain           Bound       default/mypvc                           4m11s</span><br><span class="line">pv005   15Gi       RWO,RWX        Retain           Available                                           4m11s</span><br></pre></td></tr></tbody></table></figure><h6 id="创建-Pod-并挂载-PVC"><a href="#创建-Pod-并挂载-PVC" class="headerlink" title="创建 Pod 并挂载 PVC"></a>创建 Pod 并挂载 PVC</h6><ul><li>通过 YAML 文件（比如 <code>pod-demo.yaml</code>）创建一个 Deployment 和 Service，并挂载 PVC</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>                 <span class="comment"># Service 类型为 NodePort，可通过节点 IP 访问</span></span><br><span class="line">  <span class="attr">selector:</span>                      <span class="comment"># 选择器，匹配后端 Pod 的标签（labels）</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>                   <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span>             <span class="comment"># Pod 内容器实际监听的端口（即将请求转发到容器的 xxxx 端口）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">volumeMounts:</span>               <span class="comment"># 声明要挂载的卷（volume）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html/</span></span><br><span class="line">      <span class="attr">volumes:</span>                        <span class="comment"># 定义 Pod 级别的卷（volume）</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span>      <span class="comment"># 指定使用已有的 PersistentVolumeClaim（PVC）</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">mypvc</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>配置字段</th><th>含义</th></tr></thead><tbody><tr><td><code>containers.volumeMounts.mountPath</code></td><td>指定容器内的挂载路径 <code>/usr/share/nginx/html/</code>。</td></tr><tr><td><code>volumes.persistentVolumeClaim.claimName</code></td><td>绑定前面创建的 PVC 名称 <code>mypvc</code>。</td></tr></tbody></table><ul><li>创建或更新 YAML 文件（比如 <code>pod-demo.yaml</code>）中定义的 Deployment 和 Service 对象 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> pod-demo.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                            READY   STATUS    RESTARTS   AGE    IP            NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-deploy-7ccc7cd487-77mmd   1/1     Running   0          8m9s   10.244.0.11   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Service</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP        92d</span><br><span class="line">nginx-svc    NodePort    10.0.0.62    &lt;none&gt;        80:31566/TCP   3m29s</span><br></pre></td></tr></tbody></table></figure><ul><li>在 NFS 的共享目录中，创建 Nginx 的首页文件（<code>index.html</code>），避免挂载卷（Volume）后覆盖了 Nginx 镜像原有的默认首页，导致 Nginx 首页访问出现 403 错误 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接进 Nginx 容器内，在 NFS 共享目录中创建 Nginx 首页的 HTML 文件</span></span><br><span class="line">kubectl <span class="built_in">exec</span><span class="params"> -it</span> nginx-deploy-7ccc7cd487-77mmd -- bash<span class="params"> -c</span> <span class="string">'echo "&lt;h1&gt;Hello from NFS Volume&lt;/h1&gt;" &gt; /usr/share/nginx/html/index.html'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>最后通过任意一个集群节点的 IP 与 Service 对外暴露的端口（比如 <code>http://192.168.2.191:31566</code>），就可以在 Kubernetes 集群外部通过浏览器访问 Nginx 的首页（如下图所示）</li></ul><p><img data-src="../../../asset/2025/11/k8s-volume-nfs-nginx.png"></p><h6 id="手动回收-Released-PV"><a href="#手动回收-Released-PV" class="headerlink" title="手动回收 Released PV"></a>手动回收 Released PV</h6><p>在<a href="/posts/723af70c.html#PV-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B">上面的案例中</a>，当 Pod 和 PVC 都被删除后，PV 会处于 <code>Released</code> 状态，对应的底层存储与数据会保留下来。此时，集群管理员需要手动处理（例如备份或清理数据），然后手动将 PV 重新配置，这样该 PV 才可以供新的 PVC 使用。</p><ul><li>删除 Pod 与 PVC</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 Pod</span></span><br><span class="line">kubectl delete<span class="params"> -f</span> pod-demo.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 PVC</span></span><br><span class="line">kubectl delete<span class="params"> -f</span> pvc-demo.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 PV</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pv</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM           STORAGECLASS   REASON   AGE</span><br><span class="line">pv001   2Gi        RWO,RWX        Retain           Available                                           3h35m</span><br><span class="line">pv002   3Gi        RWO            Retain           Available                                           3h35m</span><br><span class="line">pv003   5Gi        RWO,RWX        Retain           Available                                           3h35m</span><br><span class="line">pv004   10Gi       RWO,RWX        Retain           Released    default/mypvc                           3h35m</span><br><span class="line">pv005   15Gi       RWO,RWX        Retain           Available                                           3h35m</span><br></pre></td></tr></tbody></table></figure><p>从上面的输出信息，可以看到 <code>pv004</code> 的状态为 <code>STATUS: Released</code>，表示该 PV 原先被某个 PVC（这里是 <code>default/mypvc</code>）绑定过，但 PVC 已被删除。由于该 PV 的回收策略是 <code>Retain</code>，Kubernetes 不会自动清理其中的数据，也不会重新将它标记为可用（<code>Available</code>）。要让处于 <code>Released</code> 状态的 PV 再次可用（允许重新绑定新的 PVC），必须手动回收该 PV，以下是标准的做法。</p><hr><ul><li><p>1、删除旧 PVC 产生的残留数据</p><ul><li>通常 PV 对应一个存储路径（比如 NFS、<code>hostPath</code>、或本地目录等）。</li><li>(1) 先找到 PV 对应的存储目录路径：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pv pv004</span><br></pre></td></tr></tbody></table></figure></li><li>(2) 然后在输出内容中找到：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Source:</span></span><br><span class="line">    <span class="attr">Server:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.188</span></span><br><span class="line">    <span class="attr">Path:</span> <span class="string">/data/volumes/v4</span></span><br></pre></td></tr></tbody></table></figure></li><li>(3) 最后手动删除存储目录路径中的所有文件：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这一步骤会删除上一个 PVC 的所有数据，请谨慎执行</span></span><br><span class="line">sudo rm<span class="params"> -rf</span> /data/volumes/v4/*</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>2、移除 PV 上的旧 Claim 信息</p><ul><li>因为 PV 仍然绑定了旧的 PVC（<code>claimRef</code> 字段），所以必须解除旧 PVC 的绑定。</li><li>Kubernetes 不允许直接编辑已绑定的 PV<ul><li> 需要强制修改 PV<ul><li> 强制修改 PV<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch pv pv004<span class="params"> -p</span> <span class="string">'{"spec":{"claimRef": null}}'</span></span><br></pre></td></tr></tbody></table></figure></li><li>修改完成后，PV 的状态会改变为 <code>Available</code></li></ul></li><li>或者手动编辑 PV<ul><li> 手动编辑 PV<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit pv pv004</span><br></pre></td></tr></tbody></table></figure></li><li>删除如下字段（<code>claimRef</code>）内容 <figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">claimRef:</span></span><br><span class="line">  <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"473636"</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">1be643da-a7fe-4957-b8ec-887952ae7763</span></span><br></pre></td></tr></tbody></table></figure></li><li>保存退出后，PV 的状态会改变为 <code>Available</code></li></ul></li></ul></li></ul></li><li><p>3、确认 PV 可用</p><ul><li>查看所有 PV<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 PV 列表</span></span><br><span class="line">kubectl get pv</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">pv001   2Gi        RWO,RWX        Retain           Available                                   3h56m</span><br><span class="line">pv002   3Gi        RWO            Retain           Available                                   3h56m</span><br><span class="line">pv003   5Gi        RWO,RWX        Retain           Available                                   3h56m</span><br><span class="line">pv004   10Gi       RWO,RWX        Retain           Available                                   3h56m</span><br><span class="line">pv005   15Gi       RWO,RWX        Retain           Available                                   3h56m</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/35310aec.html">Centos7 搭建 NFS 服务器</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之九</title>
    <link href="https://www.techgrow.cn/posts/cfb1715d.html"/>
    <id>https://www.techgrow.cn/posts/cfb1715d.html</id>
    <published>2025-10-08T13:12:19.000Z</published>
    <updated>2025-10-08T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><h4 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h4><h5 id="Secret-的介绍"><a href="#Secret-的介绍" class="headerlink" title="Secret 的介绍"></a>Secret 的介绍</h5><ul><li><p>Secret 的概述</p><ul><li>Secret 是 Kubernetes 中一种用于存储敏感数据的对象类型。</li><li>Secret 会将敏感数据存储在 Etcd 里面，让 Pod 容器以环境变量或者挂载 Volume（卷）的方式进行访问。</li><li>Secret 的主要设计目标是：避免将敏感信息直接写入 Pod 的镜像或配置文件（如 Deployment、ConfigMap）中。</li><li>这些敏感数据包括（不限于）：<ul><li>数据库的用户名和密码</li><li> API Token 或访问密钥</li><li> SSL/TLS 私钥和证书</li><li> SSH 密钥</li></ul></li></ul></li><li><p> Secret 的作用</p></li></ul><table><thead><tr><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>保护敏感信息</td><td>通过 Base64 编码的形式保存机密数据，防止在 YAML 文件中明文出现。</td></tr><tr><td>与 Pod 解耦</td><td>应用不直接携带凭证，Secret 可独立管理、更新和分发。</td></tr><tr><td>灵活挂载</td><td>可作为环境变量或 Volume（卷）文件挂载到容器中。</td></tr><tr><td>与 ServiceAccount 结合使用</td><td>可用于保存访问 API Server 的 Token 等认证信息。</td></tr><tr><td>支持自动轮换和更新</td><td>可结合控制器或外部系统（如 Vault）可实现密钥动态更新。</td></tr></tbody></table><ul><li>Secret 的类型</li></ul><table><thead><tr><th> Secret 类型</th><th>用途说明</th></tr></thead><tbody><tr><td> Opaque</td><td> 默认类型，用于存放任意用户定义的键值对。</td></tr><tr><td>kubernetes.io/dockerconfigjson</td><td> 存放 Docker Registry 的认证信息，用于拉取私有镜像。</td></tr><tr><td>kubernetes.io/service-account-token</td><td> 系统自动创建，用于 ServiceAccount 与 API Server 通信。</td></tr><tr><td>kubernetes.io/tls</td><td> 存放 TLS 证书与私钥，用于 HTTPS、Ingress 等场景。</td></tr><tr><td>bootstrap.kubernetes.io/token</td><td> 集群引导时 Kubelet 注册节点所用的临时令牌。</td></tr></tbody></table><ul><li>Secret 的使用场景</li></ul><table><thead><tr><th>使用场景</th><th>使用说明</th></tr></thead><tbody><tr><td>应用访问数据库</td><td>存放数据库的账号密码，通过环境变量注入。</td></tr><tr><td>拉取私有镜像</td><td>创建 Docker Registry Secret 供 <code>imagePullSecrets</code> 使用。</td></tr><tr><td>HTTPS 服务</td><td>存放 TLS 证书，用于 Ingress 或自签服务。</td></tr><tr><td>外部 API 调用</td><td>存放第三方服务的 API Token。</td></tr><tr><td>集群内部通信认证</td><td> ServiceAccount Token 类型 Secret。</td></tr></tbody></table><ul><li>Secret 的注意事项<ul><li>虽然 Secret 可以用于保护敏感信息，但它并非绝对安全：<ul><li>默认仅使用 Base64 编码，并未将信息加密存储；</li><li>通常需要启用 Kubernetes Encryption at Rest，确保在 Etcd 中加密存储；</li><li>合理配置集群安全机制（RBAC），限制访问 Secret 的权限；</li><li>避免将 Secret 信息直接输出到日志文件或终端；</li><li>建议结合外部安全系统（如 HashiCorp Vault、Sealed Secrets、External Secrets Operator）进行管理。</li></ul></li><li>Secret 以 Volume（卷）的方式挂载时支持热更新<ul><li><strong> Secret 更新后，不会自动更新 Pod 中容器内的环境变量，也不会触发容器重启；</strong></li><li><strong>但是，如果 Secret 是以 Volume（卷）的方式挂载，并且该挂载未使用 <code>subPath</code>，则 Pod 中容器内挂载的文件会在 60 秒内自动更新（热更新）；</strong></li><li>另外，应用程序需要在运行时重新读取这些文件（例如通过文件监听或定时重新加载配置）才能真正实现热更新。</li></ul></li><li>通过控制器（如 Deployment）触发 Pod 重启可以实现 Secret 更新生效<ul><li>更改 Secret 后，可以手动触发 Deployment 滚动重启（比如执行 <code>kubectl rollout restart deployment &lt;name&gt;</code>）；</li><li>Deployment 滚动重启时，Kubernetes 会让该 Deployment 下的所有 Pod 重新创建，但不会更改镜像版本；</li><li>当 Pod 重启后，容器启动时会重新加载 Secret，从而使最新的机密配置生效。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">subPath 的作用</p><ul><li><code>subPath</code> 是 Kubernetes 在 Volume 挂载中的一个重要机制，用于只挂载卷里的单个文件或者子目录，而不是整个目录。</li><li><code>subPath</code> 不支持热更新，即使底层 Volume（如 ConfigMap 或 Secret）更新后，挂载到 <code>subPath</code> 的文件也不会自动刷新（热更新）。</li><li><code>subPath</code> 不能用于挂载整个目录时的热更新场景，如果需要实时更新配置（比如热更新 Nginx 配置），不可以使用 <code>subPath</code>。</li></ul></div><h5 id="Secret-的创建"><a href="#Secret-的创建" class="headerlink" title="Secret 的创建"></a>Secret 的创建</h5><p>Secret 的创建通常有以下三种方式：</p><ul><li>通过命令行创建 Secret</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动创建 Secret</span></span><br><span class="line">kubectl create secret generic my-secret<span class="params"> --from</span>-literal=username=admin<span class="params"> --from</span>-literal=password=123456</span><br></pre></td></tr></tbody></table></figure><ul><li>通过文件创建 Secret</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic db-secret<span class="params"> --from</span>-file=username.txt<span class="params"> --from</span>-file=password.txt</span><br></pre></td></tr></tbody></table></figure><ul><li>通过 YAML 文件（比如 <code>my-secret.yaml</code>）创建 Secret</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span>      <span class="comment"># Base64(admin)</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MTIzNDU2</span>      <span class="comment"># Base64(123456)</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 Secret 对象</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> my-secret.yaml</span><br></pre></td></tr></tbody></table></figure><h5 id="Secret-的查看"><a href="#Secret-的查看" class="headerlink" title="Secret 的查看"></a>Secret 的查看</h5><ul><li>查看 Secret 的详情 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe secret my-secret</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Secret 的完整内容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Secret 的内容（注意：内容经过 Base64 编码）</span></span><br><span class="line">kubectl get secret my-secret<span class="params"> -o</span> yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Secret 列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看默认命名空间下的所有 Secret</span></span><br><span class="line">kubectl get secrets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定命名空间下的所有 Secret</span></span><br><span class="line">kubectl get secrets<span class="params"> -n</span> dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有命名空间下的 Secret</span></span><br><span class="line">kubectl get secrets<span class="params"> --all</span>-namespaces</span><br></pre></td></tr></tbody></table></figure><h5 id="Secret-的更改"><a href="#Secret-的更改" class="headerlink" title="Secret 的更改"></a>Secret 的更改</h5><blockquote><p>Secret 的更改有以下几种方式</p></blockquote><ul><li>(1) 使用 <code>kubectl edit secret</code>（最常用）直接编辑 Secret，默认会打开一个临时编辑器（比如 <code>vi</code> 或 <code>nano</code>），编辑后保存退出即可，保存后会自动更新 Secret。这种方式需要手动对配置内容进行 Base64 编码，比如 <code>echo -n 'newuser' | base64</code>。</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit secret my-secret</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 使用 <code>kubectl apply</code>（声明式更新），如果有一个用于定义 Secret 的 YAML 文件（例如 <code>my-secret.yaml</code>），可以执行以下命令更新 Secret。这种方式可以直接在 YAML 文件中使用未经过 Base64 编码的配置内容，K8s 会自动将其转换成 Base64 编码。</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> my-secret.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 使用 <code>kubectl patch secret</code>（部分字段更新），只更新指定的字段（无需编辑整个 YAML）。这种方式 K8s 会自动将配置内容转换成 Base64 编码再存入 Etcd 中，不需要手动处理 Base64 编码。</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新单个字段（Key）</span></span><br><span class="line">kubectl patch secret my-secret<span class="params"> -p</span> <span class="string">'{"stringData":{"password":"123456"}}'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时改两个字段（Key）</span></span><br><span class="line">kubectl patch secret my-secret<span class="params"> -p</span> <span class="string">'{"stringData":{"username":"root","password":"123456"}}'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 直接重新创建 Secret（简单粗暴），也就是先删除旧的 Secret，然后创建新的 Secret。这种方式 K8s 会自动将配置内容转换成 Base64 编码再存入 Etcd 中，不需要手动处理 Base64 编码。</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic my-secret<span class="params"> --from</span>-literal=username=root<span class="params"> --from</span>-literal=password=123456<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml | kubectl apply<span class="params"> -f</span> -</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">Secret 热更新说明</p><ul><li>上面介绍的四种 Secret 更新方式，都不会自动更新相关 Pod 中容器内的环境变量，也不会触发相关 Pod 的 滚动更新（即不会重启 Pod，不会重启容器）。</li><li>但是，如果 Secret 是以 Volume（卷）的方式挂载，并且该挂载未使用 <code>subPath</code>，那么在 Secret 更新后，Pod 中容器内挂载的文件会在 60 秒内自动刷新（热更新）。</li></ul></div><blockquote><p>Secret 更新后滚动更新 Pod</p></blockquote><ul><li>上面介绍的四种 Secret 更新方式，都不会触发相关 Pod 的滚动更新（Rolling Update），也就是 Pod 不会自动重启，但可以通过手动修改 Pod Annotations 的方式强制触发 Pod 的滚动更新。比如：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch deployment my-nginx<span class="params"> --patch</span> <span class="string">'{"spec": {"template": {"metadata":{"annotations": {"version/config": "20190411" }}}}}'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在这个例子中，往 <code>spec.template.metadata.annotations</code> 中添加了 <code>version/config</code>，每次在 Secret 更新后，可以通过手动修改 <code>version/config</code> 来触发 Pod 的滚动更新。</li><li>这里的 <code>spec.template.metadata.annotations</code> 是 Pod 模板（<code>spec.template</code>）元数据中的注解字段，当该字段的内容发生变化时，Kubernetes 会认为 Pod 模板被修改，于是触发新的 Replica Set（RS）创建，从而滚动替换所有旧的 Pod。</li></ul><div class="admonition warning"><p class="admonition-title">其他 Pod 滚动更新方案</p><ul><li>在更新 Secret 后，除了可以通过手动修改 Pod Annotations 的方式强制触发 Pod 的滚动更新，还可以手动触发 Deployment 重启，从而实现 Pod 重启，比如 <code>kubectl rollout restart deployment my-nginx</code>。</li><li>推荐自动检测 Secret 变化（更高级），比如使用第三方工具（如 Stakater Reloader）监控 Secret 的变化，一旦检测到 Secret 更新，就自动触发对应 Pod 滚动更新。</li></ul></div><h5 id="Secret-的删除"><a href="#Secret-的删除" class="headerlink" title="Secret 的删除"></a>Secret 的删除</h5><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除默认命名空间下的单个 Secret</span></span><br><span class="line">kubectl delete secret my-secret</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除默认命名空间下的多个 Secret</span></span><br><span class="line">kubectl delete secret my-secret db-secret api-token</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除默认命名空间下的所有 Secret（慎用），系统自动生成的 ServiceAccount Token Secret 也会被删掉，从而影响 K8s 集群的正常运行</span></span><br><span class="line">kubectl delete secret<span class="params"> --all</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除特定命名空间下的单个 Secret</span></span><br><span class="line">kubectl delete secret my-secret<span class="params"> -n</span> dev</span><br></pre></td></tr></tbody></table></figure><h5 id="在-Pod-中使用-Secret"><a href="#在-Pod-中使用-Secret" class="headerlink" title="在 Pod 中使用 Secret"></a>在 Pod 中使用 Secret</h5><p>Secret 创建后，可以通过以下两种方式供 Pod 容器使用：</p><ul><li>挂载为环境变量，K8s 会将 Secret 中的键值对映射为系统环境变量 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-env-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo $DB_USER $DB_PASS; tail -f /dev/null"</span>]</span><br><span class="line">    <span class="attr">env:</span>                      <span class="comment"># 定义环境变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DB_USER</span>           <span class="comment"># 环境变量名</span></span><br><span class="line">      <span class="attr">valueFrom:</span>              <span class="comment"># 值来源于外部引用</span></span><br><span class="line">        <span class="attr">secretKeyRef:</span>         <span class="comment"># 引用类型为 Secret</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">my-secret</span>     <span class="comment"># Secret 的名称（需事先创建）</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">username</span>       <span class="comment"># Secret 中对应的键</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DB_PASS</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">secretKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">my-secret</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">password</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者使用 Deployment 管理 Pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-env-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">secret-env-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">secret-env-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo $DB_USER $DB_PASS; tail -f /dev/null"</span>]</span><br><span class="line">        <span class="attr">env:</span>                      <span class="comment"># 定义环境变量</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DB_USER</span>           <span class="comment"># 环境变量名</span></span><br><span class="line">          <span class="attr">valueFrom:</span>              <span class="comment"># 值来源于外部引用</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span>         <span class="comment"># 引用类型为 Secret</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">my-secret</span>     <span class="comment"># Secret 的名称（需事先创建）</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">username</span>       <span class="comment"># Secret 中对应的键</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DB_PASS</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">my-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">password</span></span><br></pre></td></tr></tbody></table></figure><ul><li>挂载为 Volume（卷），K8s 会自动将 Secret 中每个键映射为文件名（最终会自动创建多个文件），文件内容为键对应的值 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-volume-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"cat /etc/secret-data/username; tail -f /dev/null"</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span>                     <span class="comment"># 定义容器内要挂载的卷</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span>             <span class="comment"># 对应下面 volumes 中的卷名称（必须一致）</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/secret-data</span>     <span class="comment"># 将 Secret 内容挂载到容器内的该目录下</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span>                  <span class="comment"># 设置为只读（推荐），防止容器内误修改</span></span><br><span class="line">  <span class="attr">volumes:</span>                            <span class="comment"># 在 Pod 层定义卷（Volume）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span>               <span class="comment"># 指定卷的名称</span></span><br><span class="line">    <span class="attr">secret:</span>                           <span class="comment"># 指定卷的类型为 Secret</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">my-secret</span>           <span class="comment"># 指定引用的 Secret 名称（需事先创建）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者使用 Deployment 管理 Pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-volume-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">secret-volume-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">secret-volume-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"cat /etc/secret-data/username; tail -f /dev/null"</span>]</span><br><span class="line">        <span class="attr">volumeMounts:</span>                     <span class="comment"># 定义容器内要挂载的卷</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span>             <span class="comment"># 对应下面 volumes 中的卷名称（必须一致）</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/secret-data</span>     <span class="comment"># 将 Secret 内容挂载到容器内的该目录下</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span>                  <span class="comment"># 设置为只读（推荐），防止容器内误修改</span></span><br><span class="line">      <span class="attr">volumes:</span>                            <span class="comment"># 在 Pod 层定义卷（Volume）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span>               <span class="comment"># 指定卷的名称</span></span><br><span class="line">        <span class="attr">secret:</span>                           <span class="comment"># 指定卷的类型为 Secret</span></span><br><span class="line">          <span class="attr">secretName:</span> <span class="string">my-secret</span>           <span class="comment"># 指定引用的 Secret 名称（需事先创建）</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Secret-的完整使用案例"><a href="#Secret-的完整使用案例" class="headerlink" title="Secret 的完整使用案例"></a>Secret 的完整使用案例</h5><ul><li>通过 YAML 文件（比如 <code>secret-env-demo.yaml</code>）定义 Secret 和 Pod，并使用环境变量的方式引用 Secret</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 Secret</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span>      <span class="comment"># Base64(admin)</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MTIzNDU2</span>      <span class="comment"># Base64(123456)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 定义 Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-env-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">secret-env-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">secret-env-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo $DB_USER $DB_PASS; tail -f /dev/null"</span>]</span><br><span class="line">        <span class="attr">env:</span>                      <span class="comment"># 定义环境变量</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DB_USER</span>           <span class="comment"># 环境变量名</span></span><br><span class="line">          <span class="attr">valueFrom:</span>              <span class="comment"># 值来源于外部引用</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span>         <span class="comment"># 引用类型为 Secret</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">my-secret</span>     <span class="comment"># Secret 的名称（需事先创建）</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">username</span>       <span class="comment"># Secret 中对应的键</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DB_PASS</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">my-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">password</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 Secret 和 Deployment 对象</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> secret-env-demo.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                               READY   STATUS    RESTARTS   AGE   IP            NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">secret-env-demo-6c74c9dd76-9rbgr   1/1     Running   0          39s   10.244.0.13   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Pod 的日志信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs secret-env-demo-6c74c9dd76-9rbgr</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin 123456</span><br></pre></td></tr></tbody></table></figure><h4 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h4><p>在 Kubernetes 中，ConfigMap（配置映射）是一种非常重要的配置管理对象，用于将配置数据与应用程序代码分离。它的设计初衷是：应用程序镜像保持通用性，而不同环境下的配置信息（如开发、测试、生产）通过 ConfigMap 动态注入。</p><h5 id="ConfigMap-的介绍"><a href="#ConfigMap-的介绍" class="headerlink" title="ConfigMap 的介绍"></a>ConfigMap 的介绍</h5><ul><li><p>ConfigMap 的概述</p><ul><li>ConfigMap 是一种用于存储非敏感配置信息的键值对集合的 Kubernetes 资源对象。</li><li>ConfigMap 会将非敏感数据存储在 Etcd 里面，让 Pod 容器以环境变量和挂载 Volume（卷）的方式进行访问。</li><li>ConfigMap 的核心思想是：配置应该与镜像解耦，应用部署时再注入配置，换句话说：<ul><li>用户可以在不修改镜像的前提下更改配置；</li><li>用户可以让相同的容器镜像在不同环境中以不同的方式运行。</li></ul></li></ul></li><li><p>ConfigMap 的作用</p><ul><li>配置解耦<ul><li>应用程序不再依赖镜像内置的配置，而是从外部（ConfigMap）加载配置。</li></ul></li><li>集中化管理配置<ul><li>所有 Pod 的环境变量、配置文件都可以统一由 ConfigMap 管理。</li></ul></li><li>灵活的注入方式<ul><li> ConfigMap 可通过以下方式注入到 Pod 容器中：<ul><li>作为环境变量；</li><li>以卷（Volume）挂载的方式出现在容器文件系统中。</li></ul></li></ul></li></ul></li><li><p>ConfigMap 的注意事项</p><ul><li>ConfigMap 不适合存储敏感信息<ul><li>因为信息是明文保存的，敏感信息应该使用 Secret 进行存储。</li></ul></li><li>ConfigMap 以 Volume（卷）的方式挂载时支持热更新<ul><li><strong> ConfigMap 更新后，不会自动更新 Pod 中容器内的环境变量，也不会触发容器重启；</strong></li><li><strong>但是，如果 ConfigMap 是以 Volume（卷）的方式挂载，并且该挂载未使用 <code>subPath</code>，则 Pod 中容器内挂载的文件会在 60 秒内自动更新（热更新）；</strong></li><li>另外，应用程序需要在运行时重新读取这些文件（例如通过文件监听或定时重新加载配置）才能真正实现热更新。</li></ul></li><li>通过控制器（如 Deployment）触发 Pod 重启可以实现 ConfigMap 更新生效<ul><li>更改 ConfigMap 后，手动触发 Deployment 滚动重启（比如执行 <code>kubectl rollout restart deployment &lt;name&gt;</code>）；</li><li>Deployment 滚动重启时，K8s 会让 Deployment 下的 Pod 全部重新创建，但不会改变镜像版本；</li><li>当 Pod 重启后，容器启动时会重新加载 ConfigMap，从而使最新的配置生效。</li></ul></li><li>配置信息的大小限制<ul><li>单个 ConfigMap 的大小不能超过 1MB。</li></ul></li></ul></li><li><p>ConfigMap 的使用场景</p></li></ul><table><thead><tr><th>使用场景</th><th>示例</th></tr></thead><tbody><tr><td>多环境配置</td><td>开发、测试、生产等环境使用不同的 ConfigMap</td></tr><tr><td> 应用启动参数</td><td>通过环境变量动态配置应用的启动参数</td></tr><tr><td>配置文件注入</td><td>将配置文件挂载进容器内部，如 Nginx、Tomcat 的配置文件</td></tr><tr><td>滚动更新配置</td><td>更改 ConfigMap 后，可以通过 Deployment 滚动重启 Pod，动态加载新的配置</td></tr><tr><td>与 Secret 搭配使用</td><td> ConfigMap 负责管理非敏感配置信息，Secret 负责管理敏感配置信息（如密码、Token）</td></tr></tbody></table><ul><li>ConfigMap 的最佳实践</li></ul><table><thead><tr><th>使用场景</th><th>推荐方案</th></tr></thead><tbody><tr><td>应用支持热更新（如 Nginx、Envoy）</td><td>挂载 ConfigMap 文件，监控文件变更，感知配置更新</td></tr><tr><td>应用不支持热更新（如 Java Spring Boot）</td><td>更改 ConfigMap 后，触发 Deployment 滚动重启（<code>kubectl rollout restart deployment &lt;name&gt;</code>），不会改变镜像版本</td></tr><tr><td>同时包含敏感与非敏感配置</td><td>使用 Secret + ConfigMap 分开挂载</td></tr></tbody></table><ul><li> ConfigMap 与 Secret 对比</li></ul><table><thead><tr><th>对比项</th><th> ConfigMap</th><th>Secret</th></tr></thead><tbody><tr><td> 内容</td><td>非敏感配置信息</td><td>敏感配置信息（如密码、证书）</td></tr><tr><td>编码</td><td>明文</td><td> Base64 编码</td></tr><tr><td>用途</td><td>普通配置文件、应用启动参数</td><td>密钥、Token、证书</td></tr><tr><td>安全性</td><td>低</td><td>高</td></tr><tr><td>存储方式</td><td> Etcd 明文存储</td><td> Etcd 加密存储（需要额外配置）</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">subPath 的作用</p><ul><li><code>subPath</code> 是 Kubernetes 在 Volume 挂载中的一个重要机制，用于只挂载卷里的单个文件或者子目录，而不是整个目录。</li><li><code>subPath</code> 不支持热更新，即使底层 Volume（如 ConfigMap 或 Secret）更新后，挂载到 <code>subPath</code> 的文件也不会自动刷新（热更新）。</li><li><code>subPath</code> 不能用于挂载整个目录时的热更新场景，如果需要实时更新配置（比如热更新 Nginx 配置），不可以使用 <code>subPath</code>。</li></ul></div><h5 id="ConfigMap-的创建"><a href="#ConfigMap-的创建" class="headerlink" title="ConfigMap 的创建"></a>ConfigMap 的创建</h5><p>ConfigMap 的创建通常有以下几种方式：</p><ul><li>通过命令行创建 ConfigMap</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap app-config<span class="params"> --from</span>-literal=app_mode=production<span class="params"> --from</span>-literal=app_debug=<span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><ul><li>通过文件创建 ConfigMap</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap app-config<span class="params"> --from</span>-file=app.properties</span><br></pre></td></tr></tbody></table></figure><ul><li>通过目录创建 ConfigMap</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap app-config<span class="params"> --from</span>-file=./config/</span><br></pre></td></tr></tbody></table></figure><ul><li>通过 YAML 文件（比如 <code>app-config.yaml</code>）创建 ConfigMap</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: app-config</span><br><span class="line">data:</span><br><span class="line">  app_mode: <span class="string">"production"</span></span><br><span class="line">  app_debug: <span class="string">"false"</span></span><br><span class="line">  database.conf: |</span><br><span class="line">    host=127.0.0.1</span><br><span class="line">    port=3306</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 ConfigMap 对象</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> app-config.yaml</span><br></pre></td></tr></tbody></table></figure><h5 id="ConfigMap-的查看"><a href="#ConfigMap-的查看" class="headerlink" title="ConfigMap 的查看"></a>ConfigMap 的查看</h5><ul><li>查看 ConfigMap 的详情 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe configmap app-config</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 ConfigMap 的完整内容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get configmap app-config<span class="params"> -o</span> yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 ConfigMap 列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看默认命名空间下的所有 ConfigMap</span></span><br><span class="line">kubectl get configmaps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定命名空间下的所有 ConfigMap</span></span><br><span class="line">kubectl get configmaps<span class="params"> -n</span> dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有命名空间下的 ConfigMap</span></span><br><span class="line">kubectl get configmaps<span class="params"> --all</span>-namespaces</span><br></pre></td></tr></tbody></table></figure><h5 id="ConfigMap-的更改"><a href="#ConfigMap-的更改" class="headerlink" title="ConfigMap 的更改"></a>ConfigMap 的更改</h5><blockquote><p>ConfigMap 的更改有以下几种方式</p></blockquote><ul><li>(1) 使用 <code>kubectl edit configmap</code>（最常用）直接编辑 ConfigMap，默认会打开一个临时编辑器（比如 <code>vi</code> 或 <code>nano</code>），编辑后保存退出即可，保存后会自动更新 ConfigMap</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit configmap app-config</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 使用 <code>kubectl apply</code>（声明式更新），如果有一个用于定义 ConfigMap 的 YAML 文件（例如 <code>app-config.yaml</code>），可以执行以下命令更新 ConfigMap</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> app-config.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 使用 <code>kubectl patch configmap</code>（部分字段更新），只更新指定的字段（无需编辑整个 YAML）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新单个字段（Key）</span></span><br><span class="line">kubectl patch configmap app-config<span class="params"> -p</span> <span class="string">'{"data":{"app_mode":"development"}}'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时改两个字段（Key）</span></span><br><span class="line">kubectl patch configmap app-config<span class="params"> -p</span> <span class="string">'{"data":{"app_mode":"development","app_debug":"true"}}'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 直接重新创建 ConfigMap（简单粗暴），也就是先删除旧的 ConfigMap，然后创建新的 ConfigMap</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap app-config<span class="params"> --from</span>-literal=app_mode=development<span class="params"> --from</span>-literal=app_debug=<span class="literal">true</span><span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml | kubectl apply<span class="params"> -f</span> -</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">ConfigMap 热更新说明</p><ul><li>上面介绍的四种 ConfigMap 更新方式，都不会自动更新相关 Pod 中容器内的环境变量，也不会触发相关 Pod 的 滚动更新（即不会重启 Pod，不会重启容器）。</li><li>但是，如果 ConfigMap 是以 Volume（卷）的方式挂载，并且该挂载未使用 <code>subPath</code>，那么在 ConfigMap 更新后，Pod 中容器内挂载的文件会在 60 秒内自动刷新（热更新）。</li></ul></div><blockquote><p>ConfigMap 更新后滚动更新 Pod</p></blockquote><ul><li>上面介绍的四种 ConfigMap 更新方式，都不会触发相关 Pod 的滚动更新（Rolling Update），也就是 Pod 不会自动重启，但可以通过手动修改 Pod Annotations 的方式强制触发 Pod 的滚动更新。比如：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch deployment my-nginx<span class="params"> --patch</span> <span class="string">'{"spec": {"template": {"metadata":{"annotations": {"version/config": "20190411" }}}}}'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在这个例子中，往 <code>spec.template.metadata.annotations</code> 中添加了 <code>version/config</code>，每次在 ConfigMap 更新后，可以通过手动修改 <code>version/config</code> 来触发 Pod 的滚动更新。</li><li>这里的 <code>spec.template.metadata.annotations</code> 是 Pod 模板（<code>spec.template</code>）元数据中的注解字段，当该字段的内容发生变化时，Kubernetes 会认为 Pod 模板被修改，于是触发新的 Replica Set（RS）创建，从而滚动替换所有旧的 Pod。</li></ul><div class="admonition warning"><p class="admonition-title">其他 Pod 滚动更新方案</p><ul><li>在更新 ConfigMap 后，除了可以通过手动修改 Pod Annotations 的方式强制触发 Pod 的滚动更新，还可以手动触发 Deployment 重启，从而实现 Pod 重启，比如 <code>kubectl rollout restart deployment my-nginx</code>。</li><li>推荐自动检测 ConfigMap 变化（更高级），比如使用第三方工具（如 Stakater Reloader）监控 ConfigMap 的变化，一旦检测到 ConfigMap 更新，就自动触发对应 Pod 滚动更新。</li></ul></div><h5 id="ConfigMap-的删除"><a href="#ConfigMap-的删除" class="headerlink" title="ConfigMap 的删除"></a>ConfigMap 的删除</h5><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除默认命名空间下的单个 ConfigMap</span></span><br><span class="line">kubectl delete configmap app-config</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除默认命名空间下的多个 ConfigMap</span></span><br><span class="line">kubectl delete configmap cm1 cm2 cm3</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除默认命名空间下的所有 ConfigMap（慎用），系统自动生成的 ConfigMap 也会被删掉，从而影响 K8s 集群的正常运行</span></span><br><span class="line">kubectl delete configmap<span class="params"> --all</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除特定命名空间下的单个 ConfigMap</span></span><br><span class="line">kubectl delete configmap nginx-config<span class="params"> -n</span> dev</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>删除 ConfigMap 不会立即影响已运行的 Pod，除非该 ConfigMap 是以挂载卷（Volume）或环境变量形式注入，并且 Pod 被重新启动或重新加载。</li><li>如果在 Deployment、DaemonSet 或 StatefulSet 中使用了 ConfigMap，可以手动更新 ConfigMap，然后执行 <code>kubectl rollout restart deployment &lt;name&gt;</code> 命令进行滚动更新，这样 ConfigMap 的更新就会生效。</li></ul></div><h5 id="在-Pod-中使用-ConfigMap"><a href="#在-Pod-中使用-ConfigMap" class="headerlink" title="在 Pod 中使用 ConfigMap"></a>在 Pod 中使用 ConfigMap</h5><p>ConfigMap 创建后，可以通过以下两种方式供 Pod 容器使用：</p><ul><li>挂载为环境变量：K8s 会将 ConfigMap 中的键值对映射为系统环境变量 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-env-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo $APP_MODE $APP_DEBUG; tail -f /dev/null"</span>]</span><br><span class="line">    <span class="attr">env:</span>                       <span class="comment"># 定义环境变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">APP_MODE</span>           <span class="comment"># 环境变量名</span></span><br><span class="line">      <span class="attr">valueFrom:</span>               <span class="comment"># 值来源于外部引用</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span>       <span class="comment"># 引用类型为 ConfigMap</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">app-config</span>     <span class="comment"># ConfigMap 的名称（需事先创建）</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">app_mode</span>        <span class="comment"># ConfigMap 中对应的键</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">APP_DEBUG</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">app-config</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">app_debug</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者使用 Deployment 管理 Pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-env-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">configmap-env-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">configmap-env-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo $APP_MODE $APP_DEBUG; tail -f /dev/null"</span>]</span><br><span class="line">        <span class="attr">env:</span>                       <span class="comment"># 定义环境变量</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">APP_MODE</span>           <span class="comment"># 环境变量名</span></span><br><span class="line">          <span class="attr">valueFrom:</span>               <span class="comment"># 值来源于外部引用</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span>       <span class="comment"># 引用类型为 ConfigMap</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">app-config</span>     <span class="comment"># ConfigMap 的名称（需事先创建）</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">app_mode</span>        <span class="comment"># ConfigMap 中对应的键</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">APP_DEBUG</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">app-config</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">app_debug</span></span><br></pre></td></tr></tbody></table></figure><ul><li>挂载为 Volume（卷）：K8s 会自动将 ConfigMap 中每个键映射为文件名（最终会自动创建多个文件），文件内容为键对应的值 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-volume-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"cat /etc/config-data/app_mode; tail -f /dev/null"</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span>                     <span class="comment"># 定义容器内要挂载的卷</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span>             <span class="comment"># 对应下面 volumes 中的卷名称（必须一致）</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/config-data</span>     <span class="comment"># 将 ConfigMap 内容挂载到容器内的该目录下</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span>                  <span class="comment"># 设置为只读（推荐），防止容器内误修改</span></span><br><span class="line">  <span class="attr">volumes:</span>                            <span class="comment"># 在 Pod 层定义卷（Volume）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span>               <span class="comment"># 指定卷的名称</span></span><br><span class="line">    <span class="attr">configMap:</span>                        <span class="comment"># 指定卷的类型为 ConfigMap</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">app-config</span>                <span class="comment"># 指定引用的 ConfigMap 名称（需事先创建）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者使用 Deployment 管理 Pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-volume-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">configmap-volume-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">configmap-volume-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"cat /etc/config-data/app_mode; tail -f /dev/null"</span>]</span><br><span class="line">        <span class="attr">volumeMounts:</span>                     <span class="comment"># 定义容器内要挂载的卷</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span>             <span class="comment"># 对应下面 volumes 中的卷名称（必须一致）</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/config-data</span>     <span class="comment"># 将 ConfigMap 内容挂载到容器内的该目录下</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span>                  <span class="comment"># 设置为只读（推荐），防止容器内误修改</span></span><br><span class="line">      <span class="attr">volumes:</span>                            <span class="comment"># 在 Pod 层定义卷（Volume）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span>               <span class="comment"># 指定卷的名称</span></span><br><span class="line">        <span class="attr">configMap:</span>                        <span class="comment"># 指定卷的类型为 ConfigMap</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">app-config</span>                <span class="comment"># 指定引用的 ConfigMap 名称（需事先创建）</span></span><br></pre></td></tr></tbody></table></figure><h5 id="ConfigMap-的完整使用案例"><a href="#ConfigMap-的完整使用案例" class="headerlink" title="ConfigMap 的完整使用案例"></a>ConfigMap 的完整使用案例</h5><ul><li>通过 YAML 文件（比如 <code>configmap-env-demo.yaml</code>）定义 ConfigMap 和 Pod，并使用环境变量的方式引用 ConfigMap</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">app_mode:</span> <span class="string">"production"</span></span><br><span class="line">  <span class="attr">app_debug:</span> <span class="string">"false"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 定义 Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-env-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">configmap-env-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">configmap-env-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo $APP_MODE $APP_DEBUG; tail -f /dev/null"</span>]</span><br><span class="line">        <span class="attr">env:</span>                       <span class="comment"># 定义环境变量</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">APP_MODE</span>           <span class="comment"># 环境变量名</span></span><br><span class="line">          <span class="attr">valueFrom:</span>               <span class="comment"># 值来源于外部引用</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span>       <span class="comment"># 引用类型为 ConfigMap</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">app-config</span>     <span class="comment"># ConfigMap 的名称（需事先创建）</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">app_mode</span>        <span class="comment"># ConfigMap 中对应的键</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">APP_DEBUG</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">app-config</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">app_debug</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 ConfigMap 和 Deployment 对象</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> configmap-env-demo.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">configmap-env-demo-698c84b677-625sk   1/1     Running   0          49s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Pod 的日志信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs configmap-env-demo-698c84b677-625sk</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">production false</span><br></pre></td></tr></tbody></table></figure><h5 id="ConfigMap-实现-Nginx-自动热更新"><a href="#ConfigMap-实现-Nginx-自动热更新" class="headerlink" title="ConfigMap 实现 Nginx 自动热更新"></a>ConfigMap 实现 Nginx 自动热更新</h5><ul><li><a href="/posts/8639f08c.html">Kubernetes 中实现 Nginx 配置自动热更新</a></li></ul><h3 id="集群安全机制"><a href="#集群安全机制" class="headerlink" title="集群安全机制"></a>集群安全机制</h3><h4 id="RBAC-的基本概念"><a href="#RBAC-的基本概念" class="headerlink" title="RBAC 的基本概念"></a>RBAC 的基本概念</h4><p>RBAC（Role Based Access Control，基于角色的访问控制）在 Kubernetes <code>v1.5</code> 中首次引入，并在 <code>v1.6</code> 版本升级为 Beta，成为 Kubeadm 安装方式下的默认授权模式。RBAC 的核心思想是：通过角色定义权限，通过角色绑定将权限授予给特定的主体（比如 User、Group、ServiceAccount），从而实现精细化的访问控制。<strong>Kubernetes 集群要启用 RBAC 授权模式，需要在 API Server 的启动参数中添加 <code>--authorization-mode=RBAC</code>。</strong></p><hr><ul><li><p>在 RBAC（基于角色的访问控制）中，主要包含以下四个核心概念：</p><ul><li>角色（Role / ClusterRole）：<ul><li>定义一组可执行的权限规则，即允许对哪些资源执行哪些操作。</li></ul></li><li>角色绑定（RoleBinding / ClusterRoleBinding）：<ul><li>将角色与主体进行关联，从而使主体获得该角色定义的权限。</li></ul></li><li>主体（Subject）：<ul><li>表示可以被授予权限的实体，包括用户（User）、用户组（Group）和服务账户（ServiceAccount）。</li></ul></li><li>权限规则（Policy Rules）：<ul><li>具体描述允许执行的操作，包括对哪些资源（<code>resources</code>）、在哪些命名空间（<code>namespace</code>）、执行哪些动作（<code>verbs</code>）等。</li></ul></li></ul></li><li><p>相比其他访问控制方式，RBAC（基于角色的访问控制）具有以下优势：</p><ul><li>权限覆盖全面：<ul><li>对集群中的资源和非资源类型的访问权限均提供完整支持。</li></ul></li><li>动态调整：<ul><li>可在集群运行时更改权限配置，无需重启 API Server。</li></ul></li><li>API 原生支持：<ul><li>RBAC 由若干 API 对象构成，可像其他 Kubernetes 资源一样通过 <code>kubectl</code> 或 API 进行管理。</li></ul></li></ul></li></ul><hr><ul><li>在访问 Kubernetes 集群的时候，需要经过以下三个步骤：<ul><li>第一步：认证<ul><li>核心目标：<ul><li>用于确认访问者的身份。</li></ul></li><li>访问端口：<ul><li>对外不暴露 <code>8080</code> 端口（仅供集群内部组件访问）；</li><li>对外提供的访问端口为 <code>6443</code>（HTTPS 端口）。</li></ul></li><li>认证方式：<ul><li>HTTPS 证书认证：基于 CA 证书验证客户端身份；</li><li>HTTP Token 认证：通过 Token 标识用户身份；</li><li>HTTP Basic 认证：基于用户名和密码进行身份校验。</li></ul></li></ul></li><li>第二步：鉴权（授权）<ul><li>在确认用户身份后，判断其是否具备执行该操作的权限；</li><li>Kubernetes 主要基于 RBAC（基于角色的访问控制）机制进行鉴权；</li><li>权限通过角色（Role / ClusterRole）与角色绑定（RoleBinding / ClusterRoleBinding）来定义和分配。</li></ul></li><li>第三步：准入控制<ul><li>用于在请求通过认证和鉴权后，对请求内容进行进一步的策略检查；</li><li>本质上是一个由多个准入控制器（Admission Controllers）组成的列表；</li><li>如果请求被这些准入控制器中的规则允许，则放行请求；否则，请求会被拒绝。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>在访问 Kubernetes 的过程中，都需要经过 API Server，由 API Server 做统一协调。比如，访问过程中需要 CA 证书、Token、或者用户名和密码；如果访问 Pod，则需要 Service Account。</p></div><h4 id="RBAC-的-API-资源对象"><a href="#RBAC-的-API-资源对象" class="headerlink" title="RBAC 的 API 资源对象"></a>RBAC 的 API 资源对象</h4><p>在 Kubernetes 中，RBAC 引入了 4 个新的顶级资源对象：Role、ClusterRole、RoleBinding、ClusterRoleBinding。同其他 API 资源对象一样，用户可以使用 <code>kubectl</code> 命令或者 API 调用等方式操作这些资源对象。</p><h5 id="Role（角色）"><a href="#Role（角色）" class="headerlink" title="Role（角色）"></a>Role（角色）</h5><blockquote><p>概念介绍</p></blockquote><ul><li>Role（角色）只能对命名空间内的资源进行授权。</li><li>一个 Role（角色）就是一组权限的集合，这里的权限都是许可形式的，不存在拒绝的规则。</li><li>在一个命名空间中，可以用 Role（角色）来定义一个角色。如果是集群级别的，就需要使用 ClusterRole（集群角色）了。</li></ul><blockquote><p>使用案例</p></blockquote><ul><li>在下面的例子中，定义的 Role（角色）具备读取 Pod 的权限：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">""</span>]    <span class="comment"># 空字符串表示核心 API 组（/api/v1）</span></span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"pods"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"get"</span>, <span class="string">"watch"</span>, <span class="string">"list"</span>]</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>参数名称</th><th>说明</th><th>配置示例</th></tr></thead><tbody><tr><td><code>apiGroups</code></td><td>支持的 API 组列表，用于指定资源所属的 API 组。核心组使用空字符串 <code>""</code> 表示。</td><td><code>"", "apps", "batch", "extensions"</code>（对应 <code>apiVersion: v1</code>、<code>apps/v1</code>、<code>batch/v1</code> 等）</td></tr><tr><td><code>resources</code></td><td>支持的资源对象列表，指定该角色可操作的 Kubernetes 资源类型。</td><td><code>pods</code>、<code>deployments</code>、<code>jobs</code>、<code>services</code> 等</td></tr><tr><td><code>verbs</code></td><td>对资源对象的操作方法列表，定义允许的具体操作。</td><td><code>get</code>、<code>watch</code>、<code>list</code>、<code>create</code>、<code>update</code>、<code>delete</code>、<code>patch</code>、<code>replace</code> 等</td></tr></tbody></table><h5 id="ClusterRole（集群角色）"><a href="#ClusterRole（集群角色）" class="headerlink" title="ClusterRole（集群角色）"></a>ClusterRole（集群角色）</h5><blockquote><p>概念介绍</p></blockquote><p>ClusterRole（集群角色）除了具备与 Role（角色）在单一命名空间内相同的资源管理能力外，由于其作用域为集群级别，还可用于授权以下几类对象：</p><ul><li>集群范围的资源，例如 <code>Node</code>（节点）；</li><li>非资源型路径，例如 <code>/healthz</code>；</li><li>跨全部命名空间的资源，例如在所有命名空间中的 <code>pods</code>。</li></ul><blockquote><p>使用案例</p></blockquote><ul><li>在下面的例子中，定义的 ClusterRole（集群角色）可以让用户有权访问任意一个或所有命名空间的 Secrets：</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="comment"># ClusterRole 不受限于命名空间，因此不需要定义 namespace</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">""</span>]     <span class="comment"># 空字符串表示核心 API 组（/api/v1）</span></span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"secrets"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"get"</span>, <span class="string">"watch"</span>, <span class="string">"list"</span>]</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>参数名称</th><th>说明</th><th>配置示例</th></tr></thead><tbody><tr><td><code>apiGroups</code></td><td>支持的 API 组列表，用于指定资源所属的 API 组。核心组使用空字符串 <code>""</code> 表示。</td><td><code>"", "apps", "batch", "extensions"</code>（对应 <code>apiVersion: v1</code>、<code>apps/v1</code>、<code>batch/v1</code> 等）</td></tr><tr><td><code>resources</code></td><td>支持的资源对象列表，指定该角色可操作的 Kubernetes 资源类型。</td><td><code>pods</code>、<code>deployments</code>、<code>jobs</code>、<code>services</code> 等</td></tr><tr><td><code>verbs</code></td><td>对资源对象的操作方法列表，定义允许的具体操作。</td><td><code>get</code>、<code>watch</code>、<code>list</code>、<code>create</code>、<code>update</code>、<code>delete</code>、<code>patch</code>、<code>replace</code> 等</td></tr></tbody></table><h5 id="RoleBinding（角色绑定）"><a href="#RoleBinding（角色绑定）" class="headerlink" title="RoleBinding（角色绑定）"></a>RoleBinding（角色绑定）</h5><blockquote><p>核心概念</p></blockquote><ul><li>RoleBinding（角色绑定）用于将一个 Role（角色）绑定到一个指定的主体上，绑定的主体可以是 User（用户）、Group（用户组）或 ServiceAccount（服务账户）。</li><li>RoleBinding（角色绑定）的授权范围限定在某个命名空间内，它可以引用同一命名空间中的 Role，为该命名空间内的资源授予相应的访问权限。</li></ul><blockquote><p>使用案例</p></blockquote><ul><li>在下面的例子中，RoleBinding（角色绑定）将在 <code>default</code> 命名空间中将 <code>pod-reader</code> 角色授予用户 <code>jane</code>，可以让 <code>jane</code> 用户读取 <code>default</code> 命名空间里的 Pod：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">jane</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>参数名称</th><th>说明</th><th>配置示例</th></tr></thead><tbody><tr><td><code>subjects</code></td><td>指定要绑定的访问主体，可以是用户（User）、用户组（Group）或服务账户（ServiceAccount）。此处绑定的主体是名为 <code>jane</code> 的用户。</td><td><code>jane</code></td></tr><tr><td><code>roleRef</code></td><td>指定要绑定的角色，用于定义该主体可执行的权限操作。此处引用的是命名空间内的 <code>pod-reader</code> 角色。</td><td><code>pod-reader</code></td></tr><tr><td><code>namespace</code></td><td>指定 RoleBinding 所属的命名空间，授权范围仅限于该命名空间内。此处为 <code>default</code> 命名空间。</td><td><code>default</code></td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><p>RoleBinding 除了可以引用 Role，还可以引用 ClusterRole，对属于同一命名空间内 ClusterRole 定义的资源主体进行授权。一种常见的做法是 Kubernetes 集群管理员为集群范围预先定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些 ClusterRole。</p></div><ul><li>在下面的例子中，使用 RoleBinding 绑定 ClusterRole（集群角色）<code>secret-reader</code>，使用户 <code>dave</code> 只能读取 <code>development</code> 命名空间中的 Secret：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dave</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></tbody></table></figure><ul><li>配置说明：<ul><li>RoleBinding 将集群角色 <code>secret-reader</code> 授权给命名空间 <code>development</code> 中的用户 <code>dave</code>。</li><li>虽然绑定的是 集群角色（ClusterRole），但作用仍限定在 <code>development</code> 命名空间。</li><li><code>subjects</code> 指定了被授权的主体，<code>roleRef</code> 指定了要绑定的集群角色（ClusterRole）。</li></ul></li></ul><h5 id="ClusterRoleBinding（集群角色绑定）"><a href="#ClusterRoleBinding（集群角色绑定）" class="headerlink" title="ClusterRoleBinding（集群角色绑定）"></a>ClusterRoleBinding（集群角色绑定）</h5><blockquote><p>核心概念</p></blockquote><ul><li>ClusterRoleBinding（集群角色绑定）用于将一个 ClusterRole（集群角色）绑定到一个指定的主体上，绑定的主体可以是 User（用户）、Group（用户组）或 ServiceAccount（服务账户）。</li><li>ClusterRoleBinding（集群角色绑定）的授权范围为整个集群，它可以引用任意命名空间中的 ServiceAccount，并为所有命名空间或集群级资源授予相应的访问权限。</li><li>ClusterRoleBinding（集群角色绑定）中的角色只能是 ClusterRole（集群角色），不能是 Role（角色），用于执行集群级别或者对所有命名空间都生效的授权操作。</li></ul><blockquote><p>使用案例</p></blockquote><ul><li>在下面的例子中，使用 ClusterRoleBinding 绑定 ClusterRole（集群角色）<code>secret-reader</code>，允许 <code>manager</code> 组的用户读取所有命名空间中的 Secret：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets-global</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">manager</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></tbody></table></figure><ul><li>配置说明：<ul><li>ClusterRoleBinding 将集群角色 <code>secret-reader</code> 授权给整个集群中的用户组 <code>manager</code>。</li><li>授权作用范围为整个集群，不仅限于某个命名空间。</li><li><code>subjects</code> 指定了被授权的主体，<code>roleRef</code> 指定了要绑定的集群角色（ClusterRole）。</li></ul></li></ul><h4 id="RBAC-对资源的引用方式"><a href="#RBAC-对资源的引用方式" class="headerlink" title="RBAC 对资源的引用方式"></a>RBAC 对资源的引用方式</h4><ul><li>多数 Kubernetes 资源可以通过其名称字符串表示，即在 Endpoint 的 URL 相对路径中体现，例如 <code>pods</code>。</li><li>某些 Kubernetes API 包含下级资源，例如 Pod 的日志 (<code>logs</code>)。<ul><li>例如，Pod 日志的访问路径为： <code>GET /api/v1/namespaces/{namespaces}/pods/{name}/log</code>。</li><li>在这个例子中，Pod 是命名空间内的主资源，而 <code>log</code> 是 Pod 的下级资源。</li></ul></li><li>如果要在 RBAC 角色（Role 或 ClusterRole）中体现这种层级关系，需要用斜杠 <code>/</code> 来分隔主资源和下级资源。<ul><li>例如，如果希望某个主体同时拥有读取 Pod 以及读取 Pod 日志的权限，则可以配置 <code>resources</code> 为一个数组：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-and-pod-logs-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">""</span>]                  <span class="comment"># 空字符串表示核心 API 组（/api/v1）</span></span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"pods"</span>, <span class="string">"pods/log"</span>]  <span class="comment"># 同时包含了主资源 pods 和下级资源 pods/log</span></span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"get"</span>, <span class="string">"list"</span>]           <span class="comment"># 指定该角色允许执行的操作</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>Kubernetes 资源还可以通过名称（ResourceName）进行引用。<ul><li>在指定 ResourceName 后，使用 <code>get</code>、<code>delete</code>、<code>update</code>、<code>patch</code> 动词的请求，就会被限制在这个资源实例范围内。</li><li>例如，下面的声明可以授权一个主体只能对一个叫 <code>my-configmap</code> 的 ConfigMap 执行 <code>get</code> 和 <code>update</code> 操作：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-updater</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">""</span>]                   <span class="comment"># 空字符串表示核心 API 组（/api/v1）</span></span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"configmaps"</span>]         <span class="comment"># resources 应为复数形式，比如 configmaps</span></span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">"my-configmap"</span>]   <span class="comment"># 指定作用对象</span></span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"update"</span>, <span class="string">"get"</span>]          <span class="comment"># 指定该角色允许执行的操作</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="RBAC-中常见的角色定义示例"><a href="#RBAC-中常见的角色定义示例" class="headerlink" title="RBAC 中常见的角色定义示例"></a>RBAC 中常见的角色定义示例</h4><ul><li>(1) 允许读取核心 API 组中 Pod 的资源 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">""</span>]   <span class="comment"># 空字符串表示核心 API 组（/api/v1）</span></span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"pods"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"get"</span>, <span class="string">"list"</span>, <span class="string">"watch"</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 允许读写 <code>extensions</code> 和 <code>apps</code> 两个 API 组中的 <code>deployment</code> 资源 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">"extensions"</span>, <span class="string">"apps"</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"deployments"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"get"</span>, <span class="string">"list"</span>, <span class="string">"watch"</span>, <span class="string">"create"</span>, <span class="string">"update"</span>, <span class="string">"patch"</span>, <span class="string">"delete"</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 允许读写 <code>pods</code> 及读写 <code>jobs</code></li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">""</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"pods"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"get"</span>, <span class="string">"list"</span>, <span class="string">"watch"</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">"batch"</span>, <span class="string">"extensions"</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"jobs"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"get"</span>, <span class="string">"list"</span>, <span class="string">"watch"</span>, <span class="string">"create"</span>, <span class="string">"update"</span>, <span class="string">"patch"</span>, <span class="string">"delete"</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 允许读取一个名为 <code>my-config</code> 的 ConfigMap（必须绑定到一个 RoleBinding 来限制到一个命名空间下的 ConfigMap）：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">""</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"configmaps"</span>]</span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">"my-config"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"get"</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>(5) 允许读取核心 API 组的 Node 资源（Node 属于集群级别的资源，必须放在 ClusterRole 中，并使用 ClusterRoleBinding 进行绑定）：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">""</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"nodes"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"get"</span>, <span class="string">"list"</span>, <span class="string">"watch"</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>(6) 允许对非资源端点 <code>/healthz</code> 及其所有子路径进行 GET / POST 操作（必须使用 ClusterRole 和 ClusterRoleBinding）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nonResourceURLs:</span> [<span class="string">"/healthz"</span>, <span class="string">"/healthz/*"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"get"</span>, <span class="string">"post"</span>]</span><br></pre></td></tr></tbody></table></figure><h4 id="RBAC-中常用的角色绑定示例"><a href="#RBAC-中常用的角色绑定示例" class="headerlink" title="RBAC 中常用的角色绑定示例"></a>RBAC 中常用的角色绑定示例</h4><ul><li>绑定用户名 <code>Alice@example.com</code></li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">"Alice@example.com"</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></tbody></table></figure><ul><li>绑定组名 <code>frontend-admins</code></li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">"frontend-admins"</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></tbody></table></figure><ul><li>绑定 <code>kube-system</code> 命名空间中的默认 Service Account</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">system:authentication</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">system:unauthentication</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></tbody></table></figure><h4 id="RBAC-中默认的角色和角色绑定"><a href="#RBAC-中默认的角色和角色绑定" class="headerlink" title="RBAC 中默认的角色和角色绑定"></a>RBAC 中默认的角色和角色绑定</h4><p>API Server 会创建一套默认的 ClusterRole 和 ClusterRoleBinding 资源对象，其中很多是以 <code>system:</code> 为前缀的，以表明这些资源属于基础架构，对这些对象的改动可能会造成集群故障。所有默认的 ClusterRole 和 RoleBinding 资源对象都会用标签 <code>kubernetes.io/bootstrapping=rbac-defaults</code> 进行标记。</p><blockquote><p>常见的系统角色</p></blockquote><table><thead><tr><th>默认的 ClusterRole</th><th> 默认的 ClusterRoleBinding</th><th> 描述</th></tr></thead><tbody><tr><td><code>system:basic-user</code></td><td><code>system:authenticated</code> 和 <code>system:unauthorized</code> 组</td><td>让用户能够读取自身的信息</td></tr><tr><td><code>system:discovery</code></td><td><code>system:authenticated</code> 和 <code>system:unauthorized</code> 组</td><td>对 API 发现 Endpoint 的只读访问，用于 API 级别的发现和协商</td></tr></tbody></table><blockquote><p>常见的用户角色</p></blockquote><p>有些默认角色不是以 <code>system:</code> 为前缀的，这部分角色是针对用户的，其中包含超级用户角色 <code>cluster-admin</code>，有的用于集群一级的角色 <code>cluster-status</code>，还有针对命名空间的角色 <code>admin</code>、<code>edit</code>、<code>view</code>。</p><table><thead><tr><th>默认的 ClusterRole</th><th> 默认的 ClusterRoleBinding</th><th> 描述</th></tr></thead><tbody><tr><td><code>cluster-admin</code></td><td><code>system:masters</code> 组</td><td>让超级用户可以对任何资源执行任何操作。如果在 ClusterRoleBinding 中使用，则影响的是整个集群的所有 NameSpace 中的任何资源；如果使用的是 RoleBinding，则能控制这一绑定的 NameSpace 中的资源，还包括 NameSpace 本身</td></tr><tr><td><code>cluster-status</code></td><td>None</td><td> 可以对基础集群状态信息进行只读访问</td></tr><tr><td><code>admin</code></td><td>None</td><td> 允许 <code>admin</code> 访问，可以限制在一个 NameSpace 中使用 RoleBinding。如果在 RoleBinding 中使用，则允许对 NameSpace 中的大多数资源进行读写访问，其中包含创建角色和角色绑定的能力。这一角色不允许操作 NameSpace 本身，也不能写入资源限制</td></tr><tr><td><code>edit</code></td><td>None</td><td> 允许对 NameSpace 内的大多数资源进行读写操作，不允许查看或更改角色，以及角色绑定</td></tr><tr><td><code>view</code></td><td>None</td><td> 允许对多数资源对象进行只读操作，但是对角色、角色绑定及 Secret 是不可访问的</td></tr></tbody></table><blockquote><p>核心 Master 组件角色</p></blockquote><table><thead><tr><th>默认的 ClusterRole</th><th> 默认的 ClusterRoleBinding</th><th> 描述</th></tr></thead><tbody><tr><td><code>system:kube-scheduler</code></td><td><code>system:kube-scheduler</code> 用户</td><td>能够访问 kube-scheduler 组件所需的资源</td></tr><tr><td><code>system:kube-controller-manager</code></td><td><code>system:kube-controller-manager</code> 用户</td><td>能够访问 kube-controller-manager 组件所需的资源</td></tr><tr><td><code>system:node</code></td><td><code>system:nodes</code> 组</td><td><br>- 允许访问 kubelet 所需的资源，包括对 Secret 的读取，以及对 Pod 的写入<br>- 未来会把上面的两个权限限制在分配到本 Node 的对象上<br>- 今后的鉴权过程，kubelet 必须以 <code>system:node</code> 及一个 <code>system:node</code> 形式的用户名进行。参看 <code>https://pr.k8s.io/40476</code></td></tr><tr><td><code>system:node-proxier</code></td><td><code>system:kube-proxy</code> 用户</td><td>允许访问 kube-proxy 所需的资源</td></tr><tr><td><code>system:kube-scheduler</code></td><td><code>system:kube-scheduler</code> 用户</td><td>能够访问 kube-scheduler 组件所需的资源</td></tr></tbody></table><h4 id="RBAC-中预防提权和授权初始化"><a href="#RBAC-中预防提权和授权初始化" class="headerlink" title="RBAC 中预防提权和授权初始化"></a>RBAC 中预防提权和授权初始化</h4><ul><li>RBAC API 会拒绝用户通过编辑角色或角色绑定的方式进行提权。这一限制是在 API 层面实现的，因此即使 RBAC 未启用，该限制仍然有效。</li><li>用户只能在拥有某个角色的所有权限，且与该角色的生效范围一致的前提下，才能对角色进行创建和更改。例如，用户 <code>user-1</code> 没有列出集群中所有 Secret 的权限，就无法创建具有该权限的 <code>ClusterRole</code>。</li><li>要让一个用户能够创建或者更改角色，需要满足以下条件：<ul><li>授予用户一个允许创建 / 更改 <code>Role</code> 或 <code>ClusterRole</code> 资源对象的角色；</li><li>为用户授予角色时，要覆盖该用户所能控制的所有权限范围。</li></ul></li><li>如果用户尝试创建超出自身权限的 Role 或 ClusterRole，该 API 调用会被拒绝。</li><li>如果一个用户的权限包含了某个角色的所有权限，则可以为其创建和更改该角色的绑定；或者，如果用户被授予了针对某个角色的绑定授权，也可以完成此操作。<ul><li>例如，用户 <code>user-1</code> 没有列出集群中所有 Secret 的权限，因此无法为一个具有此权限的角色创建 ClusterRoleBinding。要使用户能够创建或更改该角色绑定，需要：<ul><li>授予用户一个允许创建和更改 <code>RoleBinding</code> 或 <code>ClusterRoleBinding</code> 的角色；</li><li>授予用户绑定某一角色的权限，可以通过两种方式：<ul><li>隐式：让用户拥有该角色的所有权限；</li><li>显式：授予用户针对该角色或 ClusterRoleBinding 的操作权限。</li></ul></li></ul></li></ul></li><li>在进行第一个角色和角色绑定时，必须让初始用户具备其尚未被授予的权限，要进行初始的角色和角色绑定设置，有以下两种方法:<ul><li> 使用属于 <code>system:masters</code> 组的身份，这一群组默认具有 <code>cluster-admin</code> 这一超级用户角色的绑定；</li><li>如果 API Server 以 <code>--insecure-port</code> 参数启动，则客户端通过这个非安全端口进行接口调用，这一端口没有认证鉴权的限制。</li></ul></li></ul><blockquote><p>举个例子，允许用户 <code>user-1</code> 在 <code>user-1-namespace</code> 命名空间中，可以对其他用户授予 <code>admin</code>、<code>edit</code> 及 <code>view</code> 角色</p></blockquote><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-grantor</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">"rbac.authorization.k8s.io"</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"rolebindings"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"create"</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">"rbac.authorization.k8s.io"</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">"clusterroles"</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">"bind"</span>]</span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">"admin"</span>, <span class="string">"edit"</span>, <span class="string">"view"</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-grantor-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">user-1-namespace</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-1</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-grantor</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></tbody></table></figure><h4 id="RBAC-的完整使用演示案例"><a href="#RBAC-的完整使用演示案例" class="headerlink" title="RBAC 的完整使用演示案例"></a>RBAC 的完整使用演示案例</h4><div class="admonition note"><p class="admonition-title">提示</p><ul><li>本节将演示如何在 Kubernetes 集群中使用 RBAC，并通过 CA 证书进行认证（识别身份）。</li><li><strong>Kubernetes 集群要启用 RBAC 授权模式，需要在 API Server 的启动参数中添加 <code>--authorization-mode=RBAC</code>。</strong></li></ul></div><blockquote><p><strong>(1) 创建命名空间</strong></p></blockquote><ul><li>创建命名空间 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create ns roledemo</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有命名空间 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ns</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   83d</span><br><span class="line">kube-flannel      Active   81d</span><br><span class="line">kube-node-lease   Active   83d</span><br><span class="line">kube-public       Active   83d</span><br><span class="line">kube-system       Active   83d</span><br><span class="line">roledemo          Active   111m</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>(2) 创建 Deployment</strong></p></blockquote><ul><li>通过 YAML 文件（比如 <code>nginx-deploy.yaml</code>）创建 Deployment（用于创建和管理 Pod）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">roledemo</span>     <span class="comment"># 指定命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 Deployment 对象</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> nginx-deploy.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看特定命名空间内的所有 Pod</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -n</span> roledemo</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deploy-85b7dd6b6d-29gs6   1/1     Running   0          16s</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>(3) 创建 Role（角色）</strong></p></blockquote><ul><li>通过 YAML 文件（比如 <code>role-demo.yaml</code>）创建 Role（角色）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">roledemo</span>     <span class="comment"># 指定命名空间</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">""</span>]                     <span class="comment"># 空字符串表示核心 API 组（/api/v1）</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">"pods"</span>]                 <span class="comment"># resources 应为复数形式，比如 pods</span></span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">"get"</span>, <span class="string">"watch"</span>, <span class="string">"list"</span>]     <span class="comment"># 指定该角色允许执行的操作</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 Role 对象</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> role-demo.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看特定命名空间内的所有 Role（角色）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get roles<span class="params"> -n</span> roledemo</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME         CREATED AT</span><br><span class="line">pod-reader   2025-10-08T11:47:10Z</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>(4) 创建 RoleBinding（角色绑定）</strong></p></blockquote><ul><li>通过 YAML 文件（比如 <code>rolebinding-demo.yaml</code>）创建 RoleBinding（角色绑定）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">roledemo</span>     <span class="comment"># 指定命名空间</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mary</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 RoleBinding（角色绑定）</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> rolebinding-demo.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看特定命名空间内的所有 RoleBinding（角色绑定）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get rolebindings<span class="params"> -n</span> roledemo</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME        ROLE              AGE</span><br><span class="line">read-pods   Role/pod-reader   2m43s</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>(5) 基于 CFSSL 生成 CA 证书</strong></p></blockquote><ul><li>创建 <code>ca-config.json</code>  文件 </li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"signing"</span>: {</span><br><span class="line">      <span class="attr">"default"</span>: {</span><br><span class="line">          <span class="attr">"expiry"</span>: <span class="string">"87600h"</span></span><br><span class="line">      },</span><br><span class="line">      <span class="attr">"profiles"</span>: {</span><br><span class="line">          <span class="attr">"kubernetes"</span>: {</span><br><span class="line">              <span class="attr">"expiry"</span>: <span class="string">"87600h"</span>,</span><br><span class="line">              <span class="attr">"usages"</span>: [</span><br><span class="line">                  <span class="string">"signing"</span>,</span><br><span class="line">                  <span class="string">"key encipherment"</span>,</span><br><span class="line">                  <span class="string">"server auth"</span>,</span><br><span class="line">                  <span class="string">"client auth"</span></span><br><span class="line">              ]</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建 <code>ca-csr.json</code> 文件 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"CN":</span> <span class="string">"kubernetes"</span>,</span><br><span class="line">    <span class="attr">"key":</span> {</span><br><span class="line">        <span class="attr">"algo":</span> <span class="string">"rsa"</span>,</span><br><span class="line">        <span class="attr">"size":</span> <span class="number">2048</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"names":</span> [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"C":</span> <span class="string">"CN"</span>,</span><br><span class="line">            <span class="attr">"L":</span> <span class="string">"Beijing"</span>,</span><br><span class="line">            <span class="attr">"ST":</span> <span class="string">"Beijing"</span>,</span><br><span class="line">            <span class="attr">"O":</span> <span class="string">"k8s"</span>,</span><br><span class="line">            <span class="attr">"OU":</span> <span class="string">"System"</span></span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建 <code>mary-csr.json</code> 文件 </li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"mary"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: {</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"BeiJing"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"BeiJing"</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>拷贝 Kubernetes 集群搭建时所创建的 CA 证书（包括 <code>ca.pem</code> 和 <code>ca-key.pem</code>），<strong>请自行更改 CA 证书的路径 </strong></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/kubernetes/ssl/ca* .</span><br></pre></td></tr></tbody></table></figure><ul><li>查看当前目录下的文件列表（最重要的是 <code>ca-key.pem</code>、<code>ca.pem</code> 文件）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls .</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca-config.json  ca-csr.json  ca-key.pem  ca.pem  mary-csr.json  nginx-deploy.yaml  rolebinding-demo.yaml  role-demo.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>通过 CFSSL 工具生成 CA 证书 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert<span class="params"> -ca</span>=ca.pem<span class="params"> -ca</span>-key=ca-key.pem<span class="params"> -config</span>=ca-config.json<span class="params"> -profile</span>=kubernetes mary-csr.json | cfssljson<span class="params"> -bare</span> mary</span><br></pre></td></tr></tbody></table></figure><ul><li>查看当前目录下的文件列表（最重要的是新生成的 <code>mary.csr</code>、<code>mary-key.pem</code>、<code>mary.pem</code> 文件）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls .</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca-config.json  ca-csr.json  ca-key.pem  ca.pem  mary.csr  mary-csr.json  mary-key.pem  mary.pem  nginx-deploy.yaml  rolebinding-demo.yaml  role-demo.yaml</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>(6) 为用户创建一个独立的 kubeconfig 配置文件</strong></p></blockquote><ul><li>定义集群连接信息（API Server 地址 + CA 证书），<strong>请自行将 <code>192.168.2.191</code> 更改为 API Server 的 IP 地址 </strong></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-cluster kubernetes \<span class="params"></span></span><br><span class="line"><span class="params">  --certificate</span>-authority=ca.pem \<span class="params"></span></span><br><span class="line"><span class="params">  --embed</span>-certs=<span class="literal">true</span> \<span class="params"></span></span><br><span class="line"><span class="params">  --server</span>=https://192.168.2.191:6443 \<span class="params"></span></span><br><span class="line"><span class="params">  --kubeconfig</span>=mary-kubeconfig</span><br></pre></td></tr></tbody></table></figure><ul><li>配置用户身份（客户端证书和私钥）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-credentials mary \<span class="params"></span></span><br><span class="line"><span class="params">  --client</span>-key=mary-key.pem \<span class="params"></span></span><br><span class="line"><span class="params">  --client</span>-certificate=mary.pem \<span class="params"></span></span><br><span class="line"><span class="params">  --embed</span>-certs=<span class="literal">true</span> \<span class="params"></span></span><br><span class="line"><span class="params">  --kubeconfig</span>=mary-kubeconfig</span><br></pre></td></tr></tbody></table></figure><ul><li>将集群与用户 <code>mary</code> 绑定成一个上下文 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-context default \<span class="params"></span></span><br><span class="line"><span class="params">  --cluster</span>=kubernetes \<span class="params"></span></span><br><span class="line"><span class="params">  --user</span>=mary \<span class="params"></span></span><br><span class="line"><span class="params">  --kubeconfig</span>=mary-kubeconfig</span><br></pre></td></tr></tbody></table></figure><ul><li>切换到 <code>default</code> 上下文，使后续 <code>kubectl</code> 命令能够以用户 <code>mary</code> 的身份访问集群 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl config use-context default<span class="params"> --kubeconfig</span>=mary-kubeconfig</span><br></pre></td></tr></tbody></table></figure><ul><li>查看当前目录下的文件列表（最重要的是新生成的 <code>mary-kubeconfig</code> 文件）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls .</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca-config.json  ca-csr.json  ca-key.pem  ca.pem  mary.csr  mary-csr.json  mary-key.pem  mary-kubeconfig  mary.pem  nginx-deploy.yaml  rolebinding-demo.yaml  role-demo.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看凭证（用户）信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl<span class="params"> --kubeconfig</span>=mary-kubeconfig config view<span class="params"> --minify</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: DATA+OMITTED</span><br><span class="line">    server: https://192.168.2.191:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: mary</span><br><span class="line">  name: default</span><br><span class="line">current-context: default</span><br><span class="line">kind: Config</span><br><span class="line">preferences: {}</span><br><span class="line">users:</span><br><span class="line">- name: mary</span><br><span class="line">  user:</span><br><span class="line">    client-certificate-data: REDACTED</span><br><span class="line">    client-key-data: REDACTED</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>(7) 验证 RBAC 控制是否生效</strong></p></blockquote><ul><li>验证用户是否可以访问已被允许的资源，正常情况下用户 <code>mary</code> 可以在命名空间 <code>roledemo</code> 下列出或者查看 Pod</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -n</span> roledemo<span class="params"> --kubeconfig</span>=mary-kubeconfig</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deploy-85b7dd6b6d-29gs6   1/1     Running   1          18h</span><br></pre></td></tr></tbody></table></figure><ul><li>验证用户是否可以越权访问其他命名空间的资源，正常情况下用户 <code>mary</code> 不可以在其他命名空间（比如 <code>default</code>）下列出或者查看 Pod</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -n</span> default<span class="params"> --kubeconfig</span>=mary-kubeconfig</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error from server (Forbidden): pods is forbidden: User "mary" cannot list resource "pods" in API group "" in the namespace "default"</span><br></pre></td></tr></tbody></table></figure><ul><li>验证用户是否可以执行未被允许的操作（例如，删除 Pod），正常情况下用户 <code>mary</code> 不能执行删除 Pod 的操作 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod nginx-deploy-85b7dd6b6d-29gs6<span class="params"> -n</span> roledemo<span class="params"> --kubeconfig</span>=mary-kubeconfig</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error from server (Forbidden): pods "nginx-deploy-85b7dd6b6d-29gs6" is forbidden: User "mary" cannot delete resource "pods" in API group "" in the namespace "roledemo"</span><br></pre></td></tr></tbody></table></figure><ul><li>通过 API Server + CA 证书直接验证用户身份，如果身份验证失败，可以添加 <code>-v</code> 参数让 <code>curl</code> 命令输出详细的日志信息来排查问题 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl<span class="params"> --cert</span> ./mary.pem<span class="params"> --key</span> ./mary-key.pem<span class="params"> --cacert</span> ./ca.pem https://192.168.2.191:6443/api/v1/namespaces/roledemo/pods</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者，curl 命令加上 -v 参数，输出详细的日志信息</span></span><br><span class="line">curl<span class="params"> -v</span><span class="params"> --cert</span> ./mary.pem<span class="params"> --key</span> ./mary-key.pem<span class="params"> --cacert</span> ./ca.pem https://192.168.2.191:6443/api/v1/namespaces/roledemo/pods</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 中实现 Nginx 配置信息自动热加载</title>
    <link href="https://www.techgrow.cn/posts/8639f08c.html"/>
    <id>https://www.techgrow.cn/posts/8639f08c.html</id>
    <published>2025-10-05T13:12:19.000Z</published>
    <updated>2025-10-05T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Nginx-配置信息自动热加载"><a href="#Nginx-配置信息自动热加载" class="headerlink" title="Nginx 配置信息自动热加载"></a>Nginx 配置信息自动热加载</h2><p>在生产环境中，Nginx 的配置信息通常是通过 Kubernetes 的 ConfigMap 进行存储和管理。为了在 ConfigMap 更新后，让 Nginx 自动加载最新的配置信息（即热加载，不会重启 Pod，不会中断请求），可以采用以下几种方案：</p><table><thead><tr><th>方案序号</th><th>方案名称</th><th> Nginx 是否可以直接 Reload</th><th> 优点</th><th>缺点</th></tr></thead><tbody><tr><td>方案一</td><td>容器之间共享进程命名空间</td><td>可以</td><td>简单有效</td><td>依赖 <code>shareProcessNamespace</code>（共享进程命名空间），容器间进程可见，安全性较低</td></tr><tr><td>方案二</td><td>部署 Reload Agent</td><td> 可以</td><td>安全隔离</td><td>实现复杂一点</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">方案选择建议</p><ul><li>如果是在开发或测试环境中简单实现 Nginx 配置信息自动热加载，推荐使用方案一（容器之间共享进程命名空间）。</li><li>如果是在生产环境中实现 Nginx 配置信息自动热加载，推荐使用方案二（部署 Reload Agent），避免跨容器进程控制，隔离性更好。</li></ul></div><span id="more"></span><div class="admonition warning"><p class="admonition-title">Secret 热更新</p><ul><li>在 Kubernetes 中，如果使用 Secret 来管理密码、证书、Token 等敏感信息，同样可以使用文中介绍的两种方案来实现 Secret 自动热更新，只需要简单更改对应的 YAML 配置文件（Volume 挂载的配置内容）即可。</li><li>这是因为 Secret 与 ConfigMap 的使用方式基本是一致的，都可以使用 Volume（卷）的方式将其挂载到 Pod 容器中。</li></ul></div><h3 id="实现方案一"><a href="#实现方案一" class="headerlink" title="实现方案一"></a>实现方案一</h3><h4 id="方案介绍"><a href="#方案介绍" class="headerlink" title="方案介绍"></a>方案介绍</h4><p>使用 ConfigMap + 共享进程命名空间实现 Nginx 配置信息自动热加载，其工作机制和特点如下：</p><ul><li><p>方案原理：</p><ul><li>主容器（Nginx）<ul><li>负责运行 Nginx；</li><li>将 ConfigMap 挂载到 <code>/etc/nginx/conf.d</code> 目录；</li><li>不负责监测配置变更，也不额外运行 Reload Agent 服务。</li></ul></li><li>Sidecar 容器（Reloader）<ul><li>与主容器（Nginx）共享同一个进程命名空间（通过 <code>shareProcessNamespace: true</code> 实现）；</li><li>将 ConfigMap 挂载到 <code>/etc/nginx/conf.d</code> 目录，并监测该目录的文件变更；</li><li>一旦监测到文件发生变更，立刻向 Nginx 的 Master 进程发送 <code>kill -HUP &lt;master_pid&gt;</code> 信号，触发配置热加载。</li></ul></li></ul></li><li><p>方案特点：</p><ul><li>支持通过 ConfigMap 实现 Nginx 配置信息自动热加载，无需重启 Pod；</li><li>依赖 <code>shareProcessNamespace</code> 特性，使 Sidecar 容器能直接访问主容器（Nginx）的进程；</li><li>实现简单，无需在主容器中暴露 HTTP 接口或额外的 Reload Agent；</li><li>进程空间共享带来一定的安全隐患（Sidecar 容器可直接操作主容器的进程）；</li><li>不易与外部系统（如 CI/CD、Webhook）直接集成，触发方式较固定；</li><li>适合轻量级场景或内部环境下使用，不建议在高安全要求的生产环境中采用。</li></ul></li></ul><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul><li>创建 YAML 配置文件（比如 <code>nginx-reload.yaml</code>），由于 Pod 支持多个容器共享同一个进程命名空间（依赖 <code>shareProcessNamespace</code> 特性），因此在这种模式下，Sidecar 容器就能看到并操作主容器（Nginx）的进程 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">default.conf:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    server {</span></span><br><span class="line"><span class="string">      listen 80;</span></span><br><span class="line"><span class="string">      location / {</span></span><br><span class="line"><span class="string">        return 200 "Hello from ConfigMap.\n";</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string"></span><span class="meta">---</span></span><br><span class="line"><span class="comment"># 定义 Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hotreload</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>         <span class="comment"># Service 类型为 NodePort，可通过节点 IP 访问</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-hotreload</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>           <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span>     <span class="comment"># Pod 内容器实际监听的端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span>    <span class="comment"># 映射到物理机的端口号，默认范围 30000 - 32767</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 定义 Deployment </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hotreload</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-hotreload</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-hotreload</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="comment"># 共享进程命名空间</span></span><br><span class="line">      <span class="attr">shareProcessNamespace:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="comment"># 主容器：用于运行 Nginx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-config-cm</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx/conf.d</span></span><br><span class="line">      <span class="comment"># Sidecar 容器：用于监控文件变更，并 Reload Nginx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">reloader</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">alpine:3.19</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>]</span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">            echo "$(date '+%F %T') [INFO] Starting config reloader ..."</span></span><br><span class="line"><span class="string">            # 计算初始配置的 md5sum</span></span><br><span class="line"><span class="string">            last_sum=$(find /etc/nginx/conf.d -type f -exec md5sum {} + | sort | md5sum)</span></span><br><span class="line"><span class="string">            while true; do</span></span><br><span class="line"><span class="string">              new_sum=$(find /etc/nginx/conf.d -type f -exec md5sum {} + | sort | md5sum)</span></span><br><span class="line"><span class="string">              # 判断配置是否已更新</span></span><br><span class="line"><span class="string">              if [ "$new_sum" != "$last_sum" ]; then</span></span><br><span class="line"><span class="string">                echo "$(date '+%F %T') [INFO] Config change detected, reloading nginx ..."</span></span><br><span class="line"><span class="string">                # 获取 Nginx Master 进程的 PID</span></span><br><span class="line"><span class="string">                nginx_pid=$(ps | grep "nginx: master process" | grep -v grep | awk '{print $1}')</span></span><br><span class="line"><span class="string">                if [ -n "$nginx_pid" ]; then</span></span><br><span class="line"><span class="string">                  echo "$(date '+%F %T') [INFO] Reload nginx (master pid: $nginx_pid)"</span></span><br><span class="line"><span class="string">                  kill -HUP $nginx_pid || echo "$(date '+%F %T') [WARN] Failed to send HUP"</span></span><br><span class="line"><span class="string">                else</span></span><br><span class="line"><span class="string">                  echo "$(date '+%F %T') [WARN] Nginx master pid not found"</span></span><br><span class="line"><span class="string">                fi</span></span><br><span class="line"><span class="string">                last_sum="$new_sum"</span></span><br><span class="line"><span class="string">              fi</span></span><br><span class="line"><span class="string">              sleep 5</span></span><br><span class="line"><span class="string">            done</span></span><br><span class="line"><span class="string"></span>        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-config-cm</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx/conf.d</span></span><br><span class="line">      <span class="comment"># 定义卷（Volume）</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-config-cm</span>     <span class="comment"># 指定卷的名称</span></span><br><span class="line">        <span class="attr">configMap:</span>                <span class="comment"># 指定卷的类型为 ConfigMap</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx-config</span>      <span class="comment"># 指定引用的 ConfigMap 名称（需事先创建）</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的资源对象 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 ConfigMap 和 Deployment</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">nginx-reload.yaml</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">关键点</p><ul><li><code>shareProcessNamespace: true</code>：表示整个 Pod 里面的所有容器共享同一个进程命名空间。</li><li>因此，在 Sidecar 容器中，可以直接看到并控制主容器（Nginx）的进程，比如 PID 为 11 的 Nginx Master 进程。</li><li>命令 <code>kill -HUP &lt;master_pid&gt;</code> 与 <code>nginx -s reload</code> 的效果在 Nginx 中是等价的，两者都会触发 Nginx 热加载（Reload）配置文件。</li><li>对于 <code>kill -HUP &lt;master_pid&gt;</code> 命令，这里必须使用 Nginx Master 进程的 ID，而不是 Worker 进程的 ID，否则无法实现 Nginx 平滑更新配置文件（不中断请求）。</li></ul></div><h4 id="验证步骤"><a href="#验证步骤" class="headerlink" title="验证步骤"></a>验证步骤</h4><ul><li>验证 Nginx 配置信息自动热加载的步骤 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Service 列表</span></span><br><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME              TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes        ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP        66d</span><br><span class="line">nginx-hotreload   NodePort    10.0.0.96    &lt;none&gt;        80:30080/TCP   25s</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Pod 的运行状态</span></span><br><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                               READY   STATUS    RESTARTS   AGE   IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-hotreload-6646755fcf-bq26b   2/2     Running   0          38s   10.244.1.32   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Sidecar 容器的日志</span></span><br><span class="line">kubectl logs nginx-hotreload-6646755fcf-bq26b<span class="params"> -c</span> reloader</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2025-10-05 10:03:24 [INFO] Starting config reloader ...</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 Sidecar 容器内部</span></span><br><span class="line">kubectl <span class="built_in">exec</span><span class="params"> -it</span> nginx-hotreload-6646755fcf-bq26b<span class="params"> -c</span> reloader sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Nginx 的进程列表</span></span><br><span class="line"><span class="keyword">for</span> pid <span class="keyword">in</span> /proc/[0-9]*; <span class="keyword">do</span> name=$(cat <span class="variable">$pid</span>/comm 2&gt;/dev/null) || <span class="built_in">continue</span>; [ <span class="string">"<span class="variable">$name</span>"</span> = <span class="string">"nginx"</span> ] || <span class="built_in">continue</span>; <span class="built_in">type</span>=$(tr <span class="string">'\0'</span> <span class="string">' '</span> &lt; <span class="variable">$pid</span>/cmdline 2&gt;/dev/null | grep<span class="params"> -q</span> <span class="string">"master process"</span> &amp;&amp; <span class="built_in">echo</span> master || <span class="built_in">echo</span> worker); <span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> <span class="variable">$type</span> <span class="variable">$pid</span>"</span>; <span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx master /proc/11</span><br><span class="line">nginx worker /proc/16</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在集群外部通过节点 IP 访问 Nginx</span></span><br><span class="line">wget<span class="params"> -qO</span>- http://192.168.2.112:30080</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello from ConfigMap.</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改 ConfigMap</span></span><br><span class="line">kubectl create configmap nginx-config<span class="params"> --from</span>-literal=default.conf=<span class="string">"server { listen 80; return 200 'Updated ConfigMap.\n'; }"</span><span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml | kubectl apply<span class="params"> -f</span> -</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等待约 60 秒后，再次查看 Sidecar 容器的日志</span></span><br><span class="line">kubectl logs nginx-hotreload-6646755fcf-bq26b<span class="params"> -c</span> reloader</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2025-10-05 10:16:32 [INFO] Starting config reloader ...</span><br><span class="line">2025-10-05 10:19:02 [INFO] Config change detected, reloading nginx ...</span><br><span class="line">2025-10-05 10:19:02 [INFO] Reload nginx (master pid: 11)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在集群外部再次通过节点 IP 访问 Nginx</span></span><br><span class="line">wget<span class="params"> -qO</span>- http://192.168.2.112:30080</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Updated ConfigMap.</span><br></pre></td></tr></tbody></table></figure><h3 id="实现方案二"><a href="#实现方案二" class="headerlink" title="实现方案二"></a>实现方案二</h3><h4 id="方案介绍-1"><a href="#方案介绍-1" class="headerlink" title="方案介绍"></a>方案介绍</h4><p>使用 ConfigMap + 部署 Reload Agent 实现 Nginx 配置信息自动热加载，其工作机制和特点如下：</p><ul><li><p>方案概述：</p><ul><li>有时为了更安全，会在 Nginx 容器中部署一个小的 Reload Agent，例如：<ul><li>在 Nginx 容器里部署一个轻量级 API 服务（比如，基于 Python 开发一个简易的 Web 服务）；</li><li>当 Sidecar 容器监测到 ConfigMap 挂载的文件发生变更时，通过 <code>curl http://localhost:8080/reload</code> 调用 Reload Agent 的 API 服务；</li><li>Reload Agent 接收到 Reload 请求后，内部会执行 <code>nginx -s reload</code> 或者 <code>kill -HUP &lt;master_pid&gt;</code> 触发 Nginx 热加载。</li></ul></li></ul></li><li><p>方案原理：</p><ul><li>主容器（Nginx）<ul><li>负责运行 Nginx；</li><li>将 ConfigMap 挂载到 <code>/etc/nginx/conf.d</code> 目录；</li><li>额外部署一个轻量级 API 服务（Reload Agent），监听 <code>8080</code> 端口；</li><li>当接收到 <code>/reload</code> 请求时，执行 <code>nginx -s reload</code> 或者 <code>kill -HUP &lt;master_pid&gt;</code> 让 Nginx 重新加载配置文件。</li></ul></li><li>Sidecar 容器（Reloader）<ul><li>将 ConfigMap 挂载到 <code>/etc/nginx/conf.d</code> 目录；</li><li>监测 <code>/etc/nginx/conf.d</code> 目录中的文件更改；</li><li>当监测到有配置更改后，通过 HTTP 协议调用 Reload Agent 的 API 接口 <code>http://127.0.0.1:8080/reload</code>，触发 Nginx 热加载。</li></ul></li></ul></li><li><p>方案特点：</p><ul><li>支持通过 ConfigMap 实现 Nginx 配置信息自动热加载，无需重启 Pod；</li><li>不依赖 <code>shareProcessNamespace</code>，容器进程空间隔离（安全性更高）；</li><li>结构清晰，便于与 CI/CD 或外部触发器集成；</li><li>可扩展为 Webhook 式控制（比如在 GitOps 更新配置后自动触发 Reload）；</li><li>适合在高安全要求的生产环境下使用。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>为了方便演示，在下面的 Reloader Agent 实现中，使用 Linux Socket 通信来替代 HTTP 接口。由于需要在容器之间通过 Volume（卷）共享 Socket 文件，因此生产环境推荐使用 HTTP 接口来实现 Reloader Agent，而不是 Linux Socket 通信。</p></div><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul><li>创建 YAML 配置文件（比如 <code>nginx-hotreload.yaml</code>）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">default.conf:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    server {</span></span><br><span class="line"><span class="string">      listen 80;</span></span><br><span class="line"><span class="string">      location / {</span></span><br><span class="line"><span class="string">        return 200 "Hello from ConfigMap.\n";</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string"></span><span class="meta">---</span></span><br><span class="line"><span class="comment"># 定义 Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hotreload</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>         <span class="comment"># Service 类型为 NodePort，可通过节点 IP 访问</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-hotreload</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>           <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span>     <span class="comment"># Pod 内容器实际监听的端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span>    <span class="comment"># 映射到物理机的端口号，默认范围 30000 - 32767</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 定义 Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hotreload</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-hotreload</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-hotreload</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="comment"># 主容器：用于运行 Nginx + Reload Agent</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>]</span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">            # 创建共享运行目录</span></span><br><span class="line"><span class="string">            mkdir -p /var/run/nginx</span></span><br><span class="line"><span class="string">            # 创建 Socket 文件</span></span><br><span class="line"><span class="string">            SOCKET=/var/run/nginx/nginx-reload.sock</span></span><br><span class="line"><span class="string">            rm -f $SOCKET</span></span><br><span class="line"><span class="string">            mkfifo $SOCKET</span></span><br><span class="line"><span class="string">            # 启动 Nginx</span></span><br><span class="line"><span class="string">            echo "$(date '+%F %T') [INFO] Starting Nginx ..."</span></span><br><span class="line"><span class="string">            nginx -g 'daemon off;' &amp;</span></span><br><span class="line"><span class="string">            echo "$(date '+%F %T') [INFO] Reload agent started, listening on $SOCKET"</span></span><br><span class="line"><span class="string">            # 监听 Sidecar 发来的 Reload 请求</span></span><br><span class="line"><span class="string">            while true; do</span></span><br><span class="line"><span class="string">              if read line &lt; $SOCKET; then</span></span><br><span class="line"><span class="string">                echo "$(date '+%F %T') [INFO] Reload request received from Sidecar"</span></span><br><span class="line"><span class="string">                # 先校验配置文件</span></span><br><span class="line"><span class="string">                if nginx -t -q; then</span></span><br><span class="line"><span class="string">                  echo "$(date '+%F %T') [INFO] Nginx config test passed"</span></span><br><span class="line"><span class="string">                  # 检查 PID 文件</span></span><br><span class="line"><span class="string">                  if [ -f /var/run/nginx.pid ]; then</span></span><br><span class="line"><span class="string">                    kill -HUP $(cat /var/run/nginx.pid)</span></span><br><span class="line"><span class="string">                    echo "$(date '+%F %T') [INFO] Nginx reloaded successfully"</span></span><br><span class="line"><span class="string">                  else</span></span><br><span class="line"><span class="string">                    echo "$(date '+%F %T') [WARN] file nginx.pid not found"</span></span><br><span class="line"><span class="string">                  fi</span></span><br><span class="line"><span class="string">                else</span></span><br><span class="line"><span class="string">                  echo "$(date '+%F %T') [ERROR] Invalid nginx config, skipping reload"</span></span><br><span class="line"><span class="string">                fi</span></span><br><span class="line"><span class="string">              fi</span></span><br><span class="line"><span class="string">            done</span></span><br><span class="line"><span class="string"></span>        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-config-cm</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx/conf.d</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-run</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run/nginx</span></span><br><span class="line">      <span class="comment"># Sidecar 容器：用于监控文件变更，并发送 Reload 请求</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">reloader</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">alpine:3.19</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>]</span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">            echo "$(date '+%F %T') [INFO] Starting config reloader ..."</span></span><br><span class="line"><span class="string">            last_sum=""</span></span><br><span class="line"><span class="string">            while true; do</span></span><br><span class="line"><span class="string">              new_sum=$(find /etc/nginx/conf.d -type f -exec md5sum {} + | sort | md5sum)</span></span><br><span class="line"><span class="string">              if [ -z "$last_sum" ]; then</span></span><br><span class="line"><span class="string">                last_sum="$new_sum"</span></span><br><span class="line"><span class="string">              elif [ "$new_sum" != "$last_sum" ]; then</span></span><br><span class="line"><span class="string">                echo "$(date '+%F %T') [INFO] Config change detected, reloading nginx ..."</span></span><br><span class="line"><span class="string">                if [ -p /var/run/nginx/nginx-reload.sock ]; then</span></span><br><span class="line"><span class="string">                  echo "reload" &gt; /var/run/nginx/nginx-reload.sock</span></span><br><span class="line"><span class="string">                else</span></span><br><span class="line"><span class="string">                  echo "$(date '+%F %T') [WARN] file nginx-reload.sock not found"</span></span><br><span class="line"><span class="string">                fi</span></span><br><span class="line"><span class="string">                last_sum="$new_sum"</span></span><br><span class="line"><span class="string">              fi</span></span><br><span class="line"><span class="string">              sleep 5</span></span><br><span class="line"><span class="string">            done</span></span><br><span class="line"><span class="string"></span>        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-config-cm</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx/conf.d</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-run</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run/nginx</span></span><br><span class="line">      <span class="comment"># 定义卷（Volume）</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-config-cm</span>     <span class="comment"># 指定卷的名称</span></span><br><span class="line">        <span class="attr">configMap:</span>                <span class="comment"># 指定卷的类型为 ConfigMap</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx-config</span>      <span class="comment"># 指定引用的 ConfigMap 名称（需事先创建）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-run</span>           <span class="comment"># 指定卷的名称</span></span><br><span class="line">        <span class="attr">emptyDir:</span> {}              <span class="comment"># 共享运行目录（用于存放 nginx-reload.sock 文件）</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的资源对象 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 ConfigMap 和 Deployment</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> nginx-hotreload.yaml</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">关键点</p><ul><li>Nginx 默认使用的是 <code>/var/run/nginx.pid</code> 文件，该文件的内容就是 Nginx Master 进程的 ID。</li><li>命令 <code>kill -HUP &lt;master_pid&gt;</code> 与 <code>nginx -s reload</code> 的效果在 Nginx 中是等价的，两者都会触发 Nginx 热加载（Reload）配置文件。</li><li>对于 <code>kill -HUP &lt;master_pid&gt;</code> 命令，这里必须使用 Nginx Master 进程的 ID，而不是 Worker 进程的 ID，否则无法实现 Nginx 平滑更新配置文件（不中断请求）。</li></ul></div><h4 id="验证步骤-1"><a href="#验证步骤-1" class="headerlink" title="验证步骤"></a>验证步骤</h4><ul><li>验证 Nginx 配置信息自动热加载的步骤 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Service 列表</span></span><br><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME              TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes        ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP        66d</span><br><span class="line">nginx-hotreload   NodePort    10.0.0.126   &lt;none&gt;        80:30080/TCP   59s</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Pod 的运行状态</span></span><br><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                              READY   STATUS    RESTARTS   AGE   IP            NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-hotreload-9d56b494b-vbkhv   2/2     Running   0          74s   10.244.0.39   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Nginx 容器的日志</span></span><br><span class="line">kubectl logs nginx-hotreload-9d56b494b-vbkhv<span class="params"> -c</span> nginx</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2025-10-05 10:26:53 [INFO] Starting Nginx ...</span><br><span class="line">2025-10-05 10:26:53 [INFO] Reload agent started, listening on /var/run/nginx/nginx-reload.sock</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Sidecar 容器的日志</span></span><br><span class="line">kubectl logs nginx-hotreload-9d56b494b-vbkhv<span class="params"> -c</span> reloader</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2025-10-05 09:42:50 [INFO] Starting config reloader ...</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在集群外部通过节点 IP 访问 Nginx</span></span><br><span class="line">wget<span class="params"> -qO</span>- http://192.168.2.131:30080</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello from ConfigMap.</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改 ConfigMap</span></span><br><span class="line">kubectl create configmap nginx-config<span class="params"> --from</span>-literal=default.conf=<span class="string">"server { listen 80; return 200 'Updated ConfigMap.\n'; }"</span><span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml | kubectl apply<span class="params"> -f</span> -</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等待约 60 秒后，再次查看 Sidecar 容器的日志</span></span><br><span class="line">kubectl logs nginx-hotreload-9d56b494b-vbkhv<span class="params"> -c</span> reloader</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2025-10-05 10:26:53 [INFO] Starting config reloader ...</span><br><span class="line">2025-10-05 10:32:09 [INFO] Config change detected, reloading nginx ...</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等待约 60 秒后，再次查看 Nginx 容器的日志</span></span><br><span class="line">kubectl logs nginx-hotreload-9d56b494b-vbkhv<span class="params"> -c</span> nginx</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2025-10-05 10:26:53 [INFO] Reload agent started, listening on /var/run/nginx/nginx-reload.sock</span><br><span class="line">2025-10-05 10:32:09 [INFO] Reload request received from Sidecar</span><br><span class="line">2025-10-05 10:32:09 [INFO] Nginx config test passed</span><br><span class="line">2025-10-05 10:32:09 [INFO] Nginx reloaded successfully</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在集群外部再次通过节点 IP 访问 Nginx</span></span><br><span class="line">wget<span class="params"> -qO</span>- http://192.168.2.131:30080</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Updated ConfigMap.</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/20eeb044.html#kill-HUP-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%9C%E7%94%A8">Nginx 中 kill -HUP 命令的作用</a></li><li><a href="https://blog.csdn.net/cghcgyhbc/article/details/139752940">Nginx 平滑升级版本和回滚版本</a></li><li><a href="/posts/cfb1715d.html#ConfigMap">Kubernetes 中 ConfigMap 的使用</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 中如何实现 Nginx 配置信息自动热加载。</summary>
    
    
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    <category term="Web服务器" scheme="https://www.techgrow.cn/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之六</title>
    <link href="https://www.techgrow.cn/posts/76121b26.html"/>
    <id>https://www.techgrow.cn/posts/76121b26.html</id>
    <published>2025-09-17T13:12:19.000Z</published>
    <updated>2025-09-17T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><span id="more"></span><h3 id="Probe"><a href="#Probe" class="headerlink" title="Probe"></a>Probe</h3><p>为了监控容器的运行状态，Kubernetes 提供了探针（Probe）。</p><h4 id="Probe-的类型"><a href="#Probe-的类型" class="headerlink" title="Probe 的类型"></a>Probe 的类型</h4><p>Kubernetes 提供了三种类型的探针：Liveness Probe（存活探针）、Readiness Probe（就绪探针）、Startup Probe（启动探针）。</p><h5 id="Liveness-Probe"><a href="#Liveness-Probe" class="headerlink" title="Liveness Probe"></a>Liveness Probe</h5><p><strong>Liveness Probe（存活探针）用于判断容器是否处于健康状态，即 Pod 是否真正处于 <code>Running</code> 状态。</strong>如果 Liveness Probe 探测到容器不健康，kubelet 会将该容器 Kill 掉，并根据 Pod 的重启策略决定是否重启它。<strong>Liveness Probe 可用于修复死锁、无响应的应用（如数据库卡死）。</strong>如果容器未配置 Liveness Probe，kubelet 会默认认为其探测结果始终为成功。在实际场景中，应用程序可能由于某些原因（例如后端服务故障）暂时无法对外提供服务，但进程本身仍在运行。这种情况下，Kubernetes 无法识别并隔离这个有故障的 Pod，调用方仍可能访问到该 Pod，导致业务不稳定。为解决这一问题，Kubernetes 提供了 Liveness Probe 来检测应用程序的运行健康状况，并在检测到异常时执行相应的补救措施，例如重启容器，以保证系统的整体稳定性。Liveness Probe 的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">exec:</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"cat"</span>, <span class="string">"/tmp/healthy"</span>]  <span class="comment"># 执行命令检查文件是否存在</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">5</span>              <span class="comment"># 容器启动后等待5秒开始检查</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span>                    <span class="comment"># 每5秒检查一次</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">3</span>                 <span class="comment"># 连续失败3次后判定为不健康</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Readiness-Probe"><a href="#Readiness-Probe" class="headerlink" title="Readiness Probe"></a>Readiness Probe</h5><p><strong>Readiness Probe（就绪探针）用于判断容器是否已经启动完成并能够对外提供服务，即容器的 <code>Ready</code> 状态是否为 <code>true</code>。</strong>如果 Readiness Probe 探测失败，容器的 <code>Ready</code> 状态会被置为 <code>False</code>，Kubernetes 控制器会将该 Pod 的 Endpoint 从对应 Service 的 Endpoint 列表中移除，从而停止将任何请求调度到该 Pod，直到下一次探测成功为止。<strong>Readiness Probe 可用于控制流量进入（如应用启动时需要加载大量数据，导致容器启动后无法立刻对外提供服务）。</strong>通过 Readiness Probe，Kubernetes 可以在应用完全就绪之前，阻止流量被路由到尚未准备好的 Pod 副本，确保服务稳定性。例如，对于基于 Tomcat 的应用来说，Tomcat 进程启动成功并不代表应用可以立即对外提供服务，可能还需要等待 Spring 容器初始化、数据库连接建立等操作完成。在 Spring Boot 应用中，可以使用 Actuator 提供的 <code>/health</code> 接口作为 Readiness Probe 的检测目标，用于判断应用是否已经准备好对外提供服务。Readiness Probe 的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/healthz</span>                    <span class="comment"># 发送 HTTP 请求进行检测</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">10</span>             <span class="comment"># 容器启动后等待10秒开始检查</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">3</span>                    <span class="comment"># 每3秒检查一次</span></span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">1</span>                 <span class="comment"># 成功1次即标记为就绪</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Startup-Probe"><a href="#Startup-Probe" class="headerlink" title="Startup Probe"></a>Startup Probe</h5><p><strong>Startup Probe（启动探针）是在 Kubernetes <code>1.16+</code> 版本中引入的，主要用于检测慢启动应用是否完成初始化。在 Startup Probe 检测成功之前，Liveness Probe 和 Readiness Probe 都不会生效</strong>；从而避免因应用启动过慢，被存活探针或就绪探针误判为异常并提前终止容器。<strong>Startup Probe 非常适合启动时间较长的应用，例如 Java / SpringBoot 应用、需要加载大量数据或复杂初始化逻辑的服务。</strong>通过配置合适的 Startup Probe，可以为应用提供足够的启动缓冲时间，确保在应用真正完成初始化之前，Kubernetes 不会对其进行健康检查或流量调度，从而保证系统的稳定性。Startup Probe 的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">startupProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health</span>             <span class="comment"># Spring Boot 健康检查端点</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">30</span>                 <span class="comment"># 允许的最大失败次数</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">10</span>                    <span class="comment"># 每10秒检查一次</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Probe-的核心参数"><a href="#Probe-的核心参数" class="headerlink" title="Probe 的核心参数"></a>Probe 的核心参数</h4><ul><li>探针（Probe）可配置的核心参数（用于精确控制探针的行为）</li></ul><table><thead><tr><th>参数</th><th>作用</th><th>默认值</th><th>最小值</th><th>适用探针类型</th></tr></thead><tbody><tr><td><code>initialDelaySeconds</code></td><td>容器启动后，等待多少秒才开始第一次执行探测，避免容器未完成启动就被误判为失败。</td><td>0 秒</td><td> 0 秒</td><td> liveness、readiness、startup</td></tr><tr><td><code>periodSeconds</code></td><td>探测的执行频率，即两次探测之间的间隔时间。</td><td>10 秒</td><td> 1 秒</td><td> liveness、readiness</td></tr><tr><td><code>timeoutSeconds</code></td><td>单次探测的超时时间，超过该时间未响应则判定为探测失败。</td><td>1 秒</td><td> 1 秒</td><td> liveness、readiness</td></tr><tr><td><code>failureThreshold</code></td><td>探测成功后，连续失败多少次才会被认定为容器不健康。</td><td>3</td><td>1</td><td>liveness、readiness、startup</td></tr><tr><td><code>successThreshold</code></td><td>对于已标记为不健康的容器，需要连续成功多少次才会重新标记为健康。对于 Liveness Probe，该值必须为 <code>1</code>。</td><td>1</td><td>1</td><td>liveness、readiness</td></tr></tbody></table><h4 id="Probe-的检测方法"><a href="#Probe-的检测方法" class="headerlink" title="Probe 的检测方法"></a>Probe 的检测方法</h4><ul><li>Kubernetes 的三类探针都支持以下三种检测方法</li></ul><table><thead><tr><th>检测方法</th><th>说明</th><th>配置示例</th></tr></thead><tbody><tr><td><code>exec</code></td><td>- 在容器内执行命令，返回状态码为 <code>0</code> 表示检测成功。<br> - 适用于复杂检测逻辑或没有 HTTP 接口的服务。</td><td><code>command: ["cat", "/tmp/healthy"]</code></td></tr><tr><td><code>httpGet</code></td><td>- 通过发送 HTTP 请求检查服务是否正常。<br> - 返回状态码 <code>200 ~ 399</code> 表示检测成功。</td><td><code>httpGet: { path: /health, port: 80 }</code></td></tr><tr><td><code>tcpSocket</code></td><td>- 通过容器 IP + 端口建立 TCP 连接，<br> - 连接成功，即表示容器健康。</td><td><code>tcpSocket: { port: 3306 }</code></td></tr></tbody></table><h4 id="Probe-的检测结果"><a href="#Probe-的检测结果" class="headerlink" title="Probe 的检测结果"></a>Probe 的检测结果</h4><ul><li>探针（Probe）的三种检测结果状态</li></ul><table><thead><tr><th>检测结果状态</th><th>说明</th></tr></thead><tbody><tr><td><code>Success</code></td><td>容器通过检查，状态正常。</td></tr><tr><td><code>Failure</code></td><td>容器未通过检查，状态异常。</td></tr><tr><td><code>Unknown</code></td><td>无法执行检查，因此不采取任何措施。</td></tr></tbody></table><blockquote><p>Pod 的重启策略有以下三种（如果 Liveness Probe 探测到容器不健康，kubelet 会将该容器 Kill 掉，并根据 Pod 的重启策略决定是否重启它）</p></blockquote><table><thead><tr><th>重启策略</th><th>说明</th></tr></thead><tbody><tr><td><code>Always</code></td><td>默认值，当容器退出时，总是由 kubelet 自动重启该容器（适用于长期运行的 Pod，如 Web 服务）。</td></tr><tr><td><code>OnFailure</code></td><td>仅在容器异常退出（非 0 状态码）时，由 kubelet 自动重启该容器（适合批处理任务）。</td></tr><tr><td><code>Never</code></td><td>无论容器如何退出，kubelet 都不会重启该容器（适合一次性任务）。</td></tr></tbody></table><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mynginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span>  <span class="comment"># Pod 的重启策略</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Probe-的使用示例"><a href="#Probe-的使用示例" class="headerlink" title="Probe 的使用示例"></a>Probe 的使用示例</h4><ul><li>基于 Liveness Probe（存活探针）检测容器健康 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-exec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">touch</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">30</span><span class="string">;</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/healthy</span></span><br><span class="line">    <span class="comment"># 存活检查</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><ul><li>存活探针、就绪探针二者配合使用 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">goproxy</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">goproxy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">goproxy</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s.gcr.io/goproxy:0.1</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span>      <span class="comment"># 容器内应用（比如 Goproxy）监听的端口</span></span><br><span class="line">      <span class="comment"># 存活检查</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">tcpSocket:</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 就绪检查</span></span><br><span class="line">      <span class="attr">readinessProbe:</span></span><br><span class="line">        <span class="attr">tcpSocket:</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><ul><li>启动探针、存活探针和就绪探针三者配合使用 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">springboot-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-springboot-app:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span>      <span class="comment"># 容器内应用（比如 Tomcat）监听的端口</span></span><br><span class="line">    <span class="comment"># 启动探针（给予充足启动时间）</span></span><br><span class="line">    <span class="attr">startupProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="comment"># 存活检查（启动探针成功后生效）</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment"># 就绪检查（启动探针成功后生效）</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health/readiness</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><h4 id="调度器的概述"><a href="#调度器的概述" class="headerlink" title="调度器的概述"></a>调度器的概述</h4><p>一个容器平台的核心功能是为容器分配运行所需的计算、存储和网络资源。其中，容器调度系统负责在最合适的主机上启动容器，并将相关容器进行关联。它必须能够自动处理容器故障，并在应用访问量增加时，自动在更多主机上启动容器以应对扩展需求。目前，主流的三大容器平台 Swarm、Mesos 和 Kubernetes 各自拥有不同的调度系统：</p><ul><li>Swarm：直接调度 Docker 容器，并提供与标准 Docker API 一致的接口，使用起来较为简单。</li><li>Mesos：采用多框架并行的调度模型，不同运行框架拥有相对独立的调度系统。其中，Marathon 框架对 Docker 容器提供了原生支持。</li><li>Kubernetes：引入 Pod 和 Label 的概念，将一组有依赖关系的容器组合成一个逻辑单元 Pod，并以 Pod 为基本单位进行部署和调度。同时，多个 Pod 可以通过 Service 形成一个完整的服务。</li></ul><p>Kubernetes 通过这种抽象，简化了集群范围内相关容器的共同调度和管理复杂度。从另一个角度看，这种设计使得 Kubernetes 更容易实现功能更强大、逻辑更复杂的容器调度算法，这也是其与 Swarm 和 Mesos 的主要区别所在。</p><h4 id="K8s-的资源分类"><a href="#K8s-的资源分类" class="headerlink" title="K8s 的资源分类"></a>K8s 的资源分类</h4><p>Kubernetes 调度器作为整个集群的 “大脑”，在提升集群资源利用率和保障服务稳定运行方面起着至关重要的作用，其重要性也会随着集群规模和复杂度的提升而不断增加。在 Kubernetes 中，资源可分为两类：</p><ul><li><p>可压缩资源（Compressible Resources）</p><ul><li>这类资源可以被限制或回收，例如 CPU 周期、磁盘 I/O 带宽等。</li><li>当 Pod 资源不足时，Kubernetes 可以通过降低资源分配的方式来限制 Pod 对这些资源的使用，而无需直接杀掉 Pod。</li></ul></li><li><p>不可压缩资源（Incompressible Resources）</p><ul><li>这类资源一旦被 Pod 占用，除非终止 Pod，否则无法回收，例如内存、硬盘空间等。</li><li>当 Pod 占用不可压缩资源过多且无法满足需求时，Kubernetes 只能通过驱逐（Eviction）或杀掉 Pod 来释放资源。</li></ul></li></ul><p>未来，Kubernetes 还将支持更多类型的资源，如网络带宽、存储 IOPS 等，使得调度和资源管理更加精细化和智能化。</p><h4 id="K8s-调度器的概述"><a href="#K8s-调度器的概述" class="headerlink" title="K8s 调度器的概述"></a>K8s 调度器的概述</h4><p><code>kube-scheduler</code> 是 Kubernetes 系统的核心组件之一，主要负责整个集群的资源调度工作。它通过特定的调度算法和调度策略，将 Pod 调度到最合适的 Node（工作节点） 上，从而更高效、更合理地利用集群资源。这也是企业选择 Kubernetes 的一个重要原因：如果一项新技术不能帮助企业节约成本、提升效率，那么它将很难被真正落地和推广。</p><h4 id="K8s-调度器的工作流程"><a href="#K8s-调度器的工作流程" class="headerlink" title="K8s 调度器的工作流程"></a>K8s 调度器的工作流程</h4><blockquote><p>K8s 调度器的简介</p></blockquote><p><code>kube-scheduler</code> 是一个独立的二进制程序，启动后会持续监听 API Server，获取所有 <code>PodSpec.NodeName</code> 为空的 Pod，并为其执行调度。每个成功调度的 Pod，调度器都会生成一个 Binding 对象 并存入 Etcd，随后目标节点上的 Kubelet 会根据调度结果创建 Pod。在默认情况下，<code>kube-scheduler</code> 内置的默认调度器已经能够满足大多数场景的需求。例如，默认策略可以保证 Pod 被分配到资源充足的节点上运行。但在实际生产环境中，企业往往对业务需求和应用特性有更深入的了解，因此需要更灵活、可控的调度策略，例如：</p><ul><li>限制某些 Pod 只能运行在特定节点上；</li><li>某些节点只允许运行特定类型的应用；</li><li>针对资源隔离、安全性或性能优化进行特殊调度。</li></ul><div class="admonition note"><p class="admonition-title">Pod 的创建流程</p><p>更多关于 Pod 的创建流程的介绍，可以看 <a href="/posts/c57e8370.html#Pod-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B">这里</a>。</p></div><blockquote><p>K8s 调度器的工作流程</p></blockquote><p>K8s 调度器的工作流程主要分为以下四个阶段（<a href="../../../asset/2025/09/k8s-scheduler-process.png">点击查看流程图</a>）：</p><ul><li><p>(1) 预选阶段（Predicates）— 节点过滤</p><ul><li>在该阶段，K8s 调度器会根据一系列规则过滤掉不符合要求的节点，形成候选节点列表。</li><li>例如，当 Pod 设置了资源 <code>requests</code>，如果某节点的可用资源不足，则该节点会被过滤掉。</li><li>常见的 Predicates 过滤算法：<table><thead><tr><th>算法名称</th><th>说明</th></tr></thead><tbody><tr><td><code>PodFitsResources</code></td><td>节点剩余资源是否满足 Pod 的资源请求（CPU / 内存等）。</td></tr><tr><td><code>PodFitsHost</code></td><td>如果 Pod 指定了 <code>NodeName</code>，检查节点名称是否匹配。</td></tr><tr><td><code>PodFitsHostPorts</code></td><td>节点上已使用的端口是否与 Pod 申请的端口冲突。</td></tr><tr><td><code>PodSelectorMatches</code></td><td>节点的标签是否与 Pod 指定的 <code>labelSelector</code> 匹配。</td></tr><tr><td><code>NoDiskConflict</code></td><td>检查 Pod 所需的 Volume 是否与节点上已挂载的 Volume 冲突（只读 Volume 除外）。</td></tr><tr><td><code>CheckNodeDiskPressure</code></td><td>节点磁盘压力是否过大，是否满足调度要求。</td></tr><tr><td><code>CheckNodeMemoryPressure</code></td><td>节点内存压力是否过大，是否满足调度要求。</td></tr></tbody></table></li></ul></li><li><p>(2) 优选阶段（Priorities）— 节点打分</p><ul><li>在该阶段，K8s 调度器会对通过预选阶段的节点进行打分，分数越高，表示该节点越适合部署该 Pod。</li><li>打分规则是由一组键值对组成的：<ul><li>键：优先级策略的名称</li><li>值：该策略的权重</li></ul></li><li>常见的 Priorities 优先级策略：<table><thead><tr><th>优先级策略</th><th>说明</th></tr></thead><tbody><tr><td><code>LeastRequestedPriority</code></td><td>根据 CPU 和内存使用率计算权重，使用率越低，权重越高，从而优先选择负载较低的节点。</td></tr><tr><td><code>SelectorSpreadPriority</code></td><td>为了实现高可用，将同一个 Deployment / Replica Set 下的多个 Pod 尽量分散到不同节点上。运行该类型 Pod 数量较少的节点权重更高。</td></tr><tr><td><code>ImageLocalityPriority</code></td><td>如果某节点已经存在 Pod 需要的镜像，且镜像总大小越大，则该节点权重越高，从而减少镜像拉取时间。</td></tr><tr><td><code>NodeAffinityPriority</code></td><td>根据 Node Affinity（节点亲和性）规则计算权重，优先调度到符合亲和性条件的节点上。</td></tr></tbody></table></li></ul></li><li><p>(3) 绑定阶段（Binding）</p><ul><li>K8s 调度器会从打分结果中选择分数最高的节点，将该 Pod 与该 Node（工作节点）进行绑定（Binding）。</li><li>绑定结果会被写入 Etcd，供集群其他组件使用。</li></ul></li><li><p>(4) Kubelet 执行</p><ul><li>最终被选定的 Node（工作节点）对应的 Kubelet 会接收到绑定信息，随后拉取容器镜像并创建 Pod。</li></ul></li></ul><blockquote><p>K8s 调度器的工作流程图</p></blockquote><p><img data-src="../../../asset/2025/09/k8s-scheduler-1.png"></p><div class="admonition note"><p class="admonition-title">总结</p><p>K8s 的调度过程分为两个阶段：首先是预选阶段（Predicates），用于过滤掉不满足条件的节点；然后是优选阶段（Priorities），对通过预选的节点按优先级进行排序。最后，从中选择优先级最高的节点进行调度。如果在任意阶段出现错误，调度器会直接返回错误。在预选阶段（Predicates），调度器会遍历所有节点，过滤掉不满足条件的节点。该阶段属于强制性规则，输出的所有符合要求的节点将作为第二阶段（优选阶段）的输入。如果所有节点都不满足条件，Pod 将一直处于 Pending 状态，直到出现满足条件的节点。期间，调度器会不断重试。因此，在部署应用时，如果发现 Pod 长时间处于 Pending 状态，说明没有符合调度条件的节点，可以检查节点资源是否可用。在优选阶段（Priorities），如果有多个节点都通过了预选条件，系统会根据节点的优先级对这些节点进行排序，最终选择优先级最高的节点来部署 Pod。K8s 调度器除了有上面介绍的 Predicates 过滤算法之外，还有一些其他的算法，更多更详细的过滤算法可以查看源码文件：<code>k8s.io/kubernetes/pkg/scheduler/algorithm/predicates/predicates.go</code>。</p></div><h4 id="K8s-调度器的核心特性"><a href="#K8s-调度器的核心特性" class="headerlink" title="K8s 调度器的核心特性"></a>K8s 调度器的核心特性</h4><div class="admonition note"><p class="admonition-title">提示</p><p>更多关于影响 Pod 调度的因素可以看<a href="/posts/c57e8370.html#%E5%BD%B1%E5%93%8D-Pod-%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9B%A0%E7%B4%A0">这里</a>。</p></div><h5 id="节点亲和性调度"><a href="#节点亲和性调度" class="headerlink" title="节点亲和性调度"></a>节点亲和性调度</h5><ul><li><p>概述：</p><ul><li>K8s 节点亲和性（Node Affinity）调度规则有两种：硬亲和性（<code>required</code>）、软亲和性（<code>preferred</code>）。</li></ul></li><li><p>作用：</p><ul><li>节点亲和性调度使得 Pod 对象被吸引运行到一类特定的节点上。</li></ul></li><li><p>特性：</p><ul><li>比 <code>nodeSelector</code> 字段更灵活的规则。</li><li>支持硬亲和性（约束条件必须满足）和软亲和性（尝试满足约束条件，但不保证满足）。</li><li>支持常用操作：<code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>Gt</code>、<code>Lt</code>、<code>DoesNotExist</code>。</li></ul></li><li><p>定义字段：</p><ul><li>节点硬亲和性：<code>requiredDuringSchedulingIgnoredDuringExecution</code></li><li>节点软亲和性：<code>preferredDuringSchedulingIgnoredDuringExecution</code></li><li>权重 <code>weight</code>：用于定义优先级，范围是 1 ~ 100，值越大优先级越高</li></ul></li><li><p>定义方式：</p><ul><li>定义方式一：Pod 使用 <code>spec.nodeSelector</code>（基于等值关系）</li><li>定义方式二：Pod 使用 <code>spec.affinity.nodeAffinity</code> 支持 <code>matchExpressions</code> 属性（基于复杂标签选择机制）</li></ul></li></ul><hr><ul><li>节点硬亲和性的配置示例：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span></span><br><span class="line">          <span class="comment"># 节点硬亲和性：Pod 只能调度到满足条件的节点</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">env_role</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br></pre></td></tr></tbody></table></figure><ul><li>节点软亲和性的配置示例：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span></span><br><span class="line">          <span class="comment"># 节点软亲和性：Pod 优先调度到符合条件的节点，但不是强制要求</span></span><br><span class="line">          <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">60</span></span><br><span class="line">              <span class="attr">preference:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">zone</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">foo</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">30</span></span><br><span class="line">              <span class="attr">preference:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">ssd</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-亲和性调度"><a href="#Pod-亲和性调度" class="headerlink" title="Pod 亲和性调度"></a>Pod 亲和性调度</h5><p>K8s 的 Pod 亲和性（Pod Affinity）调度用于控制 Pod 倾向于与指定 Pod 调度到同一拓扑域，常用于需要紧密协作或低延迟通信的场景。</p><ul><li><p>Pod 亲和性（Pod Affinity）调度规则有两种：</p><ul><li>硬亲和性（约束条件必须满足）：<code>requiredDuringSchedulingIgnoredDuringExecution</code></li><li>软亲和性（尝试满足约束条件，但不保证满足）：<code>preferredDuringSchedulingIgnoredDuringExecution</code></li></ul></li><li><p>可用于将相互依赖的 Pod 部署在同一机架（Rack）或同一可用区（Zone），以降低网络延迟、提升性能，比如：</p><ul><li><code>topologyKey: kubernetes.io/hostname</code>：倾向于将 Pod 调度到同一 Node（工作节点）。</li><li><code>topologyKey: zone</code>：倾向于将 Pod 调度到同一可用区。</li></ul></li></ul><hr><ul><li>Pod 硬亲和性调度的配置示例：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="comment"># Pod 硬亲和性调度</span></span><br><span class="line">        <span class="attr">podAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">myapp</span></span><br><span class="line">              <span class="attr">topologyKey:</span> <span class="string">zone</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">busybox:latest</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"sleep 3600"</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>配置说明：<ul><li>Kubernetes 调度器会强制保证，Pod 调度到与匹配 <code>labelSelector</code> 条件的 Pod 所在的同一 <code>zone</code> 中。</li><li>如果集群中所有 <code>zone</code> 都没有匹配的 Pod，则新 Pod 会一直处于 <code>Pending</code> 状态。<table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td><code>requiredDuringSchedulingIgnoredDuringExecution</code></td><td>硬亲和性约束：必须满足条件，否则 Pod 无法被调度。</td></tr><tr><td><code>labelSelector.matchExpressions</code></td><td>指定匹配条件，比如匹配拥有 <code>app=myapp</code> 标签的 Pod。</td></tr><tr><td><code>topologyKey</code></td><td>定义拓扑域的维度，如 <code>zone</code>、<code>kubernetes.io/hostname</code> 等。</td></tr></tbody></table></li></ul></li></ul><h5 id="Pod-反亲和性调度"><a href="#Pod-反亲和性调度" class="headerlink" title="Pod 反亲和性调度"></a>Pod 反亲和性调度</h5><p>K8s 的 Pod 反亲和性（Pod AntiAffinity）调度用于控制 Pod 不与指定 Pod 调度到同一拓扑域，常用于高可用场景。</p><ul><li>可用于将 Pod 副本分布到不同机架（Rack）或可用区（Zone） 中，避免单点故障，比如：<ul><li><code>topologyKey: kubernetes.io/hostname</code>：避免 Pod 调度到同一 Node（工作节点）。</li><li><code>topologyKey: zone</code>：避免 Pod 调度到同一可用区。</li></ul></li></ul><p>Pod 反亲和性调度的配置示例：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">busybox:latest</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"sleep 3600"</span>]</span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="comment"># Pod 反亲和性调度</span></span><br><span class="line">        <span class="attr">podAntiAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">myapp</span></span><br><span class="line">              <span class="attr">topologyKey:</span> <span class="string">zone</span></span><br></pre></td></tr></tbody></table></figure><ul><li>配置说明：<ul><li>Kubernetes 调度器会强制保证，同一 <code>zone</code> 下，不会与匹配 <code>labelSelector</code> 条件的 Pod 同时调度运行。</li><li>如果所有 <code>zone</code> 都有匹配的 Pod，则新 Pod 会一直处于 <code>Pending</code> 状态。<table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td><code>requiredDuringSchedulingIgnoredDuringExecution</code></td><td>硬亲和性约束：必须满足条件，否则 Pod 无法被调度。</td></tr><tr><td><code>labelSelector.matchExpressions</code></td><td>指定匹配条件，比如匹配拥有 <code>app=myapp</code> 标签的 Pod。</td></tr><tr><td><code>topologyKey</code></td><td>定义拓扑域的维度，如 <code>zone</code>、<code>kubernetes.io/hostname</code> 等。</td></tr></tbody></table></li></ul></li></ul><h5 id="污点和容忍度"><a href="#污点和容忍度" class="headerlink" title="污点和容忍度"></a>污点和容忍度</h5><blockquote><p>污点（Taints）</p></blockquote><ul><li><p>污点的作用：</p><ul><li>让节点拒绝调度 Pod 到其上运行，除非 Pod 显式声明可以容忍该污点。</li></ul></li><li><p>污点的定义：</p><ul><li>定义在节点（Node）上的键值型属性数据。</li><li>字段 <code>spec.taints</code>，语法是 <code>key=value:effect</code>。</li></ul></li><li><p>污点的适用场景：</p><ul><li>专用节点隔离：保留节点给特定 Pod（如 GPU 节点只运行 AI 任务）</li><li>节点维护：标记节点为不可调度（如 <code>NoSchedule）</code>，避免新 Pod 被分配到正在维护的节点</li><li>特殊硬件限制：防止普通 Pod 调度到带特殊硬件（如 FPGA）的节点</li></ul></li><li><p>污点的类型：</p><table><thead><tr><th>污点类型（Effect）</th><th>作用</th><th>对已运行 Pod 的影响</th><th>典型场景</th></tr></thead><tbody><tr><td> NoSchedule</td><td> 新的 Pod 无法调度到该节点，除非 Pod 明确声明容忍该污点</td><td>不容忍此污点的 Pod 不会被驱逐</td><td>保留节点给特定用途（如 GPU 节点、生产环境专用节点）</td></tr><tr><td>PreferNoSchedule</td><td> 调度器尽量避免将 Pod 调度到该节点，但若无其他节点可选，仍可被调度</td><td>不容忍此污点的 Pod 不会被驱逐</td><td>软性隔离，如临时维护节点但不强制拒绝调度</td></tr><tr><td> NoExecute</td><td> 新的 Pod 无法调度到该节点（与 NoSchedule 相同）</td><td>不容忍此污点的 Pod 会被驱逐（Evict）</td><td>节点故障或紧急隔离，如磁盘损坏需立即迁移所有 Pod</td></tr></tbody></table></li><li><p> 节点自动添加的污点</p><ul><li>当节点出现特定状态或资源异常时，Kubernetes 会自动为节点添加带有 <code>NoExecute</code> 效果的污点，从而驱逐不具备相应容忍度的 Pod。</li><li>K8s 核心组件通常会自动容忍下面这些系统级别的污点，以确保系统服务的持续运行。<table><thead><tr><th>污点键（Taint Key）</th><th>触发条件 / 含义</th><th>说明</th></tr></thead><tbody><tr><td><code>node.kubernetes.io/not-ready</code></td><td>节点进入 NotReady 状态</td><td>表示节点不可调度且无法响应心跳</td></tr><tr><td><code>node.alpha.kubernetes.io/unreachable</code></td><td>节点进入 NotReachable 状态</td><td>旧版本中使用，表示节点网络不可达（已被废弃，改为下一个键）</td></tr><tr><td><code>node.kubernetes.io/unreachable</code></td><td>节点网络不可达</td><td>替代 <code>alpha</code> 版本的键，节点与控制平面失联时自动添加</td></tr><tr><td><code>node.kubernetes.io/out-of-disk</code></td><td>节点磁盘空间不足</td><td>节点磁盘空间耗尽时自动添加</td></tr><tr><td><code>node.kubernetes.io/memory-pressure</code></td><td>节点内存资源紧张</td><td>表示节点内存使用率过高</td></tr><tr><td><code>node.kubernetes.io/disk-pressure</code></td><td>节点磁盘面临压力</td><td>表示节点磁盘可用空间或 I/O 受限</td></tr><tr><td><code>node.kubernetes.io/network-unavailable</code></td><td>节点网络不可用</td><td>节点网络尚未就绪或中断</td></tr><tr><td><code>node.cloudprovider.kubernetes.io/uninitialized</code></td><td>节点由云提供商组件初始化中</td><td>当 kubelet 由云环境程序启动时自动添加，待控制器初始化节点后自动移除</td></tr></tbody></table></li></ul></li><li><p>节点的污点操作示例：</p></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给节点添加污点</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;=&lt;value&gt;:NoSchedule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 举个例子</span></span><br><span class="line">kubectl taint node kube-node1 node-<span class="built_in">type</span>=production:NoShedule</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点的污点</span></span><br><span class="line">kubectl describe node &lt;node-name&gt; | grep Taint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">kubectl get nodes &lt;node-name&gt;<span class="params"> -o</span> go-template={{.spec.taints}}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除节点的单个污点（末尾的 "-" 符号表示删除）</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;:NoSchedule-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的指定键的所有污点（末尾的 "-" 符号表示删除）</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的所有污点</span></span><br><span class="line">kubectl patch nodes &lt;node-name&gt;<span class="params"> -p</span> <span class="string">'{"spec":{"taints":[]}}'</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>容忍度（Tolerations）</p></blockquote><ul><li><p>容忍度的概述：</p><ul><li>节点设置污点后，Pod 必须声明可以容忍哪些污点，才允许其被调度到具有这些污点的节点上。</li></ul></li><li><p>容忍度的定义：</p><ul><li>定义在 Pod 上的键值型属性数据。</li><li>字段 <code>spec.tolerations</code>，语法是 <code>key=value:effect</code>。</li><li>字段 <code>tolerationSeconds</code> 用于定义延迟驱逐 Pod 的时间<ul><li><code>tolerationSeconds</code> 仅在 <code>effect: NoExecute</code> 的容忍规则中生效；</li><li>超过设定时间后，若节点上的污点仍存在，则 Pod 会被驱逐；</li><li>如果未设置 <code>tolerationSeconds</code>，则表示 Pod 将无限期地容忍该污点，即 Pod 不会因为该污点被驱逐。</li></ul></li></ul></li><li><p>容忍度的调度规则：</p><ul><li>Pod 优先调度到没有污点的节点。</li><li>如果目标节点有污点，则 Pod 必须显式声明容忍该污点，否则无法被调度过去。</li></ul></li><li><p>容忍度的适用场景：</p><ul><li>特权 Pod 调度：允许关键 Pod（如日志收集组件）无视污点，调度到任意节点</li><li>故障恢复：容忍 <code>NoExecute</code> 污点，使 Pod 在节点故障时不被驱逐（如数据库 Pod）</li><li>共享特殊节点：让普通 Pod 通过容忍临时使用专用节点（如容忍 GPU 节点污点）</li></ul></li><li><p>容忍度的类型：</p></li></ul><table><thead><tr><th>容忍度类型（Effect）</th><th>作用</th><th>典型场景</th></tr></thead><tbody><tr><td> NoSchedule</td><td> 允许 Pod 调度到带有 <code>NoSchedule</code> 污点的节点，无视节点的硬性隔离规则</td><td>关键 Pod，如存储服务、核心系统组件</td></tr><tr><td> PreferNoSchedule</td><td> 允许 Pod 调度到带有 <code>PreferNoSchedule</code> 污点的节点，但调度器仍会优先选择其他节点</td><td>非关键 Pod 在资源不足时，仍可使用软隔离节点</td></tr><tr><td> NoExecute</td><td>1. 允许 Pod 调度到带有 <code>NoExecute</code> 污点的节点 <br>2. 豁免驱逐：即使节点新增 NoExecute 污点，Pod 也不会被驱逐</td><td>守护进程（如日志收集器、监控代理）需长期运行，无视节点维护状态</td></tr><tr><td>空值（未指定 Effect）</td><td>容忍所有类型的污点，包括未来新增的类型</td><td>超级特权 Pod，如集群管理组件、CNI/CSI 插件等需在所有节点运行</td></tr></tbody></table><ul><li> Pod 的容忍度配置示例：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"key1"</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">"Equal"</span>           <span class="comment"># 等值判断，判断条件为 Equal</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">"value1"</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">"NoExecute"</span></span><br><span class="line">      <span class="attr">tolerationSeconds:</span> <span class="number">600</span>      <span class="comment"># 延迟 600 秒后驱逐 Pod（可选）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"key1"</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">"Exists"</span>          <span class="comment"># 存在性判断，只要污点键（Key）存在即可匹配</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">"NoExecute"</span></span><br><span class="line">      <span class="attr">tolerationSeconds:</span> <span class="number">600</span>      <span class="comment"># 延迟 600 秒后驱逐 Pod（可选）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="comment"># 容忍 NoSchedule 污点</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"dedicated"</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">"gpu"</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 容忍 NoExecute 污点</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"unreachable"</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">"NoExecute"</span></span><br><span class="line">      <span class="attr">tolerationSeconds:</span> <span class="number">600</span>  <span class="comment"># 延迟 600 秒后驱逐 Pod（可选）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 容忍所有污点（危险！慎用！）</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-deploy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">      <span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">        <span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="comment"># 容忍 NoExecute 污点</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"node-type"</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"production"</span></span><br><span class="line">          <span class="attr">effect:</span> <span class="string">"NoExecute"</span></span><br><span class="line">          <span class="attr">tolerationSeconds:</span> <span class="number">600</span>  <span class="comment"># 延迟 600 秒后驱逐 Pod（可选）</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>一个节点可以配置多个污点，一个 Pod 也可以有多个容忍度。</li><li>污点提供了让节点（Node）排斥运行特定 Pod 对象的能力。</li><li>节点亲和性（Node Affinity）调度使得 Pod 对象被吸引运行到一类特定的节点上。</li></ul></div><h5 id="Pod-优先级与抢占式调度"><a href="#Pod-优先级与抢占式调度" class="headerlink" title="Pod 优先级与抢占式调度"></a>Pod 优先级与抢占式调度</h5><p>在 Pod 上定义容忍度时，Pod 的优先级与抢占式调度机制如下：</p><ul><li><p>优先级（Pod Priority）</p><ul><li>表示 Pod 对象的重要程度。</li><li>作用：<ul><li>影响调度顺序：高优先级 Pod 会优先被调度。</li><li>影响驱逐次序：节点资源不足时，低优先级 Pod 会先被驱逐。</li></ul></li></ul></li><li><p>抢占机制（Preemption）</p><ul><li>当一个 Pod 无法被调度时，调度器会尝试驱逐节点上优先级更低的 Pod，为当前高优先级 Pod 腾出资源。</li><li>适合关键业务 Pod 需要资源保障的场景。</li></ul></li><li><p>启用方法</p><ul><li>Pod 优先级与抢占式调度机制默认处于禁用状态，需要手动启用。</li><li>启用方式：在以下组件的启动参数中增加 <code>--feature-gates=PodPriority=true</code>：<ul><li><code>kube-apiserver</code></li><li><code>kube-scheduler</code></li><li><code>kubelet</code></li></ul></li></ul></li><li><p>使用步骤</p><ul><li><p>(1) 创建优先级类别（<code>PriorityClass</code>）</p><ul><li>定义不同的优先级，如关键业务、高优先级、低优先级等。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">scheduling.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">high-priority</span>                               <span class="comment"># 优先级类别名称</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">1000</span>                                         <span class="comment"># 优先级值，数值越大优先级越高</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span>                                <span class="comment"># 是否为默认优先级类别</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"用于关键业务 Pod，例如存储、网络组件"</span>      <span class="comment"># 优先级的描述信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">scheduling.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">low-priority</span>                                <span class="comment"># 优先级类别名称</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">100</span>                                          <span class="comment"># 优先级值，数值越大优先级越高</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span>                                <span class="comment"># 是否为默认优先级类别</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"用于低优先级 Pod，例如测试或批处理任务"</span>     <span class="comment"># 优先级的描述信息</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>(2) 在 Pod 中指定优先级</p><ul><li>创建 Pod 时，通过 <code>priorityClassName</code> 属性绑定到对应的优先级类别。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">critical-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">priorityClassName:</span> <span class="string">high-priority</span>    <span class="comment"># Pod 绑定高优先级类别</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">critical-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">Pod 的优先级与抢占式调度总结</p><p>高优先级 Pod 无法被调度 → 调度器检查目标节点 → 驱逐低优先级 Pod → 为高优先级 Pod 腾出资源 → 高优先级 Pod 调度成功。</p></div>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之十一</title>
    <link href="https://www.techgrow.cn/posts/fb1a55bb.html"/>
    <id>https://www.techgrow.cn/posts/fb1a55bb.html</id>
    <published>2025-09-16T13:12:19.000Z</published>
    <updated>2025-09-16T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="实战部署-Java-应用"><a href="#实战部署-Java-应用" class="headerlink" title="实战部署 Java 应用"></a>实战部署 Java 应用</h3><h3 id="平滑重启-Java-应用"><a href="#平滑重启-Java-应用" class="headerlink" title="平滑重启 Java 应用"></a>平滑重启 Java 应用</h3>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之五</title>
    <link href="https://www.techgrow.cn/posts/6bf07963.html"/>
    <id>https://www.techgrow.cn/posts/6bf07963.html</id>
    <published>2025-09-13T13:12:19.000Z</published>
    <updated>2025-09-13T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><h4 id="Service-的概念"><a href="#Service-的概念" class="headerlink" title="Service 的概念"></a>Service 的概念</h4><p>Service 是 Kubernetes 的核心概念之一。<strong>通过创建 Service，可以为一组具备相同功能的 Pod 提供统一的访问入口（即暴露服务），并将请求流量负载均衡地分发到后端各个 Pod 上。</strong>Pod 与 Service 之间是通过 Label（标签）和 Label Selector（标签选择器）建立关联关系的。值得一提的是，在 Kubernetes 中，Service + EndpointController 的配合实现了类似注册中心的功能：当 Pod 创建后，Kubernetes 控制器会自动将其加入对应 Service 的 Endpoints 列表，并通过 Readiness Probe（就绪探针）动态更新，确保只有可用的 Pod 接收流量。Pod 可以通过 DNS 直接访问 Service 名称（如 <code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>），而流量则由 kube-proxy 负责负载均衡。整体上，Service 提供了 DNS 名称 + 虚拟 IP（ClusterIP）的抽象，真正存储服务实例信息的是 EndpointSlice，整个过程完全自动化，Pod 无需显式注册，从而实现了透明的服务注册与发现。</p><span id="more"></span><div class="admonition note"><p class="admonition-title">提示</p><p>Kubernetes 中的 Service + EndpointController 机制，提供了与注册中心类似的自动注册和服务发现能力，但 Pod 无需显式注册，且数据由 Kubernetes 控制平面自动维护，主要面向集群内部的服务（Pod）注册与发现。</p></div><h4 id="Service-的作用"><a href="#Service-的作用" class="headerlink" title="Service 的作用"></a>Service 的作用</h4><ul><li><p>服务发现（Service Discovery）</p><ul><li>Pod 间互相通信的唯一入口：<ul><li>为一组 Pod 提供一个固定的访问入口，解决 Pod IP 动态变化的问题。</li></ul></li><li>DNS 服务发现：<ul><li>集群内部 Pod 可通过 <code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code> 访问目标服务，无需感知 Pod 的 IP。</li></ul></li><li>自动注册与维护：<ul><li>Pod 创建或销毁时，Kubernetes 会自动更新 Service 对应的 <code>EndpointSlice</code>，应用无需显式注册。</li></ul></li></ul></li><li><p>负载均衡（Load Balancing）</p><ul><li>集群内负载均衡：<ul><li>kube-proxy 会自动将访问 Service 的流量分发到后端多个 Pod。</li></ul></li><li>负载策略：<ul><li>默认采用轮询（Round Robin）。</li><li>结合 <code>SessionAffinity</code> 可以实现会话保持。</li></ul></li><li>Service 类型扩展：<ul><li><code>ClusterIP</code>：仅集群内访问，内部负载均衡。</li><li><code>NodePort</code>：通过每个节点固定端口暴露服务。</li><li><code>LoadBalancer</code>：集成云厂商的外部负载均衡器。</li></ul></li></ul></li><li><p>对外暴露服务</p><ul><li>集群外访问能力：<ul><li><code>NodePort</code>：通过节点 IP + 端口访问。</li><li><code>LoadBalancer</code>：借助云厂商负载均衡对外暴露。</li><li><code>ExternalName</code>：将集群内部访问映射到外部域名。</li></ul></li></ul></li><li><p>解耦应用与底层 Pod</p><ul><li>稳定访问地址：<ul><li>应用通过 Service 名称访问后端服务，不依赖具体 Pod IP。</li></ul></li><li>支持滚动升级：<ul><li>Pod 替换过程中，Service 始终提供不变的入口，保障请求不中断。</li></ul></li><li>简化业务逻辑：<ul><li>业务代码不需要实现服务注册、心跳检测、路由等逻辑。</li></ul></li></ul></li><li><p>健康检查与流量控制</p><ul><li>与 Readiness Probe（就绪探针）结合：<ul><li>只将健康的 Pod 添加到 <code>EndpointSlice</code>，自动摘除异常 Pod。</li></ul></li><li>支持蓝绿发布 / 灰度发布：<ul><li>结合标签选择器（<code>selector</code>），灵活管理流量转发目标。</li></ul></li></ul></li><li><p>服务注册中心的替代方案</p><ul><li>自动化注册与发现：<ul><li>无需像 Zookeeper / Eureka 那样主动注册，Pod 生命周期事件由 Kubernetes 控制器接管。</li></ul></li><li>真实的 “注册表”：<ul><li>Pod 实例信息存储在 <code>EndpointSlice</code> 中，Service 只是抽象层，负责提供 DNS 和虚拟 IP（ClusterIP）。</li></ul></li></ul></li></ul><h4 id="Service-的类型"><a href="#Service-的类型" class="headerlink" title="Service 的类型"></a>Service 的类型</h4><h5 id="五大类型"><a href="#五大类型" class="headerlink" title="五大类型"></a>五大类型</h5><p>在 Kubernetes 中，Service 有以下几种类型：</p><ul><li><strong>ClusterIP</strong><ul><li> 概述<ul><li> ClusterIP 是 Service 的默认类型。</li></ul></li><li>作用：<ul><li>为一组 Pod 提供一个集群内部虚拟 IP，只能通过集群内部的 Pod 或 Service 访问。</li></ul></li><li>使用场景：<ul><li>内部微服务之间通信。</li><li>数据库、内部 API 等只在集群内部访问的服务。</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;service-name&gt;</span>          <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span>           <span class="comment"># Service 类型为 ClusterIP，集群内部可访问</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span>             <span class="comment"># 选择标签为 app=my-app 的 Pod 作为后端</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>              <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>      <span class="comment"># Pod 内容器实际监听的端口（即将请求转发到容器的 xxxx 端口）</span></span><br></pre></td></tr></tbody></table></figure></li><li>访问方式：<ul><li>外部访问：<ul><li><code>ClusterIP</code> 类型的 Service 默认无法被外部访问，它只在集群内部有效。</li><li>如果需要外部访问，则必须通过 Ingress、LoadBalancer 或 NodePort 将流量引入集群，再访问集群内的 Pod 或 Service。</li></ul></li><li>集群内部访问：<ul><li>通过虚拟 IP（ClusterIP）访问：<ul><li>集群内 Pod 可以直接访问 Service 的 ClusterIP：<code>http://&lt;clusterIp&gt;:&lt;port&gt;</code></li></ul></li><li>通过 DNS 名称访问：<ul><li>Kubernetes 会自动为 Service 创建 DNS 名称（域名）。</li><li>Pod 内部可以通过这个 DNS 名称访问 Service：<code>http://&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local:&lt;port&gt;</code>。</li><li>Service 的默认命名空间（<code>namespace</code>）是 <code>default</code>，可以通过 <code>kubectl get svc -A</code> 命令查看。</li><li>kube-proxy 会将流量转发到对应 Pod 的 <code>targetPort</code>。</li></ul></li></ul></li></ul></li></ul></li></ul><hr><ul><li><strong>NodePort</strong><ul><li> 概述：<ul><li>将 Service 暴露在每个集群节点的固定端口上。</li></ul></li><li>作用：<ul><li>外部流量可以通过集群节点的 IP 和 NodePort 访问到集群内的 Pod。</li></ul></li><li>端口范围：<ul><li>默认 <code>30000 ~ 32767</code>。</li></ul></li><li>使用场景：<ul><li>测试环境或临时访问集群服务。</li><li>没有 Ingress 或云负载均衡器时，简单暴露服务。</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;service-name&gt;</span>        <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>          <span class="comment"># Service 类型为 NodePort，可通过节点 IP 访问</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span>           <span class="comment"># 选择标签为 app=my-app 的 Pod 作为后端</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>            <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>    <span class="comment"># Pod 内容器实际监听的端口（即将请求转发到容器的 xxxx 端口）</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span>     <span class="comment"># 映射到物理机的端口号，默认范围 30000 - 32767</span></span><br></pre></td></tr></tbody></table></figure></li><li>访问方式：<ul><li>外部访问：<ul><li>通过任意一个集群节点的 IP 和 <code>nodePort</code> 访问集群内的 Pod：<code>http://&lt;nodeIP&gt;:&lt;nodePort&gt;</code>。</li></ul></li><li>集群内部访问：<ul><li>Kubernetes 会自动为 Service 创建 DNS 名称（域名）。</li><li>集群内部 Pod 可以通过这个 DNS 名称访问 Service：<code>http://&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local:&lt;port&gt;</code>。</li><li>Service 的默认命名空间（<code>namespace</code>）是 <code>default</code>，可以通过 <code>kubectl get svc -A</code> 命令查看。</li><li>kube-proxy 会将流量路由到对应 Pod 的 <code>targetPort</code>。</li></ul></li></ul></li></ul></li></ul><hr><ul><li><strong>LoadBalancer</strong><ul><li> 概述：<ul><li>依赖云厂商的负载均衡器，将外部流量分发到集群。</li></ul></li><li>作用：<ul><li>自动向云平台申请一个外部负载均衡器（如 AWS ELB、阿里云 SLB）。</li></ul></li><li>特点：<ul><li>会自动分配到一个公网 IP。</li><li>负载均衡器将流量转发到后端 NodePort。</li></ul></li><li>使用场景：<ul><li>云环境生产集群中，外部流量访问的标准方式。</li><li>对外提供 API 网关、Web 服务、支付网关等服务。</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;service-name&gt;</span>          <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span>        <span class="comment"># Service 类型为 LoadBalancer，自动申请外部负载均衡器（LB）</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span>             <span class="comment"># 选择标签为 app=my-app 的 Pod 作为后端</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>              <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>      <span class="comment"># Pod 内容器实际监听的端口（即将请求转发到容器的 xxxx 端口）</span></span><br></pre></td></tr></tbody></table></figure></li><li>访问方式：<ul><li>外部访问：<ul><li>外部通过云负载均衡器的公网 IP 或域名访问：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于公网 IP 访问</span></span><br><span class="line">curl http://&lt;loadbalancer-ip&gt;:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于域名访问</span></span><br><span class="line">curl http://&lt;service-name&gt;.example.com</span><br></pre></td></tr></tbody></table></figure></li><li><code>&lt;LoadBalancer-IP&gt;</code> 由云平台自动分配。</li><li>可绑定自定义域名，通过 DNS 解析访问。</li></ul></li><li>集群内部访问：<ul><li>Kubernetes 会自动为 Service 创建 DNS 名称（域名）。</li><li>集群内部 Pod 可以通过这个 DNS 名称访问 Service：<code>http://&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local:&lt;port&gt;</code>。</li><li>Service 的默认命名空间（<code>namespace</code>）是 <code>default</code>，可以通过 <code>kubectl get svc -A</code> 命令查看。</li><li>kube-proxy 会将流量路由到对应 Pod 的 <code>targetPort</code>。</li></ul></li></ul></li></ul></li></ul><hr><ul><li><strong>ExternalName</strong><ul><li> 概述：<ul><li>通过 DNS 将 Service 名称映射到集群外部服务域名，不做流量代理。</li></ul></li><li>作用：<ul><li>通过 Kubernetes 内部的 DNS 把 Service 映射为外部域名，Pod 通过访问 Service 名称即可访问外部服务。</li></ul></li><li>特点：<ul><li>不会创建虚拟 IP（ClusterIP）。</li><li>只是一个 DNS CNAME 解析，流量不经过 Kubernetes 负载均衡或代理（kube-proxy）。</li></ul></li><li>使用场景：<ul><li>访问外部数据库、外部 API 服务等。</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-service</span>            <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span>                <span class="comment"># Service 类型为 ExternalName，将 Service 名称映射到外部域名</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">db.example.com</span>      <span class="comment"># 集群内部访问 Service 时，DNS 解析到的外部域名</span></span><br></pre></td></tr></tbody></table></figure></li><li>访问方式：<ul><li>外部访问：<ul><li><code>ExternalName</code> 类型的 Service 本身不提供外部访问入口，它只是 Kubernetes 内部的 DNS 映射，外部无法通过 Service 名称访问集群内的 Pod 或 Service。</li><li>如果需要外部访问，则必须通过 Ingress、LoadBalancer 或 NodePort 将流量引入集群，再访问集群内的 Pod 或 Service。</li></ul></li><li>集群内部访问：<ul><li>Kubernetes 会自动为 Service 创建 DNS 名称（域名）。</li><li>集群内部 Pod 可以通过这个 DNS 名称访问 Service：<code>http://&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>，实际上会解析到 <code>db.example.com</code>。</li><li>Service 的默认命名空间（<code>namespace</code>）是 <code>default</code>，可以通过 <code>kubectl get svc -A</code> 命令查看。</li></ul></li></ul></li></ul></li></ul><hr><ul><li><strong>None</strong><ul><li> 概述：<ul><li>无虚拟 IP（ClusterIP）的 Service（Headless Service - 无头服务），是一种没有 ClusterIP 的特殊 Service 类型。</li><li>用于暴露 K8s 集群内 Pod 的真实 IP 和 DNS 名称（域名），而不是通过一个统一的虚拟 IP（ClusterIP）进行负载均衡，即 K8s 不会做流量负载均衡。</li></ul></li><li>作用：<ul><li>不需要虚拟 IP（ClusterIP）和负载均衡时使用。</li><li>客户端可以直接感知 Pod 的 IP，实现自定义的负载均衡或服务发现。</li></ul></li><li>定义方式：<ul><li>在 Service 配置中设置：<code>clusterIP: None</code>。</li></ul></li><li>使用场景：<ul><li>部署有状态服务（StatefulSet），如 MySQL、ZooKeeper、Kafka 等。</li><li>客户端需要自己实现负载均衡或服务发现的场景。</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">headless-service</span>      <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span>             <span class="comment"># 设置为 None 表示无虚拟 IP（ClusterIP），直接返回 Pod 的 IP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span>               <span class="comment"># 选择标签为 app=my-app 的 Pod 作为后端</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>                <span class="comment"># Service 对外暴露的端口，客户端访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>        <span class="comment"># Pod 内容器实际监听的端口（即将请求转发到容器的 xxxx 端口）</span></span><br></pre></td></tr></tbody></table></figure></li><li>访问方式：<ul><li>外部访问：<ul><li>由于 <code>None</code> 类型的 Service 不提供虚拟 IP，Kubernetes 不做负载均衡，因此外部不能直接访问 Service。</li><li>如果外部需要访问 <code>None</code> 类型的 Service，可以使用以下方式实现：<ul><li>通过 Pod 的 Node IP + 容器端口（Pod 暴露端口需要通过 NodePort 或其他方式实现）。</li><li>或者借助 Ingress 或 LoadBalancer 将流量引入集群，再由客户端自行选择 Pod。</li></ul></li></ul></li><li>集群内部访问：<ul><li>通过 DNS 名称访问：<ul><li>Kubernetes 会自动为 Service 创建 DNS 名称（域名）。</li><li>Service 的默认命名空间（<code>namespace</code>）是 <code>default</code>，可以通过 <code>kubectl get svc -A</code> 命令查看。</li><li>第一种 DNS 访问方式：<ul><li>集群内部 Pod，可以通过 Service 的 DNS 名称（域名）查询所有匹配 Pod 的 IP，域名格式：<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nslookup mysql.default.svc.cluster.<span class="built_in">local</span></span><br><span class="line">10.244.1.5</span><br><span class="line">10.244.1.6</span><br><span class="line">10.244.1.7</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>第二种 DNS 访问方式（StatefulSet 专用访问）<ul><li>ClusterIP 为 <code>None</code> 的 Service，每个 Pod 都有固定的 DNS 名称（域名），适用于数据库或分布式系统访问（比如 MySQL、ZooKeeper），保证客户端可以稳定访问指定 Pod。</li><li>集群内部 Pod，可以通过 Pod 的 DNS 名称（域名）直接访问指定的 Pod，域名格式：<code>&lt;pod-name&gt;.&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nslookup mysql-statefulset-0.mysql.default.svc.cluster.<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">telnet mysql-statefulset-0.mysql.default.svc.cluster.<span class="built_in">local</span> 3306</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li>直接访问 Pod 的 IP：<ul><li>客户端可根据自定义的负载均衡策略（轮询、随机、哈希等）直接访问 Pod 的 <code>targetPort</code>：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://10.244.1.5:8080</span><br><span class="line">curl http://10.244.1.6:8080</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul><hr><table><thead><tr><th>类型</th><th>访问范围</th><th>是否需要 kube-proxy</th><th> 是否有虚拟 IP（ClusterIP）</th><th>典型场景</th></tr></thead><tbody><tr><td> ClusterIP</td><td> 仅集群内部</td><td>✅ 是</td><td>✅ 有</td><td>微服务内部通信</td></tr><tr><td> NodePort</td><td> 外部可访问，通过集群节点的 IP</td><td>✅ 是</td><td>✅ 有</td><td>简单对外暴露服务</td></tr><tr><td> LoadBalancer</td><td> 外部可访问，通过 LB 公网 IP</td><td>✅ 是</td><td>✅ 有</td><td>生产外部访问</td></tr><tr><td> ExternalName</td><td> 集群内部访问外部域名</td><td>❌ 否</td><td>❌ 无</td><td>外部服务映射</td></tr><tr><td> None</td><td> 集群内部直接返回 Pod 的 IP</td><td>✅ 是</td><td>❌ 无</td><td>有状态服务访问（如 MySQL、ZooKeeper）</td></tr></tbody></table><h5 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h5><div class="admonition warning"><p class="admonition-title">特别注意</p><p><code>ClusterIP</code> 类型的 Service 只能在 Kubernetes 集群内部访问，如果在集群外部机器（比如直接在集群的 Master 节点）上，通过 Service 的 DNS 名称直接访问 Pod（比如 <code>http://nginx.default.svc.cluster.local:80</code>），肯定是无法访问成功的。</p></div><blockquote><p>在 Kubernetes 中，创建一个 Nginx 的 Pod，使用 ClusterIP 类型的 Service 来暴露服务</p></blockquote><ul><li>创建一个 Nginx 的 Deployment 和 Service</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Nginx</span></span><br><span class="line">kubectl create deployment nginx<span class="params"> --image</span>=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露 Nginx 的端口（Service 的默认类型是 ClusterIP，可以通过 --type 参数指定类型）</span></span><br><span class="line">kubectl expose deployment nginx<span class="params"> --port</span>=80<span class="params"> --target</span>-port=80</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Pod 列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-6799fc88d8-dkltf   1/1     Running   0          12m   10.244.2.2   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Service 列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc<span class="params"> -A</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAMESPACE     NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">default       kubernetes   ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP                  42d</span><br><span class="line">default       nginx        ClusterIP   10.0.0.231   &lt;none&gt;        80/TCP                   12s</span><br><span class="line">kube-system   kube-dns     ClusterIP   10.0.0.2     &lt;none&gt;        53/UDP,53/TCP,9153/TCP   25m</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 Kubernetes 集群内部，通过 Service 的 DNS 名称访问 Nginx 的 Pod</p></blockquote><ul><li>创建一个临时 Pod，并进入 Pod 内部的交互式 Shell</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 --rm 参数，为了在 Shell 中执行 exit 命令退出后自动销毁 Pod</span></span><br><span class="line">kubectl run <span class="built_in">test</span>-pod<span class="params"> --image</span>=busybox:1.35<span class="params"> --restart</span>=Never<span class="params"> -it</span><span class="params"> --rm</span> -- sh</span><br></pre></td></tr></tbody></table></figure><ul><li>在临时 Pod 的内部，通过 Service 的 DNS 名称访问 Nginx 的 Pod（必须保证临时 Pod 与 Service 处于同一个命名空间），域名格式：<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup nginx.default.svc.cluster.<span class="built_in">local</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Server:10.0.0.2</span><br><span class="line">Address:10.0.0.2:53</span><br><span class="line"></span><br><span class="line">Name:nginx.default.svc.cluster.local</span><br><span class="line">Address: 10.0.0.231</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者通过 Service 的 DNS 名称访问 Nginx 的首页面</span></span><br><span class="line">wget<span class="params"> -qO</span>- http://nginx.default.svc.cluster.<span class="built_in">local</span>:80</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>nslookup</code> 或者 <code>wget</code> 工具无法通过 Service 的 DNS 名称来访问 Nginx 的 Pod，建议重点检查 CoreDNS（Kubernetes 官方提供的 DNS 服务）是否正常运行（也可能是没有<a href="/posts/ccd6f2d4.html#%E9%83%A8%E7%BD%B2-CoreDNS%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89">安装 CoreDNS</a>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 CoreDNS 的运行状态</span></span><br><span class="line">kubectl get pod<span class="params"> -n</span> kube-system<span class="params"> -l</span> k8s-app=kube-dns</span><br></pre></td></tr></tbody></table></figure><ul><li>预期输出以下内容，如果 CoreDNS 的 <code>STATUS</code> 不是 <code>Running</code> 或 Pod 不存在，则说明 CoreDNS 服务没有正常运行 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-6b9bb479b9-g6t6f   1/1     Running   0          34m</span><br><span class="line">coredns-6b9bb479b9-lfd7j   1/1     Running   0          34m</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 删除 Deployment 和 Service</p></blockquote><ul><li>如果需要删除上面创建的 Deployment 和 Service，可以执行以下命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除Service</span></span><br><span class="line">kubectl delete service nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除Deployment</span></span><br><span class="line">kubectl delete deployment nginx</span><br></pre></td></tr></tbody></table></figure><h4 id="Service-的定义"><a href="#Service-的定义" class="headerlink" title="Service 的定义"></a>Service 的定义</h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span>                     <span class="comment"># Service 的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">production</span>                   <span class="comment"># 所属命名空间，例如生产环境</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>                            <span class="comment"># 标签，标识该服务属于哪个应用</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span>                        <span class="comment"># 层级标签，例如前端、后端</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">"Nginx Web Service for production"</span>  <span class="comment"># 业务描述信息</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>                               <span class="comment"># 匹配后端 Pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>                            <span class="comment"># 必须与 Pod 的 labels 匹配</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>                          <span class="comment"># Service 类型：ClusterIP / NodePort / LoadBalancer / ExternalName</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.15</span>                    <span class="comment"># 集群内部 IP（可选，默认自动分配）</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span>                   <span class="comment"># 会话亲和性，可选值：None / ClientIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span>                          <span class="comment"># 端口名称（可选）</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span>                       <span class="comment"># 协议类型：TCP 或 UDP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>                            <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>                    <span class="comment"># Pod 内容器实际监听的端口（即将请求转发到容器的 xxxx 端口）</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span>                     <span class="comment"># 映射到物理机的端口号，默认范围 30000 - 32767</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>                 <span class="comment"># 外部负载均衡器分配的 IP</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">lb-prod.example.com</span>     <span class="comment"># 外部负载均衡器的域名</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>属性名称</th><th>取值类型</th><th>是否必选</th><th>取值说明</th></tr></thead><tbody><tr><td><code>spec.ports[].targetPort</code></td><td><code>int</code></td><td></td><td>需要转发到后端 Pod 的端口号</td></tr><tr><td><code>spec.ports[].nodePort</code></td><td><code>int</code></td><td></td><td>当 <code>spec.type=NodePort</code> 时，指定映射到物理机的端口号</td></tr><tr><td><code>status</code></td><td><code>object</code></td><td></td><td>当 <code>spec.type=LoadBalance</code> 时，设置外部负载均衡器的地址，用于公有云环境</td></tr><tr><td><code>status.loadBalancer</code></td><td><code>object</code></td><td></td><td>外部负载均衡器</td></tr><tr><td><code>status.loadBalancer.ingress</code></td><td><code>object</code></td><td></td><td>外部负载均衡器</td></tr><tr><td><code>status.loadBalancer.ingress.ip</code></td><td><code>string</code></td><td></td><td>外部负载均衡器的 IP 地址</td></tr><tr><td><code>status.loadBalancer.ingress.hostname</code></td><td><code>string</code></td><td></td><td>外部负载均衡器的主机名</td></tr></tbody></table><h4 id="Service-的使用"><a href="#Service-的使用" class="headerlink" title="Service 的使用"></a>Service 的使用</h4><h5 id="Service-基础使用"><a href="#Service-基础使用" class="headerlink" title="Service 基础使用"></a>Service 基础使用</h5><p>一般来说，对外提供服务的应用程序需要通过一定的机制来实现暴露，而对于容器化应用，最简便的方式就是通过 TCP/IP 协议，并结合监听 IP 和端口号来对外提供服务。比如，创建一个带基本功能的 Controller：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mywebapp</span>                       <span class="comment"># RC 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span>                          <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">template:</span>                            <span class="comment"># Pod 的模板</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">mywebapp</span>                   <span class="comment"># Pod 的名称</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mywebapp</span>                  <span class="comment"># Pod 的标签，用于 Service 或 RC 选择器</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mywebapp</span>               <span class="comment"># 容器的名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">tomcat</span>                <span class="comment"># 容器使用的镜像</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span>      <span class="comment"># 容器内应用（比如 Tomcat）监听的端口</span></span><br></pre></td></tr></tbody></table></figure><p>可以通过 <code>kubectl get pods -l app=mywebapp -o yaml | grep podIP</code> 命令获取 Pod 的 IP 地址，然后使用 Pod 的 IP 地址和端口号来访问 Tomcat 服务。但是，直接通过 Pod 的 IP 来访问服务是不可靠的，因为当 Pod 所在的 Node（工作节点）发生故障时，Kubernetes 会将该 Pod 重新调度到其他 Node（工作节点），此时 Pod 的 IP 地址会发生变化，导致原有访问地址失效。为了解决这一问题，可以通过 YAML 配置文件再定义一个 Service，并使用以下命令来创建：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mywebAppService</span>          <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>                      <span class="comment"># 选择器，匹配后端 Pod 的标签（labels）</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mywebapp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8081</span>                 <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>           <span class="comment"># Pod 内容器实际监听的端口（即将请求转发到容器的 xxxx 端口）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据指定的 YAML 配置文件创建 Service</span></span><br><span class="line">kubectl create<span class="params"> -f</span> service.yaml</span><br></pre></td></tr></tbody></table></figure><h5 id="多端口-Service"><a href="#多端口-Service" class="headerlink" title="多端口 Service"></a>多端口 Service</h5><p>有时，一个容器应用可能需要对外提供多个端口的服务，这时可以在 Service 的定义中配置多个端口，将每个端口映射到对应的应用服务，如下所示：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mywebAppService</span>            <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>                        <span class="comment"># 选择器，匹配后端 Pod 的标签（labels）</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mywebapp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span>                    <span class="comment"># 第一个端口的名称</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span>                   <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>             <span class="comment"># Pod 内容器实际监听的端口（即将请求转发到容器的 xxxx 端口）</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">management</span>             <span class="comment"># 第二个端口的名称</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8005</span>                   <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8005</span>             <span class="comment"># Pod 内容器实际监听的端口（即将请求转发到容器的 xxxx 端口）</span></span><br></pre></td></tr></tbody></table></figure><h5 id="外部服务-Service"><a href="#外部服务-Service" class="headerlink" title="外部服务 Service"></a>外部服务 Service</h5><p>在某些特殊场景下，应用系统可能需要将外部数据库作为后端服务，或者将其他集群或命名空间中的服务作为后端服务。这时候，可以通过创建一个不带 Label Selector（标签选择器）的 Service 来实现对这些外部服务的访问，如下所示：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Service 定义</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;service-name&gt;</span>                  <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span>                 <span class="comment"># 协议类型</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>                      <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>              <span class="comment"># Pod 容器或 Endpoints 实际监听的端口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># Endpoints 定义</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;service-name&gt;</span>                  <span class="comment"># 对应的 Service 的名称</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.254</span><span class="number">.74</span><span class="number">.3</span>             <span class="comment"># 外部服务的 IP</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span>                  <span class="comment"># 外部服务实际监听的端口</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>当 Service 有 <code>selector</code> 时，Service 会自动匹配 Pod，并自动生成 Endpoints。</li><li>当 Service 没有 <code>selector</code> 时，它会通过 Endpoints 的 <code>metadata.name</code> 与 Service 的 <code>metadata.name</code> 相同（一致）来建立关联。</li></ul></div><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><h4 id="K8s-整体网络架构"><a href="#K8s-整体网络架构" class="headerlink" title="K8s 整体网络架构"></a>K8s 整体网络架构</h4><ul><li><p>Kubernetes 网络主要解决四方面的问题:</p><ul><li>一个 Pod 中的多个容器之间可以通过本地回路（Loopback）互通。</li><li>集群网络在不同 Pod 之间提供通信，Pod 和 Pod 之间互通。</li><li>Service 资源允许用户对外暴露 Pods 中运行的应用程序，以支持来自于集群外部的访问。Service 和 Pod 之间要互通。</li><li>可以使用 Service 来发布仅供集群内部使用的服务。</li></ul></li><li><p>Kubernetes 的整体网络架构</p></li></ul><p><img data-src="../../../asset/2025/09/k8s-ingress-3.png"></p><ul><li>Kubernetes 的网络访问流程</li></ul><p><img data-src="../../../asset/2025/09/k8s-ingress-4.png"></p><h4 id="Ingress-的基本概念"><a href="#Ingress-的基本概念" class="headerlink" title="Ingress 的基本概念"></a>Ingress 的基本概念</h4><ul><li><strong>为什么需要 Ingress？</strong><ul><li>Service 可以使用 NodePort 暴露集群外访问端口，但是性能差不安全。</li><li>缺少 Layer7 的统一访问入口，可以负载均衡、限流等。</li><li>Ingress 公开了从集群外部到集群内服务的 HTTP 和 HTTPS 路由，且流量路由是由 Ingress 资源上定义的规则控制。</li><li>使用 Ingress 作为整个集群统一的入口，配置 Ingress 规则将流量转发到对应的 Service（如下图所示）。</li></ul></li></ul><p><img data-src="../../../asset/2025/09/k8s-ingress-1.png"></p><ul><li><p><strong>Service 中 NodePort 的缺点</strong></p><ul><li>端口资源有限且容易冲突<ul><li> NodePort 在每个节点（Node）上都会占用相同的端口号。</li><li>每个端口只能对应一个 Service，一个节点上的端口号不能重复使用，端口资源有限。</li></ul></li><li>访问方式不够灵活<ul><li>必须通过节点 IP + 端口号访问，不符合实际生产中通常使用域名访问的方式。</li><li>无法直接根据域名自动路由到不同服务，需要额外配置反向代理或者 Ingress 实现域名分流。</li></ul></li><li>对外暴露复杂，安全性较低<ul><li>在所有节点上都暴露了特定的端口，增加了攻击面和安全风险。</li></ul></li><li>难以与外部负载均衡器集成<ul><li> NodePort 只提供基础的端口转发，不具备智能流量分配、健康检查等高级功能。</li></ul></li></ul></li><li><p><strong>Ingress 与 Pod 的关系</strong></p><ul><li>Ingress 并不直接与 Pod 通信，而是通过 Service 与 Pod 进行关联，访问链路是：<code>外部请求 → Ingress → Service → Pod</code>。</li><li>具体来说，Ingress 作为集群对外的统一访问入口，负责根据访问的域名或路径规则，将外部请求转发到对应的 Service；而 Service 再根据其标签选择器（Label Selector）将请求负载均衡地分发给一组符合条件的 Pod。</li></ul></li></ul><h4 id="Ingress-的两种实现"><a href="#Ingress-的两种实现" class="headerlink" title="Ingress 的两种实现"></a>Ingress 的两种实现</h4><p>Ingress 本质上是一个控制器（Controller），需要单独安装，它有两种实现，包括：</p><ul><li><p>Nginx Ingress</p><ul><li>这是 Nginx 官方开发的，适配 Kubernetes 的，分为开源版和 Nginx Plus 版（收费）。</li><li>官方文档：<code>https://docs.nginx.com/nginx-ingress-controller/overview/</code></li><li>官方网站：<code>https://www.nginx.com/products/nginx-ingress-controller</code><br><img data-src="../../../asset/2025/09/k8s-ingress-2.png"></li></ul></li><li><p>Ingress-Nginx</p><ul><li>这是 Kubernetes 官方开发的，适配 Nginx 的，开源免费的；它会及时更新一些特性，而且性能很高，被各大互联网公司广泛采用。</li><li>官方文档：<code>https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/</code></li><li>官方网站：<code>https://kubernetes.github.io/ingress-nginx/examples/auth/basic/</code></li><li>推荐使用这个镜像来部署 Ingress-Nginx：<code>registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/ingress-nginx-controller:v0.46.0</code><br><img data-src="../../../asset/2025/09/k8s-ingress-5.png"></li></ul></li></ul><h4 id="Ingress-的安装步骤"><a href="#Ingress-的安装步骤" class="headerlink" title="Ingress 的安装步骤"></a>Ingress 的安装步骤</h4><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>由于 Ingress 本质上是一个 Kubernetes 控制器（Controller），因此可以通过 YAML 文件进行安装（部署），这里使用的是 Nginx Ingress（由 Nginx 官方开发）。</li><li><strong>在下述的 YAML 配置内容中，<code>hostNetwork</code> 参数必须设置为 <code>true</code>，否则在 Kubernetes 集群外部无法直接通过域名访问 Ingress。</strong></li><li><strong>Ingress 的所有安装（部署）步骤都是在 Master 节点上执行。</strong></li></ul></div><ul><li>通过 YAML 文件（比如 <code>nginx-ingress-deploy.yaml）</code> 部署 Nginx Ingress（由 Nginx 官方开发）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-configuration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcp-services</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">udp-services</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-clusterrole</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secrets</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">events</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"extensions"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"networking.k8s.io"</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ingresses</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"extensions"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"networking.k8s.io"</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ingresses/status</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-role</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secrets</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namespaces</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">    <span class="attr">resourceNames:</span></span><br><span class="line">      <span class="comment"># Defaults to "&lt;election-id&gt;-&lt;ingress-class&gt;"</span></span><br><span class="line">      <span class="comment"># Here: "&lt;ingress-controller-leader&gt;-&lt;nginx&gt;"</span></span><br><span class="line">      <span class="comment"># This has to be adapted if you change either parameter</span></span><br><span class="line">      <span class="comment"># when launching the nginx-ingress-controller.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ingress-controller-leader-nginx"</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-role-nisa-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-role</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-clusterrole-nisa-binding</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-clusterrole</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-controller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">prometheus.io/port:</span> <span class="string">"10254"</span></span><br><span class="line">        <span class="attr">prometheus.io/scrape:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># wait up to five minutes for the drain of connections</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-ingress-controller</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">lizhenliang/nginx-ingress-controller:0.30.0</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/nginx-ingress-controller</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--configmap=$(POD_NAMESPACE)/nginx-configuration</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--tcp-services-configmap=$(POD_NAMESPACE)/tcp-services</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--udp-services-configmap=$(POD_NAMESPACE)/udp-services</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--publish-service=$(POD_NAMESPACE)/ingress-nginx</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--annotations-prefix=nginx.ingress.kubernetes.io</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">capabilities:</span></span><br><span class="line">              <span class="attr">drop:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">ALL</span></span><br><span class="line">              <span class="attr">add:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">NET_BIND_SERVICE</span></span><br><span class="line">            <span class="comment"># www-data -&gt; 101</span></span><br><span class="line">            <span class="attr">runAsUser:</span> <span class="number">101</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">fieldRef:</span></span><br><span class="line">                  <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAMESPACE</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">fieldRef:</span></span><br><span class="line">                  <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">443</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">10254</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">10254</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">lifecycle:</span></span><br><span class="line">            <span class="attr">preStop:</span></span><br><span class="line">              <span class="attr">exec:</span></span><br><span class="line">                <span class="attr">command:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">/wait-shutdown</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">90Mi</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Container</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 K8s 资源对象</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> nginx-ingress-deploy.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看特定命名空间下所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -n</span> ingress-nginx<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE   IP              NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-ingress-controller-5dc64b58f-x7stf   1/1     Running   0          17m   192.168.2.236   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>若需要取消 Ingress 的安装，可以执行以下命令删除 Ingress 相关的所有资源 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete<span class="params"> -f</span> nginx-ingress-deploy.yaml</span><br></pre></td></tr></tbody></table></figure><h4 id="Ingress-的使用案例"><a href="#Ingress-的使用案例" class="headerlink" title="Ingress 的使用案例"></a>Ingress 的使用案例</h4><div class="admonition note"><p class="admonition-title">提示</p><p>本节将使用 Ingress 对外暴露 Pod，让 Kubernetes 集群外部可以直接通过域名访问 Pod。</p></div><blockquote><p><strong>(1) 创建 Deployment，用于部署 Nginx 的 Pod</strong></p></blockquote><ul><li>通过 YAML 文件（比如 <code>nginx-deploy.yaml</code>）创建 Deployment（用于创建和管理 Pod）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 Deployment 对象</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> nginx-deploy.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                            READY   STATUS    RESTARTS   AGE   IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-deploy-85b7dd6b6d-grk6n   1/1     Running   0          65m   10.244.3.47   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>(2) 创建 Service，用于在集群内部暴露 Nginx 的 Pod</strong></p></blockquote><ul><li>通过 YAML 文件（比如 <code>nginx-service.yaml</code>）创建 Service（用于对外暴露服务）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span>       <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span>           <span class="comment"># Service 类型为 ClusterIP，集群内部可访问</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span>          <span class="comment"># 选择标签为 app=nginx-pod 的 Pod 作为后端</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>              <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span>        <span class="comment"># Pod 内容器实际监听的端口（即将请求转发到容器的 xxxx 端口）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 Service 对象</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> nginx-service.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Service</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME            TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes      ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP   84d</span><br><span class="line">nginx-service   ClusterIP   10.0.0.193   &lt;none&gt;        80/TCP    27s</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>(3) 创建 Ingress 的路由规则，用于将外部请求转发给 Service</strong></p></blockquote><ul><li>通过 YAML 文件（比如 <code>ingress-http.yaml</code>）创建 Ingress 的路由规则 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">example.ingress.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx-service</span>         <span class="comment"># Service 的名称</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span>                <span class="comment"># Service 对外暴露的端口</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或更新 YAML 文件中定义的 Ingress 对象</span></span><br><span class="line">kubectl apply<span class="params"> -f</span> ingress-http.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Ingress 路由规则 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ingress</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME              CLASS    HOSTS                 ADDRESS   PORTS   AGE</span><br><span class="line">example-ingress   &lt;none&gt;   example.ingress.com             80      13s</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>(4) 在 K8s 集群外部的操作系统中，添加 Hosts 映射记录</strong></p></blockquote><ul><li>在 K8s 集群外部的操作系统中，编辑系统配置文件 <code>/etc/hosts</code>，添加域名映射记录，其中 <code>192.168.2.236</code> 是 Ingress Controller 所在节点的 IP 地址（<strong>请自行更改 IP 地址</strong>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑系统配置文件，添加以下内容</span></span><br><span class="line">vim /etc/hosts</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.236     example.ingress.com</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>(5) 在 K8s 集群外部的操作系统中，通过域名访问 Ingress，验证 Pod 是否可以访问</strong></p></blockquote><ul><li>在 K8s 集群外部的操作系统中，通过域名访问 Ingress；如果可以成功访问 Nginx 的首页，则说明 Ingress + Service + Pod 都正常运行 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://example.ingress.com</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之七</title>
    <link href="https://www.techgrow.cn/posts/2ca57d7f.html"/>
    <id>https://www.techgrow.cn/posts/2ca57d7f.html</id>
    <published>2025-09-13T13:12:19.000Z</published>
    <updated>2025-09-13T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h3><h4 id="Helm-的引入"><a href="#Helm-的引入" class="headerlink" title="Helm 的引入"></a>Helm 的引入</h4><p>在 Kubernetes 中，应用由特定的资源对象组成，如 Deployment、Service、Ingress 等。通常，这些资源的配置会分别保存在多个独立的 YAML 资源文件中，或集中写入一个 YAML 资源文件中，然后通过 <code>kubectl apply -f</code> 命令进行部署。对于只包含一个或少数几个服务的简单应用，这种方式已经足够。但对于复杂应用（例如微服务架构的系统），往往由十几个甚至数十个服务组成。如果需要更新或回滚应用，就必须修改和维护大量的 YAML 资源文件，这种分散式的管理方式显得十分低效。此外，由于缺乏对应用整体的版本管理与控制，Kubernetes 在应用的维护与更新方面面临以下主要问题：</p><ul><li>(1) YAML 资源文件难以实现高效复用；</li><li>(2) YAML 资源文件不支持应用级别的版本管理与回滚；</li><li>(3) 难以将多个服务作为一个整体进行统一管理。</li></ul><p>为此，Kubernetes 引入了 Helm 来解决上述问题。</p><h4 id="Helm-的概念"><a href="#Helm-的概念" class="headerlink" title="Helm 的概念"></a>Helm 的概念</h4><p>Helm 是 Kubernetes 的包管理工具，类似于 Linux 下的包管理器（如 <code>yum</code> 或 <code>apt</code>），可以方便地将预先打包好的 YAML 资源文件部署到 Kubernetes 集群中。Helm 主要包含以下三个核心概念：</p><ul><li>(1) <code>Helm</code>：命令行客户端工具，用于创建、打包、发布和管理 Kubernetes 应用的 Chart。</li><li>(2) <code>Chart</code>：应用的描述包，由一组用于定义 Kubernetes 资源的 YAML 资源文件组成。</li><li>(3) <code>Release</code>：基于 Chart 的部署实体。每当通过 Helm 部署一个 Chart 时，都会在 Kubernetes 集群中自动生成一个对应的 Release，用于表示实际运行的资源对象。</li></ul><p>值得注意的是，在 Chart 安装后，Helm 会自动创建一个对应的 Release 对象，并根据 Chart 模板文件创建相应的 Kubernetes 资源对象（如 Deployment、Service、Ingress 等），随后由控制器（Controller）自动拉起并运行相应的 Pod。</p><h4 id="Helm-的版本变化"><a href="#Helm-的版本变化" class="headerlink" title="Helm 的版本变化"></a>Helm 的版本变化</h4><p>2019 年 11 月 13 日，Helm 团队发布 Helm <code>v3</code> 的第一个稳定版本。该版本的主要变化如下：</p><ul><li>(1) 最明显的变化是 Tiller 的删除</li><li> (2) Release 名称可以在不同命名空间中重用</li><li> (3) 支持将 Chart 推送至 Docker 镜像仓库中</li><li> (4) 使用 JSONSchema 验证 Chart Values</li><li>(5) 其他变化</li></ul><p>Helm <code>v2</code> 与 <code>v3</code> 版本的整体架构对比如下图所示：</p><p><img data-src="../../../asset/2025/09/k8s-helm-1.png"></p><h4 id="Helm-客户端安装"><a href="#Helm-客户端安装" class="headerlink" title="Helm 客户端安装"></a>Helm 客户端安装</h4><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>Helm 不同版本的客户端可以从 <a href="https://github.com/helm/helm/releases">GitHub Releases</a> 下载得到。</li><li><strong>通常只需要在 Kubernetes 集群的 Master 节点上安装 Helm，其他 Worker 节点不需要安装 Helm。</strong></li></ul></div><blockquote><p>Helm 客户端的安装</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载压缩包</span></span><br><span class="line">wget https://get.helm.sh/helm-v3.2.1-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压压缩包</span></span><br><span class="line">tar<span class="params"> -zxvf</span> helm-v3.2.1-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line">sudo mv linux-amd64/helm /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">helm version</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Helm 客户端配置国内 Chart 仓库（存储库）</p></blockquote><ul><li><p>微软仓库：</p><ul><li>仓库地址：<code>http://mirror.azure.cn/kubernetes/charts</code></li><li>这个 Chart 仓库推荐使用，基本上 Kubernetes 官方仓库有的 Chart 它都有。</li></ul></li><li><p>阿里云仓库：</p><ul><li>仓库地址：<code>https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</code></li><li>这个 Chart 仓库国内可以正常访问。</li></ul></li><li><p>官方仓库：</p><ul><li>仓库地址：<code>https://hub.kubeapps.com/charts/incubator</code></li><li>Kubernetes 官方的 Chart 仓库，国内可能无法正常访问。</li></ul></li></ul><hr><ul><li>添加新的仓库 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加微软仓库</span></span><br><span class="line">helm repo add stable http://mirror.azure.cn/kubernetes/charts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加阿里云仓库</span></span><br><span class="line">helm repo add aliyun https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新本地仓库索引</span></span><br><span class="line">helm repo update</span><br></pre></td></tr></tbody></table></figure><ul><li>查看已有的存储库 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看已添加的仓库列表</span></span><br><span class="line">helm repo list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在本地仓库中搜索名称包含 stable 的 Chart</span></span><br><span class="line">helm search repo stable</span><br></pre></td></tr></tbody></table></figure><ul><li>删除已有的存储库 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除名称为 aliyun 的仓库  </span></span><br><span class="line">helm repo remove aliyun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新本地仓库索引</span></span><br><span class="line">helm repo update</span><br></pre></td></tr></tbody></table></figure><h4 id="Helm-的常用命令"><a href="#Helm-的常用命令" class="headerlink" title="Helm 的常用命令"></a>Helm 的常用命令</h4><blockquote><p>Chart 的三个核心命令</p></blockquote><ul><li><code>chart install</code>：安装一个新的 Chart，并在集群中创建对应的应用实例。</li><li><code>chart upgrade</code>：升级已安装的 Chart 到新版本或更新其配置。</li><li><code>chart rollback</code>：将已部署的 Chart 回滚到指定的历史版本。</li></ul><blockquote><p>Chart 的常用命令列表</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>create</code></td><td>创建一个 Chart 并指定名称</td></tr><tr><td><code>dependency</code></td><td>管理 Chart 依赖</td></tr><tr><td><code>get</code></td><td>下载一个 Release，可用于命令：<code>all</code>、<code>hooks</code>、<code>manifest</code>、<code>notes</code>、<code>values</code></td></tr><tr><td><code>history</code></td><td>获取 Release 历史</td></tr><tr><td><code>install</code></td><td>安装一个 Chart</td></tr><tr><td><code>list</code></td><td>列出 Release</td></tr><tr><td><code>package</code></td><td>将 Chart 目录打包到 Chart 存档文件中</td></tr><tr><td><code>pull</code></td><td>从远程仓库中下载 Chart 并解压到本地</td></tr><tr><td><code>repo</code></td><td>添加、列出、移除、更新和索引 Chart 仓库，可用于命令：<code>add</code>、<code>index</code>、<code>list</code>、<code>remove</code>、<code>update</code></td></tr><tr><td><code>rollback</code></td><td>从之前版本回滚</td></tr><tr><td><code>search</code></td><td>根据关键字搜索 Chart，可用于命令：<code>hub</code>、<code>repo</code></td></tr><tr><td><code>show</code></td><td>查看 Chart 的详细信息，可用于命令：<code>all</code>、<code>chart</code>、<code>readme</code>、<code>values</code></td></tr><tr><td><code>status</code></td><td>显示已命名版本的状态</td></tr><tr><td><code>template</code></td><td>本地呈现模板</td></tr><tr><td><code>uninstall</code></td><td>卸载一个 Release</td></tr><tr><td><code>upgrade</code></td><td>更新一个 Release</td></tr><tr><td><code>version</code></td><td>查看 Helm 客户端的版本</td></tr></tbody></table><h4 id="Helm-的使用案例"><a href="#Helm-的使用案例" class="headerlink" title="Helm 的使用案例"></a>Helm 的使用案例</h4><h5 id="创建管理员用户"><a href="#创建管理员用户" class="headerlink" title="创建管理员用户"></a>创建管理员用户</h5><div class="admonition note"><p class="admonition-title">提示</p><p>本节将演示如何在 Kubernetes 集群中创建管理员用户，否则在后续使用 Helm 时，可能无法正常访问 Kubernetes 资源，比如执行 <code>helm install</code> 命令会出现错误：<code>Error: Kubernetes cluster unreachable</code>。</p></div><ul><li>通过 YAML 文件（比如 <code>admin-user-sa.yaml</code>）创建管理员用户 <code>admin-user</code></li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> admin-user-sa.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>通过 YAML 文件（比如 <code>admin-user-rolebinding.yaml</code>）给管理员用户 <code>admin-user</code> 授权 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> admin-user-rolebinding.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>获取管理员用户 <code>admin-user</code> 的 Token</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECRET_NAME=$(kubectl get sa admin-user<span class="params"> -n</span> kube-system<span class="params"> -o</span> jsonpath=<span class="string">"{.secrets[0].name}"</span>)</span><br><span class="line"></span><br><span class="line">kubectl get secret <span class="variable">$SECRET_NAME</span><span class="params"> -n</span> kube-system<span class="params"> -o</span> jsonpath=<span class="string">"{.data.token}"</span> | base64<span class="params"> --decode</span></span><br></pre></td></tr></tbody></table></figure><ul><li>获取 Kubernetes 集群 CA 证书的 Base64 编码（<strong>请自行更改 CA 证书的路径</strong>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /opt/kubernetes/ssl/ca.pem | base64<span class="params"> -w</span> 0</span><br></pre></td></tr></tbody></table></figure><ul><li>创建一个 kubeconfig 文件（比如 <code>admin-user.kubeconfig</code>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建配置目录（可自定义）</span></span><br><span class="line">mkdir<span class="params"> -p</span> /opt/kubernetes/cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并编辑文件，写入以下 YAML 配置内容</span></span><br><span class="line">vim /opt/kubernetes/cfg/admin-user.kubeconfig</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://&lt;IP&gt;:6443</span>                       <span class="comment">#  填写 API Server 的 IP 地址和端口</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> <span class="string">&lt;CA_CERT_BASE64&gt;</span>    <span class="comment">#  填写 K8s 集群 CA 证书的 Base64 编码</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">kubernetes</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-context</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">admin-context</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">token:</span> <span class="string">&lt;TOKEN&gt;</span>      <span class="comment"># 填写管理员用户的 Token</span></span><br></pre></td></tr></tbody></table></figure><ul><li>验证 kubeconfig 文件（比如 <code>admin-user.kubeconfig</code>）是否可以正常使用 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc<span class="params"> --kubeconfig</span>=/opt/kubernetes/cfg/admin-user.kubeconfig</span><br></pre></td></tr></tbody></table></figure><ul><li>添加系统环境变量 <code>KUBECONFIG</code>（可选步骤）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加系统环境变量</span></span><br><span class="line"><span class="built_in">export</span> KUBECONFIG=/opt/kubernetes/cfg/admin-user.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后就可以直接访问 K8s 资源了，不再需要通过 "--kubeconfig" 参数指定 kubeconfig 文件</span></span><br><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><h5 id="通过-Chart-部署应用"><a href="#通过-Chart-部署应用" class="headerlink" title="通过 Chart 部署应用"></a>通过 Chart 部署应用</h5><div class="admonition note"><p class="admonition-title">提示</p><ul><li>本节将演示如何使用 Chart 快速部署应用（比如 Weave，这是 Kubernetes 集群可视化与监控工具）。</li></ul></div><div class="admonition warning"><p class="admonition-title">注意</p><ul><li>如果 <code>helm</code> 命令执行失败，并提示错误信息 <code>Error: Kubernetes cluster unreachable</code>，可以参考以下任意一种方案来解决：</li><li>(1) 尝试往 <code>helm</code> 命令的末尾添加参数 <code>--kubeconfig=/opt/kubernetes/cfg/admin-user.kubeconfig</code>。</li><li>(2) 通过 <code>export KUBECONFIG=/opt/kubernetes/cfg/admin-user.kubeconfig</code> 命令添加对应的环境变量。</li></ul></div><ul><li>搜索指定的 Chart</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm search repo weave</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAME              CHART VERSIONAPP VERSIONDESCRIPTION                                       </span><br><span class="line">aliyun/weave-cloud0.1.2                   Weave Cloud is a add-on to Kubernetes which pro...</span><br><span class="line">aliyun/weave-scope0.9.2        1.6.5      A Helm chart for the Weave Scope cluster visual...</span><br><span class="line">stable/weave-cloud0.3.9        1.4.0      DEPRECATED - Weave Cloud is a add-on to Kuberne...</span><br><span class="line">stable/weave-scope1.1.12       1.12.0     DEPRECATED - A Helm chart for the Weave Scope c...</span><br></pre></td></tr></tbody></table></figure><ul><li>查看指定 Chart 的详细信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm show chart stable/weave-scope</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">appVersion: 1.12.0</span><br><span class="line">deprecated: true</span><br><span class="line">description: DEPRECATED - A Helm chart for the Weave Scope cluster visualizer.</span><br><span class="line">home: https://www.weave.works/oss/scope/</span><br><span class="line">icon: https://avatars1.githubusercontent.com/u/9976052?s=64</span><br><span class="line">keywords:</span><br><span class="line">- containers</span><br><span class="line">- dashboard</span><br><span class="line">- monitoring</span><br><span class="line">name: weave-scope</span><br><span class="line">sources:</span><br><span class="line">- https://github.com/weaveworks/scope</span><br><span class="line">version: 1.1.12</span><br></pre></td></tr></tbody></table></figure><ul><li>安装指定的 Chart</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install ui stable/weave-scope</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NAME: ui</span><br><span class="line">LAST DEPLOYED: Tue Oct 28 20:17:33 2025</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">NOTES:</span><br><span class="line">You should now be able to access the Scope frontend in your web browser, by</span><br><span class="line">using kubectl port-forward:</span><br><span class="line"></span><br><span class="line">kubectl -n default port-forward $(kubectl -n default get endpoints \</span><br><span class="line">ui-weave-scope -o jsonpath='{.subsets[0].addresses[0].targetRef.name}') 8080:4040</span><br><span class="line"></span><br><span class="line">then browsing to http://localhost:8080/.</span><br><span class="line">For more details on using Weave Scope, see the Weave Scope documentation:</span><br><span class="line"></span><br><span class="line">https://www.weave.works/docs/scope/latest/introducing/</span><br></pre></td></tr></tbody></table></figure><ul><li>查看发布（Release）的列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm list</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAMENAMESPACEREVISIONUPDATED                                STATUS  CHART             APP VERSION</span><br><span class="line">ui  default  1       2025-10-28 20:17:33.899483553 +0800 CSTdeployedweave-scope-1.1.121.12.0  </span><br></pre></td></tr></tbody></table></figure><ul><li>查看指定发布（Release）的详细信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm status ui</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NAME: ui</span><br><span class="line">LAST DEPLOYED: Tue Oct 28 20:17:33 2025</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">NOTES:</span><br><span class="line">You should now be able to access the Scope frontend in your web browser, by</span><br><span class="line">using kubectl port-forward:</span><br><span class="line"></span><br><span class="line">kubectl -n default port-forward $(kubectl -n default get endpoints \</span><br><span class="line">ui-weave-scope -o jsonpath='{.subsets[0].addresses[0].targetRef.name}') 8080:4040</span><br><span class="line"></span><br><span class="line">then browsing to http://localhost:8080/.</span><br><span class="line">For more details on using Weave Scope, see the Weave Scope documentation:</span><br><span class="line"></span><br><span class="line">https://www.weave.works/docs/scope/latest/introducing/</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NAME                                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">weave-scope-agent-ui-lw2lf                      1/1     Running   0          35s</span><br><span class="line">weave-scope-agent-ui-nn4vs                      1/1     Running   0          35s</span><br><span class="line">weave-scope-agent-ui-pzqgk                      1/1     Running   0          35s</span><br><span class="line">weave-scope-agent-ui-qbcvm                      1/1     Running   0          35s</span><br><span class="line">weave-scope-cluster-agent-ui-5cbc84db49-4wvvt   1/1     Running   0          35s</span><br><span class="line">weave-scope-frontend-ui-6698fd5545-4lpl9        1/1     Running   0          35s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Service</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME             TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes       ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP   86d</span><br><span class="line">ui-weave-scope   ClusterIP   10.0.0.64    &lt;none&gt;        80/TCP    78s</span><br></pre></td></tr></tbody></table></figure><ul><li>若希望在 Kubernetes 集群外部访问 Weave，可以更改 Service 的类型 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑 Service 的配置，更改 type 参数，保存退出后自动生效</span></span><br><span class="line">kubectl edit svc ui-weave-scope</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  clusterIP: 10.0.0.64</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: http</span><br><span class="line">  selector:</span><br><span class="line">    app: weave-scope</span><br><span class="line">    component: frontend</span><br><span class="line">    release: ui</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  <span class="built_in">type</span>: NodePort      <span class="comment"># 将 Service 的类型更改为 NodePort</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有 Service，获取节点暴露的端口</span></span><br><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME             TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes       ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP        86d</span><br><span class="line">ui-weave-scope   NodePort    10.0.0.64    &lt;none&gt;        80:31764/TCP   6m4s</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后通过任意一个集群节点的 IP 与 Service 对外暴露的端口（比如 `http://192.168.2.191:31764`），就可以在 Kubernetes 集群外部通过浏览器访问 Weave 的 Web 控制台页面</span><br></pre></td></tr></tbody></table></figure><ul><li>若希望卸载前面所安装的 Chart，可以执行以下命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接删除 Chart，默认不会删除关联的 PVC（数据卷）</span></span><br><span class="line">helm uninstall ui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要删除 Chart 关联的 PVC（数据卷），可以执行以下命令</span></span><br><span class="line">kubectl delete pvc<span class="params"> -l</span> release=ui</span><br></pre></td></tr></tbody></table></figure><h5 id="自定义-Chart-配置信息"><a href="#自定义-Chart-配置信息" class="headerlink" title="自定义 Chart 配置信息"></a>自定义 Chart 配置信息</h5><div class="admonition note"><p class="admonition-title">提示</p><p>本节将演示如何在安装 Chart 之前，自定义 Chart 的配置信息，目的是覆盖 Chart 的默认配置信息。</p></div><div class="admonition warning"><p class="admonition-title">注意</p><ul><li>如果 <code>helm</code> 命令执行失败，并提示错误信息 <code>Error: Kubernetes cluster unreachable</code>，可以参考以下任意一种方案来解决：</li><li>(1) 尝试往 <code>helm</code> 命令的末尾添加参数 <code>--kubeconfig=/opt/kubernetes/cfg/admin-user.kubeconfig</code>。</li><li>(2) 通过 <code>export KUBECONFIG=/opt/kubernetes/cfg/admin-user.kubeconfig</code> 命令添加对应的环境变量。</li></ul></div><p>自定义 Chart 配置信息的原因在于，Chart 仓库中并非所有 Chart 都能在默认配置下成功运行，有时需要根据环境提供额外依赖，例如 <code>PVC</code>（数据卷）。因此，需要在安装 Chart 前自定义配置信息，主要有以下两种配置信息传递方式：</p><ul><li><p><code>--values</code> 或 <code>-f</code></p><ul><li>指定一个包含覆盖配置信息的 YAML 文件。</li><li>可以指定多个 YAML 文件，右边的 YAML 文件优先级更高。</li></ul></li><li><p><code>--set</code></p><ul><li>直接在命令行中指定覆盖配置信息。</li><li>当同时使用 <code>--values</code> 与 <code>--set</code> 时，<code>--set</code> 的优先级更高。</li><li>YAML 与 <code>--set</code> 配置格式的对比请看 <a href="../../../asset/2025/09/k8s-helm-2.png">这里</a>。</li></ul></li></ul><hr><ul><li>查看指定 Chart 的默认配置信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm show values stable/mysql</span><br></pre></td></tr></tbody></table></figure><ul><li>创建 YAML 配置文件，用于覆盖 Chart 的默认配置信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim mysql-server-config.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">persistence:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span>                          <span class="comment"># 关闭持久化存储</span></span><br><span class="line"><span class="attr">mysqlUser:</span> <span class="string">"k8s"</span>                          <span class="comment"># 自定义 MySQL 用户名</span></span><br><span class="line"><span class="attr">mysqlPassword:</span> <span class="string">"123456"</span>                   <span class="comment"># 自定义 MySQL 密码</span></span><br><span class="line"><span class="attr">mysqlDatabase:</span> <span class="string">"k8s"</span>                      <span class="comment"># 自定义创建的数据库名称</span></span><br></pre></td></tr></tbody></table></figure><ul><li>安装指定的 Chart，并覆盖默认配置 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install mysql-server<span class="params"> -f</span> mysql-server-config.yaml stable/mysql</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">mysql-server-9c7558dc8-rb89z   0/1     Running   0          15s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Service</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME           TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">kubernetes     ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP    86d</span><br><span class="line">mysql-server   ClusterIP   10.0.0.4     &lt;none&gt;        3306/TCP   88s</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 Chart 的安装 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个临时容器并连接进去，--rm 参数表示退出后会自动销毁容器</span></span><br><span class="line">kubectl run<span class="params"> -it</span> mysql-client<span class="params"> --rm</span><span class="params"> --restart</span>=Never<span class="params"> --image</span>=mysql:5.7 -- bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在临时容器的内部登录 MySQL（可以通过 Service 的名称直接访问 MySQL Server，前提是在同一个命名空间，且安装了 CoreDNS）</span></span><br><span class="line">mysql<span class="params"> -hmysql</span>-server<span class="params"> -uk8s</span><span class="params"> -p123456</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Helm-构建自定义的-Chart"><a href="#Helm-构建自定义的-Chart" class="headerlink" title="Helm 构建自定义的 Chart"></a>Helm 构建自定义的 Chart</h4><div class="admonition note"><p class="admonition-title">提示</p><p>本节将演示如何构建一个自己的 Chart（比如，用于部署 Nginx 的 Chart），并将其安装和打包。</p></div><h5 id="三大核心构建步骤"><a href="#三大核心构建步骤" class="headerlink" title="三大核心构建步骤"></a>三大核心构建步骤</h5><p>Kubernetes 支持用户构建（开发）自己的 Chart，核心的构建步骤如下：</p><ul><li><p>(1) 创建 Chart 基础模板</p><ul><li>使用 <code>helm create &lt;chart-name&gt;</code> 命令创建基础模板。</li></ul></li><li><p>(2) 更改 Chart 配置文件</p><ul><li>编辑 <code>Chart.yaml</code> 文件，填写应用名称、版本、描述等信息。</li><li>编辑 <code>values.yaml</code> 文件，添加常用变量和默认值，用于自定义配置。</li></ul></li><li><p>(3) 创建 Chart 模板文件</p><ul><li>在自动生成的 <code>templates</code> 目录下，创建或编辑部署应用所需的 YAML 文件（如 Deployment、Service、Ingress 等）。</li><li>在 YAML 文件中，可以使用变量引用经常变化的字段，支持从 <code>values.yaml</code> 文件中获取动态值，比如 <code>replicas: {{ .Values.replicas }}</code>。</li></ul></li></ul><h5 id="Chart-的构建安装"><a href="#Chart-的构建安装" class="headerlink" title="Chart 的构建安装"></a>Chart 的构建安装</h5><blockquote><p>(1) 构建自定义的 Chart</p></blockquote><ul><li>创建一个 Chart，自动生成 Chart 的模板文件（YAML 配置文件）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm create nginx</span><br></pre></td></tr></tbody></table></figure><ul><li>查看自动生成的目录结构 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree nginx/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nginx/</span><br><span class="line">├── charts</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── templates</span><br><span class="line">│&nbsp;&nbsp; ├── deployment.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── _helpers.tpl</span><br><span class="line">│&nbsp;&nbsp; ├── hpa.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── ingress.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── NOTES.txt</span><br><span class="line">│&nbsp;&nbsp; ├── serviceaccount.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── service.yaml</span><br><span class="line">│&nbsp;&nbsp; └── tests</span><br><span class="line">│&nbsp;&nbsp;     └── test-connection.yaml</span><br><span class="line">└── values.yaml</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>文件 / 目录名</th><th>类型</th><th>描述</th><th>主要作用</th></tr></thead><tbody><tr><td><code>charts/</code></td><td>目录</td><td>存放 Chart 依赖的所有子 Chart</td><td> 管理当前 Chart 所依赖的其他 Chart，支持复杂的应用依赖关系</td></tr><tr><td><code>Chart.yaml</code></td><td>文件</td><td>描述 Chart 的基本信息</td><td>定义 Chart 的名称、描述、版本、依赖关系等元数据</td></tr><tr><td><code>values.yaml</code></td><td>文件</td><td>存储模板文件中使用的变量值</td><td>提供用户可配置的参数默认值，支持部署时的自定义配置</td></tr><tr><td><code>templates/</code></td><td>目录</td><td>存放所有 YAML 模板文件</td><td>包含 Kubernetes 资源清单模板，如 Deployment、Service、ConfigMap 等</td></tr><tr><td><code>NOTES.txt</code></td><td>文件</td><td>介绍 Chart 的帮助信息</td><td>在 <code>helm install</code> 部署后展示给用户，包含使用指南和默认设置说明</td></tr><tr><td><code>_helpers.tpl</code></td><td>文件</td><td>放置模板助手的地方</td><td>定义可以在整个 Chart 中重复使用的模板片段或函数，提高模板代码的复用性和可维护性</td></tr></tbody></table><ul><li>删除自动生成的 Chart 模板文件（可选步骤）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm<span class="params"> -rf</span> nginx/templates/*</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 Chart 的 <code>Chart.yaml</code> 文件，定义 Chart 的名称、描述、版本等信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/Chart.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v2</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">custom</span> <span class="string">Helm</span> <span class="string">chart</span> <span class="string">for</span> <span class="string">nginx</span> <span class="string">application</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">application</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="number">1.15</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑 Chart 的模板文件 <code>deployment.yaml</code>，定义要创建的 Deployment</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deploy</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-pod</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: nginx</span><br><span class="line">          image: nginx:1.15</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑 Chart 的模板文件 <code>service.yaml</code>，定义要创建的 Service</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/templates/service.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-pod</span><br><span class="line">  name: nginx-svc</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-pod</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br></pre></td></tr></tbody></table></figure><blockquote><p>(2) 安装自定义的 Chart</p></blockquote><ul><li>安装自定义的 Chart</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm install web nginx/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME: web</span><br><span class="line">LAST DEPLOYED: Wed Oct 13 21:10:20 2025</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br></pre></td></tr></tbody></table></figure><ul><li>还可以将自定义的 Chart 打包成 <code>.tgz</code> 压缩包，共享给别人使用 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm package nginx/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx-1.0.0.tgz</span><br></pre></td></tr></tbody></table></figure><ul><li>查看实际的 Chart 模板被渲染过后的 YAML 资源文件 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm get manifest web</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Source: nginx/templates/service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Source: nginx/templates/deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>(3) 验证自定义的 Chart</p></blockquote><ul><li>查看发布（Release）的列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm list</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAMENAMESPACEREVISIONUPDATED                                STATUS  CHART      APP VERSION</span><br><span class="line">web default  1       2025-10-13 21:10:20.593922287 +0800 CSTdeployednginx-1.0.01.15      </span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deploy-85b7dd6b6d-2dswj   1/1     Running   0          104s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Service</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP        86d</span><br><span class="line">nginx-svc    NodePort    10.0.0.150   &lt;none&gt;        80:32377/TCP   2m20s</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后通过任意一个集群节点的 IP 与 Service 对外暴露的端口（比如 `http://192.168.2.191:32377`），就可以在 Kubernetes 集群外部通过浏览器访问 Nginx 的首页面</span><br></pre></td></tr></tbody></table></figure><h5 id="Chart-的版本升级"><a href="#Chart-的版本升级" class="headerlink" title="Chart 的版本升级"></a>Chart 的版本升级</h5><ul><li>在 Chart 安装（发布）后，如果 Chart 的模板文件发生了变更，可以执行以下命令对已部署的应用进行升级 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里 web 是 Release 的名称</span></span><br><span class="line">helm upgrade web nginx/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Release "web" has been upgraded. Happy Helming!</span><br><span class="line">NAME: web</span><br><span class="line">LAST DEPLOYED: Wed Oct 13 21:37:23 2025</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 2</span><br><span class="line">TEST SUITE: None</span><br></pre></td></tr></tbody></table></figure><ul><li>或者使用 <code>-</code> 参数进行升级（指定包含覆盖配置信息的 YAML 文件）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里 web 是 Release 的名称</span></span><br><span class="line">helm upgrade<span class="params"> -f</span> values.yaml web nginx/</span><br></pre></td></tr></tbody></table></figure><ul><li>或者使用 <code>--set</code> 参数进行升级（直接传入参数值）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里 web 是 Release 的名称</span></span><br><span class="line">helm upgrade<span class="params"> --set</span> imageTag=1.17 web nginx/</span><br></pre></td></tr></tbody></table></figure><h5 id="Chart-的版本回滚"><a href="#Chart-的版本回滚" class="headerlink" title="Chart 的版本回滚"></a>Chart 的版本回滚</h5><div class="admonition note"><p class="admonition-title">提示</p><p>在 Chart 安装（发布）后，如果没有达到预期的效果，则可以使用 <code>helm rollback</code> 将 Release 回滚到之前的版本。</p></div><ul><li>查看 Release 的列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm list</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAMENAMESPACEREVISIONUPDATED                                STATUS  CHART      APP VERSION</span><br><span class="line">web default  1       2025-10-13 21:10:20.593922287 +0800 CSTdeployednginx-1.0.01.15      </span><br></pre></td></tr></tbody></table></figure><ul><li>查看指定 Release 的历史版本 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm <span class="built_in">history</span> web</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVISIONUPDATED                 STATUS    CHART      APP VERSIONDESCRIPTION     </span><br><span class="line">1       Wed Oct 13 21:10:20 2025supersedednginx-1.0.01.15       Install complete</span><br><span class="line">2       Wed Oct 13 21:23:26 2025deployed  nginx-1.0.01.15       Upgrade complete</span><br></pre></td></tr></tbody></table></figure><ul><li>将 Release 回滚到指定的历史版本 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称，1 是要 Release 回滚到的历史版本号</span></span><br><span class="line">helm rollback web 1</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Release 的版本是否成功回滚 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm status web</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME: web</span><br><span class="line">LAST DEPLOYED: Wed Oct 13 21:31:56 2025</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 3</span><br><span class="line">TEST SUITE: None</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">推送 Chart 到仓库</p><p>对于自定义的 Chart，除了可以打包成 <code>.tgz</code> 压缩包，还可以将其推送到 Chart 仓库（如 Harbor、ChartMuseum 等），详细的推送步骤可以参考网上的资料，这里不再累述。</p></div><h4 id="Helm-中-Chart-模板的使用"><a href="#Helm-中-Chart-模板的使用" class="headerlink" title="Helm 中 Chart 模板的使用"></a>Helm 中 Chart 模板的使用</h4><h5 id="Chart-模板的简单介绍"><a href="#Chart-模板的简单介绍" class="headerlink" title="Chart 模板的简单介绍"></a>Chart 模板的简单介绍</h5><p>Helm 的核心在于模板化的 Kubernetes Manifests 文件，这些模板本质上是基于 Go Template 的模板文件。在原生 Go 模板语法的基础上，Helm 还扩展了许多功能，例如：</p><ul><li>自定义的元数据定义（如 <code>Chart.yaml</code>）</li><li>内置函数库和模板函数</li><li>类似编程语言的控制语句（如条件判断、循环、管道等）</li></ul><p>这些扩展使模板具备了强大的灵活性和复用性。为了将用户的具体配置与模板结合，Helm 使用 <code>values.yaml</code> 文件来提供参数化的配置数据。</p><div class="admonition note"><p class="admonition-title">提示</p><p>模板文件与 <code>values</code> 文件的结合，这就是 Helm Chart 的核心机制 —— 通过模板化 + 参数化的方式，实现 Kubernetes 应用的灵活部署与管理。</p></div><h5 id="Chart-模板的使用案例"><a href="#Chart-模板的使用案例" class="headerlink" title="Chart 模板的使用案例"></a>Chart 模板的使用案例</h5><blockquote><p>(1) 构建自定义的 Chart</p></blockquote><ul><li>创建一个 Chart，自动生成 Chart 的模板文件（YAML 配置文件）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm create nginx</span><br></pre></td></tr></tbody></table></figure><ul><li>查看自动生成的目录结构 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree nginx/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nginx/</span><br><span class="line">├── charts</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── templates</span><br><span class="line">│&nbsp;&nbsp; ├── deployment.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── _helpers.tpl</span><br><span class="line">│&nbsp;&nbsp; ├── hpa.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── ingress.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── NOTES.txt</span><br><span class="line">│&nbsp;&nbsp; ├── serviceaccount.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── service.yaml</span><br><span class="line">│&nbsp;&nbsp; └── tests</span><br><span class="line">│&nbsp;&nbsp;     └── test-connection.yaml</span><br><span class="line">└── values.yaml</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>文件 / 目录名</th><th>类型</th><th>描述</th><th>主要作用</th></tr></thead><tbody><tr><td><code>charts/</code></td><td>目录</td><td>存放 Chart 依赖的所有子 Chart</td><td> 管理当前 Chart 所依赖的其他 Chart，支持复杂的应用依赖关系</td></tr><tr><td><code>Chart.yaml</code></td><td>文件</td><td>描述 Chart 的基本信息</td><td>定义 Chart 的名称、描述、版本、依赖关系等元数据</td></tr><tr><td><code>values.yaml</code></td><td>文件</td><td>存储模板文件中使用的变量值</td><td>提供用户可配置的参数默认值，支持部署时的自定义配置</td></tr><tr><td><code>templates/</code></td><td>目录</td><td>存放所有 YAML 模板文件</td><td>包含 Kubernetes 资源清单模板，如 Deployment、Service、ConfigMap 等</td></tr><tr><td><code>NOTES.txt</code></td><td>文件</td><td>介绍 Chart 的帮助信息</td><td>在 <code>helm install</code> 部署后展示给用户，包含使用指南和默认设置说明</td></tr><tr><td><code>_helpers.tpl</code></td><td>文件</td><td>放置模板助手的地方</td><td>定义可以在整个 Chart 中重复使用的模板片段或函数，提高模板代码的复用性和可维护性</td></tr></tbody></table><ul><li>删除自动生成的 Chart 模板文件（可选步骤）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm<span class="params"> -rf</span> nginx/templates/*</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 Chart 的 <code>Chart.yaml</code> 文件，定义 Chart 的名称、描述、版本等信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/Chart.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v2</span><br><span class="line">name: nginx</span><br><span class="line">description: A Helm chart for Nginx</span><br><span class="line">type: application</span><br><span class="line">version: 0.1.0</span><br><span class="line">appVersion: 1.15</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 Chart 的 <code>values.yaml</code> 文件，定义全局的变量值 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/values.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image: nginx</span><br><span class="line">tag: 1.15</span><br><span class="line">replicas: 3</span><br><span class="line">serviceport: 80</span><br><span class="line">targetport: 80</span><br><span class="line">containerPort: 80</span><br><span class="line">label: nginx-app</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑 Chart 的模板文件 <code>NOTES.txt</code>，定义 Chart 的帮助信息（使用指南）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/templates/NOTES.txt</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get service expose port: `kubectl get svc`</span><br><span class="line">Access nginx by: `http://&lt;node_ip&gt;:&lt;service_port&gt;`</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑 Chart 的模板文件 <code>deployment.yaml</code>，定义要创建的 Deployment</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">.Release.Name</span> }}</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> {{ <span class="string">.Values.label</span> }}</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> {{ <span class="string">.Values.replicas</span> }}</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> {{ <span class="string">.Values.label</span> }}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> {{ <span class="string">.Values.label</span> }}</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> {{ <span class="string">.Values.image</span> }}<span class="string">:{{</span> <span class="string">.Values.tag</span> <span class="string">}}</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> {{ <span class="string">.Values.containerPort</span> }}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑 Chart 的模板文件 <code>service.yaml</code>，定义要创建的 Service</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/templates/service.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">.Release.Name</span> }}</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> {{ <span class="string">.Values.label</span> }}</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> {{ <span class="string">.Values.label</span> }}</span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> {{ <span class="string">.Values.serviceport</span> }}</span><br><span class="line">      <span class="attr">targetPort:</span> {{ <span class="string">.Values.targetport</span> }}</span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>(2) 安装自定义的 Chart</p></blockquote><ul><li>安装自定义的 Chart</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm install web nginx/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NAME: web</span><br><span class="line">LAST DEPLOYED: Wed Oct 13 17:39:32 2025</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Get service expose port: `kubectl get svc`</span><br><span class="line">Access nginx by: `http://&lt;node_ip&gt;:&lt;service_port&gt;`</span><br></pre></td></tr></tbody></table></figure><ul><li>查看实际的 Chart 模板被渲染过后的 YAML 资源文件 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm get manifest web</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Source: nginx/templates/service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Source: nginx/templates/deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>(3) 验证自定义的 Chart</p></blockquote><ul><li>查看发布（Release）的列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm list</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAMENAMESPACEREVISIONUPDATED                                STATUS  CHART      APP VERSION</span><br><span class="line">web default  1       2025-10-29 17:39:32.267654796 +0800 CSTdeployednginx-0.1.01.15  </span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">web-766795cc8b-6knwm   1/1     Running   0          100s</span><br><span class="line">web-766795cc8b-7nlr4   1/1     Running   0          100s</span><br><span class="line">web-766795cc8b-q4h8q   1/1     Running   0          100s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Service</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP        86d</span><br><span class="line">web          NodePort    10.0.0.197   &lt;none&gt;        80:30654/TCP   2m13s</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后通过任意一个集群节点的 IP 与 Service 对外暴露的端口（比如 `http://192.168.2.191:30654`），就可以在 Kubernetes 集群外部通过浏览器访问 Nginx 的首页面</span><br></pre></td></tr></tbody></table></figure><h5 id="Chart-模板的调试技巧"><a href="#Chart-模板的调试技巧" class="headerlink" title="Chart 模板的调试技巧"></a>Chart 模板的调试技巧</h5><ul><li>Helm 提供了 <code>--dry-run</code> 和 <code>--debug</code> 调试参数，可用于在执行 <code>helm install</code> 命令之前，验证 Chart 模板文件的正确性。</li><li>当 <code>helm install</code> 命令加上这两个参数后，Helm 会将模板文件与对应的 <code>values.yaml</code> 文件进行渲染，并打印出生成的 YAML 资源清单，而不会实际部署任何 Release。</li><li>比如，调试 <a href="/posts/2ca57d7f.html#Chart-%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B">上面案例</a> 中自定义的 Chart 包，可以使用以下命令：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm install web<span class="params"> --dry</span>-run nginx/</span><br></pre></td></tr></tbody></table></figure><h5 id="Chart-模板的内置对象"><a href="#Chart-模板的内置对象" class="headerlink" title="Chart 模板的内置对象"></a>Chart 模板的内置对象</h5><p>上面使用 <code>{{.Release.Name}}</code> 将 Release 的名称插入到 Chart 模板中。这里的 <code>Release</code> 就是 Helm 的内置对象，下面是一些常用的内置对象：</p><table><thead><tr><th>Helm 内置对象</th><th>描述</th></tr></thead><tbody><tr><td><code>Release.Name</code></td><td>Release 名称</td></tr><tr><td><code>Release.Namespace</code></td><td>Release 命名空间</td></tr><tr><td><code>Release.Service</code></td><td>Release 服务的名称</td></tr><tr><td><code>Release.Revision</code></td><td>Release 修订版本号，从 1 开始累加</td></tr></tbody></table><h5 id="Chart-模板的-Values-对象"><a href="#Chart-模板的-Values-对象" class="headerlink" title="Chart 模板的 Values 对象"></a>Chart 模板的 Values 对象</h5><p>Values 对象用于为 Chart 模板文件提供参数值，其来源主要有以下四个：</p><ul><li>(1) Chart 包中的 <code>values.yaml</code> 文件</li><li> (2) 父 Chart 包中的 <code>values.yaml</code> 文件</li><li> (3) 通过 <code>helm install</code> 或 <code>helm upgrade</code> 命令使用 <code>-f</code> 或 <code>--values</code> 参数传入的自定义 YAML 配置文件</li><li> (4) 通过 <code>helm install</code> 或 <code>helm upgrade</code> 命令使用 <code>--set</code> 参数直接传入的值</li></ul><div class="admonition warning"><p class="admonition-title">参数值不同来源的优先级关系</p><p>Chart 参数值的优先级遵循一定的覆盖顺序（优先级）：<code>Chart 包中的 values.yaml 文件</code> &lt; <code>用户通过 -f 参数自定义的 YAML 配置文件</code> &lt; <code>用户通过 --set 参数传入的值</code>。</p></div><ul><li>举个例子，通过 <code>--set</code> 参数更新 Chart（比如，Pod 的副本数量）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm upgrade web<span class="params"> --set</span> replicas=5 nginx/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Release "web" has been upgraded. Happy Helming!</span><br><span class="line">NAME: web</span><br><span class="line">LAST DEPLOYED: Wed Oct 13 18:04:34 2025</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 2</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Get service expose port: `kubectl get svc`</span><br><span class="line">Access nginx by: `http://&lt;node_ip&gt;:&lt;service_port&gt;`</span><br></pre></td></tr></tbody></table></figure><ul><li>查看指定 Release 的历史版本 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm <span class="built_in">history</span> web</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVISIONUPDATED                 STATUS    CHART      APP VERSIONDESCRIPTION     </span><br><span class="line">1       Wed Oct 13 17:39:32 2025supersedednginx-0.1.01.15       Install complete</span><br><span class="line">2       Wed Oct 13 18:04:34 2025deployed  nginx-0.1.01.15       Upgrade complete</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">web-766795cc8b-6knwm   1/1     Running   0          28m</span><br><span class="line">web-766795cc8b-7nlr4   1/1     Running   0          28m</span><br><span class="line">web-766795cc8b-lpr27   1/1     Running   0          3m57s</span><br><span class="line">web-766795cc8b-q4h8q   1/1     Running   0          28m</span><br><span class="line">web-766795cc8b-vpdh4   1/1     Running   0          3m57s</span><br></pre></td></tr></tbody></table></figure><h5 id="Chart-模板的函数与管道"><a href="#Chart-模板的函数与管道" class="headerlink" title="Chart 模板的函数与管道"></a>Chart 模板的函数与管道</h5><blockquote><p>模板函数与管道的简单介绍</p></blockquote><p>前面讲的内容，其实就是将参数值传给 Go 模板引擎进行渲染，模板引擎还支持通过模板函数和管道对拿到数据（参数值）进行二次处理。Helm 支持的模板函数和管道如下所示：</p><ul><li><p>默认值处理</p><ul><li><code>default</code><ul><li>为不存在或空的值提供默认值</li><li>调用语法：<code>{{ .Values.name | default "nginx" }}</code></li></ul></li></ul></li><li><p>大小写转换</p><ul><li><code>upper</code><ul><li>将字符串转换为大写</li><li>调用语法：<code>{{ upper .Values.resources }}</code></li></ul></li><li><code>lower</code><ul><li>将字符串转换为小写</li><li>调用语法：<code>{{ lower .Values.resources }}</code></li></ul></li><li><code>title</code><ul><li>将首字母大写</li><li>调用语法：<code>{{ title .Values.resources }}</code></li></ul></li></ul></li><li><p>布尔、数字、长度</p><ul><li><code>bool</code><ul><li>将值转换为布尔</li><li>调用语法：<code>{{ bool .Values.featureFlag }}</code></li></ul></li><li><code>int</code><ul><li>将值转换为整数</li><li>调用语法：<code>{{ int .Values.replicaCount }}</code></li></ul></li><li><code>float</code><ul><li>将值转换为浮点数</li><li>调用语法：<code>{{ float .Values.cpus }}</code></li></ul></li><li><code>len</code><ul><li>获取列表（数组）、字典或字符串的长度</li><li>调用语法：<code>{{ len .Values.env }}</code></li></ul></li></ul></li><li><p>字符串转换、拼接与替换</p><ul><li><code>quote</code><ul><li>将参数值转换为带双引号的字符串</li><li>调用语法：<code>{{ quote .Values.label }}</code></li></ul></li><li><code>cat</code><ul><li>拼接多个字符串</li><li>调用语法：<code>{{ cat .Release.Name "-" .Chart.Name }}</code></li></ul></li><li><code>replace</code><ul><li>替换字符串</li><li>调用语法：<code>{{ .Values.name | replace "_" "-" }}</code></li></ul></li><li><code>trim</code><ul><li>去除字符串首尾空格</li><li>调用语法：<code>{{ .Values.name | trim " " }}</code></li></ul></li><li><code>trimAll</code><ul><li>去除指定字符</li><li>调用语法：<code>{{ .Values.name | trimAll "-" }}</code></li></ul></li></ul></li><li><p>加空格与缩进</p><ul><li><code>indent</code><ul><li>每行前加指定空格数</li><li>调用语法：<code>{{ .Values.resources | indent 10 }}</code></li></ul></li><li><code>nindent</code><ul><li>每行缩进并加换行</li><li>调用语法：<code>{{ .Values.resources | nindent 10 }}</code></li></ul></li></ul></li><li><p>对象转换</p><ul><li><code>toYaml</code><ul><li>将对象转换为 YAML</li><li> 调用语法：<code>{{ .Values.resources | toYaml }}</code></li></ul></li><li><code>toJson</code><ul><li>将对象转换为 JSON</li><li> 调用语法：<code>{{ .Values.config | toJson | quote }}</code></li></ul></li></ul></li><li><p>条件 / 验证</p><ul><li><code>hasKey</code><ul><li>判断字典中是否存在某个键</li><li>调用语法：<code>{{- if hasKey .Values.env "JAVA_HOME" }}</code></li></ul></li><li><code>required</code><ul><li>必填参数验证，参数不存在时报错</li><li>调用语法：<code>{{ required "image.repository is required" .Values.image.repository }}</code></li></ul></li></ul></li></ul><blockquote><p>模板函数 quote 的使用案例</p></blockquote><ul><li>在 <a href="/posts/2ca57d7f.html#Chart-%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B">上面案例</a> 的基础上，通过模板函数 <code>quote</code> 将从 <code>.Values</code> 中读取到的参数值转换成字符串 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">.Release.Name</span> }}</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> {{ <span class="string">quote</span> <span class="string">.Values.label</span> }}</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> {{ <span class="string">.Values.replicas</span> }}</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> {{ <span class="string">quote</span> <span class="string">.Values.label</span> }}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> {{ <span class="string">quote</span> <span class="string">.Values.label</span> }}</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> {{ <span class="string">.Values.image</span> }}<span class="string">:{{</span> <span class="string">.Values.tag</span> <span class="string">}}</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> {{ <span class="string">.Values.containerPort</span> }}</span><br></pre></td></tr></tbody></table></figure><ul><li>将模板文件与对应的 <code>values.yaml</code> 文件进行渲染，并打印出生成的 YAML 资源清单，不会实际部署任何 Release</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm install web<span class="params"> --dry</span>-run nginx/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...(省略)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">"nginx-app"</span>    <span class="comment"># 参数值已经被 quote 模板函数转换为字符串</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">"nginx-app"</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">"nginx-app"</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Chart-模板的流程控制语句"><a href="#Chart-模板的流程控制语句" class="headerlink" title="Chart 模板的流程控制语句"></a>Chart 模板的流程控制语句</h5><p>流程控制是为 Chart 模板提供了一种能力，满足更复杂的数据逻辑处理。Helm 模板语言提供以下流程控制语句：</p><ul><li><code>if/else</code>：条件块</li><li><code>with</code>：指定范围</li><li><code>range</code>：循环块</li></ul><h6 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h6><blockquote><p><strong>if/else 的简单介绍</strong></p></blockquote><ul><li><code>if/else</code> 块是用于在模板中有条件地包含文本块的方法，条件块的基本结构如下：</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{{ <span class="string">if</span> <span class="string">PIPELINE</span> }}</span><br><span class="line"><span class="comment"># Do something</span></span><br><span class="line">{{ <span class="string">elseif</span> <span class="string">OTHER</span> <span class="string">PIPELINE</span> }}</span><br><span class="line"><span class="comment"># Do something else</span></span><br><span class="line">{{ <span class="string">else</span> }}</span><br><span class="line"><span class="comment"># Default case</span></span><br><span class="line">{{ <span class="string">end</span> }}</span><br></pre></td></tr></tbody></table></figure><ul><li>条件判断支持使用 <code>eq</code> 运算符来判断是否相等，除此之外，还支持 <code>ne</code>、<code>lt</code>、<code>gt</code>、<code>and</code>、<code>or</code> 等运算符，请注意数据类型。</li><li>条件判断就是判断条件是否为 <code>true</code>，如果值为以下几种情况之一则为 <code>false</code>：<ul><li>一个布尔类型的 <code>false</code></li><li>一个数字零</li><li>一个空的字符串</li><li>一个空的集合（<code>map</code>、<code>slice</code>、<code>tuple</code>、<code>dict</code>、<code>array</code>）</li></ul></li><li>除了上面的这些情况外，其他所有条件都为 <code>true</code>。</li></ul><blockquote><p><strong>if/else 的使用案例一，演示如何使用基本的条件判断</strong></p></blockquote><ul><li>在 Chart 包中，<code>values.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat values.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devops: k8s</span><br></pre></td></tr></tbody></table></figure><ul><li>在 Chart 包中，<code>deployment.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">        {{ <span class="string">if</span> <span class="string">eq</span> <span class="string">.Values.devops</span> <span class="string">"k8s"</span> }}</span><br><span class="line">        <span class="attr">devops:</span> <span class="literal">true</span></span><br><span class="line">        {{ <span class="string">else</span> }}</span><br><span class="line">        <span class="attr">devops:</span> <span class="literal">false</span></span><br><span class="line">        {{ <span class="string">end</span> }}</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>通过模板引擎渲染后，会得到如下结果 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 web 是 Release 的名称</span></span><br><span class="line">helm install web<span class="params"> --dry</span>-run nginx/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">devops:</span> <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>可以看到渲染出来结果会有多余的空行，这是因为当模板引擎渲染时，会将控制指令删除掉，所以之前占的位置也就空白了，需要使用 <code>{{- if ... }}</code> 的方式来消除空行 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">        {{<span class="bullet">-</span> <span class="string">if</span> <span class="string">eq</span> <span class="string">.Values.devops</span> <span class="string">"k8s"</span> }}</span><br><span class="line">        <span class="attr">devops:</span> <span class="literal">true</span></span><br><span class="line">        {{<span class="bullet">-</span> <span class="string">else</span> }}</span><br><span class="line">        <span class="attr">devops:</span> <span class="literal">false</span></span><br><span class="line">        {{<span class="bullet">-</span> <span class="string">end</span> }}</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果使用 <code>-}}</code> 需谨慎，比如在上面的模板文件中：</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...(省略)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  {{<span class="bullet">-</span> <span class="string">if</span> <span class="string">eq</span> <span class="string">.Values.devops</span> <span class="string">"k8s"</span> <span class="string">-</span>}}</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">devops:</span> <span class="literal">true</span></span><br><span class="line">  {{<span class="bullet">-</span> <span class="string">end</span> }}</span><br></pre></td></tr></tbody></table></figure><ul><li>最终会渲染成下面这样子，因为 <code>-}}</code> 它会删除双方的换行符，导致模板文件渲染失败 </li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:- devops:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>if/else 的使用案例二，演示如何判断一个数组是否为空</strong></p></blockquote><ul><li>在 Chart 包中，<code>values.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat values.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span> {}</span><br><span class="line">  <span class="comment"># limits:</span></span><br><span class="line">  <span class="comment">#   cpu: "100m"</span></span><br><span class="line">  <span class="comment">#   memory: "128Mi"</span></span><br><span class="line">  <span class="comment"># requests:</span></span><br><span class="line">  <span class="comment">#   cpu: "100m"</span></span><br><span class="line">  <span class="comment">#   memory: "128Mi"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在 Chart 包中，<code>deployment.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-app</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: nginx</span><br><span class="line">          image: nginx:1.16</span><br><span class="line">          {{- <span class="keyword">if</span> .Values.resources }}</span><br><span class="line">          resources:</span><br><span class="line">{{ toYaml .Values.resources | indent 12 }}</span><br><span class="line">          {{- end }}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>if/else 的使用案例三，演示如何判断一个布尔值是否为 true</strong></p></blockquote><ul><li>在 Chart 包中，<code>values.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat values.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">example.ingress.com</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在 Chart 包中，<code>ingress.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/ingress.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">{{<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.ingress.enabled</span> }}</span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">.Release.Name</span> }}<span class="string">-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> {{ <span class="string">.Values.ingress.host</span> }}</span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> {{ <span class="string">.Release.Name</span> }}</span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> {{ <span class="string">.Values.service.port</span> }}</span><br><span class="line">{{<span class="bullet">-</span> <span class="string">end</span> }}</span><br></pre></td></tr></tbody></table></figure><h6 id="range"><a href="#range" class="headerlink" title="range"></a>range</h6><p>在 Helm 模板语言中，可以使用 <code>range</code> 语句来进行循环操作。</p><blockquote><p><strong>range 的使用案例，演示如何通过 <code>range</code> 读取一个数组的所有元素值</strong></p></blockquote><ul><li>在 Chart 包中，<code>values.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat values.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">list:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在 Chart 包中，<code>deployment.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>在 Chart 包中，<code>deployment.yaml</code> 文件的内容如下（在循环内部使用的是一个 <code>.</code> 符号，这是因为当前的作用域就在当前循环内，这个 <code>.</code> 符号用于表示当前读取到的元素）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: {{ .Release.Name }}</span><br><span class="line">data:</span><br><span class="line">  list: |</span><br><span class="line">  {{- range .Values.list }}</span><br><span class="line">    {{ . }}</span><br><span class="line">  {{- end }}</span><br></pre></td></tr></tbody></table></figure><ul><li>通过模板引擎渲染后，会得到如下结果 </li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">list:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br></pre></td></tr></tbody></table></figure><h6 id="with"><a href="#with" class="headerlink" title="with"></a>with</h6><blockquote><p><strong>with 的简单介绍</strong></p></blockquote><ul><li><code>with</code> 语句就可以用来控制变量的作用域范围。</li><li><code>with</code> 的使用语法和一个简单的 <code>if</code> 语句比较类似：</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{{ <span class="string">with</span> <span class="string">PIPELINE</span> }}</span><br><span class="line">  <span class="comment"># restricted scope</span></span><br><span class="line">{{ <span class="string">end</span> }}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>值得注意的是，在 <code>with</code> 语句块内不能使用内置对象（比如 <code>.Release.Name</code>），否则模板渲染会失败，可以将内置对象赋值给一个变量来解决该问题。</strong></li><li><code>with</code> 语句可以允许将当前范围 <code>.</code> 设置为特定的对象，比如前面一直使用的 <code>.Values.label</code>，就是使用 <code>with</code> 语句来将当前范围 <code>.</code> 指向 <code>.Values.label</code>。</li><li>还记得之前的 <code>{{ .Release.xxx }}</code> 或者 <code>{{ .Values.xxx }}</code> 吗？其中的 <code>.</code> 符号就是表示对当前范围的引用，<code>.Values</code> 就是告诉模板引擎在当前范围中查找 <code>Values</code> 对象的值。</li></ul><blockquote><p><strong>with 的使用案例，演示如何使用 with 来控制变量作用域</strong></p></blockquote><ul><li>在 Chart 包中，<code>values.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat values.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="attr">team:</span> <span class="string">python</span></span><br><span class="line">  <span class="attr">gpu:</span> <span class="literal">yes</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在 Chart 包中，<code>deployment.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">.Release.Name</span> }}<span class="string">-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      {{<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.nodeSelector</span> }}</span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">team:</span> {{ <span class="string">.team</span> }}</span><br><span class="line">        <span class="attr">gpu:</span> {{ <span class="string">.gpu</span> }}</span><br><span class="line">      {{<span class="bullet">-</span> <span class="string">end</span> }}</span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.16</span></span><br></pre></td></tr></tbody></table></figure><ul><li>通过模板引擎渲染后，会得到如下结果 </li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">team:</span> <span class="string">python</span></span><br><span class="line">        <span class="attr">gpu:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.16</span></span><br></pre></td></tr></tbody></table></figure><ul><li>上面的配置内容还可以继续优化一下 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">.Release.Name</span> }}<span class="string">-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      {{<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.nodeSelector</span> }}</span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        {{ <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> }}</span><br><span class="line">      {{<span class="bullet">-</span> <span class="string">end</span> }}</span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.16</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Chart-模板的变量"><a href="#Chart-模板的变量" class="headerlink" title="Chart 模板的变量"></a>Chart 模板的变量</h5><p>在 Chart 模板中，使用变量的场景不多，但下面将看到如何使用变量来简化模板代码，并更好地使用 <code>with</code> 和 <code>range</code> 语句。</p><blockquote><p><strong>变量的使用案例一，演示如何通过变量获取数组的键值</strong></p></blockquote><ul><li>在 Chart 包中，<code>values.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat values.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">NAME:</span> <span class="string">"gateway"</span></span><br><span class="line">  <span class="attr">JAVA_OPTS:</span> <span class="string">"-Xmx2G"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在 Chart 包中，<code>deployment.yaml</code> 文件的内容如下（在 <code>range</code> 循环中，使用 <code>$k</code> 和 <code>$v</code> 这两个变量来接收后面数组循环的键和值）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gateway-deploy</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">gateway-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">gateway-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">gateway-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">gateway:2.13</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            {{<span class="bullet">-</span> <span class="string">range</span> <span class="string">$k</span>, <span class="string">$v</span> <span class="string">:=</span> <span class="string">.Values.env</span> }}</span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> {{ <span class="string">$k</span> }}</span><br><span class="line">              <span class="attr">value:</span> {{ <span class="string">$v</span> <span class="string">|</span> <span class="string">quote</span> }}</span><br><span class="line">            {{<span class="bullet">-</span> <span class="string">end</span> }}</span><br></pre></td></tr></tbody></table></figure><ul><li>通过模板引擎渲染后，会得到如下结果 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gateway-deploy</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">gateway-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">gateway-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">gateway-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">gateway:2.13</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">"gateway"</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">JAVA_OPTS</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">"-Xmx2G"</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>变量的使用案例二，演示如何解决在 <code>with</code> 语句块中不能使用内置对象的问题</strong></p></blockquote><ul><li>在 Chart 包中，<code>values.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat values.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">label:</span></span><br><span class="line">  <span class="attr">project:</span> <span class="string">my-project</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在 Chart 包中，<code>deployment.yaml</code> 文件的内容如下（模板文件渲染会报错，因为在 <code>with</code> 语句块内不能再使用内置对象，比如 <code>.Release.Name</code>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">.Release.Name</span> }}<span class="string">-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> {{ <span class="string">.Values.replicas</span> }}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        {{<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.label</span> }}</span><br><span class="line">        <span class="attr">project:</span> {{ <span class="string">.project</span> }}</span><br><span class="line">        <span class="attr">app:</span> {{ <span class="string">.app</span> }}</span><br><span class="line">        <span class="attr">release:</span> {{ <span class="string">.Release.Name</span> }}</span><br><span class="line">        {{<span class="bullet">-</span> <span class="string">end</span> }}</span><br></pre></td></tr></tbody></table></figure><ul><li>上面的模板内容会渲染失败，但可以将内置对象赋值给一个变量来解决该问题 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">.Release.Name</span> }}<span class="string">-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> {{ <span class="string">.Values.replicas</span> }}</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> {{ <span class="string">.Values.label.app</span> }}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        {{<span class="bullet">-</span> <span class="string">$releaseName</span> <span class="string">:=</span> <span class="string">.Release.Name</span> <span class="string">-</span>}}</span><br><span class="line">        {{<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.label</span> }}</span><br><span class="line">        <span class="attr">project:</span> {{ <span class="string">.project</span> }}</span><br><span class="line">        <span class="attr">app:</span> {{ <span class="string">.app</span> }}</span><br><span class="line">        <span class="attr">release:</span> {{ <span class="string">$releaseName</span> }}</span><br><span class="line">        {{<span class="bullet">-</span> <span class="string">end</span> }}</span><br></pre></td></tr></tbody></table></figure><ul><li>通过模板引擎渲染后，会得到如下结果 </li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">project:</span> <span class="string">my-project</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">release:</span> <span class="string">web</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Chart-模板的命名模板"><a href="#Chart-模板的命名模板" class="headerlink" title="Chart 模板的命名模板"></a>Chart 模板的命名模板</h5><blockquote><p><strong>命名模板的简单介绍</strong></p></blockquote><ul><li><p>命名模板</p><ul><li>用于在 Chart 中复用模板代码片段。</li><li>使用 <code>{{- define "templateName" }} ... {{- end }}</code> 定义模板。</li><li>使用 <code>{{ template "templateName" . }}</code> 引用模板，并传递上下文 <code>.</code>。</li></ul></li><li><p>公共模板文件</p><ul><li>Helm 中，<code>templates</code> 目录下以下划线 <code>_</code> 开头的文件（如 <code>_helpers.tpl</code>）都会被视作公共模板文件。</li><li>这些公共模板文件不会直接渲染成 Kubernetes 对象，而是用于存放命名模板或函数，供其他模板使用。</li></ul></li><li><p>使用注意事项</p><ul><li><code>template</code> 函数不能用于 Go 模板的管道，可以使用 <code>include</code> 语句来解决该问题。</li></ul></li></ul><blockquote><p><strong>命名模板的使用案例一，演示命名模板的基础使用</strong></p></blockquote><ul><li>在 Chart 包中，<code>_helpers.tpl</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/_helpers.tpl</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{{<span class="bullet">-</span> <span class="string">define</span> <span class="string">"demo.fullname"</span> <span class="string">-</span>}}</span><br><span class="line">{{<span class="bullet">-</span> <span class="string">.Chart.Name</span> <span class="string">-</span>}}<span class="string">-{{</span> <span class="string">.Release.Name</span> <span class="string">}}</span></span><br><span class="line">{{<span class="bullet">-</span> <span class="string">end</span> <span class="string">-</span>}}</span><br></pre></td></tr></tbody></table></figure><ul><li>在 Chart 包中，<code>deployment.yaml</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">template</span> <span class="string">"demo.fullname"</span> <span class="string">.</span> }}</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>通过模板引擎渲染后，会得到如下结果 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-web</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>命名模板的使用案例二，演示如何解决 template 函数不能用于 Go 模板的管道的问题</strong></p></blockquote><ul><li>在 Chart 包中，<code>_helpers.tpl</code> 文件的内容如下 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/_helpers.tpl</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{{<span class="bullet">-</span> <span class="string">define</span> <span class="string">"demo.fullname"</span> <span class="string">-</span>}}</span><br><span class="line">{{<span class="bullet">-</span> <span class="string">.Chart.Name</span> <span class="string">-</span>}}<span class="string">-{{</span> <span class="string">.Release.Name</span> <span class="string">}}</span></span><br><span class="line">{{<span class="bullet">-</span> <span class="string">end</span> <span class="string">-</span>}}</span><br><span class="line"></span><br><span class="line">{{<span class="bullet">-</span> <span class="string">define</span> <span class="string">"demo.labels"</span> <span class="string">-</span>}}</span><br><span class="line"><span class="attr">app:</span> {{ <span class="string">template</span> <span class="string">"demo.fullname"</span> <span class="string">.</span> }}</span><br><span class="line"><span class="attr">chart:</span> <span class="string">"<span class="template-variable">{{ .Chart.Name }}</span>-<span class="template-variable">{{ .Chart.Version }}</span>"</span></span><br><span class="line"><span class="attr">release:</span> <span class="string">"<span class="template-variable">{{ .Release.Name }}</span>"</span></span><br><span class="line">{{<span class="bullet">-</span> <span class="string">end</span> <span class="string">-</span>}}</span><br></pre></td></tr></tbody></table></figure><ul><li>在 Chart 包中，<code>deployment.yaml</code> 文件的内容如下（模板文件渲染会报错，因为 <code>template</code> 函数不能用于 Go 模板的管道）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat templates/deployment.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">template</span> <span class="string">"demo.fullname"</span> <span class="string">.</span> }}</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    {{<span class="bullet">-</span> <span class="string">template</span> <span class="string">"demo.labels"</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">4</span> }}</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>上面的模板内容会渲染失败，但可以使用 <code>include</code> 语句来解决该问题 </li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> {{ <span class="string">include</span> <span class="string">"demo.fullname"</span> <span class="string">.</span> }}</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    {{<span class="bullet">-</span> <span class="string">include</span> <span class="string">"demo.labels"</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">4</span> }}</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>通过模板引擎渲染后，会得到如下结果 </li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-web</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-web</span></span><br><span class="line">    <span class="attr">chart:</span> <span class="string">"nginx-0.1.0"</span></span><br><span class="line">    <span class="attr">release:</span> <span class="string">"web"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之十</title>
    <link href="https://www.techgrow.cn/posts/6158b4d2.html"/>
    <id>https://www.techgrow.cn/posts/6158b4d2.html</id>
    <published>2025-09-13T13:12:19.000Z</published>
    <updated>2025-09-13T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="搭建高可用集群"><a href="#搭建高可用集群" class="headerlink" title="搭建高可用集群"></a>搭建高可用集群</h3><h3 id="部署性能监控平台"><a href="#部署性能监控平台" class="headerlink" title="部署性能监控平台"></a>部署性能监控平台</h3><p>开源软件 cAdvisor（Container Advisor）可用于监控所在节点的容器运行状态，当前已经被默认集成到 Kubernetes 的 Kubelet 组件内，默认使用 TCP <code>4194</code> 端口。在中小型规模容器集群中，通常使用 Prometheus + Grafana 来实现容器集群性能数据的采集、存储与展示。</p><h4 id="监控方案"><a href="#监控方案" class="headerlink" title="监控方案"></a>监控方案</h4><blockquote><p>监控方案的介绍</p></blockquote><ul><li><p>Heapster + InfluxDB + Grafana</p><ul><li>架构：Heapster + InfluxDB + Grafana</li><li> 功能：Heapster 汇聚各 Node 上 cAdvisor 的监控数据，存入 InfluxDB 后通过 Grafana 展示。</li><li>状态：已被 Kubernetes 官方弃用，自 Kubernetes <code>v1.13</code> 起不再维护。</li><li>适用场景：早期集群监控，仅作学习了解。</li></ul></li><li><p>Metrics Server</p><ul><li>角色：Heapster 的官方替代品。</li><li>功能：提供实时的资源用量指标（CPU、内存）给 <code>kubectl top</code>、Horizontal Pod Autoscaler（HPA）等使用。</li><li>限制：不存储历史数据，不提供可视化界面或持久化存储。</li><li>状态：Kubernetes 官方的核心组件。</li><li>适用场景：HPA 自动扩缩容、轻量实时监控。</li></ul></li><li><p>Prometheus + Grafana</p><ul><li>架构：Prometheus + Grafana</li><li> 功能：<ul><li>Prometheus = 数据收集 + 存储 + 告警。</li><li>Grafana = 数据展示 + 可视化分析界面。</li></ul></li><li>优点：<ul><li>监控维度丰富（节点、容器、Pod、Service、集群状态）</li><li>数据查询灵活（PromQL）</li><li>支持历史数据存储</li></ul></li><li>状态：当前主流的开源监控方案。</li><li>适用场景：中小型或自建环境中的主力方案。</li></ul></li><li><p>Prometheus Operator + kube-prometheus-stack</p><ul><li>架构组件：<ul><li>Prometheus（采集与存储指标）</li><li>Alertmanager（告警）</li><li>Grafana（可视化）</li><li>kube-state-metrics（集群资源状态）</li><li>node-exporter（节点系统指标）</li></ul></li><li>特点：<ul><li>Operator 自动化管理 Prometheus、Alertmanager、Grafana 等部署与配置。</li><li>社区维护的 “kube-prometheus-stack” Helm Chart 是生产级推荐方案。</li></ul></li><li>状态：功能最全、生态最活跃。</li><li>适用场景：生产级集群的监控、告警、可视化一体化方案。</li></ul></li><li><p>Weave Scope / Weave Cloud</p><ul><li>功能：<ul><li>直观展示 Pod、容器、Service 之间的拓扑关系与状态。</li><li>支持查看部分性能指标（CPU、内存、网络流量）。</li></ul></li><li>定位：<ul><li>更偏向于可视化与运维调试工具。</li><li>不属于严格意义上的 “性能监控方案”。</li></ul></li><li>适用场景：<ul><li>集群拓扑观测、实时诊断、开发或测试环境。</li><li>可作为 Prometheus 或 Metrics Server 的补充。</li></ul></li></ul></li></ul><blockquote><p>监控方案的对比</p></blockquote><table><thead><tr><th>监控方案</th><th>类型</th><th>是否官方推荐</th><th>是否可替代 Heapster</th><th> 可视化</th><th>是否持久化存储</th></tr></thead><tbody><tr><td> Heapster + InfluxDB + Grafana</td><td> 旧版指标监控</td><td>❌ 已弃用</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>Metrics Server</td><td> 资源指标采集</td><td>✔ 官方推荐</td><td>✔</td><td>❌</td><td>❌</td></tr><tr><td>Prometheus + Grafana</td><td> 指标监控</td><td>✔ 官方推荐</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>Prometheus Operator Stack</td><td> 生产级集群监控告警平台</td><td>✔ 官方推荐</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>Weave Scope / Weave Cloud</td><td> 拓扑与可视化</td><td>⚙️ 可选</td><td>❌</td><td>✔</td><td>部分</td></tr></tbody></table><h4 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h4><h5 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h5><table><thead><tr><th>组件</th><th>版本</th></tr></thead><tbody><tr><td> Prometheus</td><td><code>v1.3.3</code></td></tr><tr><td>Grafana</td><td><code>v4.4.3</code></td></tr><tr><td>Kubernetes</td><td><code>v1.19.10</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Gateway 实现动态路由和灰度发布</title>
    <link href="https://www.techgrow.cn/posts/d806b69a.html"/>
    <id>https://www.techgrow.cn/posts/d806b69a.html</id>
    <published>2025-09-12T14:33:05.000Z</published>
    <updated>2025-09-12T14:33:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Gateway-动态路由"><a href="#Gateway-动态路由" class="headerlink" title="Gateway 动态路由"></a>Gateway 动态路由</h2><span id="more"></span><ul><li>创建数据库表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `gateway_api_route` (</span><br><span class="line">   `id` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `path` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `service_id` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `url` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `retryable` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `enabled` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `strip_prefix` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `api_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"> ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></tbody></table></figure><ul><li>插入表数据 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO gateway_api_route (id, path, service_id, retryable, strip_prefix, url, enabled) VALUES (<span class="string">'order-service'</span>, <span class="string">'/order/**'</span>, <span class="string">'order-service'</span>,0,1, NULL, 1);</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>企业项目中可以使用 Spring MVC 结合前端页面，开发一个可视化网关管理工作台。当新服务开发完成后，可以通过这个工作台对网关配置进行管理，比如为某个服务绑定对应的 URL 路径，并支持增删改查操作，实现服务路由配置的可视化管理。</p></div><h2 id="Gateway-灰度发布"><a href="#Gateway-灰度发布" class="headerlink" title="Gateway 灰度发布"></a>Gateway 灰度发布</h2><ul><li>创建数据库表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `gray_release_config` (</span><br><span class="line">   `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">   `service_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `path` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `enable_gray_release` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"> ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/distributed-system/dynamic-route.md">Zuul 网关实现动态路由</a></li><li><a href="https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/distributed-system/gray-environment.md">Zuul 网关实现灰度发布</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Spring Cloud Gateway 实现动态路由和灰度发布。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之三</title>
    <link href="https://www.techgrow.cn/posts/2722157d.html"/>
    <id>https://www.techgrow.cn/posts/2722157d.html</id>
    <published>2025-09-10T13:12:19.000Z</published>
    <updated>2025-09-10T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><span id="more"></span><h3 id="Controller-的介绍"><a href="#Controller-的介绍" class="headerlink" title="Controller 的介绍"></a>Controller 的介绍</h3><div class="admonition note"><p class="admonition-title">Pod 与 Controller（控制器）的关系</p><ul><li>Pod 通过 Controller 进行运维管理，包括创建、扩缩容、滚动更新等操作。</li><li>Pod 与 Controller 之间是通过 Label（标签）和 Label Selector（标签选择器）机制建立关联关系。</li><li>Controller 通过识别 Pod 的 Label（标签）来实现对一组 Pod 的集中管理。</li></ul></div><h4 id="Replication-Controller（RC）"><a href="#Replication-Controller（RC）" class="headerlink" title="Replication Controller（RC）"></a>Replication Controller（RC）</h4><h5 id="RC-的概念"><a href="#RC-的概念" class="headerlink" title="RC 的概念"></a>RC 的概念</h5><p>Replication Controller（RC）是 Kubernetes 系统中的核心概念之一。当定义一个 RC 并将其提交到 Kubernetes 集群后，Master 节点上的 Controller Manager 组件会接收到通知，并持续监控集群中 Pod 的运行状态。</p><h5 id="RC-的作用"><a href="#RC-的作用" class="headerlink" title="RC 的作用"></a>RC 的作用</h5><ul><li><p>Pod 的副本数量管理</p><ul><li>确保集群中实际运行的 Pod 副本数量与 RC 定义的期望值（<code>spec.replicas</code>）保持一致：<ul><li>如果运行的 Pod 副本数量 过多，RC 会自动停止并删除多余的 Pod；</li><li>如果运行的 Pod 副本数量 不足，RC 会自动创建新的 Pod 来补足数量。</li></ul></li></ul></li><li><p>Pod 的自动修复能力</p><ul><li>当 Pod 因故障或异常退出时，RC 会自动创建新的 Pod 来替代，确保服务始终可用。</li></ul></li><li><p>Pod 的弹性伸缩能力</p><ul><li>用户可以通过调整 RC 定义中的副本数，实现 Pod 的动态扩缩容（Scaling），从而根据业务需求灵活提升或降低服务处理能力。</li><li>比如：<code>kubectl scale rc nginx --replicas=5</code></li></ul></li></ul><h5 id="RS-替代-RC"><a href="#RS-替代-RC" class="headerlink" title="RS 替代 RC"></a>RS 替代 RC</h5><p>从 Kubernetes <code>1.2</code> 版本开始，Replica Set（RS）已经逐渐取代 Replication Controller（RC），成为更常用的 Pod 副本管理控制器。二者的演进说明如下：</p><ul><li><p>命名冲突</p><ul><li>由于 Replication Controller 与 Kubernetes 代码模块中同名，在 Kubernetes <code>1.2</code> 版本中，RC 升级为新的概念 Replica Set ，官方将其定义为 RC 的下一代版本。  </li></ul></li><li><p>主要区别  </p><ul><li>Replication Controller：只支持基于等式的 Label Selector，如 <code>app=nginx</code>。</li><li>Replica Set ：除了支持等式的 Label Selector 外，还支持基于集合式的 Label Selector，如 <code>in</code>、<code>notin</code>、<code>exists</code> 等更复杂的匹配规则。</li></ul></li><li><p>使用场景</p><ul><li>在实际工作中，很少单独使用 Replica Set，它通常由 Deployment 管理。Deployment 提供了更高层次的功能，包括 Pod 创建、删除、更新 的完整编排与滚动升级机制。</li><li>在生产环境中，通常通过 Deployment → Replica Set → Pod 这一管理链路进行编排和管理。</li></ul></li></ul><blockquote><p>使用 RC / RS 管理 Pod 的原因</p></blockquote><ul><li><p>避免直接创建 Pod</p><ul><li>不建议越过 RC / RS 直接创建 Pod，因为直接创建的 Pod 无法自动修复或扩缩容。</li><li>RC 或 RS 通过副本管理机制，可以实现 Pod 的自动创建、补足、替换和删除。</li></ul></li><li><p>提升容灾能力</p><ul><li>当节点故障或 Pod 异常退出时，RC / RS 会自动创建新的 Pod，确保服务稳定可用，减少因节点崩溃等意外带来的损失。</li></ul></li><li><p>适用于单副本场景</p><ul><li>即使应用只有一个 Pod 副本，也强烈建议使用 RC / RS 来管理 Pod，以获得自动恢复和高可用能力。</li></ul></li></ul><h4 id="Replica-Set（RS）"><a href="#Replica-Set（RS）" class="headerlink" title="Replica Set（RS）"></a>Replica Set（RS）</h4><h5 id="RS-的概念"><a href="#RS-的概念" class="headerlink" title="RS 的概念"></a>RS 的概念</h5><p>从 Kubernetes <code>1.2</code> 版本开始，Replica Set（RS）已经逐渐取代 Replication Controller（RC），成为更常用的 Pod 副本管理控制器。Replica Set 是 Replication Controller 的升级版本，支持更强大的 Label Selector，二者的关系如下：</p><ul><li><p>功能一致</p><ul><li>Replica Set 与 Replication Controller 在功能上没有本质的区别，二者的核心作用都是确保 Pod 副本数量与预期值保持一致。</li></ul></li><li><p>用法差异</p><ul><li>Replication Controller 只支持基于等式的 Label Selector，例如 <code>app=nginx</code>。</li><li>Replica Set 除了支持等式的 Label Selector 外，还支持基于集合式的 Label Selector，如 <code>in</code>、<code>notin</code>、<code>exists</code> 等更复杂的匹配规则。</li></ul></li><li><p>官方建议</p><ul><li>Kubernetes 官方强烈建议避免直接使用 Replica Set，而是通过 Deployment 来创建和管理 Replica Set 及其 Pod，以此获得滚动更新、回滚等高级功能。</li><li>在生产环境中，通常通过 Deployment → Replica Set → Pod 这一管理链路进行编排和管理。</li></ul></li></ul><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><h5 id="Deployment-的概念"><a href="#Deployment-的概念" class="headerlink" title="Deployment 的概念"></a>Deployment 的概念</h5><p>Deployment 控制器是 Kubernetes 在 <code>1.2</code> 版本中引入的新概念，主要目的是为了更好地解决 Pod 的编排问题 。</p><ul><li><p>主要功能</p><ul><li>部署和管理无状态应用；</li><li>维护期望数量的 Pod 实例，支持自动修复异常 Pod；</li><li>提供滚动升级、灰度发布、快速回滚 等版本管理功能；</li><li>支持自动扩缩容（结合 HPA 使用）；</li><li>与 Service 配合，实现应用的高可用与负载均衡。</li></ul></li><li><p>实现机制</p><ul><li>Deployment 内部通过 Replica Set 管理 Pod 副本：<ul><li>Replica Set 负责 Pod 的实际创建、扩容和缩容；</li><li>Deployment 作为更高一层控制器，可以管理多个 Replica Set，从而支持版本管理和回滚。</li></ul></li><li>当更新镜像或配置时，Deployment 会创建新的 Replica Set 并逐步替换旧 Pod，实现平滑升级。</li></ul></li><li><p>定义特点</p><ul><li>定义结构与 Replica Set 类似，但提供了更高层的编排能力：<ul><li>Replica Set 的 Kind 类型：<code>ReplicaSet</code>；</li><li>Deployment 的 Kind 类型：<code>Deployment</code>，支持滚动更新、回滚、暂停、恢复、历史版本管理等高级功能。</li></ul></li><li>可通过 YAML 文件、命令行等多种方式定义，易于集成到 CI/CD 流水线中。</li></ul></li><li><p>适用场景</p><ul><li>部署无状态 Web 应用，如 Nginx、前端服务、API 网关；结合 Service 实现高可用和负载均衡，支持滚动更新不中断访问；</li><li>部署微服务中的业务服务实例，支持自动扩缩容，满足不同流量需求；通过滚动更新和灰度发布，保证服务持续迭代；</li><li>部署无状态的计算或处理任务，如日志收集、ETL、数据清洗等；</li><li>部署一些无状态的基础设施，如 Prometheus、Grafana、Fluentd；</li><li>通过 Deployment 的版本控制能力，实现持续交付流程；支持分批滚动更新、A/B 测试和金丝雀发布。</li></ul></li></ul><h4 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h4><h5 id="StatefulSet-的概念"><a href="#StatefulSet-的概念" class="headerlink" title="StatefulSet 的概念"></a>StatefulSet 的概念</h5><p>StatefulSet 控制器是 Kubernetes 在 <code>1.5</code> 版本中引入的控制器，主要用于管理有状态应用，为每个 Pod 提供固定身份标识、稳定的网络标识符和持久化存储，确保 Pod 的部署和管理有序进行。</p><ul><li><p>主要功能</p><ul><li>部署和管理有状态应用；</li><li>保证每个 Pod 具有固定的标识符（名称、网络标识）；</li><li>按照顺序有序创建、有序扩容、有序删除 Pod；</li><li>结合 PersistentVolume 为每个 Pod 提供独立的持久化存储；</li><li>确保 Pod 在重启或迁移后仍能保持原有的存储和网络标识。</li></ul></li><li><p>实现机制</p><ul><li>StatefulSet 内部通过 Headless Service 实现固定 DNS 解析，为 Pod 提供稳定的网络标识；</li><li>每个 Pod 会被分配一个有序的编号，例如 <code>mysql-0</code>、<code>mysql-1</code>；</li><li>Pod 与 PersistentVolumeClaim（PVC）绑定，确保数据不会因 Pod 重建而丢失；</li><li>Pod 创建、扩容、更新、删除等操作严格按照顺序进行，保证集群一致性。</li></ul></li><li><p>定义特点</p><ul><li>StatefulSet 的定义与 Deployment 类似，但支持更多有状态特性：<ul><li>Pod 命名固定：Pod 名称由 StatefulSet 名称 + 编号组成，如 <code>mysql-0</code>；</li><li>网络标识稳定：通过 Headless Service 绑定，Pod 拥有固定 DNS，如 <code>mysql-0.mysql</code>；</li><li>持久化存储：每个 Pod 自动绑定独立 PVC，与 Pod 生命周期解耦；</li><li>严格的顺序控制：Pod 启动、扩容和删除过程严格有序。</li></ul></li></ul></li><li><p>适用场景</p><ul><li>部署数据库服务，如 MySQL 主从、PostgreSQL；</li><li>部署分布式存储，如 HDFS、Ceph；</li><li>部署分布式协调服务，如 ZooKeeper、Etcd；</li><li>部署需要稳定网络标识的集群，如 Kafka、RabbitMQ。</li></ul></li></ul><h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><h5 id="DaemonSet-的概念"><a href="#DaemonSet-的概念" class="headerlink" title="DaemonSet 的概念"></a>DaemonSet 的概念</h5><p>DaemonSet 控制器是 Kubernetes 在 <code>1.2</code> 版本中引入的重要控制器，主要用于确保集群中每个（或指定）Node（工作节点）上都运行一个 Pod，非常适合运行节点级的后台服务或守护进程。</p><ul><li><p>主要功能</p><ul><li>在每个节点上运行一个指定的 Pod<ul><li> 自动在集群中每个符合条件的节点上部署且只运行一个指定的 Pod 实例。</li></ul></li><li>节点加入自动部署<ul><li>当新节点加入集群时，DaemonSet 会自动在该节点上调度并启动 Pod。</li></ul></li><li>节点移除自动回收<ul><li>节点被移除或不可用时，对应 Pod 会自动删除，保持一致性。</li></ul></li><li>不支持手动扩容 / 缩容<ul><li> Pod 的副本数量与节点数量直接关联，不支持手动管理 <code>replicas</code>。</li></ul></li><li>支持滚动更新与回滚<ul><li>可平滑升级版本，并在出现问题时快速回滚。</li></ul></li><li>可结合节点选择器、节点亲和性、污点 / 容忍等使用<ul><li>支持精确控制 DaemonSet Pod 部署在哪些节点上。</li></ul></li><li>与 Deployment 区别<ul><li> Deployment：通常用于无状态服务，副本数固定，由用户定义。</li><li>DaemonSet：与节点数量绑定，强调 “每个节点一个 Pod”。</li></ul></li><li>删除行为可控<ul><li>使用 <code>kubectl delete daemonset</code> 删除 DaemonSet 时，可通过 <code>--cascade=orphan</code> 参数控制是否保留关联的 Pod。</li></ul></li></ul></li><li><p>实现机制</p><ul><li>DaemonSet 控制器实时监听集群节点变化：<ul><li>当新节点加入时，DaemonSet 会根据调度规则自动为该节点创建一个 Pod；</li><li>当节点下线或被删除时，DaemonSet 会清理对应的 Pod；</li><li>通过 <code>updateStrategy</code> 配置支持滚动更新，保证节点上的 Pod 平滑升级；</li></ul></li><li>一个 DaemonSet 只能管理一组相同功能的 Pod，不会像 Deployment 那样创建多个 Replica Set（RS）；</li><li>与 Deployment 不同，DaemonSet 的 Pod 不通过调度器进行普通调度，而是直接绑定到目标节点。</li></ul></li><li><p>定义特点</p><ul><li>Kind 类型是 <code>DaemonSet</code>；</li><li>Pod 数量等于匹配规则的节点数量；</li><li>支持的更新策略：<ul><li><code>RollingUpdate</code>：逐个节点更新 Pod，保证服务连续性；</li><li><code>OnDelete</code>：需要手动删除旧 Pod 时，DaemonSet 才会创建新 Pod；</li></ul></li><li>可通过节点标签、节点亲和性、污点 / 容忍等配置精确控制 Pod 的分布；</li><li>YAML 文件定义结构与 Deployment 类似，但 <code>spec.strategy</code> 配置略有不同。</li><li>使用 <code>kubectl delete daemonset</code> 删除 DaemonSet 时，可通过 <code>--cascade=orphan</code> 参数控制是否保留关联的 Pod。</li></ul></li><li><p>适用场景</p><ul><li>日志收集：如 Fluentd、Logstash、Filebeat，保证每个节点日志都能被采集。</li><li>监控代理：如 Prometheus Node Exporter、Datadog Agent、cAdvisor 等，采集节点和 Pod 的监控指标。</li><li>网络插件：如 Flannel、Calico、Cilium 等 CNI 插件，需要在所有节点上运行网络代理；</li><li>存储插件：如 Ceph、GlusterFS、CSI Driver 等，部署存储卷管理进程；</li><li>安全与合规审计：如 Falco、Sysdig Secure 等安全审计、防护 Agent；</li><li>节点运维任务：自动在每个节点运行健康检查、系统运维脚本或运维工具；</li><li>边缘计算场景：在特定节点部署边缘服务或代理。</li></ul></li><li><p>总结对比</p><table><thead><tr><th>特性</th><th> Deployment</th><th>DaemonSet</th></tr></thead><tbody><tr><td>Pod 数量控制</td><td>支持自定义 Pod 的副本数量</td><td>每个节点部署 1 个 Pod，自动匹配节点</td></tr><tr><td>调度机制</td><td>由调度器调度</td><td>直接绑定到目标节点</td></tr><tr><td>适用场景</td><td>无状态应用、微服务、Web 服务</td><td>节点级服务、日志、监控、网络插件等</td></tr><tr><td>支持扩缩容</td><td>支持 HPA 自动扩缩容</td><td>不支持扩缩容，Pod 数量由节点数决定</td></tr><tr><td>更新策略</td><td>滚动更新、回滚、暂停、恢复</td><td>滚动更新，或者手动删除更新</td></tr></tbody></table></li></ul><h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><h5 id="Job-的概念"><a href="#Job-的概念" class="headerlink" title="Job 的概念"></a>Job 的概念</h5><p>Job 控制器是 Kubernetes 中用于<strong>一次性任务</strong>管理的重要控制器，适合运行批处理作业或有限执行次数的任务。Job 会确保指定数量的 Pod 成功执行完成（即运行到 Completed 状态），通常用于离线计算、数据处理或临时任务。</p><ul><li><p>主要功能</p><ul><li>执行一次性任务，保证任务至少成功执行一次<ul><li> Job 会确保定义的 Pod 按照预期执行，直到成功完成（运行状态为 <code>Completed</code>）。</li><li>Pod 运行失败时，Job 会根据重试策略自动重新创建新的 Pod 继续执行任务。</li></ul></li><li>支持并行或串行执行<ul><li>可以通过 <code>spec.parallelism</code> 控制同时运行的 Pod 数量；</li><li>可以通过 <code>spec.completions</code> 控制任务总共需要成功完成的 Pod 数量。</li></ul></li><li>适合一次性任务，执行完成后不会再次运行<ul><li> Job 完成后，Pod 不会被自动删除，但状态保持为 <code>Completed</code>；</li><li>可以通过配置 TTL 控制器自动清理已完成的 Job 及 Pod。</li></ul></li></ul></li><li><p>实现机制</p><ul><li>Job 控制器实时监听任务的执行状态：<ul><li>创建 Pod：Job 根据并发配置启动一个或多个 Pod；</li><li>失败重试：如果 Pod 执行失败（运行状态为 <code>Failed</code>），Job 会根据 <code>backoffLimit</code> 限制重试次数；</li><li>完成判断：当成功完成的 Pod 数量达到 <code>spec.completions</code> 时，Job 进入 <code>Completed</code> 状态；</li><li>清理策略：可通过 <code>ttlSecondsAfterFinished</code> 设置任务完成后延迟删除资源。</li></ul></li><li>Pod 调度：Job 创建的 Pod 由调度器进行普通调度，可结合节点选择策略运行在特定节点。</li><li>Job 控制器本身不做并发同步逻辑，任务并发控制需通过应用自身或外部工具实现。</li></ul></li><li><p>定义特点</p><ul><li>Kind 类型：<code>Job</code></li><li>核心参数：<ul><li><code>spec.completions</code>：任务需要成功完成的 Pod 总数量；</li><li><code>spec.parallelism</code>：允许同时运行的 Pod 数量；</li><li><code>spec.backoffLimit</code>：Pod 失败时的最大重试次数，超过该次数后 Job 会被标记为失败；</li><li><code>spec.ttlSecondsAfterFinished</code>：Job 完成后延迟清理的时间（秒）；</li><li><code>spec.template.spec.restartPolicy</code>：Pod 的重启策略，Job 必须设置为：<ul><li><code>Never</code>：Pod 失败时，不会在同一个 Pod 内重启，而是由 Job 创建新的 Pod；</li><li><code>OnFailure</code>：Pod 失败时，会在同一个 Pod 内重启一次，仍未成功则由 Job 重新创建 Pod。</li></ul></li></ul></li><li>YAML 定义结构与 Deployment 类似，但 <code>spec.strategy</code> 等部署策略不适用。</li></ul></li><li><p>更新策略</p><ul><li>Job 通常不支持直接滚动更新：<ul><li>如果需要修改 Job 逻辑，通常是删除旧 Job 后重新创建新 Job；</li><li>可以通过 <code>kubectl replace</code> 或者 <code>kubectl apply</code> 覆盖更新。</li></ul></li></ul></li><li><p>适用场景</p><ul><li>一次性批处理作业<ul><li>数据清理、日志分析、批量数据转换等。</li></ul></li><li>离线计算任务<ul><li>机器学习模型训练、视频转码、大数据计算等。</li></ul></li><li>自动化任务<ul><li>备份数据库、生成报表、执行临时脚本等。</li></ul></li><li>测试任务<ul><li>压力测试、集成测试或单次验证任务。</li></ul></li></ul></li></ul><h4 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h4><h5 id="CronJob-的概念"><a href="#CronJob-的概念" class="headerlink" title="CronJob 的概念"></a>CronJob 的概念</h5><p>CronJob 控制器是 Kubernetes 中用于<strong>定时任务调度</strong>的重要控制器，适合周期性执行任务或在特定时间点自动运行一次性任务。CronJob 基于 Linux 的 <code>cron</code> 语法定义任务调度规则，本质上是按时间计划自动创建 Job 资源，由 Job 再去管理 Pod 的执行与重试。</p><ul><li><p>主要功能</p><ul><li>周期性任务调度<ul><li>使用 <code>cron</code> 表达式定义执行计划，精确到分钟；</li><li>可在每天、每周、每月或特定时间点自动运行任务。</li></ul></li><li>自动创建 Job<ul><li>CronJob 在到达调度时间后，会自动创建对应的 Job 资源；</li><li>CronJob 不直接创建和运行 Pod，所有 Pod 都由其生成的 Job 进行管理；</li><li>Job 负责任务的执行、失败重试和状态维护。</li></ul></li><li>控制并发执行<ul><li>可通过 <code>concurrencyPolicy</code> 控制多次调度的 Job 是否允许并发执行：<ul><li><code>Allow</code>：允许多个任务并发运行；</li><li><code>Forbid</code>：禁止并发，若上一个任务未完成，跳过新的调度；</li><li><code>Replace</code>：如果上一个任务未完成，先删除旧任务，再启动新任务。</li></ul></li></ul></li><li>支持任务历史管理<ul><li>可以配置保留的成功任务和失败任务历史数量，避免资源无限增长。</li></ul></li><li>支持一次性定时任务<ul><li>通过指定一次性运行的时间点，实现一次性定时触发的 Job。</li></ul></li></ul></li><li><p>实现机制</p><ul><li>CronJob 控制器周期性检查当前时间是否符合 <code>schedule</code> 定义的规则：<ul><li>(1) 到达调度时间点 → 创建新的 Job；</li><li>(2) Job 执行任务 → 根据 Pod 模板启动 Pod；</li><li>(3) 任务执行失败 → 根据 Job 的重试策略进行管理；</li><li>(4) 任务历史清理 → 按配置保留一定数量的成功和失败记录。</li></ul></li><li>CronJob 仅负责调度和 Job 创建，实际的 Pod 管理由 Job 负责；</li><li>当控制器或 API Server 不可用时，会在恢复后补偿执行任务（可通过 <code>startingDeadlineSeconds</code> 控制补偿的时间窗口）。</li></ul></li><li><p>定义特点</p><ul><li>Kind 类型：<code>CronJob</code></li><li>核心参数：<ul><li><code>spec.schedule</code>：调度时间，使用标准 <code>cron</code> 表达式；</li><li><code>spec.concurrencyPolicy</code>：任务并发执行策略；</li><li><code>spec.startingDeadlineSeconds</code>：任务延迟启动的容忍时间（秒）；</li><li><code>spec.successfulJobsHistoryLimit</code>：保留的成功 Job 数量；</li><li><code>spec.failedJobsHistoryLimit</code>：保留的失败 Job 数量；</li><li><code>spec.jobTemplate</code>：定义要运行的 Job 模板<ul><li><code>spec.jobTemplate.spec.template.spec.restartPolicy</code>：Pod 的重启策略，CronJob 必须设置为：<ul><li><code>Never</code>：Pod 失败后不重启（常用于一次性任务）；</li><li><code>OnFailure</code>：Pod 失败后自动重启，直到成功或超过 <code>backoffLimit</code> 限制。</li></ul></li></ul></li></ul></li></ul></li><li><p>更新策略</p><ul><li>CronJob 更新时：<ul><li>新的调度规则在应用后立即生效；</li><li>已经创建的 Job 不会被中断或自动更新；</li><li>修改任务逻辑需更新 <code>jobTemplate</code> 并等待下一个调度周期生效。</li></ul></li><li>如果需要中断已生成的 Job，需要手动删除 Job 或 Pod。</li></ul></li><li><p>适用场景</p><ul><li>定时数据处理<ul><li>每天凌晨自动跑批处理作业，生成统计报表；</li><li>定时清理临时文件或过期数据。</li></ul></li><li>数据库备份<ul><li>每天或每小时自动执行数据库备份任务。</li></ul></li><li>日志归档<ul><li>定期收集、压缩和上传日志文件到集中存储。</li></ul></li><li>周期性健康检查<ul><li>定时执行诊断脚本或检查任务，输出报告。</li></ul></li><li>定时通知或消息推送<ul><li>定时触发消息发送、告警提醒或业务事件。</li></ul></li><li>一次性延时执行任务<ul><li>通过设置特定时间点，完成一次性延时任务的执行。</li></ul></li></ul></li><li><p>Linux 的 Cron 表达式规则</p><ul><li><p>常用示例（仅支持精确到分钟）：</p><ul><li><code>"*/5 * * * *"</code> → 每 5 分钟执行一次；</li><li><code>"0 0 * * *"</code> → 每天 0 点执行；</li><li><code>"0 2 * * 1"</code> → 每周一凌晨 2 点执行。</li></ul><table><thead><tr><th>字段位置</th><th>含义</th><th>取值范围</th></tr></thead><tbody><tr><td>第 1 位</td><td>分钟</td><td> 0–59</td></tr><tr><td> 第 2 位</td><td>小时</td><td> 0–23</td></tr><tr><td> 第 3 位</td><td>日期（日）</td><td>1–31</td></tr><tr><td> 第 4 位</td><td>月份</td><td> 1–12</td></tr><tr><td> 第 5 位</td><td>星期</td><td> 0–7（0 和 7 都表示星期日）</td></tr></tbody></table></li></ul></li></ul><h4 id="Horizontal-Pod-Autoscaler"><a href="#Horizontal-Pod-Autoscaler" class="headerlink" title="Horizontal Pod Autoscaler"></a>Horizontal Pod Autoscaler</h4><h5 id="HPA-的概念"><a href="#HPA-的概念" class="headerlink" title="HPA 的概念"></a>HPA 的概念</h5><p>Horizontal Pod Autoscaler（Pod 横向自动扩容，简称 HPA）与 Replication Controller（RC）、Deployment 一样，都是 Kubernetes 的资源对象。HPA 的实现原理是：通过持续追踪和分析 Replication Controller（RC）或 Deployment 控制的目标 Pod 的负载变化，判断是否需要针对性地调整 Pod 的副本数量（自动扩容和缩容）。</p><h5 id="HPA-的两种模式"><a href="#HPA-的两种模式" class="headerlink" title="HPA 的两种模式"></a>HPA 的两种模式</h5><p>Kubernetes 对 Pod 的扩容与缩容提供了手动和自动两种模式。</p><ul><li><p>手动扩容和缩容：</p><ul><li>通过 <code>kubectl scale</code> 命令对 Deployment 或 Replication Controller 的 Pod 副本数量进行设置；</li><li>比如：<code>kubectl scale deployment frontend --replicas 1</code>。</li></ul></li><li><p>自动扩容和缩容（HPA）：</p><ul><li>用户需要根据某个性能指标或自定义业务指标，指定 Pod 副本数量的最小值和最大值范围，Kubernetes 会根据实时指标变化，在这个范围内自动调整 Pod 的副本数量。</li><li>HPA 控制器通过 Master 节点的 <code>kube-controller-manager</code> 服务的启动参数 <code>--horizontal-pod-autoscaler-sync-period</code>（默认值为 30 秒）来周期性运行，包括：<ul><li>HPA 控制器会定期监测目标 Pod 的 CPU 使用率；</li><li>当 Pod 的 CPU 平均使用率达到用户设定的阈值条件时，HPA 控制器会自动调整 Replication Controller 或 Deployment 中的 Pod 副本数量，以使实际 Pod 副本数满足用户定义的 CPU 平均使用率要求。</li></ul></li></ul></li></ul><h5 id="HPA-的扩容配置示例"><a href="#HPA-的扩容配置示例" class="headerlink" title="HPA 的扩容配置示例"></a>HPA 的扩容配置示例</h5><ul><li>配置示例 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">50m</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">50</span>    <span class="comment"># 当 Pod 的 CPU 平均使用率超过 50% 时扩容</span></span><br></pre></td></tr></tbody></table></figure><ul><li>配置说明：<ul><li>Deployment（<code>nginx-deployment</code>）<ul><li>核心作用：<ul><li>创建并管理 Nginx Pod，实现副本管理、自动恢复。</li></ul></li><li>核心配置：<ul><li><code>replicas: 1</code>：初始创建 1 个 Pod 副本。</li><li><code>selector.matchLabels</code>：用于匹配 Pod 的标签，这里为 <code>app: nginx</code>，确保 Deployment 管理正确的 Pod。</li><li><code>template.metadata.labels</code>：Pod 模板的标签，与 <code>selector</code> 对应。</li><li><code>containers</code>：定义容器信息<ul><li><code>name</code> / <code>image</code>：容器名称及镜像（nginx）</li><li><code>resources.requests.cpu: 50m</code>：CPU 请求资源，保证 Pod 调度时的资源预留（<code>50m</code> 表示 <code>0.05</code> 个 CPU 核心）</li><li><code>ports.containerPort: 80</code>：容器端口</li></ul></li></ul></li></ul></li><li> Service（<code>nginx-svc</code>）<ul><li>核心作用：<ul><li>为 Pod 提供统一访问入口，实现负载均衡。</li></ul></li><li>核心配置：<ul><li><code>ports.port: 80</code>：Service 暴露的端口</li><li><code>ports.targetPort: 80</code>：转发到 Pod 的容器端口</li><li><code>selector.app: nginx</code>：Service 选择带有 <code>app=nginx</code> 标签的 Pod 作为后端</li></ul></li></ul></li><li> HorizontalPodAutoscaler（<code>nginx-hpa</code>）<ul><li>核心作用：<ul><li>基于 CPU 使用率自动调整 Pod 副本数量，实现弹性伸缩（自动扩容和缩容）。</li></ul></li><li>核心配置：<ul><li><code>scaleTargetRef</code>：指定 HPA 控制器管理的对象，这里为 <code>Deployment/nginx-deployment</code></li><li><code>minReplicas: 1</code>：Pod 副本数量的最小值</li><li><code>maxReplicas: 5</code>：Pod 副本数量的最大值</li><li><code>targetCPUUtilizationPercentage: 50</code>：HPA 控制器会根据 Pod 的 CPU 平均使用率是否达到 <code>50%</code> 来自动扩缩容</li></ul></li></ul></li></ul></li></ul><h5 id="HPA-的扩容高级配置"><a href="#HPA-的扩容高级配置" class="headerlink" title="HPA 的扩容高级配置"></a>HPA 的扩容高级配置</h5><p>在 HPA 中，除了 <code>targetCPUUtilizationPercentage</code> 这种基于 CPU 使用率的扩缩容条件外，还可以配置更多维度的指标，例如内存、Pod 自定义指标、外部 Kubernetes 对象指标、外部监控系统指标等。</p><hr><ul><li><p>API 版本 <code>autoscaling/v1</code>（最基础版本）</p><ul><li>核心作用：<ul><li>只支持 CPU 使用率指标；</li><li>无法基于内存或自定义指标来扩容或缩容，只适用于简单场景。</li></ul></li><li>配置字段：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">50</span>    <span class="comment"># 当 Pod 的 CPU 平均使用率超过 50% 时扩容</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>API 版本 <code>autoscaling/v2beta2</code> 或者 <code>autoscaling/v2</code>（推荐版本）</p><ul><li>核心作用：<ul><li>支持基于多种指标类型来扩容或缩容，通过 <code>metrics</code> 字段配置。</li></ul></li><li>四种核心指标类型：</li></ul><table><thead><tr><th>指标类型</th><th>用途</th><th>示例场景</th><th>是否需要结合 Metrics Adapter（比如 Prometheus Adapter）使用</th></tr></thead><tbody><tr><td> Resource</td><td> 基于 Pod 资源指标（CPU、内存等）</td><td>当 Pod 的 CPU 平均使用率超过 <code>50%</code> 时扩容</td><td>不需要</td></tr><tr><td> Pods</td><td> 基于每个 Pod 计算出的指标</td><td>当每个 Pod 处理的业务请求数超过 1000 时扩容</td><td>需要</td></tr><tr><td> Object</td><td> 基于外部 Kubernetes 对象指标</td><td>根据某个 Service 的 QPS 来扩容</td><td>需要</td></tr><tr><td> External</td><td> 基于外部监控系统指标</td><td>根据 Prometheus 或外部监控系统的 QPS 扩容</td><td>需要</td></tr></tbody></table></li></ul><hr><ul><li>基于资源指标（CPU / 内存）自动扩容和缩容，不需要结合 Metrics Adapter（比如 Prometheus Adapter）使用 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">      <span class="attr">resource:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">          <span class="attr">averageUtilization:</span> <span class="number">50</span>   <span class="comment"># 当 Pod 的 CPU 平均使用率超过 50% 时扩容</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">      <span class="attr">resource:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">memory</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">          <span class="attr">averageValue:</span> <span class="string">200Mi</span>      <span class="comment"># 当 Pod 的内存平均使用量超过 200Mi 时扩容</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>配置字段</th><th>配置作用</th></tr></thead><tbody><tr><td><code>averageUtilization</code></td><td>百分比，基于 Pod CPU 或内存的使用率</td></tr><tr><td><code>averageValue</code></td><td>绝对值，基于 Pod CPU 或内存的使用量</td></tr></tbody></table><ul><li>基于每个 Pod 的自定义指标来自动扩容和缩容，需要结合 Metrics Adapter（比如 Prometheus Adapter）使用，适用于：根据每个 Pod 处理的业务请求数、活跃连接数等指标来扩容 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">      <span class="attr">pods:</span></span><br><span class="line">        <span class="attr">metric:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">requests_per_second</span>    <span class="comment"># Prometheus Adapter 暴露的指标名称</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">          <span class="attr">averageValue:</span> <span class="string">"1000"</span>   <span class="comment"># 当每个 Pod 每秒所处理的业务请求数大于 1000 时扩容</span></span><br></pre></td></tr></tbody></table></figure><ul><li>基于外部 Kubernetes 对象指标来自动扩容和缩容，需要结合 Metrics Adapter（比如 Prometheus Adapter）使用，适用于：根据 Service、Ingress 等对象的指标来扩容 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Object</span></span><br><span class="line">      <span class="attr">object:</span></span><br><span class="line">        <span class="attr">describedObject:</span></span><br><span class="line">          <span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line">          <span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">my-ingress</span></span><br><span class="line">        <span class="attr">metric:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">requests_per_second</span>    <span class="comment"># Prometheus Adapter 暴露的指标名称</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">Value</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"1000"</span>   <span class="comment"># 当该 Ingress 的每秒请求数超过 1000 时扩容</span></span><br></pre></td></tr></tbody></table></figure><ul><li>基于外部监控系统指标来自动扩容和缩容，需要结合 Metrics Adapter（比如 Prometheus Adapter）使用，适用于：根据 Prometheus、CloudWatch、阿里云 ARMS 等外部监控系统指标来扩容 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">External</span></span><br><span class="line">      <span class="attr">external:</span></span><br><span class="line">        <span class="attr">metric:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx_ingress_qps</span>   <span class="comment"># Prometheus Adapter 暴露的指标名称</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">          <span class="attr">averageValue:</span> <span class="string">"2000"</span>  <span class="comment"># 当外部系统的 QPS 大于 2000 时扩容</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">总结说明</p><ul><li>Kubernetes 的 Metrics Server：仅提供 CPU、内存指标，适用于简单扩缩容场景。</li><li>推荐使用 Prometheus + Prometheus Adapter：采集并适配 QPS、连接数、延迟等复杂业务指标供 HPA 使用。</li><li>多个指标组合使用：HPA 支持同时配置 CPU、内存、QPS 等多个指标，最终副本数取最大值，确保系统稳定性。</li><li>生产最佳实践：统一部署 Metrics Server + Prometheus + Prometheus Adapter，构建完整的自动扩缩容体系。</li></ul></div><h5 id="HPA-的缩容高级配置"><a href="#HPA-的缩容高级配置" class="headerlink" title="HPA 的缩容高级配置"></a>HPA 的缩容高级配置</h5><p>在 Kubernetes 的 Horizontal Pod Autoscaler（HPA） 中，自动缩容实际上是自动扩容机制的一部分，一般不需要单独写一个专门的 “缩容配置”。HPA 会根据用户设定的 Metrics 指标，自动计算目标 Pod 副本数量，既包括扩容，也包括缩容。</p><ul><li><p><strong>缩容的核心逻辑</strong></p><ul><li>HPA 会根据当前负载和目标值计算期望 Pod 副本数量：<ul><li>计算公式：<code>desiredReplicas = ceil(currentReplicas × currentMetricValue ÷ targetMetricValue)</code></li><li>如果 <code>desiredReplicas &gt; currentReplicas</code>，HPA 会进行扩容</li><li>如果 <code>desiredReplicas &lt; currentReplicas</code>，HPA 会进行缩容</li></ul></li><li>假设配置里有以下内容，这意味着 Pod 缩容最小会缩到 1 个副本，不会被缩容到 0 个副本 <figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">maxReplicas:</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>如何让缩容生效</strong></p><ul><li><p>(1) HPA 默认就支持缩容，一般不需要额外配置</p><ul><li>比如，当 CPU 或内存使用率持续低于目标值时，Pod 的数量会被逐步缩减，直到达到 <code>minReplicas</code> 限制</li></ul></li><li><p> (2) 如果想控制 Pod 缩容的速度和行为，可以在 <code>spec.behavior</code> 中配置策略</p><ul><li>必须使用 API 版本 <code>autoscaling/v2</code> 或者 <code>autoscaling/v2beta2</code></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">      <span class="attr">resource:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">          <span class="attr">averageUtilization:</span> <span class="number">50</span>             <span class="comment"># 当 Pod 的 CPU 平均使用率超过 50% 时扩容</span></span><br><span class="line">  <span class="attr">behavior:</span></span><br><span class="line">    <span class="attr">scaleDown:</span></span><br><span class="line">      <span class="attr">stabilizationWindowSeconds:</span> <span class="number">300</span>        <span class="comment"># 缩容前观察 5 分钟，避免波动</span></span><br><span class="line">      <span class="attr">policies:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">50</span>                          <span class="comment"># 每次最多缩减 50%</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">60</span>                  <span class="comment"># 每 60 秒评估一次缩容</span></span><br></pre></td></tr></tbody></table></figure></li><li>配置字段：<ul><li><code>stabilizationWindowSeconds</code>：稳定窗口，只有指标持续低于目标值这段时间后才缩容，避免频繁抖动</li><li><code>policies</code>：定义缩容速率，可以按百分比或固定数量缩减 Pod 的数量</li><li><code>periodSeconds</code>：缩容策略评估的时间间隔</li></ul></li></ul></li></ul></li><li><p><strong> Pod 缩容为 0 个副本</strong></p><ul><li>在 Kubernetes 中，当 Pod 缩容到 0 个副本时，指的是 Pod 数量为 0，即一个 Pod 都不会存在（相当于删除所有正在运行的 Pod）。</li><li>如果希望 Pod 完全缩到 0 个副本，HPA 本身做不到，需要配合 KEDA 或 VPA 或 Deployment 的 <code>scale-to-zero</code> 机制。</li><li>但是，如果只是普通业务场景，直接设置 <code>minReplicas: 0</code> 即可让 HPA 在负载极低时将 Pod 缩到 0 个副本：<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure></li><li>注意：当 Pod 缩容到 0 个副本后<ul><li>如果没有请求进来，这个服务将处于完全停机状态</li><li>如果之后有请求到达，Kubernetes 不会自动重建 Pod</li><li> 必须由 HPA 再次检测到指标上升，将 Pod 的副本数量从 0 调整为 1 或更多，Pod 才会被重新启动</li><li>这期间会有冷启动延迟（Pod 拉取镜像、启动应用、健康检查等）</li></ul></li></ul></li><li><p><strong>完整的扩缩容配置示例</strong></p><ul><li>配置示例：<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">      <span class="attr">resource:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">          <span class="attr">averageUtilization:</span> <span class="number">50</span>             <span class="comment"># 当 Pod 的 CPU 平均使用率超过 50% 时扩容</span></span><br><span class="line">  <span class="attr">behavior:</span></span><br><span class="line">    <span class="attr">scaleDown:</span></span><br><span class="line">      <span class="attr">stabilizationWindowSeconds:</span> <span class="number">300</span>        <span class="comment"># 缩容前观察 5 分钟，避免波动</span></span><br><span class="line">      <span class="attr">policies:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">50</span>                          <span class="comment"># 每次最多缩减 50%</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">60</span>                  <span class="comment"># 每 60 秒评估一次缩容</span></span><br></pre></td></tr></tbody></table></figure></li><li>配置效果<ul><li>当 Pod 的 CPU 平均使用率超过 50% 时扩容 </li><li>当 Pod 的 CPU 平均使用率低于 50% 且持续 5 分钟时，每 60 秒最多缩容 50%，直到达到 <code>minReplicas</code> 限制</li></ul></li><li>验证缩容<ul><li>实时查看 HPA 的决策过程：<code>kubectl get hpa nginx-hpa -w</code>，命令的输出结果如下：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME        REFERENCE          TARGETS         MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">nginx-hpa   Deployment/nginx   10%/50%, 80Mi   1         10        3          10m</span><br></pre></td></tr></tbody></table></figure></li><li><code>TARGETS</code>：当前值 VS 目标值</li><li>当 <code>10%/50%</code> 持续低于目标值，<code>REPLICAS</code>（Pod 的副本数量）会逐步减少。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之四</title>
    <link href="https://www.techgrow.cn/posts/37a21b7b.html"/>
    <id>https://www.techgrow.cn/posts/37a21b7b.html</id>
    <published>2025-09-10T13:12:19.000Z</published>
    <updated>2025-09-10T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="Controller-的使用"><a href="#Controller-的使用" class="headerlink" title="Controller 的使用"></a>Controller 的使用</h3><h4 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h4><h5 id="部署无状态应用"><a href="#部署无状态应用" class="headerlink" title="部署无状态应用"></a>部署无状态应用</h5><div class="admonition note"><p class="admonition-title">学习目标</p><p>本节将演示在 Kubernetes 集群中，如何通过 Deployment 部署一个 Nginx 的 Pod，并通过 Service 暴露端口，以便从 Kubernetes 集群外部访问 Nginx。</p></div><blockquote><p>Kubernetes 无状态应用（Stateless）的特点</p></blockquote><ul><li>主要特点：<ul><li>Pod 之间完全一致<ul><li>所有 Pod 完全等价，没有区别，任意一个 Pod 都可以处理请求。</li></ul></li><li>没有启动顺序要求<ul><li> Pod 启动、停止的先后顺序不影响整体业务。</li></ul></li><li>不依赖固定 Node 节点<ul><li> Pod 可以在任意 Node 节点上调度和运行，不需要绑定特定节点。</li></ul></li><li>可随意扩缩容<ul><li> Pod 数量可以随时增加或减少，自动水平扩容（HPA）非常适合。</li></ul></li><li>无持久化存储依赖<ul><li>不保存本地状态，数据通常存储在外部系统中，例如：数据库、对象存储、缓存服务等。</li></ul></li><li>Kubernetes 控制器<ul><li>通常使用 Deployment 管理，支持滚动升级和回滚。</li></ul></li></ul></li><li>典型代表：<ul><li>Nginx、Web 服务、后端接口、无状态微服务。</li></ul></li></ul><blockquote><p>Kubernetes 通过 Deployment 部署无状态应用</p></blockquote><ul><li>生成用于部署一个 Nginx 的 Deployment 的 YAML 配置文件，其中 Deployment 的名称为 <code>nginx</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>自动生成的 YAML 配置文件的内容如下所示 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span>             <span class="comment"># 标签：标识 Deployment 自身</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># 标签：在 Deployment 与 Pod 之间建立管理关系</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> {}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span>         <span class="comment"># 标签：定义 Pod 的身份（标签）</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line"><span class="attr">status:</span> {}</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>配置信息</th><th>作用对象</th><th>核心作用</th><th>简单解释</th></tr></thead><tbody><tr><td><code>metadata.labels</code></td><td>Deployment 自身</td><td>标识 Deployment 自身</td><td>给 Deployment 资源对象自己打上标签，用于被其他资源（如 Service、HPA）查询和选择，或者方便用户管理。它说：” 我是谁。”</td></tr><tr><td><code>spec.selector.matchLabels</code></td><td>Deployment 的选择器</td><td>在 Deployment 与 Pod 之间建立管理关系</td><td> Deployment 用来寻找和管理拥有指定标签的 Pod 的规则。它说：” 哪些 Pod 归我管。”</td></tr><tr><td><code>spec.template.metadata.labels</code></td><td>Pod 模板</td><td>定义 Pod 的身份（标签）</td><td>规定了 Deployment 在创建新 Pod 时会为其打上的标签。它确保了新 Pod 都带有能被选择器识别的标签。它说：” 我创建的 Pod 长这样。”</td></tr></tbody></table><ul><li> 创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Deployment）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-6799fc88d8-jwp6g   1/1     Running   0          29m   10.244.2.18   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 通过 Service 暴露无状态应用</p></blockquote><ul><li>生成 YAML 配置文件，用于为名称为 <code>nginx</code> 的 Deployment 创建一个 NodePort 类型的 Service，将该 Deployment 的 <code>80</code> 端口暴露到 Kubernetes 集群每个节点的静态端口上，以便从集群外部访问 Nginx</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment nginx<span class="params"> --port</span>=80<span class="params"> --type</span>=NodePort<span class="params"> --target</span>-port=80<span class="params"> --name</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx_service.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>自动生成的 YAML 配置文件的内容如下所示 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2025-09-11T10:15:16Z"</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:labels:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:app:</span> {}</span><br><span class="line">      <span class="attr">f:spec:</span></span><br><span class="line">        <span class="attr">f:externalTrafficPolicy:</span> {}</span><br><span class="line">        <span class="attr">f:ports:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="string">k:{"port":80,"protocol":"TCP"}:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:port:</span> {}</span><br><span class="line">            <span class="attr">f:protocol:</span> {}</span><br><span class="line">            <span class="attr">f:targetPort:</span> {}</span><br><span class="line">        <span class="attr">f:selector:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:app:</span> {}</span><br><span class="line">        <span class="attr">f:sessionAffinity:</span> {}</span><br><span class="line">        <span class="attr">f:type:</span> {}</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubectl-expose</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">"2025-09-11T10:15:16Z"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"491002"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/services/nginx</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">e3729f4c-17f9-4100-86dd-2178fe1aa65f</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.106</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">30754</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Service）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_service.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Servcie 列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP        38d</span><br><span class="line">nginx        NodePort    10.0.0.106   &lt;none&gt;        80:30754/TCP   30s</span><br></pre></td></tr></tbody></table></figure><ul><li>通过浏览器访问 <code>http://192.168.2.112:30754</code>，请自行更改 IP 和端口；其中 IP 可以是 Kubernetes 集群任意节点的 IP 地址，端口由 <code>kubectl get svc</code> 命令可得知。若 Ngninx 容器在 Kubernetes 集群中创建并启动成功，则默认会打开 Nginx 的首页。</li></ul><blockquote><p>Kubernetes 删除 Deployment 和 Service</p></blockquote><ul><li>如果需要删除上面创建的 Deployment 和 Service，可以执行以下命令：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除Service</span></span><br><span class="line">kubectl delete service nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除Deployment</span></span><br><span class="line">kubectl delete deployment nginx</span><br></pre></td></tr></tbody></table></figure><h5 id="部署有状态应用"><a href="#部署有状态应用" class="headerlink" title="部署有状态应用"></a>部署有状态应用</h5><div class="admonition note"><p class="admonition-title">学习目标</p><p>本节将演示在 Kubernetes 集群中，如何通过 StatefulSet 部署一个 Nginx 的 Pod，并通过 Headless Service（无头服务）暴露应用，以便从 Kubernetes 集群内部访问。</p></div><blockquote><p>Kubernetes 有状态应用（Stateful）的特点</p></blockquote><ul><li><p>主要特点：</p><ul><li>每个 Pod 独立且不可互换<ul><li>每个 Pod 都有自己的身份、配置、存储，不能随意替换或重建。</li></ul></li><li>需要固定的网络标识<ul><li> Pod 需要固定的名称（DNS）或网络标识符，便于集群内通信，比如 <code>mysql-0.mysql</code>。</li></ul></li><li>有启动和停止顺序<ul><li> Pod 必须按照特定顺序启动或停止。</li><li>例如，先启动主节点，再启动从节点。</li></ul></li><li>需要持久化存储<ul><li>必须使用 PersistentVolume（PV）保证数据不随 Pod 删除而丢失。</li></ul></li><li>Pod 调度位置需要考虑<ul><li> Pod 可能需要绑定特定的 Node 节点，确保存储卷挂载一致性或性能需求。</li></ul></li><li>Kubernetes 控制器<ul><li>使用 StatefulSet 管理，支持：<ul><li>固定的 Pod 命名（如 <code>mysql-0</code>, <code>mysql-1</code>）；</li><li>有序部署、有序扩容和缩容；</li><li>持久化存储与 Pod 一一对应。</li></ul></li></ul></li></ul></li><li><p>典型代表：</p><ul><li>MySQL、Kafka、ZooKeeper、ElasticSearch、Redis Cluster。</li></ul></li></ul><blockquote><p>Kubernetes 通过 StatefulSet 部署有状态应用</p></blockquote><ul><li>创建 YAML 配置文件（比如 <code>nginx_statefulset.yaml</code>），用于通过 StatefulSet 部署一个 Nginx 的 Pod</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-statefulset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 StatefulSet）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_statefulset.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态，可以看到 Pod 的名称是根据一定规则生成的（全局唯一）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-statefulset-0   1/1     Running   0          77s   10.244.2.29   k8s-node3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-statefulset-1   1/1     Running   0          65s   10.244.3.11   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-statefulset-2   1/1     Running   0          37s   10.244.0.15   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 通过 Service 暴露有状态应用</p></blockquote><ul><li>创建 YAML 配置文件（如 <code>nginx_service.yaml</code>），用于通过 Service 暴露有状态应用 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">60</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span>   <span class="comment"># None 表示无头服务（Headless Service）</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">无头服务（Headless Service）是什么</p><ul><li>无头服务是没有虚拟 IP（ClusterIP）的 Service（Headless Service），是一种没有 ClusterIP 的特殊 Service 类型，详细介绍请看 <a href="/posts/6bf07963.html#%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B">这里</a>。</li><li>无头服务可以用于暴露 Kubernetes 集群内 Pod 的真实 IP 和 DNS 名称（域名），而不是通过一个统一的虚拟 IP（ClusterIP）进行负载均衡，即 Kubernetes 不会做流量负载均衡。</li></ul></div><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Service）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_service.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Servcie 列表，可以看到有状态应用的 ClusterIP 为 <code>None</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP   53d</span><br><span class="line">nginx        ClusterIP   None         &lt;none&gt;        60/TCP    2m12s</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>通过 Headless Service 暴露 Pod 后，每个 Pod 都有一个唯一的名称和 DNS 名称（域名），域名格式：<code>&lt;pod-name&gt;.&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>，默认的命名空间（<code>namespace</code>）是 <code>default</code>。</li><li>在 Kubernetes 集群内，可以通过 Pod 的 DNS 域名直接访问 Pod（前提是已经<a href="/posts/ccd6f2d4.html#%E9%83%A8%E7%BD%B2-CoreDNS%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89">部署 CoreDNS</a>），比如：<code>http:://nginx-statefulset-0.nginx.default.svc.cluster.local:80</code>。</li></ul></div><blockquote><p>在 Kubernetes 集群内部，通过 Service 的 DNS 名称（域名）访问有状态应用</p></blockquote><div class="admonition warning"><p class="admonition-title">特别注意</p><p>ClusterIP 为 <code>None</code> 的 Service（Headless Service）只能在 Kubernetes 集群内部访问，如果在集群外部机器（比如直接在集群的 Master 节点）上，通过 Pod 的 DNS 名称直接访问 Pod（比如 <code>http://nginx-statefulset-0.nginx.default.svc.cluster.local:80</code>），肯定是无法访问成功的。</p></div><ul><li>创建一个临时 Pod，并进入 Pod 内部的交互式 Shell</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 --rm 参数，为了在 Shell 中执行 exit 命令退出后自动销毁 Pod</span></span><br><span class="line">kubectl run <span class="built_in">test</span>-pod<span class="params"> --image</span>=busybox:1.35<span class="params"> --restart</span>=Never<span class="params"> -it</span><span class="params"> --rm</span> -- sh</span><br></pre></td></tr></tbody></table></figure><ul><li>在临时 Pod 的内部，可以通过 Service 的 DNS 名称（域名）查询所有匹配 Pod 的 IP（必须保证临时 Pod 与 Service 处于同一个命名空间），域名格式：<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup nginx.default.svc.cluster.<span class="built_in">local</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Server:10.0.0.2</span><br><span class="line">Address:10.0.0.2:53</span><br><span class="line"></span><br><span class="line">Name:nginx.default.svc.cluster.local</span><br><span class="line">Address: 10.244.3.11</span><br><span class="line">Name:nginx.default.svc.cluster.local</span><br><span class="line">Address: 10.244.2.29</span><br><span class="line">Name:nginx.default.svc.cluster.local</span><br><span class="line">Address: 10.244.0.15</span><br></pre></td></tr></tbody></table></figure><ul><li>在临时 Pod 的内部，还可以通过 Pod 的 DNS 名称（域名）直接访问指定的 Pod，域名格式：<code>&lt;pod-name&gt;.&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup nginx-statefulset-0.nginx.default.svc.cluster.<span class="built_in">local</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Server:10.0.0.2</span><br><span class="line">Address:10.0.0.2:53</span><br><span class="line"></span><br><span class="line">Name:nginx-statefulset-0.nginx.default.svc.cluster.local</span><br><span class="line">Address: 10.244.2.29</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者通过 Pod 的 DNS 名称（域名）访问 Nginx 的首页面</span></span><br><span class="line">wget<span class="params"> -qO</span>- http://nginx-statefulset-0.nginx.default.svc.cluster.<span class="built_in">local</span>:80</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 删除 StatefulSet 和 Service</p></blockquote><ul><li>如果需要删除上面创建的 StatefulSet 和 Service，可以执行以下命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 Service</span></span><br><span class="line">kubectl delete service nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 StatefulSet，--cascade=true 参数表示连同 Pod 一起删除，但 PVC 默认不会被删除（如果存在）</span></span><br><span class="line">kubectl delete statefulset nginx-statefulset<span class="params"> --cascade</span>=<span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><h5 id="部署守护进程"><a href="#部署守护进程" class="headerlink" title="部署守护进程"></a>部署守护进程</h5><div class="admonition note"><p class="admonition-title">note</p><ul><li>本节将演示在 Kubernetes 集群中，如何通过 DaemonSet 在每个 Node（工作节点）上分别部署一个守护进程。</li><li>这里的守护进程是指节点级的后台服务，比如日志收集（Filebeat）、网络插件（Flannel）、监控代理（Prometheus Node Exporter）等服务，为了方便演示，下面直接使用 Nginx 来代替。</li></ul></div><blockquote><p>Kubernetes 中 DaemonSet 的主要功能和适用场景</p></blockquote><ul><li><p>主要功能：</p><ul><li>在每个节点上运行一个指定的 Pod<ul><li> 自动在集群中每个符合条件的节点上部署且只运行一个指定的 Pod 实例。</li></ul></li><li>节点加入自动部署<ul><li>当新节点加入集群时，DaemonSet 会自动在该节点上调度并启动 Pod。</li></ul></li><li>节点移除自动回收<ul><li>节点被移除或不可用时，对应 Pod 会自动删除，保持一致性。</li></ul></li><li>不支持手动扩容 / 缩容<ul><li> Pod 的副本数量与节点数量直接关联，不支持手动管理 <code>replicas</code>。</li></ul></li><li>支持滚动更新与回滚<ul><li>可平滑升级版本，并在出现问题时快速回滚。</li></ul></li><li>可结合节点选择器、节点亲和性、污点 / 容忍等使用<ul><li>支持精确控制 DaemonSet Pod 部署在哪些节点上。</li></ul></li><li>与 Deployment 区别<ul><li> Deployment：通常用于无状态服务，副本数固定，由用户定义。</li><li>DaemonSet：与节点数量绑定，强调 “每个节点一个 Pod”。</li></ul></li><li>删除行为可控<ul><li>使用 <code>kubectl delete daemonset</code> 删除 DaemonSet 时，可通过 <code>--cascade=orphan</code> 参数控制是否保留关联的 Pod。</li></ul></li></ul></li><li><p>适用场景：</p><ul><li>日志收集<ul><li>部署日志收集 Agent（如 Fluentd、Logstash、Filebeat），保证每个节点日志都能被采集。</li></ul></li><li>监控与指标采集<ul><li>例如 Prometheus Node Exporter、Datadog Agent、cAdvisor 等，采集节点和 Pod 的监控指标。</li></ul></li><li>网络插件或 CNI 管理<ul><li> Kubernetes CNI 插件通常以 DaemonSet 运行，例如 Calico、Flannel、Cilium 等。</li></ul></li><li>存储插件或 CSI 驱动<ul><li>如 Ceph、Rook 等分布式存储系统的节点守护进程。</li></ul></li><li>安全与合规审计<ul><li>如 Falco、Sysdig Secure 等安全审计或防护 Agent。</li></ul></li><li>节点运维任务<ul><li>自动在每个节点运行健康检查、系统维护脚本或运维工具。</li></ul></li></ul></li></ul><blockquote><p>Kubernetes 通过 DaemonSet 部署守护进程</p></blockquote><ul><li>创建 YAML 配置文件（比如 <code>nginx_daemonset.yaml</code>），用于通过 DaemonSet 在每个节点上分别部署一个 Nginx 的 Pod，，并将宿主机内的 <code>/var/log</code> 目录挂载到容器内部的 <code>/tmp/log</code> 目录（可选操作）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-daemonset</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># DaemonSet 资源自身的标签，用于标识和选择这个 DaemonSet 资源</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># DaemonSet 选择器标签，用于匹配和管理具有此标签的 Pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># Pod 模板标签，DaemonSet 创建的每个 Pod 都会被打上这个标签</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/tmp/log</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/log</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 DaemonSet）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_daemonset.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 DaemonSet 的状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get daemonset nginx-daemonset</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME              DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">nginx-daemonset   4         4         4       4            4           &lt;none&gt;          6m17s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态，可以发现每个 Node（工作节点）都部署了一个 Nginx 的 Pod</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                    READY   STATUS    RESTARTS   AGE   IP            NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-daemonset-mhxpg   1/1     Running   0          4s    10.244.2.35   k8s-node3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-daemonset-nsb7r   1/1     Running   0          4s    10.244.1.16   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-daemonset-p9k2d   1/1     Running   0          4s    10.244.3.17   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>进入某个 Pod 内部查看挂载的日志文件 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入某个 Pod 的内部</span></span><br><span class="line">kubectl <span class="built_in">exec</span><span class="params"> -it</span> nginx-daemonset-p9k2d bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod 内部的日志文件</span></span><br><span class="line">ls /tmp/<span class="built_in">log</span>/</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 删除 DaemonSet</p></blockquote><ul><li>如果需要删除上面创建的 DaemonSet，可以执行以下命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 DaemonSet，会级联删除该 DaemonSet 以及由它创建的所有 Pod</span></span><br><span class="line">kubectl delete daemonset nginx-daemonset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 --cascade=orphan 参数，只删除 DaemonSet，但保留它创建的所有 Pod</span></span><br><span class="line">kubectl delete daemonset nginx-daemonset<span class="params"> --cascade</span>=orphan</span><br></pre></td></tr></tbody></table></figure><h5 id="部署一次性任务"><a href="#部署一次性任务" class="headerlink" title="部署一次性任务"></a>部署一次性任务</h5><div class="admonition note"><p class="admonition-title">提示</p><p>本节将演示在 Kubernetes 集群中，如何通过 Job 执行一次性任务。</p></div><blockquote><p>Kubernetes 中 Job 的主要功能和适用场景</p></blockquote><ul><li><p>主要功能</p><ul><li>执行一次性任务，保证任务至少成功执行一次<ul><li> Job 会确保定义的 Pod 按照预期执行，直到成功完成（运行状态为 <code>Completed</code>）。</li><li>Pod 运行失败时，Job 会根据重试策略自动重新创建新的 Pod 继续执行任务。</li></ul></li><li>支持并行或串行执行<ul><li>可以通过 <code>spec.parallelism</code> 控制同时运行的 Pod 数量；</li><li>可以通过 <code>spec.completions</code> 控制任务总共需要成功完成的 Pod 数量。</li></ul></li><li>适合一次性任务，执行完成后不会再次运行<ul><li> Job 完成后，Pod 不会被自动删除，但状态保持为 <code>Completed</code>；</li><li>可以通过配置 TTL 控制器自动清理已完成的 Job 及 Pod。</li></ul></li></ul></li><li><p>适用场景</p><ul><li>一次性批处理作业<ul><li>数据清理、日志分析、批量数据转换等。</li></ul></li><li>离线计算任务<ul><li>机器学习模型训练、视频转码、大数据计算等。</li></ul></li><li>自动化任务<ul><li>备份数据库、生成报表、执行临时脚本等。</li></ul></li><li>测试任务<ul><li>压力测试、集成测试或单次验证任务。</li></ul></li></ul></li></ul><blockquote><p>Kubernetes 通过 Job 执行一次性任务</p></blockquote><ul><li>创建 YAML 配置文件（比如 <code>pi_job.yaml</code>），用于通过 Job 执行一次 Perl 脚本（计算圆周率）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi-job</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># completions: 3                # 总共需要 3 个 Pod 完成任务</span></span><br><span class="line">  <span class="comment"># parallelism: 2                # 最多允许 2 个 Pod 并行运行</span></span><br><span class="line">  <span class="comment"># ttlSecondsAfterFinished: 60   # 任务执行完成后 60 秒自动清理</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span>                 <span class="comment"># 任务执行失败后，最大重试次数为 4</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">"perl"</span>, <span class="string">"-Mbignum=bpi"</span>, <span class="string">"-wle"</span>, <span class="string">"print bpi(2000)"</span>]    <span class="comment"># 计算圆周率，并打印日志信息</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span>        <span class="comment"># Pod 失败（任务执行失败）时的重启策略</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Job）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">pi_job.yaml</span></span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Job 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get <span class="built_in">jobs</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME     COMPLETIONS   DURATION   AGE</span><br><span class="line">pi-job   1/1           25s        25s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态，可以发现当 Job（一次性任务）执行完成后，Pod 的状态会切换为 <code>Completed</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME       READY   STATUS      RESTARTS   AGE   IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">pi-ks6pn   0/1     Completed   0          41s   10.244.2.36   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Pod 的日志信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs pi-ks6pn</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 删除 Job</p></blockquote><ul><li>如果需要删除上面创建的 Job，可以执行以下命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 Job，会级联删除该 Job 以及由它创建的所有 Pod</span></span><br><span class="line">kubectl delete job pi-job</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 --cascade=orphan 参数，只删除 Job，但保留它创建的所有 Pod</span></span><br><span class="line">kubectl delete job pi-job<span class="params"> --cascade</span>=orphan</span><br></pre></td></tr></tbody></table></figure><h5 id="部署定时任务"><a href="#部署定时任务" class="headerlink" title="部署定时任务"></a>部署定时任务</h5><div class="admonition note"><p class="admonition-title">提示</p><p>本节将演示在 Kubernetes 集群中，如何通过 CronJob 周期性（定时）执行任务。</p></div><blockquote><p>Kubernetes 中 CronJob 的主要功能和适用场景</p></blockquote><ul><li><p>主要功能</p><ul><li>周期性任务调度<ul><li>使用 <code>cron</code> 表达式定义执行计划，精确到分钟；</li><li>可在每天、每周、每月或特定时间点自动运行任务。</li></ul></li><li>自动创建 Job<ul><li>CronJob 在到达调度时间后，会自动创建对应的 Job 资源；</li><li>Job 负责任务的执行、失败重试和状态维护。</li></ul></li><li>控制并发执行<ul><li>可通过 <code>concurrencyPolicy</code> 控制多次调度的 Job 是否允许并发执行：<ul><li><code>Allow</code>：允许多个任务并发运行；</li><li><code>Forbid</code>：禁止并发，若上一个任务未完成，跳过新的调度；</li><li><code>Replace</code>：如果上一个任务未完成，先删除旧任务，再启动新任务。</li></ul></li></ul></li><li>支持任务历史管理<ul><li>可以配置保留的成功任务和失败任务历史数量，避免资源无限增长。</li></ul></li><li>支持一次性定时任务<ul><li>通过指定一次性运行的时间点，实现一次性定时触发的 Job。</li></ul></li></ul></li><li><p>适用场景</p><ul><li>定时数据处理<ul><li>每天凌晨自动跑批处理作业，生成统计报表；</li><li>定时清理临时文件或过期数据。</li></ul></li><li>数据库备份<ul><li>每天或每小时自动执行数据库备份任务。</li></ul></li><li>日志归档<ul><li>定期收集、压缩和上传日志文件到集中存储。</li></ul></li><li>周期性健康检查<ul><li>定时执行诊断脚本或检查任务，输出报告。</li></ul></li><li>定时通知或消息推送<ul><li>定时触发消息发送、告警提醒或业务事件。</li></ul></li><li>一次性延时执行任务<ul><li>通过设置特定时间点，完成一次性延时任务的执行。</li></ul></li></ul></li></ul><blockquote><p>Kubernetes 通过 CronJob 运行定时任务</p></blockquote><ul><li>创建 YAML 配置文件（比如 <code>hello_cronjob.yaml</code>），用于通过 CronJob 周期性地执行 Shell 脚本（打印日志信息）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-cronjob</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">"*/1 * * * *"</span>            <span class="comment"># Cron 表达式</span></span><br><span class="line">  <span class="comment"># concurrencyPolicy: Forbid        # 禁止并发执行任务</span></span><br><span class="line">  <span class="comment"># startingDeadlineSeconds: 300     # 最长允许任务延迟启动 5 分钟</span></span><br><span class="line">  <span class="comment"># successfulJobsHistoryLimit: 3    # 保留最近 3 次执行成功的任务</span></span><br><span class="line">  <span class="comment"># failedJobsHistoryLimit: 1        # 保留最近 1 次执行失败的任务</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">            <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">date;</span> <span class="string">echo</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">the</span> <span class="string">Kubernetes</span> <span class="string">cluster</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span>    <span class="comment"># Pod 失败（任务执行失败）时的重启策略</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 CronJob）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> hello_cronjob.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 CronJob 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get cronjobs</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME            SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="line">hello-cronjob   */1 * * * *   False     0        49s             52s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Job 的运行状态，CronJob 不直接创建和运行 Pod，所有 Pod 都由其生成的 Job 进行管理 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get <span class="built_in">jobs</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                       COMPLETIONS   DURATION   AGE</span><br><span class="line">hello-cronjob-1759064520   1/1           17s        3m11s</span><br><span class="line">hello-cronjob-1759064580   1/1           13s        2m20s</span><br><span class="line">hello-cronjob-1759064640   1/1           17s        78s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态，可以发现当 CronJob 每次执行完成后，Pod 的状态会切换为 Completed</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                             READY   STATUS      RESTARTS   AGE     IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">hello-cronjob-1759064340-mfppj   0/1     Completed   0          2m28s   10.244.2.38   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">hello-cronjob-1759064400-djk6l   0/1     Completed   0          86s     10.244.2.39   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">hello-cronjob-1759064460-5lbxj   0/1     Completed   0          25s     10.244.3.18   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Pod 的日志信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs hello-cronjob-1759064460-5lbxj</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sun Sep 28 13:01:26 UTC 2025</span><br><span class="line">Hello from the Kubernetes cluster</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 删除 CronJob</p></blockquote><ul><li>如果需要删除上面创建的 CronJob，可以执行以下命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 CronJob，会级联删除该 CronJob 以及由它创建的所有 Job 和 Pod</span></span><br><span class="line">kubectl delete cronjob hello-cronjob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 --cascade=orphan 参数，只删除 CronJob，但保留它创建的所有 Job 和 Pod</span></span><br><span class="line">kubectl delete cronjob hello-cronjob<span class="params"> --cascade</span>=orphan</span><br></pre></td></tr></tbody></table></figure><h4 id="应用升级回滚"><a href="#应用升级回滚" class="headerlink" title="应用升级回滚"></a>应用升级回滚</h4><div class="admonition note"><p class="admonition-title">学习目标</p><p>本节将演示在 Kubernetes 集群中部署 Nginx 后，如何升级 Nginx 的版本，还有如何回滚 Nginx 的版本。</p></div><h5 id="部署应用-1"><a href="#部署应用-1" class="headerlink" title="部署应用"></a>部署应用</h5><ul><li>生成用于部署一个 Nginx 的 Deployment 的 YAML 配置文件，其中 Deployment 的名称为 <code>nginx</code>，Nginx 的版本号为 <code>1.14</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx<span class="params"> --image</span>=nginx:1.14<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>更改自动生成的 YAML 配置文件内容（如下所示），将 <code>replicas</code> 改为 <code>2</code>（表示 Pod 有两个副本）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span>             <span class="comment"># 标签：标识 Deployment 自身</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># 标签：在 Deployment 与 Pod 之间建立管理关系</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> {}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span>         <span class="comment"># 标签：定义 Pod 的身份（标签）</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line"><span class="attr">status:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Deployment）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5658bdf5d4-6sbmg   1/1     Running   0          31m   10.244.1.2   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-5658bdf5d4-ksjgm   1/1     Running   0          31m   10.244.3.2   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><h5 id="升级应用版本"><a href="#升级应用版本" class="headerlink" title="升级应用版本"></a>升级应用版本</h5><ul><li>当执行完上述步骤将 Nginx 部署到 Kubernetes 集群后，可以执行以下命令来升级 Nginx 的版本（比如，将 Nginx 升级到 <code>1.15</code> 版本）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment nginx nginx=nginx:1.15</span><br></pre></td></tr></tbody></table></figure><ul><li>查看应用升级版本的状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout status deployment nginx</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-764b95f4c5-f744r   1/1     Running   0          31m   10.244.1.2   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-764b95f4c5-w96gl   1/1     Running   0          31m   10.244.3.2   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><hr><ul><li>若执行完应用升级版本的命令后，在查看所有 Pod 的运行状态时，新 Pod 的 <code>STATUS</code> 一直显示 <code>ContainerCreating</code>，则说明应用升级版本存在问题 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS              RESTARTS   AGE     IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5658bdf5d4-6sbmg   1/1     Running             0          77m     10.244.1.2    k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-764b95f4c5-f744r   1/1     Running             0          27m     10.244.2.19   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-764b95f4c5-w96gl   0/1     ContainerCreating   0          3m36s   &lt;none&gt;        k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>可以执行以下命令来排查问题（比如，原因是一直卡在拉取镜像的环节上）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod nginx-764b95f4c5-w96gl</span><br></pre></td></tr></tbody></table></figure><ul><li>若无法排查应用升级版本的问题，则可以删除卡住的 Pod 以触发重建 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod nginx-764b95f4c5-w96gl</span><br></pre></td></tr></tbody></table></figure><ul><li>若无法排查应用升级版本的问题，又急需恢复服务，最快捷的方法是回滚（回退）到上一个版本（即用旧版本的 Pod 替换掉所有新版本的 Pod），之后服务会逐渐恢复正常 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment nginx</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Kubernetes 在升级应用的版本时，是不会中断服务的（比如，升级期间 Nginx 依然可以对外提供服务），这主要归功于其精细的流量控制和渐进的替换过程。具体是通过 Deployment 控制器，先启动新版本的 Pod 并确认其就绪，然后逐步终止旧版本的 Pod，同时 Service 的负载均衡器会确保流量只路由到健康的 Pod 上，从而实现了服务的平滑升级。</p></div><h5 id="回滚应用版本"><a href="#回滚应用版本" class="headerlink" title="回滚应用版本"></a>回滚应用版本</h5><ul><li>当执行完上述步骤将 Nginx 的版本从 <code>1.14</code> 升级到 <code>1.15</code> 后，若希望回滚到旧的版本（即用旧版本的 Pod 替换掉所有新版本的 Pod），可以执行以下命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Deployment 的所有历史版本</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment nginx</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回滚 Deployment 到上一个版本</span></span><br><span class="line">kubectl rollout undo deployment nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚 Deployment 到指定的版本</span></span><br><span class="line">kubectl rollout undo deployment nginx<span class="params"> --to</span>-revision=2</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5658bdf5d4-6sbmg   1/1     Running   0          31m   10.244.1.2   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-5658bdf5d4-ksjgm   1/1     Running   0          31m   10.244.3.2   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="应用弹性伸缩"><a href="#应用弹性伸缩" class="headerlink" title="应用弹性伸缩"></a>应用弹性伸缩</h4><div class="admonition note"><p class="admonition-title">学习目标</p><p>本节将演示在 Kubernetes 集群中部署 Nginx 后，如何对 Nginx 进行扩容（即增加 Pod 的副本数量）。</p></div><h5 id="部署应用-2"><a href="#部署应用-2" class="headerlink" title="部署应用"></a>部署应用</h5><ul><li>生成用于部署一个 Nginx 的 Deployment 的 YAML 配置文件，其中 Deployment 的名称为 <code>nginx</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>自动生成的 YAML 配置文件的内容如下所示 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span>             <span class="comment"># 标签：标识 Deployment 自身</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># 标签：在 Deployment 与 Pod 之间建立管理关系</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> {}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span>         <span class="comment"># 标签：定义 Pod 的身份（标签）</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line"><span class="attr">status:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Deployment）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5658bdf5d4-kt6fv   1/1     Running   0          29m   10.244.2.18   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><h5 id="应用扩缩容"><a href="#应用扩缩容" class="headerlink" title="应用扩缩容"></a>应用扩缩容</h5><ul><li>当执行完上述步骤将 Nginx 部署到 Kubernetes 集群后，可以执行以下命令来对 Pod 的副本数进行扩缩容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 Pod 的副本进行扩容（比如，扩容至 3 个副本）</span></span><br><span class="line">kubectl scale deployment nginx<span class="params"> --replicas</span>=3</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP           NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5658bdf5d4-kt6fv   1/1     Running   0          29m     10.244.0.7   k8s-node3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-5658bdf5d4-tbvzz   1/1     Running   0          2m55s   10.244.1.3   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-5658bdf5d4-z48mx   1/1     Running   0          2m57s   10.244.3.6   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>如何设计可以动态扩容缩容的分库分表方案</title>
    <link href="https://www.techgrow.cn/posts/af97a1f4.html"/>
    <id>https://www.techgrow.cn/posts/af97a1f4.html</id>
    <published>2025-08-22T13:12:19.000Z</published>
    <updated>2025-08-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/af97a1f4.html">如何设计可以动态扩容缩容的分库分表方案</a></li><li><a href="/posts/2df884fd.html">分库分表后，生产环境如何实现不停机迁移数据</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线上系统已经完成了分库分表方案的落地：库表建好、基于分库分表中间件的开发与测试也都顺利完成，数据能够均匀分布到各个库表中，系统也通过双写方案平滑迁移并成功切换到分库分表架构上。然而，随着业务持续增长，现有的库表再次面临瓶颈：单库容量接近上限、单表数据量过大、单库写入并发压力过高等问题，必须进行进一步的扩容。比如，原来是 3 个库，每个库 4 个表，现在需要扩容成 6 个库，每个库 8 个表。问题是：如何在不影响线上业务（即不停机）的情况下，进行动态扩容或缩容呢？</p><span id="more"></span><h2 id="停机扩容"><a href="#停机扩容" class="headerlink" title="停机扩容"></a>停机扩容</h2><p>停机扩容与 <a href="/posts/2df884fd.html#%E5%81%9C%E6%9C%BA%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE">停机迁移数据</a> 类似，步骤基本相同，唯一的区别是需要使用数据导入工具，将现有库表中的数据抽取并导入到新的库表中。但这种方式并不推荐，原因在于：既然已经采用了分库分表，说明数据量非常庞大，可能达到数亿甚至几十亿条记录，此时再采用停机迁移的方式风险极高。从单库单表迁移到分库分表架构时，数据量尚可接受，单表最多两三千万条，通过开发数据迁移工具，使用多台机器并行处理，1 小时内就能完成导入。但当系统基于分库分表架构运行一段时间后，例如当前有一共 3 个库和 12 个表，数据量达到 1 亿 ～ 2 亿条，仅导入数据就需要数小时。假设 6 点开始导入数据，直到导入完成，后续还要修改数据库连接配置、重新部署系统、业务测试验证，往往到 10 点才能完成，停机时间过长，线上业务无法承受。</p><h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><p>一开始就将分库分表架构规划为 32 个库，每个库 32 张表，共 1024 张表。这种设计基本能够满足国内大多数互联网公司的需求，无论是支撑并发能力还是数据容量都没有问题。通过一次性规划足够的库表数量（如 32 个库，每个库 32 张表）+ 固定取模路由规则（<code>2^n</code>）+ DBA 库级迁移工具支持，既能保证早期部署简单，又能支持后期平滑扩容或缩容，避免频繁停机迁移和复杂的数据重新分片工作。</p><ul><li>性能预估：<ul><li>每个库可承载约 1000 TPS（写入并发），则 32 个库总共可支撑 32000 TPS。</li><li>如果每个库承载到 1500 TPS，则总共可达 48000 TPS，接近 5 万 /s。</li><li>前端再加一个消息队列（MQ）进行削峰：<ul><li>MQ 写入 QPS 可达 8 万 /s，MQ 消费 QPS 可达 5 万 /s，可平滑处理高并发写入。</li></ul></li></ul></li><li>容量规划：<ul><li>32 个库，每个库 32 张表。</li><li>一共 1024 张表，每表存 500 万条数据，总容量可达 50 亿条数据。</li><li>对于国内绝大多数互联网公司，这个规模一般足够支撑多年。</li></ul></li><li>路由规则：<ul><li>库路由：<code>orderId % 32</code> → 确定库。</li><li>表路由：<code>(orderId / 32) % 32</code> → 确定表，必须先将 <code>orderId</code> 除以库数量，再对表数量进行取模运算，目的是：<ul><li>避免表内数据分布不均，导致热点数据集中在某几个表或库；</li><li>将数据均匀打散到 32 个库 × 32 张表，每个库内部的 32 张表都能均匀分布数据；</li><li>避免表的分布就和库的分布耦合在一起，比如库 0 里永远只会使用到表 0，库 1 永远只会使用到表 1；</li></ul></li><li>这种 基于 <code>2^n</code> 的取模方案，天然支持倍数扩容和缩容，减少扩容时路由规则变更的复杂度。</li></ul></li><li>扩容策略：<ul><li>首次分库分表就 “一步到位”，建立 32 个库，每个库 32 张表，避免频繁扩容。</li><li>早期阶段：<ul><li>可将多个逻辑库部署在同一台 MySQL 服务器上，例如 4 台 MySQL 服务器，每台 MySQL 服务器创建 8 个库，一共有 32 个库。</li></ul></li><li>后期扩展：<ul><li>当 MySQL 单机实例压力过大，可以申请多台 MySQL 服务器，进行倍数扩容（如从 4 台扩展至 8 台）；</li><li>扩容时只需要不断地在旧库和新的 MySQL 服务器之间做数据迁移，然后系统仅需更改库的连接地址，重新发布即可，路由规则无需变更；</li><li>最多可扩展至 32 台 MySQL 服务器（每台一个库，每个库 32 张表）。</li></ul></li></ul></li><li>缩容策略：<ul><li>如果需要减少 MySQL 服务器的数量，可以进行倍数缩容（如从 8 台扩展至 4 台），即物理合并 MySQL 服务器（保持逻辑库的总数量不变）；</li><li>比如，原来 32 个库分布在 8 台 MySQL 服务器上，现在迁移到 4 台 MySQL 服务器上，每台 MySQL 服务器上有 8 个库；</li><li>只需要将部分库的数据迁移到其他 MySQL 服务器，然后系统仅需更改库的连接地址，重新发布即可，路由规则无需变更。</li></ul></li><li>优势总结：<ul><li>DBA 通过成熟的工具迁移旧库至新的 MySQL 服务器即可完成扩缩容，业务代码无需处理复杂的数据迁移逻辑。</li><li>这种分库分表规划减少了后期频繁改造的成本，也能较好应对未来业务增长。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何设计可以动态扩容缩容的分库分表方案。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="架构设计" scheme="https://www.techgrow.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分库分表后，生产环境如何实现不停机迁移数据</title>
    <link href="https://www.techgrow.cn/posts/2df884fd.html"/>
    <id>https://www.techgrow.cn/posts/2df884fd.html</id>
    <published>2025-08-21T13:12:19.000Z</published>
    <updated>2025-08-21T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/af97a1f4.html">如何设计可以动态扩容缩容的分库分表方案</a></li><li><a href="/posts/2df884fd.html">分库分表后，生产环境如何实现不停机迁移数据</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假设，目前线上系统是单库单表（即未分库分表），单表已有约 600 万条数据。计划将数据迁移到 3 个库、每个库 4 张表的分库分表架构中，每张表存放约 50 万条数据。已经选定了分库分表的中间件（例如 Sharding-JDBC 或 Mycat），问题是：如何在不影响线上业务（即不停机）的情况下，将系统平滑迁移到新的分库分表架构上？</p><div class="admonition note"><p class="admonition-title">为什么要分库分表？</p><p>分库分表主要有两个原因，要不就是单库并发压力太高，要不就是单库数据量太大。</p></div><span id="more"></span><h2 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h2><h3 id="停机迁移数据"><a href="#停机迁移数据" class="headerlink" title="停机迁移数据"></a>停机迁移数据</h3><p>这里先介绍一种不常用的方案 - 停机迁移，相对比较简单、粗暴，技术含量不高。在网站或 App 提前发布公告，通知用户 0 点到 6 点期间系统停机维护。凌晨 0 点开始运维，到点后先停机，系统停止服务，不再有新的流量写入，此时旧的单库单表数据库保持静止。接着运行事先准备好的一次性数据迁移工具，把单库单表中的数据批量导出，并按照分库分表规则导入到新库中。数据导入完成后，更新系统的数据库连接配置，同时上线新版本代码（因为分库分表后 SQL 或数据访问逻辑可能有改动）。最后启动系统，连接新的分库分表架构，进行业务验证。如果业务验证通过，就算迁移完成。不过，这种 “停机迁移” 的方案相对比较简单、粗暴，技术含量不高。</p><p><img data-src="../../../asset/2025/08/database-split-1.png"></p><blockquote><p>停机迁移方案通常包括以下几个核心步骤：</p></blockquote><ul><li>(1) 读取数据<ul><li>按分页（<code>limit/offset</code> 或者主键范围）从旧表里分批读取数据，避免一次性读 600 万导致 OOM 或锁表。</li><li>典型做法：<ul><li>根据主键（比如自增 ID）按范围扫描：<code>select * from old_table where id between x and y</code></li><li>每次取 1w ~ 5w 条，批量处理。</li></ul></li></ul></li><li>(2) 路由规则计算（分库分表规则映射）<ul><li>根据预设的分库分表规则（比如 <code>user_id % 6</code> → 定位到某个库某个表）。</li><li>数据迁移工具对每一条数据计算：<ul><li>属于哪个分库</li><li>属于哪个分表</li></ul></li><li>举个例子： <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user_id = 1025</span><br><span class="line">库号 = user_id % 3   （0 ~ 2）</span><br><span class="line">表号 = user_id % 4   （0 ~ 3）</span><br><span class="line">最终落点 = db_2.user_table_1</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>(3) 写入新库<ul><li>批量插入目标分表（<code>batch insert</code>），减少网络往返。</li><li>写入前可能需要做：<ul><li>字段映射（比如旧表字段和新表字段不完全一致）</li><li>数据清洗（处理非法数据、空值等）</li><li>主键处理（旧表用自增 ID，新表可能使用雪花 ID 或 UUID，需要重新生成）</li></ul></li></ul></li><li>(4) 数据校验<ul><li>迁移完一批数据后，进行校验：<ul><li>数量校验：源表 10 万条数据，目标表分散后总和也应该是 10 万条数据。</li><li>抽样校验：随机抽几条数据，对比新旧库的字段值是否一致。</li><li>全量校验（可选）：做 MD5 校验，或者比对哈希值。</li></ul></li></ul></li><li>(5) 日志与容错<ul><li>每批迁移要有日志，记录成功或者失败。</li><li>失败的数据要单独写入 “重试队列”。</li><li>支持断点续传（例如数据迁移中断，可以从上次 ID 继续跑）。</li></ul></li><li>(6) 收尾工作<ul><li>所有数据迁移完毕，全量校验通过。</li><li>更新系统的数据库连接配置，让系统指向新的分库分表架构。</li><li>上线新版本代码（因为分库分表后 SQL 或数据访问逻辑可能有调整）。</li><li>重启服务，进行业务验证，确认无误后切换工作正式完成。</li></ul></li></ul><h2 id="不停机迁移方案"><a href="#不停机迁移方案" class="headerlink" title="不停机迁移方案"></a>不停机迁移方案</h2><h3 id="双写迁移数据"><a href="#双写迁移数据" class="headerlink" title="双写迁移数据"></a>双写迁移数据</h3><p>双写迁移是目前最常用且较为稳妥的一种迁移方式，优点是不需要停机，也不用熬夜等凌晨运维窗口。核心思路：在系统中对所有写库操作（增、删、改）进行改造，不仅写入旧库，同时也写入新库，即所谓的 “双写”。这样可以保证在迁移期间，新库持续写入最新数据。在此基础上，通常需要配合以下机制：</p><ul><li><code>数据同步</code>：迁移启动前，先通过全量复制将旧库的历史数据导入新库，再通过 Binlog 或数据同步程序保证新旧库实时增量同步。这样新库能够与旧库保持一致性，不会出现 “有新数据但未同步” 的情况。</li><li><code>数据比对</code>：迁移过程中，需要定期进行新旧库的数据校验（例如按主键范围抽样比对行数、字段值校验、聚合校验等），确保两边数据在数量和内容上保持一致，避免出现漏同步、同步延迟或数据不一致的问题。</li><li><code>补偿机制</code>：若比对过程中发现差异，可通过重放 Binlog、补偿 SQL 或自动修复任务进行数据回补，保证最终一致性。补偿一般在后台异步执行，不影响业务正常运行。</li></ul><p><img data-src="../../../asset/2025/08/database-split-2.png"></p><blockquote><p>双写迁移方案通常包括以下几个核心步骤：</p></blockquote><ul><li>(1) 数据实时同步<ul><li>首先开发并部署一个数据同步程序，将旧库的历史数据全量复制到新库中。由于旧库仍然在对外提供写服务（例如订单持续写入），同步程序还需要实时捕获旧库的增量变更并写入新库。核心思路是 “全量复制 + 增量实时同步”。</li><li>数据实时同步的常见做法是基于 MySQL Binlog 实时同步，通过解析 Binlog 日志捕获 <code>INSERT/UPDATE/DELETE</code> 操作，再写入新库，从而保证新旧库数据基本保持一致。</li><li>写入新库时，可以通过 <code>gmt_modified</code> 等时间戳字段进行判断：若新库不存在该数据，则直接插入；若新库已有该数据，但旧库的版本更新（修改时间更晚），则覆盖写入。</li><li>这一过程对旧库和业务系统无侵入性，不需修改应用代码，也无需回滚，仅需额外部署新库和同步程序；即使同步程序对旧库产生影响，也可随时停掉，不影响线上业务。</li></ul></li><li>(2) 双写改造与部署<ul><li>在业务系统中改造写操作，使所有增删改操作同时作用于旧库和新库。常见方案包括：<ul><li><code>数据库中间件拦截</code>：利用 ShardingSphere、MyCAT 等支持双写或路由功能的中间件，在代理层统一拦截写操作，实现业务层零改动即可完成双写。但需关注复杂 SQL 与事务支持情况，确保中间件稳定可靠。</li><li><code>ORM/AOP 层拦截</code>：在 ORM 框架或 AOP 拦截器层统一实现双写逻辑，例如通过 MyBatis 插件 + 多数据源实现。业务层透明感知数据库操作即可完成双写，同时可顺带处理幂等、异常重试和事务顺序控制，前提是系统使用统一的 ORM 框架。</li><li><code>Binlog 增量同步</code>：也可继续使用 Binlog 方式（Canal、Maxwell、Debezium 等）捕获旧库变更并实时写入新库，这种方式对业务无侵入，适合大数据量场景，但需保证 Binlog、网络和同步工具的稳定性，并结合全量导入和校验机制保障数据完整性。</li></ul></li><li>上线部署系统完成双写改造的新版本代码，然后停掉前期的数据同步程序，确保新写入数据由业务逻辑直接写入新库。</li></ul></li><li>(3) 数据比对与补偿<ul><li>由于双写策略也不保证新旧库的强一致性，此时需要上线一个数据比对与补偿程序。</li><li>数据比对与补偿程序会对比旧库近期的数据变更，逐表逐行校验新旧库的数据是否一致。</li><li>若发现不一致的数据，则从旧库读取并写入新库进行补偿。</li><li>该过程可能需要多轮循环，直至新旧库数据完全一致。</li></ul></li><li>(4) 切换到新库<ul><li>当确认新旧库数据完全一致后，可以停掉数据比对和补偿程序。</li><li>上线部署仅依赖分库分表、去掉双写逻辑的新版本代码。</li><li>重新部署系统，此时所有读写流量切换到新库，旧库逐步进入下线流程。</li></ul></li></ul><blockquote><p>双写迁移方案需要注意以下地方：</p></blockquote><ul><li>事务一致性<ul><li>旧库与新库之间无法保证强一致事务，必须容忍 “临时不一致”。</li><li>遇到异常时，至少要保证旧库优先成功，新库可以重试补偿。</li></ul></li><li>异常与补偿机制<ul><li>双写失败时（例如新库宕机），要记录失败日志或写入消息队列，后续重试补偿。</li><li>可设计一个数据补偿任务（定时比对旧库与新库的数据），保证最终一致性。</li></ul></li><li>顺序与幂等<ul><li>确保双写执行顺序与业务一致（例如先 <code>INSERT</code> 再 <code>UPDATE</code>），避免错序写入。</li><li>所有操作必须支持幂等，防止重试引起脏数据。</li><li>建议使用幂等写入，比如 MySQL 的 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</li></ul></li><li>更新操作特殊处理<ul><li>新库数据可能不存在，直接执行 <code>UPDATE</code> 可能更新不到任何行。</li><li>建议采用 “存在则更新，否则插入” 的更新策略，例如 MySQL 的 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</li></ul></li><li>全量迁移与增量校验<ul><li>在正式双写之前，最好先做一次全量迁移（减少新库缺少数据的概率）。</li><li>启用双写后，后台跑比对和补偿任务，抽查或全量校验新旧库数据，自动补偿不一致的数据。</li></ul></li></ul><p>这种方案在迁移过程中业务不会中断，用户几乎无感知，可靠性高。因此，目前大多数公司在迁移生产系统的数据时，都会采用这种 “双写 + 校验” 的方案。</p><h2 id="扩展知识内容"><a href="#扩展知识内容" class="headerlink" title="扩展知识内容"></a>扩展知识内容</h2><h3 id="数据库在线迁移工具"><a href="#数据库在线迁移工具" class="headerlink" title="数据库在线迁移工具"></a>数据库在线迁移工具</h3><p>主流的数据库在线迁移工具有以下几种，支持迁移在线业务，通常依赖 “全量复制 + 增量实时同步 + 切换” 的方案。</p><ul><li><p><strong>(1) MySQL 原生工具</strong></p><ul><li>MySQL Replication (主从复制)<ul><li> 概述：<ul><li>将新库作为旧库的从库，开启基于 Binlog 的主从复制。通常先做全量数据同步，再实时同步增量数据，追平后切换主库。</li></ul></li><li>优点：<ul><li>MySQL 自带、成熟稳定、社区支持广、对业务代码零侵入。</li><li>基于 Binlog，增量数据实时同步，保证数据一致性。</li></ul></li><li>缺点：<ul><li>跨机房或网络延迟大时，复制延迟问题明显。</li><li>切换为主库需要停写或短暂停机（秒级）。</li><li>不适用于大规模 DDL 变更或 MySQL 版本跨度过大的迁移。</li></ul></li></ul></li><li>MySQL Group Replication / InnoDB Cluster<ul><li> 概述：<ul><li>基于 MySQL 官方的高可用集群，支持多主、多从、动态扩容。</li><li>严格来说，这不是专门的 “在线迁移工具”，本质上是 MySQL 的高可用方案，只是可以顺便解决迁移问题。</li></ul></li><li>优点：<ul><li>支持多主写入、自动故障转移。</li><li>支持自动处理节点加入 / 离开，迁移过程中可降低人为操作风险。</li></ul></li><li>缺点：<ul><li>部署复杂，对网络延迟和数据库版本有严格要求。</li><li>多主模式下存在冲突处理问题。</li><li>性能相对普通主从复制略差。</li><li>跨机房支持不理想。</li></ul></li></ul></li></ul></li><li><p><strong>(2) 企业常用迁移工具</strong></p><ul><li><a href="https://github.com/percona/percona-xtrabackup">Percona XtraBackup</a><ul><li> 概述：<ul><li>用于 MySQL 的热备份，全量复制旧库数据到新库，然后结合 Binlog 或其他增量方案追平。</li></ul></li><li>优点：<ul><li>支持热备份，不锁表。</li><li>备份速度快，适合大数据量（TB 级别）场景。</li><li>一致性好，可与 MySQL 主从复制结合实现无缝切换。</li><li>开源、社区成熟，企业使用广泛。</li></ul></li><li>缺点：<ul><li>只解决全量迁移问题，增量追平仍需依赖 Binlog 或其他方案；</li><li>对磁盘空间和 I/O 有较高要求。</li></ul></li></ul></li><li><a href="https://github.com/percona/percona-toolkit">pt-table-sync（Percona Toolkit）</a><ul><li>概述：<ul><li>用于全量数据校验、增量数据同步和比对，基于对比源库和目标库数据差异，按需补齐。</li></ul></li><li>优点：<ul><li>支持在线比对数据差异，自动修复，保证一致性。</li><li>支持断点续传，适合长时间迁移。</li><li>可用作双写迁移、切换后的数据一致性保障。</li><li>可以作为 Binlog 同步之后的校验工具。</li></ul></li><li>缺点：<ul><li>性能开销大，对源库影响明显，尤其是大表，适合流量低峰期运行。</li><li>仅适合 MySQL，且在大表场景下校验速度慢。</li><li>配置和使用复杂，需要 DBA 熟悉其工作原理。</li></ul></li></ul></li></ul></li><li><p><strong>(3) 增量同步中间件</strong></p><ul><li><a href="https://github.com/alibaba/canal">Canal（阿里开源）</a><ul><li>基于 Binlog 订阅，支持异构同步（MySQL → MySQL / ElasticSearch / Kafka）。</li></ul></li><li><a href="https://github.com/debezium/debezium">Debezium（国外开源）</a><ul><li>基于 CDC（Change Data Capture），是一个开源的分布式平台，支持多种数据库实时同步。</li></ul></li><li><a href="https://github.com/alibaba/otter">Otter（阿里开源）</a><ul><li>基于 Canal + 分布式调度，适合分库分表场景。</li></ul></li><li>DTS（阿里云数据库传输服务） / DMS（腾讯云数据库传输服务）</li><li>主流云厂商的在线迁移工具，支持断点续传、实时增量同步。</li></ul></li></ul><blockquote><p>数据库在线迁移工具的最佳实践</p></blockquote><ul><li>自建环境推荐使用 XtraBackup（全量复制） + MySQL Replication（增量追平） + Canal（增量消费、双写）</li><li>云环境推荐使用云厂商的 DTS / DMS，直接提供 “全量 + 增量 + 切换” 的托管能力。</li></ul><blockquote><p>数据库在线迁移数据的典型步骤如下：</p></blockquote><ul><li>(1) 新增 MySQL 服务器，创建好库表结构（与现有表结构保持一致）。</li><li>(2) 全量迁移历史数据（XtraBackup / 全量 Dump）。</li><li>(3) 开启 Binlog 增量订阅（Canal / DTS / MySQL 原生主从复制）。</li><li>(4) 实时同步增量数据，并进行数据校验。</li><li>(5) 业务切换流量到新库（通过中间件配置或 DNS / 服务发现）。</li><li>(6) 平滑下线旧库。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cloud.tencent.com/developer/article/2204209">不停机迁移数据库的解决方案</a></li><li><a href="https://blog.csdn.net/2301_78858041/article/details/147819741">如何零停机、零丢失迁移数据库</a></li><li><a href="https://cloud.tencent.com/developer/article/1663946">分库分表后，生产环境怎么实现不停机数据迁移</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍分库分表后，生产环境如何实现不停机迁移数据。</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="架构设计" scheme="https://www.techgrow.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之二</title>
    <link href="https://www.techgrow.cn/posts/c57e8370.html"/>
    <id>https://www.techgrow.cn/posts/c57e8370.html</id>
    <published>2025-08-15T13:12:19.000Z</published>
    <updated>2025-08-15T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><h4 id="Pod-的基础概念"><a href="#Pod-的基础概念" class="headerlink" title="Pod 的基础概念"></a>Pod 的基础概念</h4><h5 id="Pod-的概述"><a href="#Pod-的概述" class="headerlink" title="Pod 的概述"></a>Pod 的概述</h5><p>Pod 是 Kubernetes 中可以创建和管理的最小资源单元，是用户在资源对象模型中创建或部署的基本单位，也是 Kubernetes 上运行容器化应用的直接载体。Kubernetes 并不会直接管理容器，而是通过管理 Pod 来间接管理容器。一个 Pod 通常由一个或多个容器组成，这些容器共享网络、存储等资源，并作为一个整体被调度和管理。在 Kubernetes 中，其他资源对象主要用于支撑或扩展 Pod 的功能，例如：Controller 资源用于管理和控制 Pod 的生命周期；Service 或 Ingress 资源用于暴露和访问 Pod；而 PersistentVolume (PV) 等存储资源用于为 Pod 提供持久化存储支持。此外，每个 Pod 都包含一个特殊的系统容器，称为 Pause 容器，它作为 Pod 的 “根容器” 存在，用于占据 Pod 的网络命名空间等资源。除了 Pause 容器，Pod 中还包含一个或多个紧密相关的用户业务容器，所有业务容器都在同一个 Namespace 里面，可以实现网络共享；这些容器协同工作，共同完成某项具体的业务功能。</p><span id="more"></span><h5 id="Pod-的特性"><a href="#Pod-的特性" class="headerlink" title="Pod 的特性"></a>Pod 的特性</h5><ul><li><p><strong>资源共享</strong></p><ul><li>一个 Pod 里的多个容器可以共享存储和网络，可以看作一个逻辑的主机（服务器），共享 Namespace（命名空间）、Cgroups（控制组）或者其他的隔离资源。</li><li>同一个 Pod 中的多个容器共享同一个 Network Namespace，因此它们共享同一个 IP 地址和端口空间。也就是说，Pod 内的容器可以通过 <code>localhost</code> 进行通信。需要注意的是，多个容器在同一个 Pod 中运行时，应避免端口冲突。不同的 Pod 之间具有各自独立的 IP 地址，默认情况下，不同 Pod 中的容器之间不能通过 IPC 机制通信（除非做了特殊配置），通常使用 Pod 的 IP 地址进行网络通信。</li><li>一个 Pod 中的多个容器可以共享同一个存储卷，该存储卷作为 Pod 的一部分被定义，并可以挂载到该 Pod 内所有容器的文件系统中，从而实现数据共享和持久化存储。</li></ul></li><li><p><strong>生命周期短暂</strong></p><ul><li>Pod 是生命周期相对短暂的组件，例如当 Pod 所在的节点发生故障时，该节点上的 Pod 会被重新调度到其他节点上运行。但需要注意的是，重新调度后创建的是一个全新的 Pod，与原来的 Pod 没有任何关联，原有的状态、数据和标识都会丢失，二者之间没有任何直接关系。</li></ul></li><li><p><strong>平坦的网络</strong></p><ul><li>Kubernetes 集群中的所有 Pod 都处于同一个共享的网络地址空间中，这意味着每个 Pod 都可以通过其他 Pod 的 IP 地址直接进行访问和通信，无需进行额外的网络配置。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Docker 容器与宿主机进程的关系</p><ul><li>Docker 容器里的进程没有独立 Linux 内核，使用的是宿主机内核，它本质就是宿主机进程。</li><li>Docker 容器只是由 Linux 内核提供的隔离（Namespace） + 资源限制（Cgroups）环境。</li><li>当宿主机关掉 Docker 容器主进程，容器就会退出运行（容器生命周期依赖主进程）。换言之，Docker 容器主进程如果挂掉，容器就会停止运行。</li><li>Docker 容器的 Linux 内核版本永远等于宿主机的内核版本，更换镜像也换不掉内核。比如，当宿主机内核版本低（例如 <code>3.3</code>），容器里即使是最新版本的 Ubuntu，也无法使用高版本内核才有的特性（比如一些新 Cgroup 特性、eBPF）。</li></ul></div><h5 id="Pod-的分类"><a href="#Pod-的分类" class="headerlink" title="Pod 的分类"></a>Pod 的分类</h5><p>Pod 有两种类型：</p><ul><li><p><strong>普通 Pod</strong>  </p><ul><li> 普通 Pod 被创建后会被存储到 Etcd 中，随后由 Kubernetes Master 调度到某个特定的 Node（工作节点）上并与之绑定。该 Node（工作节点）上的 kubelet 进程会负责将 Pod 实例化为一组相关的容器（如 Docker 容器）并启动它们。默认情况下，如果 Pod 中的某个容器停止运行，Kubernetes 会自动检测并重启该 Pod 内的所有容器。如果 Pod 所在的 Node（工作节点）发生宕机，Kubernetes 会将该 Node（工作节点）上的所有 Pod 重新调度到其他可用节点上。</li></ul></li><li><p><strong>静态 Pod</strong>  </p><ul><li> 静态 Pod 是由 kubelet 直接管理的特殊 Pod，仅存在于特定的 Node（工作节点）上。它们不受 API Server 管理，也无法与 Replication Controller、Deployment 或 DaemonSet 等控制器关联。此外，kubelet 对静态 Pod 的健康检查能力有限，通常仅能监控其运行状态，而不会像普通 Pod 那样提供完整的健康检查机制。</li></ul></li></ul><h5 id="Pod-的定义"><a href="#Pod-的定义" class="headerlink" title="Pod 的定义"></a>Pod 的定义</h5><p>定义 Pod 的 YAML 配置示例如下（<code>&lt;string&gt;</code> 是占位符，需要根据实际情况填写）：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="comment"># 元数据</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="comment"># 时间配置</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">0</span>            <span class="comment"># 检查间隔时间</span></span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 安全配置</span></span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span>       <span class="comment"># 重启策略，可选值: Always、Never、OnFailure，默认 Always</span></span><br><span class="line">  <span class="attr">nodeSelector:</span>               <span class="comment"># 节点选择，将 Pod 调度到包含这些 Label 的 Node（工作节点）上</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">value</span>                <span class="comment"># 以 key:value 格式指定</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span>          <span class="comment"># 是否使用主机网络模式，默认 false（不使用）</span></span><br><span class="line">  <span class="comment"># 共享存储卷列表</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">      <span class="attr">emptyDir:</span> {}</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">host-volume</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/path/on/host</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">configmap-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&lt;string&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-的运行方式"><a href="#Pod-的运行方式" class="headerlink" title="Pod 的运行方式"></a>Pod 的运行方式</h5><p><strong>在 Kubernetes 中，运行的容器要求其主程序必须始终在前台运行，而不能以后台方式执行。如果应用默认是以后台运行的方式启动，就需要进行修改，使其在前台运行。否则，当 kubelet 创建包含该容器的 Pod 并执行启动命令后，会因为容器立即退出而认为该 Pod 已经结束，从而立刻销毁该 Pod。</strong>如果该 Pod 是由控制器（如 Replication Controller）管理的，那么就会不断尝试重新创建和销毁 Pod，陷入无限循环。需要注意的是，一个 Pod 可以由一个或多个容器组成。</p><ul><li>下面的 YAML 配置内容定义了一个包含单个容器的 Pod，容器使用的是官方 Tomcat 镜像，并包含基本的端口和挂载配置 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mytomcat</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">tomcat:9.0</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/local/tomcat/webapps</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-data</span></span><br><span class="line">      <span class="attr">emptyDir:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>YAML 配置内容的详细说明</li></ul><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td><code>metadata.name</code></td><td>Pod 的名称，必须唯一</td></tr><tr><td><code>metadata.labels</code></td><td>标签，用于标识和选择 Pod</td></tr><tr><td><code>spec.containers</code></td><td>容器列表，一个 Pod 可包含一个或多个容器</td></tr><tr><td><code>spec.containers[].name</code></td><td>容器的名称，在 Pod 内部唯一</td></tr><tr><td><code>spec.containers[].image</code></td><td>容器使用的镜像，这里是 <code>tomcat:9.0</code></td></tr><tr><td><code>spec.containers[].ports</code></td><td>容器开放的端口列表</td></tr><tr><td><code>spec.containers[].ports[].containerPort</code></td><td>容器内部监听的端口号（如 Tomcat 默认 8080）</td></tr><tr><td><code>spec.containers[].volumeMounts</code></td><td>容器内挂载的卷配置</td></tr><tr><td><code>spec.containers[].volumeMounts[].name</code></td><td>要挂载的卷名称，对应 <code>spec.volumes</code> 中定义的名称</td></tr><tr><td><code>spec.containers[].volumeMounts[].mountPath</code></td><td>挂载点路径，如 <code>/usr/local/tomcat/webapps</code></td></tr><tr><td><code>spec.volumes</code></td><td>定义 Pod 中使用的卷</td></tr><tr><td><code>spec.volumes[].name</code></td><td>卷的名称，与 <code>volumeMounts</code> 中的名称对应</td></tr><tr><td><code>spec.volumes[].emptyDir</code></td><td>使用一个空目录卷，Pod 删除时数据也会被清除</td></tr></tbody></table><h5 id="Pod-的生命周期"><a href="#Pod-的生命周期" class="headerlink" title="Pod 的生命周期"></a>Pod 的生命周期</h5><p>Pod 的生命周期状态有以下几种：</p><table><thead><tr><th>生命周期状态</th><th>说明</th></tr></thead><tbody><tr><td> Pending</td><td>API Server 已创建该 Pod，但 Pod 中的一个或多个容器的镜像尚未创建（包括镜像下载过程）。</td></tr><tr><td>Running</td><td>Pod 内所有容器已创建，且至少有一个容器处于运行状态（包括正在启动或重启的状态）。</td></tr><tr><td>Completed</td><td>Pod 内所有容器均已成功执行并退出，且不会再重启。</td></tr><tr><td>Failed</td><td>Pod 内所有容器均已退出，但至少有一个容器退出失败。</td></tr><tr><td>Unknown</td><td> 由于某些原因（如网络通信不畅）无法获取 Pod 的状态。</td></tr></tbody></table><h5 id="Pod-的状态条件"><a href="#Pod-的状态条件" class="headerlink" title="Pod 的状态条件"></a>Pod 的状态条件</h5><p>Pod 的状态条件（Conditions）有以下几种：</p><table><thead><tr><th>状态条件</th><th>触发时机</th><th>正常状态</th><th>说明</th></tr></thead><tbody><tr><td><code>PodScheduled</code></td><td>当 Scheduler 为 Pod 分配了目标 Node（工作节点）后</td><td><code>True</code></td><td>表示 Pod 已被调度到某个 Node（工作节点）上。如果为 <code>False</code>，可能是集群资源不足或调度约束冲突。</td></tr><tr><td><code>Initialized</code></td><td>当所有 Init 容器（如果有）成功执行完成后</td><td><code>True</code></td><td>仅对包含 Init 容器的 Pod 有意义。若 Init 容器失败，此条件会显示 <code>False</code> 并记录原因。</td></tr><tr><td><code>ContainersReady</code></td><td>当 Pod 内所有主容器（非 Init 容器）的状态均为 <code>Running</code> 时</td><td><code>True</code></td><td>仅表示容器已启动，但不保证容器内应用已就绪（需结合 Readiness Probe（就绪探针）判断）。</td></tr><tr><td><code>Ready</code></td><td>当 Pod 满足以下条件时：<br>1. 所有主容器 <code>Running</code>；<br>2. 通过 Readiness Probe（就绪探针）检测（如果配置了）。</td><td><code>True</code></td><td>表示 Pod 可正常接收流量。若为 <code>False</code>，该 Pod 会被从 Service 的 Endpoints 中移除。</td></tr></tbody></table><p>Pod 状态条件的附加说明</p><ul><li>(1) 状态值：<ul><li>每个 Condition 的状态可能是 <code>True</code>、<code>False</code> 或 <code>Unknown</code>。</li></ul></li><li>(2) 依赖关系：  <ul><li><code>PodScheduled</code> → <code>Initialized</code> → <code>ContainersReady</code> → <code>Ready</code>（存在先后顺序）。  </li></ul></li><li>(3) 常见问题：  <ul><li>若 <code>PodScheduled=False</code>，需检查节点资源或亲和性规则。  </li><li>若 <code>Initialized=False</code>，需排查 Init 容器的日志。  </li><li>若 <code>Ready=False</code> 但 <code>ContainersReady=True</code>，通常是 Readiness Probe（就绪探针）配置问题。  </li></ul></li><li>(4) 查看命令：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以结构化格式提取 Pod 状态条件（Conditions）的详细信息</span></span><br><span class="line">kubectl get pod &lt;pod-name&gt;<span class="params"> -o</span> jsonpath=<span class="string">'{.status.conditions}'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用 describe 查看 Pod 的详细状态</span></span><br><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="Pod-的重启策略"><a href="#Pod-的重启策略" class="headerlink" title="Pod 的重启策略"></a>Pod 的重启策略</h5><p>Pod 的重启策略包括 Always、OnFailure 和 Never，默认值是 Always。</p><table><thead><tr><th>重启策略</th><th>说明</th></tr></thead><tbody><tr><td> Always</td><td> 默认值，当容器退出时，总是由 kubelet 自动重启该容器（适用于长期运行的 Pod，如 Web 服务）。</td></tr><tr><td>OnFailure</td><td> 仅在容器异常退出（非 0 状态码）时，由 kubelet 自动重启该容器（适合批处理任务）。</td></tr><tr><td>Never</td><td> 无论容器如何退出，kubelet 都不会重启该容器（适合一次性任务）。</td></tr></tbody></table><p>Pode 重启策略的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mynginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span>  <span class="comment"># Pod 的重启策略</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-的状态转换"><a href="#Pod-的状态转换" class="headerlink" title="Pod 的状态转换"></a>Pod 的状态转换</h5><p>Pod 生命周期状态的转换表（基于容器事件和重启策略）如下：</p><table><thead><tr><th>Pod 包含的容器数</th><th> Pod 当前的运行状态</th><th>发生的事件</th><th> Pod 的结果状态（RestartPolicy = Always）</th><th>Pod 的结果状态（RestartPolicy = OnFailure）</th><th>Pod 的结果状态（RestartPolicy = Never）</th></tr></thead><tbody><tr><td>1 个容器</td><td> Running</td><td> 容器成功退出</td><td> Running</td><td>Succeeded</td><td>Succeeded</td></tr><tr><td>1 个容器</td><td> Running</td><td> 容器失败退出</td><td> Running</td><td>Running</td><td>Failed</td></tr><tr><td>2 个容器</td><td> Running</td><td> 其中 1 个容器失败退出</td><td> Running</td><td>Running</td><td>Running</td></tr><tr><td>2 个容器</td><td> Running</td><td>2 个容器被 OOM 终止</td><td> Running</td><td>Running</td><td>Failed</td></tr></tbody></table><ul><li> 关键说明：<ul><li><strong>OOM</strong>：表示容器因内存不足（Out Of Memory）被系统终止</li><li>状态转换规则：<ul><li><code>Always</code>：任何容器终止都会触发重启（保持 Running 状态）</li><li><code>OnFailure</code>：仅当容器异常退出（非 0 状态码 / OOM）时重启</li><li><code>Never</code>：容器终止后直接反映最终状态（Succeeded/Failed）</li></ul></li><li>多容器 Pod 的状态由所有容器的综合状态决定</li></ul></li></ul><h5 id="Pod-的健康检查"><a href="#Pod-的健康检查" class="headerlink" title="Pod 的健康检查"></a>Pod 的健康检查</h5><p>Kubernetes 提供以下三种探针（Probe）来监控容器的运行状态：</p><ul><li><p>存活探针（<code>livenessProbe</code>）</p><ul><li>作用：检测容器是否正常运行。如果检测不通过，Kubernetes 会杀死容器并根据 <code>restartPolicy（重启策略）</code> 重启容器。</li><li>适用场景：用于修复死锁、无响应的应用（如数据库卡死）。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">exec:</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"cat"</span>, <span class="string">"/tmp/healthy"</span>]  <span class="comment"># 执行命令检查文件是否存在</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">5</span>              <span class="comment"># 容器启动后等待5秒开始检查</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span>                    <span class="comment"># 每5秒检查一次</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">3</span>                 <span class="comment"># 连续失败3次后判定为不健康</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>就绪探针（<code>readinessProbe</code>）</p><ul><li>作用：检测容器是否准备好接收流量。如果检测不通过，Kubernetes 会将 Pod 从 Service 的 Endpoints 中剔除，并且 Pod 会被标记为 <code>NotReady</code>，但不会被重启。</li><li>适用场景：用于控制流量进入（如应用启动时需要加载大量数据，导致容器启动后无法立刻对外提供服务</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/healthz</span>                    <span class="comment"># 发送 HTTP 请求进行检测</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">10</span>             <span class="comment"># 容器启动后等待10秒开始检查</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">3</span>                    <span class="comment"># 每3秒检查一次</span></span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">1</span>                 <span class="comment"># 成功1次即标记为就绪</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>启动探针（<code>startupProbe</code>）</p><ul><li>作用：从 Kubernetes <code>1.16+</code> 版本开始引入，专门检测慢启动应用是否完成初始化。在启动探针成功之前，其他探针不会生效。可以避免因应用启动过慢，导致被存活 / 就绪探针误杀。</li><li>适用场景：启动时间较长的应用（如 Java/SpringBoot 应用、需要加载大数据量的服务）。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">startupProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health</span>             <span class="comment"># Spring Boot 健康检查端点</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">30</span>                 <span class="comment"># 允许的最大失败次数</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">10</span>                    <span class="comment"># 每10秒检查一次</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><hr><p>探针（Probe）支持以下三种检测方法（三种类型的探针都支持）：</p><table><thead><tr><th>检测方法</th><th>说明</th><th>配置示例</th></tr></thead><tbody><tr><td><code>exec</code></td><td>- 在容器内执行命令，返回状态码为 <code>0</code> 表示检测成功。<br> - 适用于复杂检测逻辑或没有 HTTP 接口的服务。</td><td><code>command: ["cat", "/tmp/healthy"]</code></td></tr><tr><td><code>httpGet</code></td><td>- 通过发送 HTTP 请求检查服务是否正常。<br> - 返回状态码 <code>200 ~ 399</code> 表示检测成功。</td><td><code>httpGet: { path: /health, port: 80 }</code></td></tr><tr><td><code>tcpSocket</code></td><td>- 通过容器 IP + 端口建立 TCP 连接，<br> - 连接成功，即表示容器健康。</td><td><code>tcpSocket: { port: 3306 }</code></td></tr></tbody></table><p>探针（Probe）的三种探测结果状态：</p><table><thead><tr><th>探测结果状态</th><th>说明</th></tr></thead><tbody><tr><td><code>Success</code></td><td>容器通过检查，状态正常。</td></tr><tr><td><code>Failure</code></td><td>容器未通过检查，状态异常。</td></tr><tr><td><code>Unknown</code></td><td>无法执行检查，因此不采取任何措施。</td></tr></tbody></table><p>探针（Probe）的关键参数：</p><table><thead><tr><th>参数</th><th>作用</th><th>默认值</th><th>最小值</th><th>适用探针类型</th></tr></thead><tbody><tr><td><code>initialDelaySeconds</code></td><td>容器启动后，等待多少秒才开始第一次执行探测，避免容器未完成启动就被误判为失败。</td><td>0 秒</td><td> 0 秒</td><td> liveness、readiness、startup</td></tr><tr><td><code>periodSeconds</code></td><td>探测的执行频率，即两次探测之间的间隔时间。</td><td>10 秒</td><td> 1 秒</td><td> liveness、readiness</td></tr><tr><td><code>timeoutSeconds</code></td><td>单次探测的超时时间，超过该时间未响应则判定为探测失败。</td><td>1 秒</td><td> 1 秒</td><td> liveness、readiness</td></tr><tr><td><code>failureThreshold</code></td><td>探测成功后，连续失败多少次才会被认定为容器不健康。</td><td>3</td><td>1</td><td>liveness、readiness、startup</td></tr><tr><td><code>successThreshold</code></td><td>对于已标记为不健康的容器，需要连续成功多少次才会重新标记为健康。对于 Liveness Probe，该值必须为 <code>1</code>。</td><td>1</td><td>1</td><td>liveness、readiness</td></tr></tbody></table><p>基于存活探针检测容器的健康状态</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-exec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">touch</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">30</span><span class="string">;</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/healthy</span></span><br><span class="line">    <span class="comment"># 存活检查</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><p>启动探针、存活探针和就绪探针三者可以配合使用：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">springboot-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-springboot-app:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="comment"># 启动探针（给予充足启动时间）</span></span><br><span class="line">    <span class="attr">startupProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="comment"># 存活检查（启动探针成功后生效）</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment"># 就绪检查（启动探针成功后生效）</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health/readiness</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-的资源限制"><a href="#Pod-的资源限制" class="headerlink" title="Pod 的资源限制"></a>Pod 的资源限制</h5><p>每个 Pod 都可以对其可使用的 Node（工作节点）计算资源设置限额。Kubernetes 支持对以下两种计算资源进行配额限制：</p><ul><li><p>资源类型  </p><ul><li>CPU 资源：以绝对值的 CPU 数量为单位（比如 <code>500m</code> 表示 0.5 个 CPU 核心）。</li><li>Memory 资源：内存大小以字节数为单位（比如 <code>512Mi</code> 表示 512 MiB 内存）。</li></ul></li><li><p>配额参数  </p><ul><li>每种资源需要定义两个关键参数：  </li><li>Requests<ul><li> 表示该资源的最小申请量。</li><li>Kubernetes 调度器会确保 Node（工作节点）剩余资源大于等于 Requests 值，否则 Pod 无法被调度。</li></ul></li><li>Limits<ul><li> 表示该资源的最大允许使用量。若容器尝试使用超过 Limits 的资源：<ul><li>对于 CPU 资源，容器会被限制（Throttled）。</li><li>对于 Memory 资源，容器可能被 Kubernetes 终止（OOM Kill）并重启。</li></ul></li></ul></li></ul></li></ul><p>Pod 资源限制的配置示例如下，表示 MySQL 容器申请最少 <code>0.25</code> 个 CPU 以及 <code>64MiB</code> 内存，在运行过程中容器所能使用的最大资源配额为 <code>0.5</code> 个 CPU 以及 <code>128MiB</code> 内存。</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"128Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"500m"</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">CPU 资源限制的单位</p><ul><li>(1) 在 Kubernetes 的资源限制配置中，<code>cpu: "500m"</code> 表示 500 毫核（millicores）。</li><li>(2) <code>1m = 0.001 个 CPU 核心</code>，而 <code>500m</code> 等价于 <code>0.5</code> 个 CPU 核心（即 50% 的单核算力）。</li><li>(3) Kubernetes 常见的 CPU 单位如下表所示：</li></ul></div><table><thead><tr><th>CPU 单位</th><th>含义</th><th>配置示例</th></tr></thead><tbody><tr><td><code>1</code></td><td>1 个完整的 CPU 核心</td><td><code>cpu: "1"</code></td></tr><tr><td><code>1000m</code></td><td>1 个完整的 CPU 核心</td><td><code>cpu: "1000m"</code></td></tr><tr><td><code>500m</code></td><td>0.5 核（即 50% 的单核算力）</td><td><code>cpu: "500m"</code></td></tr><tr><td><code>250m</code></td><td>0.25 核（即 25% 的单核算力）</td><td><code>cpu: "250m"</code></td></tr></tbody></table><h5 id="Pod-的镜像拉取策略"><a href="#Pod-的镜像拉取策略" class="headerlink" title="Pod 的镜像拉取策略"></a>Pod 的镜像拉取策略</h5><p>Pod 有以下几种镜像拉取策略：</p><table><thead><tr><th>策略名称</th><th>描述</th></tr></thead><tbody><tr><td><code>IfNotPresent</code></td><td>默认值，只有当镜像在宿主机上不存在时才会拉取</td></tr><tr><td><code>Always</code></td><td>每次创建 Pod 时都会重新拉取一次镜像（即使宿主机上已存在）</td></tr><tr><td><code>Never</code></td><td>Pod 永远不会主动拉取镜像，仅使用宿主机上已有的镜像（若宿主机上不存在，则报错）</td></tr></tbody></table><p>Pode 镜像拉取策略的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mynginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>   <span class="comment"># Pod 的镜像拉取策略</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Pod-的调度策略"><a href="#Pod-的调度策略" class="headerlink" title="Pod 的调度策略"></a>Pod 的调度策略</h4><div class="admonition note"><p class="admonition-title">提示</p><p>更多关于 Kubernetes 调度器的介绍请看 <a href="/posts/76121b26.html#%E8%B0%83%E5%BA%A6%E5%99%A8">这里</a>。</p></div><h5 id="Pod-的创建流程"><a href="#Pod-的创建流程" class="headerlink" title="Pod 的创建流程"></a>Pod 的创建流程</h5><p><img data-src="../../../asset/2025/08/k8s-pod-create.png"></p><ul><li><p>(1) 用户提交 Pod 创建请求</p><ul><li>用户通过 <code>kubectl</code> 命令行工具或其他客户端工具提交 Pod 创建请求</li><li>请求会发送到 Master 节点的 API Server</li></ul></li><li><p>(2) API Server 处理</p><ul><li>API Server 接收并验证请求</li><li>将 Pod 配置信息写入 Etcd 进行持久化存储</li></ul></li><li><p> (3) Scheduler 调度</p><ul><li>Scheduler 组件监控 API Server，发现有未调度的新 Pod</li><li>Scheduler 通过调度算法（考虑资源需求、节点亲和性等）选择最适合的 Node（工作节点）</li><li>Scheduler 将调度决策（绑定信息）通过 API Server 更新到 Etcd</li></ul></li><li><p>(4) Node（工作节点）执行</p><ul><li>目标 Node（工作节点）上的 kubelet 组件会定期查询 API Server</li><li>kubelet 发现分配给本节点的 Pod 信息（从 Etcd 读取）</li><li>kubelet 根据 Pod 描述文件:<ul><li> 通过容器运行时（如 Docker、Containerd）创建容器</li><li>配置容器网络、存储等资源</li><li>启动容器</li></ul></li></ul></li><li><p> (5) Pod 状态更新</p><ul><li>kubelet 监控容器状态，并将容器最新状态报告给 API Server</li><li>API Server 将 Pod 状态信息写入 Etcd</li><li> 用户可以通过 <code>kubectl</code> 命令行工具查看 Pod 的运行状态</li></ul></li></ul><h5 id="影响-Pod-调度的因素"><a href="#影响-Pod-调度的因素" class="headerlink" title="影响 Pod 调度的因素"></a>影响 Pod 调度的因素</h5><p>在 Kubernetes 中，影响 Pod 调度的主要因素有以下几种。</p><h6 id="Pod-资源限制"><a href="#Pod-资源限制" class="headerlink" title="Pod 资源限制"></a>Pod 资源限制</h6><ul><li><strong>Pod 资源限制（Resource Requests）</strong><ul><li>核心机制：<ul><li>Pod 通过 <code>resources.requests</code> 声明所需的最小资源量</li><li>调度器（Scheduler）根据这些请求寻找有足够资源的节点</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br></pre></td></tr></tbody></table></figure></li><li>调度行为：<ul><li>调度器会排除所有可用资源（Allocatable）小于请求值的节点</li><li>资源包括 CPU、内存、GPU 等</li><li>实际调度基于节点的剩余资源（Allocatable - Requested）</li></ul></li></ul></li></ul><h6 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器"></a>节点选择器</h6><ul><li><strong>节点选择器（Node Selector）</strong><ul><li>核心机制：<ul><li>通过 <code>nodeSelector</code> 字段指定 Pod 必须运行在具有特定标签的节点上</li><li>这是简单的节点选择约束方式</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">env_role:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br></pre></td></tr></tbody></table></figure></li><li>节点的标签操作：<ul><li>给节点打上标签：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes &lt;node-name&gt; env_role=prod</span><br></pre></td></tr></tbody></table></figure></li><li>查看节点上的标签：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes<span class="params"> --show</span>-labels</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><h6 id="节点亲和性"><a href="#节点亲和性" class="headerlink" title="节点亲和性"></a>节点亲和性</h6><ul><li><strong>节点亲和性（Node Affinity）</strong><ul><li>概述：<ul><li>K8s 节点亲和性（Node Affinity）规则有两种：硬亲和性（<code>required</code>）、软亲和性（<code>preferred</code>）</li></ul></li><li>作用：<ul><li>节点亲和性调度使得 Pod 对象被吸引运行到一类特定的节点上。</li></ul></li><li>特性：<ul><li>比 <code>nodeSelector</code> 字段更灵活的规则</li><li>支持硬亲和性（约束条件必须满足）和软亲和性（尝试满足约束条件，但不保证满足）</li><li>支持常用操作：<code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>Gt</code>、<code>Lt</code>、<code>DoesNotExist</code></li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="comment"># 节点硬亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">env_role</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">      <span class="comment"># 节点软亲和性</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">group</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">otherprod</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h6 id="污点和容忍"><a href="#污点和容忍" class="headerlink" title="污点和容忍"></a>污点和容忍</h6><blockquote><p>污点（Taints）</p></blockquote><ul><li>污点的概述：<ul><li>节点可以设置污点（Taints）来拒绝普通 Pod 的调度</li></ul></li><li>污点的定义：<ul><li>定义在节点（Node）上的键值型属性数据</li><li>字段 <code>spec.taints</code>，语法是 <code>key=value:effect</code></li></ul></li><li>污点的类型：<ul><li><code>NoSchedule</code>  <ul><li>作用：<ul><li>默认值，新 Pod 无法调度到该节点（除非明确容忍此污点）</li><li>已运行的 Pod 若不容忍此污点，不会被驱逐（Evict）</li></ul></li><li>场景：保留节点给特定用途（如 GPU 节点、生产环境专用节点）</li></ul></li><li><code>PreferNoSchedule</code>  <ul><li>作用：<ul><li>调度器尽量避免将 Pod 分配到该节点，但若无其他可用节点仍会调度，不驱逐已运行的 Pod</li><li> 已运行的 Pod 若不容忍此污点，不会被驱逐（Evict）</li></ul></li><li>场景：软性隔离（如临时维护节点，但不强制拒绝调度）</li></ul></li><li><code>NoExecute</code>  <ul><li>作用：  <ul><li>新 Pod 无法调度到该节点（同 <code>NoSchedule</code>）</li><li>已运行的 Pod 若不容忍此污点，会被驱逐（Evict）</li></ul></li><li>场景：节点故障维护或紧急隔离（如节点磁盘故障需立即迁移所有 Pod）</li></ul></li></ul></li><li>污点的适用场景：<ul><li>专用节点隔离：保留节点给特定 Pod（如 GPU 节点只运行 AI 任务）</li><li>节点维护：标记节点为不可调度（如 <code>NoSchedule</code>），避免新 Pod 被分配到正在维护的节点</li><li>特殊硬件限制：防止普通 Pod 调度到带特殊硬件（如 FPGA）的节点</li></ul></li><li>节点的污点操作示例：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给节点添加污点</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;=&lt;value&gt;:NoSchedule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 举个例子</span></span><br><span class="line">kubectl taint node kube-node1 node-<span class="built_in">type</span>=production:NoShedule</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点的污点</span></span><br><span class="line">kubectl describe node &lt;node-name&gt; | grep Taint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">kubectl get nodes &lt;node-name&gt;<span class="params"> -o</span> go-template={{.spec.taints}}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除节点的单个污点（末尾的 "-" 符号表示删除）</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;:NoSchedule-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的指定键的所有污点（末尾的 "-" 符号表示删除）</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的所有污点</span></span><br><span class="line">kubectl patch nodes &lt;node-name&gt;<span class="params"> -p</span> <span class="string">'{"spec":{"taints":[]}}'</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>容忍（Tolerations）</p></blockquote><ul><li>容忍的概述：<ul><li>节点设置污点后，Pod 必须声明可以容忍哪些污点，才允许其被调度到具有这些污点的节点上。</li></ul></li><li>容忍的定义：<ul><li>定义在 Pod 上的键值型属性数据。</li><li>字段 <code>spec.tolerations</code>，语法是 <code>key=value:effect</code>。</li><li>字段 <code>tolerationSeconds</code> 用于定义延迟驱逐 Pod 的时间<ul><li><code>tolerationSeconds</code> 仅在 <code>effect: NoExecute</code> 的容忍规则中生效；</li><li>超过设定时间后，若节点上的污点仍存在，则 Pod 会被驱逐；</li><li>如果未设置 <code>tolerationSeconds</code>，则表示 Pod 将无限期地容忍该污点，即 Pod 不会因为该污点被驱逐。</li></ul></li></ul></li><li>容忍的类型<ul><li><code>NoSchedule</code>  <ul><li>作用：允许 Pod 调度到带有 <code>NoSchedule</code> 污点的节点 </li><li>场景：让关键 Pod（如存储服务）无视节点的硬性隔离规则</li></ul></li><li><code>PreferNoSchedule</code>  <ul><li>作用：允许 Pod 调度到带有 <code>PreferNoSchedule</code> 污点的节点（但调度器仍可能优先选择其他节点）</li><li>场景：非关键 Pod 在资源不足时仍可使用软隔离节点</li></ul></li><li><code>NoExecute</code>  <ul><li>作用：<ul><li>允许 Pod 调度到带有 <code>NoExecute</code> 污点的节点</li><li>豁免驱逐：即使节点新增 <code>NoExecute</code> 污点，Pod 也不会被驱逐</li></ul></li><li>场景：守护进程（如日志收集器）需长期运行，无视节点维护状态</li></ul></li><li><code>空值</code>（不指定 <code>effect</code> 字段）<ul><li>作用：容忍所有污点类型（包括未来可能新增的类型）</li><li>场景：超级特权 Pod（如集群管理组件）需在任何节点运行</li></ul></li></ul></li><li>容忍的适用场景：<ul><li>特权 Pod 调度：允许关键 Pod（如日志收集组件）无视污点，调度到任意节点</li><li>故障恢复：容忍 <code>NoExecute</code> 污点，使 Pod 在节点故障时不被驱逐（如数据库 Pod）</li><li>共享特殊节点：让普通 Pod 通过容忍临时使用专用节点（如容忍 GPU 节点污点）</li></ul></li><li>Pod 的容忍配置示例：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="comment"># 容忍 NoSchedule 污点</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"dedicated"</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">"gpu"</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 容忍 NoExecute 污点</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"unreachable"</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">"NoExecute"</span></span><br><span class="line">      <span class="attr">tolerationSeconds:</span> <span class="number">600</span>  <span class="comment"># 延迟 600 秒后驱逐 Pod（可选）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 容忍所有污点（危险！慎用！）</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br></pre></td></tr></tbody></table></figure><h6 id="Pod-亲和性和反亲和性"><a href="#Pod-亲和性和反亲和性" class="headerlink" title="Pod 亲和性和反亲和性"></a>Pod 亲和性和反亲和性</h6><ul><li><strong>Pod 亲和性</strong><ul><li>控制 Pod 倾向于与指定 Pod 调度到同一拓扑域（共存关系）。</li><li>适用于需要紧密协作或低延迟通信的场景，以降低网络延迟、提升性能。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="comment"># Pod 亲和性</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">"cache"</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">"kubernetes.io/hostname"</span></span><br></pre></td></tr></tbody></table></figure></li><li>配置说明：<ul><li>Kubernetes 调度器会强制保证，Pod 调度到与匹配 <code>labelSelector</code> 条件的 Pod 所在的同一 <code>zone</code> 中。</li><li>如果集群中所有 <code>zone</code> 都没有匹配的 Pod，则新 Pod 会一直处于 <code>Pending</code> 状态。</li></ul></li></ul></li><li><strong>Pod 反亲和性</strong><ul><li>控制 Pod 不与指定 Pod 调度到同一拓扑域（互斥关系）。</li><li>适用于高可用场景，比如：将 Pod 副本分布到不同机架（Rack）或可用区（Zone） 中，避免单点故障。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="comment"># Pod 反亲和性</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">cache</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">zone</span></span><br></pre></td></tr></tbody></table></figure></li><li>配置说明：<ul><li>Kubernetes 调度器会强制保证，同一 <code>zone</code> 下，不会与匹配 <code>labelSelector</code> 条件的 Pod 同时调度运行。</li><li>如果所有 <code>zone</code> 都有匹配的 Pod，则新 Pod 会一直处于 <code>Pending</code> 状态。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>Pod 亲和性和反亲和性的更详细介绍，可以看<a href="/posts/76121b26.html#Pod-%E4%BA%B2%E5%92%8C%E6%80%A7%E8%B0%83%E5%BA%A6">这里</a>。</p></div><h6 id="Pod-优先级与抢占式调度"><a href="#Pod-优先级与抢占式调度" class="headerlink" title="Pod 优先级与抢占式调度"></a>Pod 优先级与抢占式调度</h6><p>在 Pod 上定义容忍（Tolerations）时，Pod 的优先级与抢占式调度机制如下：</p><ul><li><p>优先级（Pod Priority）</p><ul><li>表示 Pod 对象的重要程度。</li><li>作用：<ul><li>影响调度顺序：高优先级 Pod 会优先被调度。</li><li>影响驱逐次序：节点资源不足时，低优先级 Pod 会先被驱逐。</li></ul></li></ul></li><li><p>抢占机制（Preemption）</p><ul><li>当一个 Pod 无法被调度时，调度器会尝试驱逐节点上优先级更低的 Pod，为当前高优先级 Pod 腾出资源。</li><li>适合关键业务 Pod 需要资源保障的场景。</li></ul></li><li><p>启用方法</p><ul><li>Pod 优先级与抢占式调度机制默认处于禁用状态，需要手动启用。</li><li>启用方式：在以下组件的启动参数中增加 <code>--feature-gates=PodPriority=true</code>：<ul><li><code>kube-apiserver</code></li><li><code>kube-scheduler</code></li><li><code>kubelet</code></li></ul></li></ul></li><li><p>使用步骤</p><ul><li><p>(1) 创建优先级类别（<code>PriorityClass</code>）</p><ul><li>定义不同的优先级，如关键业务、高优先级、低优先级等。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">scheduling.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">high-priority</span>                               <span class="comment"># 优先级类别名称</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">1000</span>                                         <span class="comment"># 优先级值，数值越大优先级越高</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span>                                <span class="comment"># 是否为默认优先级类别</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"用于关键业务 Pod，例如存储、网络组件"</span>      <span class="comment"># 优先级的描述信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">scheduling.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">low-priority</span>                                <span class="comment"># 优先级类别名称</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">100</span>                                          <span class="comment"># 优先级值，数值越大优先级越高</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span>                                <span class="comment"># 是否为默认优先级类别</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"用于低优先级 Pod，例如测试或批处理任务"</span>     <span class="comment"># 优先级的描述信息</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>(2) 在 Pod 中指定优先级</p><ul><li>创建 Pod 时，通过 <code>priorityClassName</code> 属性绑定到对应的优先级类别。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">critical-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">priorityClassName:</span> <span class="string">high-priority</span>    <span class="comment"># Pod 绑定高优先级类别</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">critical-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">Pod 的优先级与抢占式调度总结</p><p>高优先级 Pod 无法被调度 → 调度器检查目标节点 → 驱逐低优先级 Pod → 为高优先级 Pod 腾出资源 → 高优先级 Pod 调度成功。</p></div><h5 id="Pod-的调度决策流程"><a href="#Pod-的调度决策流程" class="headerlink" title="Pod 的调度决策流程"></a>Pod 的调度决策流程</h5><ul><li>(1) 预选阶段：排除不满足条件的节点（资源不足、标签不匹配等）。</li><li>(2) 优选阶段：对剩余节点打分 (考虑资源平衡、亲和性等因素)。</li><li>(3) 绑定阶段：选择最高分节点，将绑定信息写入 API Server。</li><li>(4) 执行阶段：目标 Node（工作节点）的 Kubelet 拉起 Pod。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>Kubernetes 调度器的详细工作流程，可以看<a href="/posts/76121b26.html#K8s-%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">这里</a>。</p></div><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><h4 id="Label-的概念"><a href="#Label-的概念" class="headerlink" title="Label 的概念"></a>Label 的概念</h4><p>Label 是 Kubernetes 中的核心概念之一，用于为集群中的各种资源对象打上自定义的标记。</p><ul><li><p>Label 的核心概念：</p><ul><li>一个 Label 是一个 <code>key=value</code> 形式的键值对，其中 <code>key</code> 和 <code>value</code> 由用户自定义。</li><li>Label 可以附加到各种 Kubernetes 资源对象上，例如 Node、Pod、Service、Replication Controller（RC）等。</li><li>一个资源对象可以拥有任意数量的 Label，同一个 Label 也可以被应用到任意数量的资源对象上。</li><li>Label 通常在资源对象创建时通过 <code>metadata.labels</code> 字段定义，也可以在对象创建后动态添加或删除。</li></ul></li><li><p>Label 的核心作用</p><ul><li>Label 附加到 Kubernetes 资源对象上的主要目的是对这些对象进行分组管理。</li><li>Kubernetes 分组管理的核心机制是 Label Selector（标签选择器）：<ul><li>Label Selector 根据指定的匹配规则筛选出符合条件的资源对象，实现分组控制和管理。</li><li>Label 和 Label Selector 都不能单独存在，必须附加在某些资源对象的定义文件中，才能发挥作用。</li><li>在实际使用中，Label 通常附加在 Pod 上，而 Label Selector 则常用于 Replication Controller（RC）、Replica Set（RS） 或 Service 等资源定义文件中，通过匹配特定 Label 来选择和管理 Pod。</li></ul></li></ul></li><li><p>Label 的常见用途</p><ul><li>通过在对象的定义中添加 <code>metadata.labels</code>，为对象打上标签。</li><li>其他资源（如 Service、Deployment）可以通过 <code>spec.selector</code> 来选择和关联具有特定 Label 的对象，实现分组管理和调度。</li></ul></li><li><p>Label 的注意事项</p><ul><li>Label 和 Label Selector 都不能单独存在，必须附加在某些资源对象的定义文件中，常见组合是：<ul><li>Pod + Label</li><li>Replication Controller（RC） / Replica Set（RS） / Service + Label Selector</li></ul></li></ul></li></ul><h4 id="Label-的使用"><a href="#Label-的使用" class="headerlink" title="Label 的使用"></a>Label 的使用</h4><ul><li>配置示例 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Replication</span> <span class="string">Controller</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">3333</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></tbody></table></figure><ul><li>配置说明：<ul><li>Replication Controller（RC）：<ul><li>通过 <code>selector</code> 选择并管理所有带有 <code>app=nginx</code> 标签的 Pod。</li><li>确保 Pod 的副本数量维持在 3 个，由 RC 创建的 Pod 会包含 <code>app=nginx</code> 标签。</li></ul></li><li>Service：<ul><li>通过 <code>selector</code> 匹配同样带有 <code>app=nginx</code> 标签的 Pod，并将流量分发给这些 Pod。</li><li>通过 <code>nodePort: 3333</code> 在集群外部暴露服务。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">Node（工作节点）的标签操作</p><ul><li>给 Node（工作节点）打上标签：<code>kubectl label nodes &lt;node-name&gt; env_role=prod</code></li><li>查看 Node（工作节点）上的标签：<code>kubectl get nodes --show-labels</code></li></ul></div>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Youtube 视频下载工具使用</title>
    <link href="https://www.techgrow.cn/posts/3f99e39.html"/>
    <id>https://www.techgrow.cn/posts/3f99e39.html</id>
    <published>2025-08-09T13:16:21.000Z</published>
    <updated>2025-08-09T13:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/yt-dlp/yt-dlp">yt-dlp</a> 是一个功能丰富的命令行音频 / 视频下载器，支持<a href="https://github.com/yt-dlp/yt-dlp/blob/master/supportedsites.md">数千个站点</a>，支持断点续传和网络代理等功能。</p><span id="more"></span><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li><a href="https://github.com/yt-dlp/yt-dlp">yt-dlp</a></li><li><a href="https://github.com/ytdl-org/youtube-dl">youtube-dl</a></li></ul><h2 id="yt-dlp-安装步骤"><a href="#yt-dlp-安装步骤" class="headerlink" title="yt-dlp 安装步骤"></a>yt-dlp 安装步骤</h2><ul><li>Pip 安装（依赖 Python）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Linux</span> / Mac</span><br><span class="line">pip install<span class="params"> -U</span> yt-dlp</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 安装（二进制方式）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Linux</span> (可直接下载可执行文件)</span><br><span class="line"><span class="keyword"># https</span>://github.com/yt-dlp/yt-dlp/releases</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">wget<span class="params"> -O</span> yt-dlp https://github.com/yt-dlp/yt-dlp/releases/download/2025.07.21/yt-dlp_linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line">sudo mv yt-dlp /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件授权</span></span><br><span class="line">sudo chmod +x /usr/bin/yt-dlp</span><br></pre></td></tr></tbody></table></figure><ul><li>Windows 安装（二进制方式）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Windows</span> (可直接下载 Exe 可执行文件)</span><br><span class="line"><span class="keyword"># https</span>://github.com/yt-dlp/yt-dlp/releases</span><br></pre></td></tr></tbody></table></figure><h2 id="yt-dlp-使用方法"><a href="#yt-dlp-使用方法" class="headerlink" title="yt-dlp 使用方法"></a>yt-dlp 使用方法</h2><h3 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h3><ul><li>下载命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span> <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理 + 多线程加速）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> -N</span> 4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理 + 多线程加速 + 安全文件名）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> --restrict</span>-filenames<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> -N</span> 4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>参数说明</li></ul><table><thead><tr><th>参数</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td><code>-N</code></td><td>指定线程数量</td><td>使用多个线程进行下载，可以加快下载速度</td></tr><tr><td><code>-c</code></td><td>支持断点续传</td><td>从已下载部分直接接着下载，不会重头开始下载</td></tr><tr><td><code>--restrict-filenames</code></td><td>使用安全文件名</td><td>文件名最终会变成类似 <code>2_HOUR_STUDY_WITH_ME.mp4</code></td></tr><tr><td><code>--proxy "http://127.0.0.1:7890"</code></td><td>指定代理</td><td>支持 <code>http://</code>、<code>https://</code>、<code>socks5://</code> 等代理格式</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>YouTube 视频通常分成音频 + 视频两个流下载，<code>yt-dlp</code> 会自动合并处理。</li><li>如果是长视频，建议 <code>yt-dlp</code> 配合 <code>-c</code> 断点续传和 <code>-N</code> 多线程加速，这样即使下载中途断了，也能很快恢复。</li><li><code>-N</code> 参数对大部分 HTTP 分片流（DASH、HLS）有效，对单个 MP4 文件直链无效。有些代理或网络环境下，如果线程数太高，可能触发 YouTube 限制。</li></ul></div><h3 id="查看视频格式"><a href="#查看视频格式" class="headerlink" title="查看视频格式"></a>查看视频格式</h3><ul><li>查看视频支持的格式 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -F</span><span class="params"> --cookies</span>-from-browser chrome<span class="params">  -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:6860"</span> <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>查看视频支持的格式（指定代理和 Cookie）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -F</span><span class="params"> --cookies</span>-from-browser chrome<span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:6860"</span> <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="yt-dlp-使用问题"><a href="#yt-dlp-使用问题" class="headerlink" title="yt-dlp 使用问题"></a>yt-dlp 使用问题</h2><h3 id="缺少-Cookie-信息"><a href="#缺少-Cookie-信息" class="headerlink" title="缺少 Cookie 信息"></a>缺少 Cookie 信息</h3><blockquote><p>问题描述：下载 YouTube 视频时，触发了人机验证 / 登录验证（如下所示），<code>yt-dlp</code> 没法直接绕过，所以它提示要用浏览器 Cookie 来模拟已登录的状态。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: [youtube] 5Q2Pc-e-8Qc: Sign in to confirm you’re not a bot. Use --cookies-from-browser or --cookies for the authentication. See  https://github.com/yt-dlp/yt-dlp/wiki/FAQ#how-do-i-pass-cookies-to-yt-dlp  for how to manually pass cookies. Also see  https://github.com/yt-dlp/yt-dlp/wiki/Extractors#exporting-youtube-cookies  for tips on effectively exporting YouTube cookies</span><br></pre></td></tr></tbody></table></figure><blockquote><p>解决方法一：使用浏览器插件</p></blockquote><ul><li><p>(1) 安装浏览器插件</p><ul><li>推荐用 <code>Get cookies.txt</code>（Chrome）或 Firefox 的同类扩展插件。</li></ul></li><li><p>(2) 导出 Cookie 文件</p><ul><li>浏览器打开 <code>https://www.youtube.com</code></li><li>确保已经登录 Youtube</li><li> 点击扩展插件 → 导出 Cookies → 保存成 <code>cookies.txt</code> 文件</li></ul></li><li><p> (3) 让 <code>yt-dlp</code> 用 Cookie 文件下载</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> --cookies</span> cookies.txt <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>解决方法二：从浏览器自动读取 Cookie</p></blockquote><ul><li><p>(1) <code>yt-dlp</code> 支持直接读取浏览器的 Cookie（需要本地环境支持）</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> --cookies</span>-from-browser chrome<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span> <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>(2) 参数说明</p><ul><li><code>--cookies-from-browser chrome</code> 表示从 Chrome 读取 Cookie，也支持用 <code>firefox</code>、<code>edge</code> 等。</li><li>要求本地浏览器已经登录了 YouTube，并且浏览器没有关掉 Cookie 保存功能。</li></ul></li></ul><h3 id="音频和视频合并失败"><a href="#音频和视频合并失败" class="headerlink" title="音频和视频合并失败"></a>音频和视频合并失败</h3><p>YouTube 视频通常分成音频 + 视频两个流下载，<code>yt-dlp</code> 会在两者下载完成后自动合并处理。但是，如果 <code>.webm</code> 音频是 Opus 编码，直接合并进 <code>.mp4</code> 会报错，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading webpage</span><br><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading tv client config</span><br><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading tv player API JSON</span><br><span class="line">[info] 5Q2Pc-e-8Qc: Downloading 1 format(s): 401+251</span><br><span class="line">[download] 2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].f401.mp4 has already been downloaded</span><br><span class="line">[download] 100% of    3.27GiB</span><br><span class="line">[download] 2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].f251.webm has already been downloaded</span><br><span class="line">[download] 100% of  111.71MiB</span><br><span class="line">[Merger] Merging formats into "2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].webm"</span><br><span class="line">ERROR: Postprocessing: Conversion failed!  </span><br></pre></td></tr></tbody></table></figure><p>这种情况需要使用 Ffmpeg 先将音频转成 AAC 编码，然后再进行合并（前提是 <code>yt-dlp</code> 已经将 <code>.webm</code> 和 <code>.mp4</code> 文件都完整地下载到本地）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg<span class="params"> -i</span> video.mp4<span class="params"> -i</span> audio.webm<span class="params"> -c</span>:v copy<span class="params"> -c</span>:a aac<span class="params"> -b</span>:a 192k output.mp4</span><br></pre></td></tr></tbody></table></figure><h3 id="下载时合并音频和视频"><a href="#下载时合并音频和视频" class="headerlink" title="下载时合并音频和视频"></a>下载时合并音频和视频</h3><p>YouTube 视频通常分成音频 + 视频两个流下载，若希望 <code>yt-dlp</code> 在下载两者的时候直接合并，可以参考以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> <span class="string">"bv*+ba"</span><span class="params"> --merge</span>-output-format mp4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数 <code>-f "bv*+ba"</code> 是 <code>yt-dlp</code> 里的格式选择表达式，意思是：</p><ul><li><code>bv*</code> = best video stream（最好画质的视频流），<code>*</code> 表示不限编码类型（AV1、VP9、H.264 都可以）</li><li><code>ba</code> = best audio stream（最好音质的音频流）</li><li><code>+</code> = 选择视频流和音频流，并在下载后合并成一个文件</li></ul><h3 id="下载时指定视频的分辨率"><a href="#下载时指定视频的分辨率" class="headerlink" title="下载时指定视频的分辨率"></a>下载时指定视频的分辨率</h3><ul><li>查看视频支持的格式 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -F</span><span class="params"> --cookies</span>-from-browser chrome<span class="params">  -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:6860"</span> <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[info] Available formats for DXT9dF-WK-I:</span><br><span class="line">ID      EXT   RESOLUTION FPS CH │   FILESIZE   TBR PROTO │ VCODEC          VBR ACODEC      ABR ASR MORE INFO</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">249-drc webm  audio only      2 │   89.74MiB   51k https │ audio only          opus        51k 48k low, DRC, webm_dash</span><br><span class="line">250-drc webm  audio only      2 │  119.84MiB   67k https │ audio only          opus        67k 48k low, DRC, webm_dash</span><br><span class="line">249     webm  audio only      2 │   88.83MiB   50k https │ audio only          opus        50k 48k low, webm_dash</span><br><span class="line">250     webm  audio only      2 │  118.56MiB   67k https │ audio only          opus        67k 48k low, webm_dash</span><br><span class="line">140-drc m4a   audio only      2 │  229.94MiB  129k https │ audio only          mp4a.40.2  129k 44k medium, DRC, m4a_dash</span><br><span class="line">251-drc webm  audio only      2 │  241.29MiB  136k https │ audio only          opus       136k 48k medium, DRC, webm_dash</span><br><span class="line">140     m4a   audio only      2 │  229.94MiB  129k https │ audio only          mp4a.40.2  129k 44k medium, m4a_dash</span><br><span class="line">251     webm  audio only      2 │  239.12MiB  135k https │ audio only          opus       135k 48k medium, webm_dash</span><br><span class="line">244     webm  854x480     24    │  568.95MiB  320k https │ vp9            320k video only          480p, webm_dash</span><br><span class="line">397     mp4   854x480     24    │  342.40MiB  193k https │ av01.0.04M.08  193k video only          480p, mp4_dash</span><br><span class="line">136     mp4   1280x720    24    │  385.71MiB  217k https │ avc1.4d401f    217k video only          720p, mp4_dash</span><br><span class="line">247     webm  1280x720    24    │    1.05GiB  603k https │ vp9            603k video only          720p, webm_dash</span><br><span class="line">398     mp4   1280x720    24    │  653.15MiB  368k https │ av01.0.05M.08  368k video only          720p, mp4_dash</span><br><span class="line">137     mp4   1920x1080   24    │    1.59GiB  915k https │ avc1.640028    915k video only          1080p, mp4_dash</span><br><span class="line">248     webm  1920x1080   24    │    1.62GiB  934k https │ vp9            934k video only          1080p, webm_dash</span><br><span class="line">399     mp4   1920x1080   24    │    1.21GiB  699k https │ av01.0.08M.08  699k video only          1080p, mp4_dash</span><br><span class="line">271     webm  2560x1440   24    │    4.40GiB 2540k https │ vp9           2540k video only          1440p, webm_dash</span><br><span class="line">400     mp4   2560x1440   24    │    3.72GiB 2146k https │ av01.0.12M.08 2146k video only          1440p, mp4_dash</span><br><span class="line">313     webm  3840x2160   24    │   14.92GiB 8602k https │ vp9           8602k video only          2160p, webm_dash</span><br><span class="line">401     mp4   3840x2160   24    │    8.33GiB 4805k https │ av01.0.12M.08 4805k video only          2160p, mp4_dash</span><br></pre></td></tr></tbody></table></figure><ul><li>下载视频时指定分辨率 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> 137+140 <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><code>137</code> 表示 1920x1080 视频（<code>avc1</code> 编码标记，即 H.264 视频编码）</li><li><code>140</code> 表示 MP4 音频（<code>m4a</code> 音频编码）</li></ul><h3 id="下载时指定视频编码为-H-264"><a href="#下载时指定视频编码为-H-264" class="headerlink" title="下载时指定视频编码为 H.264"></a>下载时指定视频编码为 H.264</h3><p>若希望指定 <code>yt-dlp</code> 下载视频的编码格式为 H.264（在 YouTube 格式代码中，H.264 编码视频通常带有 <code>avc1</code> 标签），可以参考以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> <span class="string">"bv[codec^=avc1]+ba"</span><span class="params"> --merge</span>-output-format mp4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><code>-f "bv[codec^=avc1]+ba"</code><ul><li><code>bv</code> = best video stream（最好画质的视频流）</li><li><code>[codec^=avc1]</code> = <code>codec</code> 字段以 <code>avc1</code> 开头（H.264 的编码标记）</li><li><code>ba</code> = best audio stream（最好音质的音频流）</li><li><code>+</code> = 选择视频流和音频流，并在下载后合并成一个文件</li></ul></li><li><code>--merge-output-format mp4</code><ul><li>限制输出容器是 MP4（和 H.264 配合更好）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Youtube 视频下载工具的使用。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Redis 哨兵机制详解</title>
    <link href="https://www.techgrow.cn/posts/660eca58.html"/>
    <id>https://www.techgrow.cn/posts/660eca58.html</id>
    <published>2025-07-27T13:15:32.000Z</published>
    <updated>2025-07-27T13:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="哨兵机制的概念"><a href="#哨兵机制的概念" class="headerlink" title="哨兵机制的概念"></a>哨兵机制的概念</h2><p>Redis 有三种模式：分别是主从复制、哨兵模式、集群模式，后两者可以保证高可用。</p><ul><li><strong>哨兵（Sentinel）机制是什么</strong><ul><li>哨兵机制主要用于 Redis 主从架构下的故障检测与自动主从切换。</li><li>哨兵一个专门用于高可用的 Redis 组件（节点），不是用于存储数据的。</li><li>哨兵不参与数据同步和读写，而是专门负责监控、故障切换和通知客户端谁是主节点。</li><li>哨兵进程通常和 Redis 节点分开部署（也可以部署在同一台机器上，但进程独立）。</li><li>通常运行多个哨兵实例（即哨兵集群），实现冗余和仲裁。每个哨兵都会连接至 Master 节点和所有 Slave 节点，监控它们的状态信息。</li></ul></li></ul><span id="more"></span><ul><li><p><strong>哨兵（Sentinel）节点的作用是什么</strong></p><ul><li>监控（Monitor）：持续检查主节点和从节点是否存活（通过 PING 等）。</li><li>通知（Notification）：检测到故障后通知系统管理员或其他服务。</li><li>自动故障转移（Failover）：如果主节点不可用，选举一个从节点提升为新主节点。</li><li>服务发现（Discovery）：提供主节点的地址信息给客户端（可供自动重连）；如果发生了故障转移，会通知客户端新的主节点地址。</li></ul></li><li><p><strong>哨兵（Sentinel）节点不是从节点（Slave）</strong></p><ul><li>哨兵节点不负责同步数据，也不参与数据读写。</li><li>它只是通过 Redis 协议连接 Redis 实例，执行命令如 INFO、PING 来感知状态。</li><li>哨兵节点不保存业务数据，最多保存一些监控状态（内存中）。</li></ul></li><li><p><strong>为什么需要哨兵（Sentinel）机制</strong></p><ul><li>Redis 的主从复制机制主要用于实现数据备份和读请求的负载分担，但它本身并不具备自动容错和主节点自动切换的能力。因此，单纯依赖主从复制并不能保证系统的高可用性。具体表现如下：<ul><li>需要人工介入：当主节点发生故障时，Redis 本身无法自动完成故障切换，需要运维人员手动将某个从节点提升为新的主节点，并重新配置其他从节点同步新的主节点。</li><li>单点故障风险：主节点作为写操作的唯一入口，一旦宕机，系统的写操作将完全中断，严重影响服务可用性。</li><li>主节点写入能力受限：Redis 是单线程模型，主节点的写入吞吐受限于单机性能，无法横向扩展。</li><li>单机节点存储容量有限：Redis 通常运行在内存中，主节点的物理内存限制了存储能力。</li></ul></li><li>Redis 哨兵机制应运而生，用于增强 Redis 在主从架构下的高可用性。它具备以下能力：<ul><li>哨兵节点自动监控 Redis 实例状态（包括主节点和从节点）。</li><li>主节点宕机时，自动完成主从切换（Failover）。</li><li>通知支持 Sentinel 机制的客户端连接新的主节点。</li><li>协助管理 Redis 主从结构并确保一致性。</li></ul></li><li>若需要进一步提高 Redis 的可用性与扩展性，还可以使用 Redis Cluster（集群），它支持数据分片（水平扩展），具备原生的多主多从架构、高可用、以及容错能力。</li></ul></li></ul><h2 id="哨兵机制的原理"><a href="#哨兵机制的原理" class="headerlink" title="哨兵机制的原理"></a>哨兵机制的原理</h2><p>Redis 哨兵机制是通过在独立的哨兵节点上运行特定的哨兵进程来实现的。这些哨兵进程监控主从节点的状态，并在出现故障时自动完成故障转移，并通知应用方，实现高可用性。</p><ul><li><p><strong>(1) 哨兵选举：</strong></p><ul><li>在启动时，每个哨兵节点都会参与选举，其中一个哨兵节点会被选为领导者（Leader），负责协调其他哨兵节点执行故障转移。选举过程如下：<ul><li>每个在线的哨兵节点都有资格成为领导者。当某个哨兵判断主节点不可用后，会向其他哨兵节点发送 <code>is-master-down-by-addr</code> 命令，请求判断主节点状态并征求选票，希望被选为本轮的领导者。</li><li>其他哨兵节点在收到该命令后，会根据自身判断和是否已经投票的情况，决定是否同意对方成为领导者（每个哨兵在同一轮选举中只能投票一次）。</li><li>如果某个哨兵节点获得的选票数达到或超过 <code>总哨兵节点数 / 2 + 1</code>（即超过半数），则该哨兵节点将成为本轮选举的领导者；如果未能获得足够票数，则会进入下一轮选举，直到选出领导者为止。</li></ul></li></ul></li><li><p><strong>(2) 哨兵监控主从节点:</strong></p><ul><li>哨兵节点通过发送命令周期性地检查主从节点的健康状态，包括主节点是否在线、从节点是否同步等。</li><li>如果哨兵节点发现主节点不可用，它会触发一次故障转移操作，而且是由哨兵领导者负责处理主节点的故障转移。</li></ul></li><li><p><strong>(3) 哨兵执行故障转移：</strong></p><ul><li>一旦主节点被判定为不可用，哨兵节点会执行故障转移操作。它会从当前的从节点中选出一个新的主节点，并将其他从节点切换到新的主节点。这样，缓存系统可以继续提供服务，而无需人工介入。</li><li>故障转移过程：<ul><li>由哨兵节点定期监控主节点是否出现故障，哨兵节点会定期向主节点发送心跳 PING 来确认主节点是否存活。</li><li>如果主节点在 “一定时间范围” 内不响应 PONG 或者是回复了一个错误消息，那么这个哨兵节点会主观地（单方面地）认为这个主节点已经不可用了。</li></ul></li><li>确认新主节点：<ul><li>过滤掉不健康的从节点（如已下线、网络断连、长时间未响应哨兵 PING 命令的节点）。</li><li>在剩余的健康从节点中，优先选择优先级（Priority）最高的节点。</li><li>如果有多个从节点优先级相同，则选择复制偏移量（Replication Offset）最大的节点，即数据最接近原主节点的从节点。</li><li>若优先级和复制偏移量都相等，则选择节点 ID 字典序最小的节点作为新主节点。</li></ul></li></ul></li><li><p><strong>(4) 客户端重定向：</strong></p><ul><li>当主节点出现故障时，哨兵节点会自动发起主从切换（故障转移），选举一个新的从节点作为新的主节点。</li><li>哨兵节点不会直接通知客户端新的主节点地址，而是提供一个服务发现机制。客户端需要通过支持哨兵机制的客户端，从哨兵节点动态获取当前的主节点地址。</li><li>这样一来，客户端可以在主节点切换后，通过哨兵节点重新获取主节点信息，从而无感知地完成主节点重连，保证业务连续性。</li><li>此外，哨兵节点还会持续监控所有主节点和所有从节点的运行状态，如果某个从节点出现故障，哨兵节点会将其标记为下线；一旦从节点恢复，哨兵节点会自动将其重新加入主从复制架构，并使其同步当前主节点的数据，以维持整个架构的完整性。</li></ul></li></ul><h2 id="哨兵的部署架构"><a href="#哨兵的部署架构" class="headerlink" title="哨兵的部署架构"></a>哨兵的部署架构</h2><p>Redis Sentinel（哨兵）本身是一个分布式系统，通常以哨兵集群的形式部署，多个哨兵节点之间可以协同工作，保障系统的高可用性（如下图所示）。</p><p><img data-src="../../../asset/2025/07/redis-sentinel-3.png"></p><ul><li><strong>哨兵（Sentinel）故障转移的核心概念</strong></li></ul><table><thead><tr><th>概念</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td><code>quorum</code>（法定票数）</td><td>Master 节点从主观下线（sdown）到客观下线（odown）所需的同意哨兵数（即最少 N 个哨兵同时判断 Master 为宕机）</td><td>确保哨兵对 Master 宕机的判断具有一定共识，避免误判</td></tr><tr><td><code>majority</code>（多数哨兵）</td><td>执行故障转移操作时，要求同意执行故障转移的哨兵数量必须达到总数的一半以上，否则不会执行故障转移</td><td>为了避免「脑裂」现象，即多个哨兵在不同网络分区中同时尝试进行故障转移，导致系统不一致或混乱</td></tr></tbody></table><ul><li><p><strong>哨兵（Sentinel）的部署架构是什么</strong></p><ul><li>Redis Sentinel（哨兵）本身是一个分布式系统，通常以哨兵集群的形式部署，多个哨兵节点之间可以协同工作，保障系统的高可用性。<ul><li>哨兵通常以集群的形式部署，这样是为了保证哨兵的高可用性<ul><li><strong>哨兵集群要求至少需要部署 3 个哨兵实例，否则可能无法保证故障转移的正常执行，同时也为了实现多数投票机制，并提高容错能力。</strong></li><li><strong>哨兵集群 + Redis 主从架构能够提供高可用性，但无法做到数据零丢失。故障转移过程中可能存在数据未完整同步到从节点的风险，因此仅适用于对可用性要求高、但允许少量数据丢失的场景。</strong></li><li>由于哨兵 + Redis 主从是一种相对复杂的部署架构，建议在测试环境和生产环境中都进行充分的测试与故障演练，确保系统在各种异常情况下都能稳定运行。</li></ul></li><li>在发生故障转移时，是否将一个主节点判定为宕机，必须经过多数哨兵节点（Quorum）的同意。这涉及到分布式选举机制，用于确保故障转移的判断和执行具备一致性和可靠性。</li><li>即使部分哨兵节点发生故障，哨兵集群仍然能够正常工作。这是因为哨兵本身作为高可用机制的一部分，必须具备容错能力，若其自身是单点的，那就违背了其设计初衷。</li><li>目前使用的是 Sentinel <code>2.x 版本</code>。与 Sentinel <code>1.x</code> 相比，Sentinel <code>2.x</code> 重写了大量核心代码，主要目的是简化故障转移流程、提升算法健壮性和系统稳定性，使其更适用于生产环境中的高可用场景。</li></ul></li></ul></li><li><p><strong>为什么 Redis 哨兵集群只有 2 个节点会无法正常工作</strong></p><ul><li>以部署了 2 个哨兵实例的场景为例（配置：<code>quorum = 1</code>）：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></tbody></table></figure></li><li>当主节点 M1 宕机时，只要 S1 和 S2 中任意一个哨兵认为 M1 宕机，就可以发起主观下线（Subjective Down，简称 sdown）判断。接着，两个哨兵会通过选举机制，选举出其中一个哨兵来执行故障转移操作。</li><li>但是，哨兵系统执行真正的故障转移时，还需要满足 <code>majority</code> 要求，也就是多数哨兵节点同意执行故障转移。例如：<ul><li>2 个哨兵时，要求 <code>majority = 2</code></li><li>3 个哨兵时，要求 <code>majority = 2</code></li><li>4 个哨兵时，要求 <code>majority = 3</code></li><li>5 个哨兵时，要求 <code>majority = 3</code></li></ul></li><li>因此在 2 个哨兵节点的场景中，只有当两个哨兵都正常运行时，才满足 <code>majority</code> 的要求，才允许执行故障转移操作。</li><li>如果运行主节点 M1 和哨兵 S1 的那台机器宕机了，意味着主节点 M1 和哨兵 S1 同时失效，只剩下从节点 R1 和哨兵 S2 仍在运行。此时虽然还有一个哨兵存在（S2），但由于无法满足 <code>majority</code> 要求，故障转移将不会被执行，导致缓存系统始终处于不可用状态。</li></ul></li><li><p><strong>Redis 经典的 3 节点哨兵集群架构</strong></p><ul><li>以部署了 3 个哨兵实例的场景为例（配置：<code>quorum = 2</code>）：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       +----+</span><br><span class="line">       | M1 |</span><br><span class="line">       | S1 |</span><br><span class="line">       +----+</span><br><span class="line">          |</span><br><span class="line">+----+    |    +----+</span><br><span class="line">| R2 |----+----| R3 |</span><br><span class="line">| S2 |         | S3 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></tbody></table></figure></li><li>如果主节点 M1 所在的机器宕机，意味着主节点 M1 和哨兵 S1 同时失效，剩下的两个哨兵 S2 和 S3 仍在运行。此时：<ul><li>哨兵 S2 和 S3 可以一致地判断主节点 M1 宕机了（满足 <code>quorum = 2</code>），从而形成客观下线（odown）判断；</li><li>接着，S2 和 S3 两个哨兵会通过选举机制，选举出其中一个哨兵负责执行故障转移操作；</li><li>因为 3 个哨兵的 <code>majority</code> 要求为 2，而当前恰好有 2 个哨兵仍然存活，所以满足故障转移所需的条件。</li></ul></li><li>因此，在这种经典的 3 节点哨兵集群架构下，即使一台机器宕机，只要剩余的 2 个哨兵还在正常运行，依然可以完成故障转移，从而保证整个哨兵集群的高可用性。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>无论 Redis 是一主一从、一主多从的复制架构，都可以使用 Redis 的哨兵机制，官方更推荐使用一主多从的复制架构，这样可用性更高。</li></ul></div><h2 id="哨兵机制的使用"><a href="#哨兵机制的使用" class="headerlink" title="哨兵机制的使用"></a>哨兵机制的使用</h2><p>在 SpringBoot 项目中，使用 Lettuce 客户端连接 Redis 的一主多从 + 哨兵模式时，只需要在 <code>application.yml</code> 正确配置哨兵信息，SpringBoot 就会自动识别并创建 Lettuce 连接。</p><ul><li>SpringBoot 配置文件示例（<code>application.yml</code>）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span>             <span class="comment"># 主节点名称，对应哨兵配置中的 sentinel monitor 的名称</span></span><br><span class="line">      <span class="attr">nodes:</span>                       <span class="comment"># 哨兵节点列表（ip:port）</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourRedisPassword</span>    <span class="comment"># Redis 认证密码（如果开启了）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><ul><li>若希望使用从节点读取数据（主节点默认可以读写，但从节点只读不可写），可以使用以下 SpringBoot 配置信息 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span>             <span class="comment"># 主节点名称，对应哨兵配置中的 sentinel monitor 的名称</span></span><br><span class="line">      <span class="attr">nodes:</span>                       <span class="comment"># 哨兵节点列表（ip:port）</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourRedisPassword</span>    <span class="comment"># Redis 认证密码（如果开启了）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">read-from:</span> <span class="string">REPLICA_PREFERRED</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>Lettuce 的配置值</th><th>含义</th></tr></thead><tbody><tr><td><code>MASTER</code></td><td>所有请求都从主节点读取（默认）</td></tr><tr><td><code>MASTER_PREFERRED</code></td><td>优先主节点，主节点不可用时才从从节点读取</td></tr><tr><td><code>REPLICA</code>（或 <code>SLAVE</code>）</td><td>所有请求都从从节点读取</td></tr><tr><td><code>REPLICA_PREFERRED</code></td><td>优先从从节点读取，从节点不可用时回退到主节点</td></tr><tr><td><code>NEAREST</code></td><td>从网络延迟最小的节点读取（需要集群拓扑支持）</td></tr></tbody></table><ul><li>Redis 哨兵配置文件示例（<code>redis-sentinel.conf</code>）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控名为 mymaster 的主节点，IP 是 192.168.1.100，端口 6379，</span></span><br><span class="line"><span class="comment"># 至少有 2 个哨兵同时判断该主节点不可达时，才会被判定为主观下线（sdown）</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span> <span class="number">6379 </span><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 5000 毫秒（5 秒）内没有收到主节点的响应，哨兵就认为主节点已主观下线</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个故障转移（Failover）过程的超时时间：10 秒</span></span><br><span class="line"><span class="comment"># 包括选举新主节点、通知其他从节点进行复制、通知客户端更新配置等</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移时，最多同时有 1 个从节点并行地从新的主节点复制数据（同步）</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><ul><li>引入 Lettuce 依赖，使用 Lettuce 的默认连接工厂 </li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot 默认使用 Lettuce 作为 Redis 客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Redis 连接验证代码 </li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"testKey"</span>, <span class="string">"hello from sentinel"</span>);</span><br><span class="line">    String value = stringRedisTemplate.opsForValue().get(<span class="string">"testKey"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Redis 返回: "</span> + value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>SpringBoot 配置（<code>application.yml</code>）的注意事项<ul><li>主从节点的 IP 和端口不需要配置，哨兵模式下 Lettuce 客户端能自动发现主从拓扑结构。</li><li><code>mymaster</code> 一定要和哨兵配置文件（<code>redis-sentinel.conf</code>）里设置的一致。</li><li>Lettuce 默认支持哨兵模式，一般不需要额外配置；但是，如果哨兵模式使用 SSL，则需要显式配置连接工厂。</li><li>SpringBoot 的默认连接池支持读写分离，只需要配置 Lettuce 的 <code>read-from</code> 属性即可生效。</li><li>在 Redis 的主从复制或者集群架构中，主节点可以读写，但从节点默认是只读的，即可以响应读请求（如 <code>GET</code>、<code>MGET</code> 等），但不能写入数据。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>无论 Redis 是一主一从、一主多从还是集群架构，Redis 的主节点都可以读写，从节点默认是可以读（只读，不能写入）；但如果想实现真正的读写分离或者读负载均衡，还需要在客户端进行配置或开发支持（比如 Jedis、Lettuce 都支持手动配置是否访问从节点），因为 Redis 本身不会自动将读请求发送给从节点。由于 Redis 的主从同步可能存在延迟，如果业务对读取一致性要求较高（如读取后马上更新），那么就不要使用从节点读取数据。</p></div><h2 id="哨兵机制的问题"><a href="#哨兵机制的问题" class="headerlink" title="哨兵机制的问题"></a>哨兵机制的问题</h2><h3 id="如何避免脑裂现象"><a href="#如何避免脑裂现象" class="headerlink" title="如何避免脑裂现象"></a>如何避免脑裂现象</h3><ul><li><p><strong>Redis 哨兵集群的脑裂现象是指什么</strong></p><ul><li>指在出现网络分区或者部分哨兵节点失联的情况下，多个哨兵节点在没有达到 <code>majority</code>（多数哨兵）共识的前提下，分别认为 Master 节点宕机并发起故障转移，导致出现两个或多个 Master 节点，从而造成数据不一致或系统混乱。</li><li>值得一提的是，除了主从同步延迟外，脑裂现象也会导致 Redis 集群丢失部分缓存数据。</li></ul></li><li><p><strong>Redis 哨兵集群如何避免脑裂现象</strong></p><ul><li>设置合适的 <code>quorum</code>（法定票数），即某个哨兵要认为主节点下线，必须要有至少 <code>quorum</code> 个哨兵达成共识。</li><li>真正的故障转移必须经过 <code>majority</code> 个哨兵（多数哨兵）投票通过，避免少数哨兵单方面误判。</li><li>因此，只要哨兵总数为奇数（如 3 个或 5 个），且大多数哨兵能互通，就不会发生脑裂现象。<ul><li>举个例子，假设集群中有 3 个哨兵，并配置 <code>quorum = 2</code>，那么：<ul><li>只有至少 2 个哨兵都判断主节点不可用，才会触发故障转移；</li><li>此时，还需要过半（即至少 2 个）的哨兵同意发起故障转移，才能选出新的主节点；</li><li>如果由于网络问题分区成 <code>1 + 2</code> 的两组哨兵，单独的哨兵将无法满足 <code>quorum</code> 和 <code>majority</code> 条件，这样就不会误判，从而避免脑裂。</li></ul></li></ul></li></ul></li></ul><table><thead><tr><th>概念</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td><code>quorum</code>（法定票数）</td><td>Master 节点从主观下线（SDOWN）到客观下线（ODOWN）所需的同意哨兵数（即最少 N 个哨兵同时判断 Master 为宕机）</td><td>确保哨兵对 Master 宕机的判断具有一定共识，避免误判</td></tr><tr><td><code>majority</code>（多数哨兵）</td><td>执行故障转移操作时，要求同意执行故障转移的哨兵数量必须达到总数的一半以上，否则不会执行故障转移</td><td>为了避免「脑裂」现象，即多个哨兵在不同网络分区中同时尝试进行故障转移，导致系统不一致或混乱</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">网络分区是指什么</p><p>网络分区（Network Partition）是指由于网络故障，集群中的一部分节点之间无法正常通信，被分隔成了两个或多个 "孤岛"，每个孤岛只能看到自身可达的节点，看不到其他节点。在 Redis 的哨兵集群架构中，网络分区通常指的是：部分哨兵与主节点失去连接、部分哨兵之间失去通信、主从节点之间断联。这些都可能导致：误判主节点下线、多个哨兵同时发起故障转移、出现多个主节点（脑裂）。</p></div><h3 id="如何避免数据丢失"><a href="#如何避免数据丢失" class="headerlink" title="如何避免数据丢失"></a>如何避免数据丢失</h3><p>Redis 的哨兵机制主要用于主从架构下的故障检测与自动主备切换，但在某些特殊场景下，哨兵机制可能会导致数据丢失，主要包括以下两种情况：</p><ul><li><p><strong>(1) 异步复制导致的数据丢失</strong></p><ul><li>Redis 主从节点之间的数据同步是异步复制，这意味着主节点写入的数据不会立即同步到从节点。<ul><li>当主节点（Master）宕机时，可能仍有部分数据尚未同步写入到从节点（Slave）。</li><li>此时，如果哨兵进行故障转移，从节点被提升为新的主节点，那么这些未同步的数据将永久丢失。</li></ul></li><li>这种情况的本质是主从延迟造成的数据不一致，属于设计上的权衡（异步复制换取更高性能和低延迟）。</li></ul></li><li><p><strong>(2) 脑裂（Split-Brain）导致的数据丢失</strong></p><ul><li>脑裂指的是：主节点与其他哨兵和从节点之间发生网络分区，导致其在局部网络中 “孤岛运行”，而在整体视角下却被认为已宕机。<ul><li>在发生网络分区期间，哨兵可能判定主节点不可用（ODOWN - 客观不可用），并发起故障转移，将某个从节点提升为新的主节点。</li><li>但由于旧主节点实际上仍在运行，客户端可能仍将数据写入旧主节点，形成了两个 “主节点”（双主）。</li><li>当网络恢复时，旧主节点会被哨兵强制转为从节点，并从新主节点复制数据，这会导致旧主节点上的数据被清空。</li></ul></li><li>因此，在发生网络分区的这段时间内，写入旧主节点的数据会丢失，因为它从未被同步到新主节点上，并且在旧主节点恢复后被覆盖掉。</li></ul></li></ul><hr><p>Redis 提供以下两个配置项用于控制写请求行为，从而减少异步复制和脑裂导致的数据丢失。</p><ul><li><code>min-slaves-to-write 1</code>：要求至少有 1 个从节点处于正常连接状态，主节点才允许写入数据。</li><li><code>min-slaves-max-lag 10</code>：要求从节点的复制延迟（ACK 返回的时间）不能超过 10 秒，主节点才允许写入数据。</li></ul><p>当主节点检测到可以正常连接的从节点数量不足，或者所有从节点的复制延迟都超过 10 秒，那么主节点将拒绝客户端的写请求。</p><ul><li><p><strong>(1) 减少异步复制导致的数据丢失</strong></p><ul><li>Redis 的主从复制是异步的。如果主节点宕机，而有些数据尚未同步到从节点，那么这些数据将永久丢失。</li><li>通过设置 <code>min-slaves-max-lag</code>，主节点可以感知从节点复制数据的延迟。如果从节点响应太慢（比如都超过了 10 秒），主节点会拒绝客户端的写入请求，防止继续写入大量数据而无法同步，从而将主节点宕机时可能丢失的数据限制在一个可控的范围（如 10 秒）内。</li></ul></li><li><p><strong>(2) 减少脑裂导致的数据丢失</strong></p><ul><li>在出现脑裂的情况下，客户端可能仍向旧主节点写入数据，形成两个主节点（双主），导致数据不一致和丢失。</li><li>通过 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 这两个配置项，可以防止脑裂主节点继续接受写请求：<ul><li>如果旧主节点失去了所有从节点的连接；</li><li>且在 <code>min-slaves-max-lag</code> 时间（如 10 秒）内未收到任何从节点的 ACK 消息；</li><li>那么主节点将自动停止接受写请求。</li></ul></li><li>这样，即使发生脑裂，旧主节点也会在 10 秒内拒绝写入数据，最多只会丢失 10 秒的数据，大大降低了数据丢失的风险。</li></ul></li></ul><p>当 Redis 主节点拒绝写请求时，客户端可以采取如下策略进行容灾处理：</p><ul><li><strong>(1) 客户限流处理</strong><ul><li>对接口请求进行限流处理，减慢请求涌入的速度，防止请求堆积或爆发式增长。</li></ul></li><li><strong>(2) 异步重试机制</strong><ul><li>将待写入的数据缓存在本地磁盘或者 Kafka 消息队列中。</li><li>客户端定时从本地磁盘或者 Kafka 队列中获取数据（例如每隔 10 分钟），然后尝试将数据重新写回 Redis 主节点。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Redis 的哨兵机制，包括 SpringBoot 项目使用哨兵机制。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="缓存" scheme="https://www.techgrow.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Higress 入门教程 - 基础篇（2025 年）</title>
    <link href="https://www.techgrow.cn/posts/63cc9919.html"/>
    <id>https://www.techgrow.cn/posts/63cc9919.html</id>
    <published>2025-07-22T13:12:19.000Z</published>
    <updated>2025-07-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Higress 是基于阿里内部的 Envoy Gateway 实践沉淀、以开源 Istio + Envoy 为核心构建的下一代云原生网关，实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力，深度集成 Dubbo、Nacos、Sentinel 等微服务技术栈，能够帮助用户极大的降低网关的部署及运维成本。在标准上全面支持 Ingress 与 Gateway API，积极拥抱云原生下的标准 API 规范；同时，Higress Controller 也支持 Nginx Ingress 平滑迁移，可以帮助用户零成本快速迁移到 Higress。</p><span id="more"></span><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li><a href="https://github.com/alibaba/higress">Higress 官方项目</a></li><li><a href="https://higress.cn/docs/latest/overview/what-is-higress/">Higress 官方文档</a></li><li><a href="https://higress.cn/">Higress 官方网站</a></li></ul><h3 id="网关的分类"><a href="#网关的分类" class="headerlink" title="网关的分类"></a>网关的分类</h3><p>行业中通常把网关分为两个大类：流量网关与业务网关，流量网关主要提供全局性的、与后端业务无关的策略配置，例如阿里内部的的统一接入网关 Tengine 就是典型的流量网关；业务网关顾名思义主要提供独立业务域级别的、与后端业务紧耦合策略配置，随着应用架构模式从单体演进到现在的微服务，业务网关也有了新的叫法 - 微服务网关。</p><p><img data-src="../../../asset/2025/07/higress-7.png"></p><p>在虚拟化时期的微服务架构下，业务通常采用流量网关 + 微服务网关的两层架构，流量网关负责南北向流量调度和安全防护，微服务网关负责东西向流量调度和服务治理，而在容器和 K8s 主导的云原生时代，Ingress 成为 K8s 生态的网关标准，赋予了网关新的使命，使得流量网关 + 微服务网关合二为一成为可能。作为面向南北向的公网网关，使用 Waf 防护异常流量是很常规的需求，而且随着互联网环境变得越来越复杂，用户对防护的诉求是持续增强的，常规做法是将流量先接入 Waf 安全网关，过滤后再将流量转发给流量网关，最后到达微服务网关；Higress 希望通过内置 Waf 模块，使得用户的请求链接只经过 Higress 就可以同时完成 Waf 防护、流量分发、微服务治理，既可以降低链路 RT，也可以降低网关的运维复杂度。因此 Higress 实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力。</p><p><img data-src="../../../asset/2025/07/higress-8.png"></p><h2 id="Higress-简介"><a href="#Higress-简介" class="headerlink" title="Higress 简介"></a>Higress 简介</h2><h3 id="Higress-是什么"><a href="#Higress-是什么" class="headerlink" title="Higress 是什么"></a>Higress 是什么</h3><ul><li>Higress 是一款云原生 API 网关，内核基于 Istio 和 Envoy，可以用 Go/Rust/JS 等编写 Wasm 插件，提供了数十个现成的通用插件，以及开箱即用的控制台。</li><li>Higress 在阿里内部为解决 Tengine Reload 对长连接业务有损，以及 gRPC/Dubbo 负载均衡能力不足而诞生。</li><li>阿里云基于 Higress 构建了云原生 API 网关产品，为大量企业客户提供 99.99% 的网关高可用保障服务能力。</li><li>Higress 基于 AI 网关能力，支撑了通义千问 APP、百炼大模型 API、机器学习 PAI 平台等 AI 业务。同时服务国内头部的 AIGC 企业（如零一万物），以及 AI 产品（如 FastGPT）。</li></ul><p><img data-src="../../../asset/2025/07/higress-1.png"></p><h3 id="什么是-AI-网关"><a href="#什么是-AI-网关" class="headerlink" title="什么是 AI 网关"></a>什么是 AI 网关</h3><p>AI Gateway = AI Native API GatewayAI，网关的本质依然是 API 网关，AI 原生的意义在于，在这样的 API 网关里，AI 是一等公民。API 研发、API 供应、API 消费、以及 API 观测都基于 AI 场景下的需求，演进出全新的能力。</p><blockquote><p>这是传统 API 网关的功能范畴，AI 场景下仍然有其通用价值：</p></blockquote><p><img data-src="../../../asset/2025/07/higress-2.png"></p><blockquote><p>在 AI 场景下，基于 Higress 可以将 API 网关的功能范畴进一步扩展：</p></blockquote><p><img data-src="../../../asset/2025/07/higress-3.png"></p><h3 id="Higress-核心优势"><a href="#Higress-核心优势" class="headerlink" title="Higress 核心优势"></a>Higress 核心优势</h3><ul><li><p>生产等级</p><ul><li>脱胎于阿里巴巴多年生产验证的内部产品，支持每秒请求量达数十万级的大规模场景。</li><li>彻底摆脱 Nginx Reload 引起的流量抖动，配置变更毫秒级生效且业务无感。对 AI 业务等长连接场景特别友好。</li></ul></li><li><p>便于扩展</p><ul><li>提供丰富的官方插件库，涵盖 AI、流量管理、安全防护等常用功能，满足 90% 以上的业务场景需求。</li><li>主打 Wasm 插件扩展，通过沙箱隔离确保内存安全，支持多种编程语言，允许插件版本独立升级，实现流量无损热更新网关逻辑。</li></ul></li><li><p>安全易用</p><ul><li>基于 Ingress API 和 Gateway API 标准，提供开箱即用的 UI 控制台，WAF 防护插件、IP/Cookie CC 防护插件开箱即用。</li><li>支持对接 Let’s Encrypt 自动签发和续签免费证书，并且可以脱离 K8s 部署，一行 Docker 命令即可启动，方便个人开发者使用。</li></ul></li><li><p>流式处理</p><ul><li>支持真正的完全流式处理请求 / 响应 Body，Wasm 插件很方便地自定义处理 SSE（Server-Sent Events）等流式协议的报文。</li><li>在 AI 业务等大带宽场景下，可以显著降低内存开销。</li></ul></li></ul><h3 id="Higress-使用场景"><a href="#Higress-使用场景" class="headerlink" title="Higress 使用场景"></a>Higress 使用场景</h3><h4 id="AI-网关"><a href="#AI-网关" class="headerlink" title="AI 网关"></a>AI 网关</h4><p>Higress 能够用统一的协议对接国内外所有 LLM 模型厂商，同时具备丰富的 AI 可观测、多模型负载均衡 / Fallback、AI Token 流控、AI 缓存等能力：</p><p><img data-src="../../../asset/2025/07/higress-4.png"></p><h4 id="K8s-Ingress-网关"><a href="#K8s-Ingress-网关" class="headerlink" title="K8s Ingress 网关"></a>K8s Ingress 网关</h4><p>Higress 可以作为 K8s 集群的 Ingress 入口网关，并且兼容了大量 K8s Nginx Ingress 的注解，可以从 K8s Nginx Ingress 快速平滑迁移到 Higress。支持 Gateway API 标准，支持用户从 Ingress API 平滑迁移到 Gateway API。相比 ingress-nginx，资源开销大幅下降，路由变更生效速度有十倍提升。</p><p><img data-src="../../../asset/2025/07/higress-5.png"></p><h4 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h4><p>Higress 可以作为微服务网关，能够对接多种类型的注册中心发现服务配置路由，例如 Nacos、ZooKeeper、Consul、Eureka 等。并且深度集成了 Dubbo、Nacos、Sentinel 等微服务技术栈，基于 Envoy C++ 网关内核的出色性能，相比传统 Java 类微服务网关，可以显著降低资源使用率，减少成本。</p><p><img data-src="../../../asset/2025/07/higress-6.png"></p><h4 id="安全防护网关"><a href="#安全防护网关" class="headerlink" title="安全防护网关"></a>安全防护网关</h4><p>Higress 可以作为安全防护网关，提供 WAF 的能力，并且支持多种认证鉴权策略，例如 key-auth、hmac-auth、jwt-auth、basic-auth、oidc 等。</p><h3 id="Higress-整体架构"><a href="#Higress-整体架构" class="headerlink" title="Higress 整体架构"></a>Higress 整体架构</h3><ul><li>整体上 Higress 网关由控制面组件 Higress-Controller 和数据面组件 Higress-Gateway 组成。Higress-Gateway 负责承载数据流量，Higress-Controller 负责管理配置下发。</li><li>数据面组件 Higress-Gateway 是基于 Envoy 开发的网关组件，负责接收和处理流量，支持 HTTP/1.1、HTTP/2、gRPC 等协议，支持 TLS、mTLS、WAF、限流、熔断、重试、负载均衡、路由、转发、重定向、跨域等功能，也就是说真正的流量处理都是在 Higress-Gateway 中完成的。</li><li>控制面组件 Higress-Controller 负责管理配置下发，支持 Ingress API、Gateway API、Istio API，支持多种注册中心，支持多种认证鉴权策略，支持多种插件扩展机制，支持多种 CRD 实现流量精细化管理，也就是说所有的配置都是通过 Higress-Controller 下发到 Higress-Gateway 中的。</li></ul><p><img data-src="../../../asset/2025/07/higress-9.png"></p><h3 id="Higress-开发语言"><a href="#Higress-开发语言" class="headerlink" title="Higress 开发语言"></a>Higress 开发语言</h3><p>Higress 主要是基于 Envoy Proxy 开发的，核心是用 C++（Envoy 内核）和 Go（控制面、插件、扩展部分）组合实现的。</p><table><thead><tr><th>组件</th><th>语言</th><th>作用</th></tr></thead><tbody><tr><td> Envoy Proxy（数据面）</td><td>C++</td><td>Higress 的流量转发核心，负责 HTTP/TCP 代理、路由、负载均衡，使用 Envoy 做高性能转发。</td></tr><tr><td>控制面 / 插件 / 扩展逻辑</td><td> Go</td><td>Higress 提供了 Ingress、Gateway API 的控制逻辑、配置管理、Wasm 插件管理等，这部分主要用 Go 实现。</td></tr><tr><td>Wasm 插件（可选）</td><td>WebAssembly（多语言）</td><td>Higress 支持流量治理的 Wasm 扩展，用户可以用 Rust、C++、AssemblyScript 编写。</td></tr></tbody></table><p>为什么采用这种语言组合？</p><ul><li>C++（Envoy 内核）：高性能、云原生友好，成熟的代理框架。</li><li>Go（控制面、插件）：易于集成 Kubernetes，开发效率高，社区有大量的 Ingress/Gateway 生态。</li><li>Wasm（扩展能力）：支持动态扩展，不用重启服务。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/qq_45038038/article/details/136005591">下一代云原生网关 Higress</a></li><li><a href="https://www.51cto.com/article/786706.html">Higress 或许是目前最好的云原生网关</a></li><li><a href="https://zhuanlan.zhihu.com/p/21624794301">使用 Higress 统一替代 APISIX/Kong/Istio Ingress</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Higress 的基础使用。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之一</title>
    <link href="https://www.techgrow.cn/posts/99bf51b3.html"/>
    <id>https://www.techgrow.cn/posts/99bf51b3.html</id>
    <published>2025-07-22T13:12:19.000Z</published>
    <updated>2025-07-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li><li><a href="/posts/2ca57d7f.html">Kubernetes 入门教程之七</a>、<a href="/posts/723af70c.html">Kubernetes 入门教程之八</a>、<a href="/posts/cfb1715d.html">Kubernetes 入门教程之九</a></li><li><a href="/posts/6158b4d2.html">Kubernetes 入门教程之十</a>、<a href="/posts/fb1a55bb.html">Kubernetes 入门教程之十一</a></li></ul><h2 id="Kubernetes-简单介绍"><a href="#Kubernetes-简单介绍" class="headerlink" title="Kubernetes 简单介绍"></a>Kubernetes 简单介绍</h2><h3 id="各种部署方式的区别"><a href="#各种部署方式的区别" class="headerlink" title="各种部署方式的区别"></a>各种部署方式的区别</h3><p>传统的应用部署方式是通过插件或脚本来安装应用，这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新、回滚等操作；当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能够快速部署，由于容器与底层设施、机器文件系统解耦的，所以它能在不同云、不同版本操作系统间进行迁移。容器占用资源少、部署快，每个应用可以被打包成一个容器镜像，每个应用与容器间成一对一关系也使容器有更大优势，使用容器可以在 <code>build</code> 或 <code>release</code> 的阶段，为应用创建容器镜像，因为每个应用不需要与其余的应用堆栈组合，也不依赖于生产环境基础结构，这使得从研发到测试、生产能提供一致环境。类似地，容器比虚拟机轻量、更 “透明”，这更便于监控和管理。</p><span id="more"></span><h3 id="Kubernetes-基本介绍"><a href="#Kubernetes-基本介绍" class="headerlink" title="Kubernetes 基本介绍"></a>Kubernetes 基本介绍</h3><p>Kubernetes 是 Google 于 2014 年 6 月正式开源的一个容器编排引擎，简称 K8s，是用 8 代替 8 个字符 <code>ubernete</code> 而成的缩写。Kubernetes 可用于管理云平台中多个主机上的容器化的应用，支持自动化部署、大规模扩缩容、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。Kubernetes 提供了应用部署、规划、更新、维护的一种机制。在 Kubernetes 中，可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p><h3 id="Kubernetes-功能介绍"><a href="#Kubernetes-功能介绍" class="headerlink" title="Kubernetes 功能介绍"></a>Kubernetes 功能介绍</h3><p>Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过 Kubernetes 能够进行应用的自动化部署和扩缩容。在 Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes 积累了作为 Google 生产环境运行工作负载 15 年的经验，并吸收了来自于社区的最佳想法和实践。Kubernetes 的核心功能如下：</p><ul><li>自动装箱：基于容器对应用运行环境的资源配置要求自动部署应用容器</li><li>自我修复：当容器运行失败时，会对容器进行重启；当所部署的 Node（工作节点）有问题时，会对容器进行重新部署和重新调度；当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</li><li>水平扩展：通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</li><li>服务发现：用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡</li><li>滚动更新：可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</li><li>版本回退：可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</li><li>密钥和配置管理：在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署</li><li>存储编排：自动实现存储系统挂载及应用，这特别对有状态应用实现数据持久化非常重要；存储系统可以来自于本地目录、网络存储（NFS、Gluster、Ceph 等）、公共云存储服务</li><li>批处理：提供一次性任务，定时任务，满足批量数据处理和分析的场景</li></ul><h3 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h3><table><thead><tr><th>技术名称</th><th>技术描述</th></tr></thead><tbody><tr><td> YAML 配置文件</td><td>使用 YAML 文件定义 Kubernetes 资源，如 Pod、Service、Deployment 等，是声明式管理的基础。</td></tr><tr><td>kubectl 命令工具</td><td> Kubernetes 的命令行客户端工具，用于操作集群、部署资源、排查故障等。</td></tr><tr><td>Pod</td><td>Kubernetes 中最小的可调度单元，通常封装一个或多个容器，容器共享网络和存储。</td></tr><tr><td>Controller（控制器）</td><td>自动化资源管理的核心组件，如 Deployment、ReplicaSet、StatefulSet、DaemonSet 等控制器。</td></tr><tr><td>Service</td><td> 定义一组 Pod 的统一访问入口，支持负载均衡和服务发现。</td></tr><tr><td>Label</td><td> 给资源打标签的机制，支持资源的分类、选择、分组管理等，用于调度和服务发现。</td></tr><tr><td>Volume</td><td> 提供容器持久化或共享数据的机制，支持本地存储、NFS、云存储等。</td></tr><tr><td>PVC 和 PV</td><td>PVC（Persistent Volume Claim）是用户请求的存储资源，PV（Persistent Volume）是实际存储资源，解耦用户和存储实现。</td></tr><tr><td>Secret 和 ConfigMap</td><td>Secret 用于管理敏感数据，ConfigMap 用于存储配置数据，都可挂载进容器或作为环境变量使用。</td></tr><tr><td>Namespace</td><td> 提供资源隔离的逻辑空间，用于多租户环境或资源分类管理。</td></tr><tr><td>Probes（探针）</td><td>包括存活探针（liveness）和就绪探针（readiness），用于健康检查和控制流量转发。</td></tr><tr><td>API Server</td><td>Kubernetes 控制平面的核心组件，负责处理来自 kubectl 或其他客户端的请求，并与 Etcd、Controller（控制器）、Scheduler（调度器）等交互。</td></tr><tr><td>Scheduler（调度器）</td><td>根据资源需求、约束条件和策略将 Pod 分配到合适的节点。</td></tr><tr><td>集群安装机制与 RBAC</td><td> 安装机制包括 kubeadm、Kops、RKE 等，RBAC（基于角色的访问控制）用于权限管理和安全控制。</td></tr><tr><td>Helm</td><td>Kubernetes 的包管理工具，用于简化应用部署，支持版本管理、参数化配置等。</td></tr></tbody></table><h3 id="Kubernetes-核心概念"><a href="#Kubernetes-核心概念" class="headerlink" title="Kubernetes 核心概念"></a>Kubernetes 核心概念</h3><p>Kubernetes 三个核心概念（Pod、Controller、Service）的介绍（<a href="../../../asset/2025/09/k8s-core.png">如图所示</a>）：</p><ul><li><p>Pod（最小部署单元）</p><ul><li>Pod 是 Kubernetes 中最小的调度和运行单元。</li><li>本质上是一组容器的集合（通常是一个容器）。</li><li>容器之间共享网络（IP、端口）和存储卷。</li><li>Pod 的生命周期可以是短暂的，比如用于运行临时任务或被控制器自动重建。</li></ul></li><li><p>Controller（控制器）</p><ul><li>用于管理和自动化 Pod 的部署与副本数量。</li><li>支持无状态应用部署（如 Deployment）。</li><li>支持有状态应用部署（如 StatefulSet）。</li><li>可实现以下功能：<ul><li>保证指定数量的 Pod 实例持续运行。</li><li>在多个节点上部署同一类 Pod（如 DaemonSet）。</li><li>支持一次性任务（Job）和定时任务（CronJob）。</li></ul></li></ul></li><li><p>Service（服务）</p><ul><li>负责定义一组 Pod 的访问规则。</li><li>提供统一的访问入口（Cluster IP、NodePort、LoadBalancer 等），实现服务发现与负载均衡。</li><li>解决 Pod 动态 IP 和短生命周期带来的访问不稳定问题。</li></ul></li></ul><p>Pod、Controller、Service 这三个核心概念的关系：</p><ul><li>Pod 是具体运行的实例。</li><li>Controller 管理 Pod 的创建、副本和调度。</li><li>Service 让外部或内部服务可以稳定地访问 Pod。</li></ul><h2 id="Kubernetes-集群搭建"><a href="#Kubernetes-集群搭建" class="headerlink" title="Kubernetes 集群搭建"></a>Kubernetes 集群搭建</h2><h3 id="集群架构组件"><a href="#集群架构组件" class="headerlink" title="集群架构组件"></a>集群架构组件</h3><p><img data-src="../../../asset/2025/07/k8s-1.png"></p><ul><li><p><code>Master（主控节点）</code>：Kubernetes 集群控制节点，负责对集群进行调度管理，接受集群外的用户去集群操作请求。Master 由 API Server、Scheduler、Controller Manager、Etcd 存储系统组成</p><ul><li>Scheduler：节点调度，选择 Node（工作节点）来应用部署</li><li> API Server：集群统一入口，以 RESTful 接口将数据交给 Etcd 进行存储</li><li> Controller Manager：处理集群中的常规后台任务，一个资源对应一个控制器</li><li> Etcd 存储系统：用于存储集群相关的数据</li></ul></li><li><p><code>Node（工作节点）</code>：Kubernetes 集群工作节点，负责运行用户业务应用容器，Node 由 Kubelet、Kube-Proxy 和 Container Runtime 组成</p><ul><li>Kubelet：负责 Pod 对应的容器的创建、启停管理，与 Master 节点协作，实现集群管理的基本功能</li><li> Kube-Proxy：提供 Kubernetes 的通信与负载均衡功能的重要组件</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Etcd 是什么</p><ul><li>在分布式系统中，Etcd 是一个高可用、强一致性的分布式键值存储系统，在 Kubernetes 等系统中扮演着核心元数据存储和协调中心的角色。</li><li>Etcd 属于更底层的基础组件，使用 Raft 算法实现强一致性（满足 CAP 中的 C 和 P），提供了一致性的 KV 存储、watch、lease、事务等机制。</li></ul></div><h3 id="集群搭建规划"><a href="#集群搭建规划" class="headerlink" title="集群搭建规划"></a>集群搭建规划</h3><p>Kubernetes 集群有两种类型，包括单 Master 集群和多 Master 集群，为了提高集群的高可用性，生产环境一般采用多 Master 集群方案，如下图所示：</p><p><img data-src="../../../asset/2021/03/kubernetes-cluster-plan.png"></p><h3 id="集群搭建要求"><a href="#集群搭建要求" class="headerlink" title="集群搭建要求"></a>集群搭建要求</h3><p>搭建 Kubernetes 集群需要满足以下几个条件：</p><ul><li>一台或多台机器，建议操作系统 CentOS 7（64 位）</li><li>Master 节点的硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 20GB 或更多</li><li> Node（工作节点）的硬件配置：4GB 或更多 RAM，4 个 CPU 或更多 CPU，硬盘 40GB 或更多</li><li>集群中所有机器之间的网络可以互通</li><li>系统内可以访问外网，需要拉取镜像</li><li>禁用 Swap 分区（必须）</li></ul><h3 id="集群搭建方式"><a href="#集群搭建方式" class="headerlink" title="集群搭建方式"></a>集群搭建方式</h3><p>目前生产环境搭建 Kubernetes 集群主要有以下两种方式：</p><ul><li><p><strong>Kubeadm</strong></p><ul><li><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">Kubeadm</a> 是一个 Kubernetes 部署工具，提供 <code>kubeadm init</code> 和 <code>kubeadm join</code> 命令，可用于快速搭建 Kubernetes 集群。</li></ul></li><li><p><strong>二进制包</strong></p><ul><li>从 Github 下载发行版的二进制包，手动部署每个组件，组成 Kubernetes 集群。Kubeadm 虽然降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。</li><li>如果想集群整体更可控，生产环境推荐使用二进制包搭建 Kubernetes 集群，虽然手动部署比较麻烦，但期间可以学习很多工作原理，也利于后期维护。</li></ul></li></ul><h3 id="集群搭建步骤"><a href="#集群搭建步骤" class="headerlink" title="集群搭建步骤"></a>集群搭建步骤</h3><h4 id="二进制包方式搭建集群"><a href="#二进制包方式搭建集群" class="headerlink" title="二进制包方式搭建集群"></a>二进制包方式搭建集群</h4><ul><li><a href="/posts/ccd6f2d4.html">基于二进制包方式搭建 Kubernetes 集群</a></li></ul><h4 id="Kubeadm-方式搭建集群"><a href="#Kubeadm-方式搭建集群" class="headerlink" title="Kubeadm 方式搭建集群"></a>Kubeadm 方式搭建集群</h4><ul><li><a href="/posts/b728042a.html">基于 Kubeadm 方式搭建 Kubernetes 集群</a></li></ul><h2 id="Kubernetes-核心技术-1"><a href="#Kubernetes-核心技术-1" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="kubectl-命令行工具"><a href="#kubectl-命令行工具" class="headerlink" title="kubectl 命令行工具"></a>kubectl 命令行工具</h3><p>kubectl 是 Kubernetes 集群的命令行工具，通过 kubectl 能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。</p><h4 id="kubectl-的语法"><a href="#kubectl-的语法" class="headerlink" title="kubectl 的语法"></a>kubectl 的语法</h4><ul><li><p>命令语法：<code>kubectl [command] [type] [name] [flags]</code></p></li><li><p><code>command</code>：</p><ul><li>指定要对资源执行的操作</li><li>例如：<code>create</code>、<code>get</code>、<code>describe</code> 和 <code>delete</code></li></ul></li><li><p><code>type</code>：</p><ul><li>指定资源类型，资源类型是大小写敏感的，开发者能够以单数、复数和缩略的形式。例如:</li><li><code>kubectl get pod pod1</code></li><li><code>kubectl get pods pod1</code></li><li><code>kubectl get po pod1</code></li><li><code>kubectl get nodes K8s-node1</code></li></ul></li><li><p><code>name</code>：</p><ul><li>指定资源的名称，名称大小写敏感。如果省略资源名称，则会显示所有的资源。例如：</li><li><code>kubectl get pods</code></li><li><code>kubectl get nodes</code></li><li><code>kubectl get nodes K8s-node1</code></li></ul></li><li><p><code>flags</code>：</p><ul><li>指定可选的参数。例如，可以使用 <code>-s</code> 或者 <code>-server</code> 参数指定 Kubernetes API Server 的地址和端口。</li></ul></li></ul><h4 id="kubectl-的使用帮助手册"><a href="#kubectl-的使用帮助手册" class="headerlink" title="kubectl 的使用帮助手册"></a>kubectl 的使用帮助手册</h4><p>可以使用 <code>kubectl --help</code> 命令查看 kubectl 命令的整体使用帮助，包括所有可用的主命令及其简要说明；还可以通过 <code>kubectl &lt;command&gt; --help</code> 获取某个具体子命令的详细使用手册和参数说明。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 kubectl 的所有主命令和帮助信息</span></span><br><span class="line"><span class="keyword"># kubectl</span><span class="params"> --help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kubectl get 子命令的详细用法和参数说明</span></span><br><span class="line"><span class="keyword"># kubectl</span> get<span class="params"> --help</span></span><br></pre></td></tr></tbody></table></figure><p>比如，<code>kubectl help</code> 命令输出的帮助内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">kubectl controls the Kubernetes cluster manager.</span><br><span class="line"></span><br><span class="line"> Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/</span><br><span class="line"></span><br><span class="line">Basic Commands (Beginner):</span><br><span class="line">  create        Create a resource from a file or from stdin.</span><br><span class="line">  expose        使用 replication controller, service, deployment 或者 pod 并暴露它作为一个 新的 Kubernetes</span><br><span class="line">Service</span><br><span class="line">  run           在集群中运行一个指定的镜像</span><br><span class="line">  set           为 objects 设置一个指定的特征</span><br><span class="line"></span><br><span class="line">Basic Commands (Intermediate):</span><br><span class="line">  explain       查看资源的文档</span><br><span class="line">  get           显示一个或更多 resources</span><br><span class="line">  edit          在服务器上编辑一个资源</span><br><span class="line">  delete        Delete resources by filenames, stdin, resources and names, or by resources and label selector</span><br><span class="line"></span><br><span class="line">Deploy Commands:</span><br><span class="line">  rollout       Manage the rollout of a resource</span><br><span class="line">  scale         Set a new size for a Deployment, ReplicaSet or Replication Controller</span><br><span class="line">  autoscale     自动调整一个 Deployment, ReplicaSet, 或者 Replication Controller 的副本数量</span><br><span class="line"></span><br><span class="line">Cluster Management Commands:</span><br><span class="line">  certificate   修改 certificate 资源.</span><br><span class="line">  cluster-info  显示集群信息</span><br><span class="line">  top           Display Resource (CPU/Memory/Storage) usage.</span><br><span class="line">  cordon        标记 node 为 unschedulable</span><br><span class="line">  uncordon      标记 node 为 schedulable</span><br><span class="line">  drain         Drain node in preparation for maintenance</span><br><span class="line">  taint         更新一个或者多个 node 上的 taints</span><br><span class="line"></span><br><span class="line">Troubleshooting and Debugging Commands:</span><br><span class="line">  describe      显示一个指定 resource 或者 group 的 resources 详情</span><br><span class="line">  logs          输出容器在 pod 中的日志</span><br><span class="line">  attach        Attach 到一个运行中的 container</span><br><span class="line">  exec          在一个 container 中执行一个命令</span><br><span class="line">  port-forward  Forward one or more local ports to a pod</span><br><span class="line">  proxy         运行一个 proxy 到 Kubernetes API server</span><br><span class="line">  cp            复制 files 和 directories 到 containers 和从容器中复制 files 和 directories.</span><br><span class="line">  auth          Inspect authorization</span><br><span class="line"></span><br><span class="line">Advanced Commands:</span><br><span class="line">  diff          Diff live version against would-be applied version</span><br><span class="line">  apply         通过文件名或标准输入流(stdin)对资源进行配置</span><br><span class="line">  patch         使用 strategic merge patch 更新一个资源的 field(s)</span><br><span class="line">  replace       通过 filename 或者 stdin替换一个资源</span><br><span class="line">  wait          Experimental: Wait for a specific condition on one or many resources.</span><br><span class="line">  convert       在不同的 API versions 转换配置文件</span><br><span class="line">  kustomize     Build a kustomization target from a directory or a remote url.</span><br><span class="line"></span><br><span class="line">Settings Commands:</span><br><span class="line">  label         更新在这个资源上的 labels</span><br><span class="line">  annotate      更新一个资源的注解</span><br><span class="line">  completion    Output shell completion code for the specified shell (bash or zsh)</span><br><span class="line"></span><br><span class="line">Other Commands:</span><br><span class="line">  alpha         Commands for features in alpha</span><br><span class="line">  api-resources Print the supported API resources on the server</span><br><span class="line">  api-versions  Print the supported API versions on the server, in the form of "group/version"</span><br><span class="line">  config        修改 kubeconfig 文件</span><br><span class="line">  plugin        Provides utilities for interacting with plugins.</span><br><span class="line">  version       输出 client 和 server 的版本信息</span><br><span class="line"></span><br><span class="line">Use "kubectl &lt;command&gt; --help" for more information about a given command.</span><br><span class="line">Use "kubectl options" for a list of global command-line options (applies to all commands).</span><br></pre></td></tr></tbody></table></figure><h4 id="kubectl-的子命令使用分类"><a href="#kubectl-的子命令使用分类" class="headerlink" title="kubectl 的子命令使用分类"></a>kubectl 的子命令使用分类</h4><ul><li>基础命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>create</code></td><td>通过文件名或标注输入创建资源</td></tr><tr><td><code>expose</code></td><td>将一个资源公开为一个新的 Service</td></tr><tr><td><code>run</code></td><td>在集群中运行一个特定的镜像</td></tr><tr><td><code>set</code></td><td>在对象上设置特定的功能</td></tr><tr><td><code>get</code></td><td>显示一个或多个资源</td></tr><tr><td><code>explain</code></td><td>文档参考资料</td></tr><tr><td><code>edit</code></td><td>使用默认的编辑器编辑一个资源</td></tr><tr><td><code>delete</code></td><td>通过文件名、标注输入、资源名或标注选择来删除资源</td></tr></tbody></table><ul><li> 部署命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>rollout</code></td><td>管理资源的发布</td></tr><tr><td><code>rolling-update</code></td><td>对某些类型的副本控制器滚动更新</td></tr><tr><td><code>scale</code></td><td>扩容或缩容 Pod 数量，Deployment、ReplicaSet、Replication Controller 或 Job</td></tr><tr><td><code>autoscale</code></td><td>创建一个自动选择扩容或缩容容器并设置 Pod 数量</td></tr></tbody></table><ul><li> 集群管理命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>certificate</code></td><td>修改证书资源</td></tr><tr><td><code>cluster-info</code></td><td>显示集群信息</td></tr><tr><td><code>top</code></td><td>显示资源（CPU/Memory/Storage）使用情况，需要 Heapster 运行</td></tr><tr><td><code>cordon</code></td><td>标记节点不可调度</td></tr><tr><td><code>uncordon</code></td><td>标记节点可调度</td></tr><tr><td><code>drain</code></td><td>驱逐节点上的应用，准备下线维护</td></tr><tr><td><code>taint</code></td><td>修改节点 Taint 标记</td></tr></tbody></table><ul><li>故障和调试命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>describe</code></td><td>显示特定资源或资源组的详细信息</td></tr><tr><td><code>logs</code></td><td>在一个 Pod 中打印一个容器日志。如 Pod 只有一个容器，容器名称是可选的</td></tr><tr><td><code>attach</code></td><td>附加到一个运行的容器</td></tr><tr><td><code>exec</code></td><td>执行命令到容器</td></tr><tr><td><code>port-forward</code></td><td>转发一个或多个本地端口到一个 Pod</td></tr><tr><td><code>proxy</code></td><td>运行一个 Proxy 到 Kubernetes API server</td></tr><tr><td><code>cp</code></td><td>拷贝文件和目录到容器中或从容器中拷贝出来</td></tr><tr><td><code>auth</code></td><td>检查授权</td></tr></tbody></table><ul><li>其他高级命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>apply</code></td><td>通过文件名或标准输入对资源应用配置</td></tr><tr><td><code>patch</code></td><td>使用补丁修改、更新资源的字段</td></tr><tr><td><code>replace</code></td><td>通过文件名或标准输入替换一个资源</td></tr><tr><td><code>convert</code></td><td>不同的 API 版本之间转换配置文件</td></tr></tbody></table><ul><li>其他设置命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>label</code></td><td>更新资源上的标签</td></tr><tr><td><code>annotate</code></td><td>更新资源上的注释</td></tr></tbody></table><ul><li>其他常用命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>completion</code></td><td>用于实现 kubectl 工具自动补全</td></tr><tr><td><code>api-versions</code></td><td>打印可用的 API 版本</td></tr><tr><td><code>config</code></td><td>修改 kubeconfig 文件（用于访问 API，比如凭证信息配置）</td></tr><tr><td><code>help</code></td><td>所有命令帮助</td></tr><tr><td><code>plugin</code></td><td>运行一个可执行插件</td></tr><tr><td><code>version</code></td><td>打印客户端和服务端的版本信息</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">最常用的命令</p><ul><li><code>kubectl get pods</code>：查看当前命名空间下所有 Pod 的状态信息。</li><li><code>kubectl get nodes</code>：查看集群中所有节点（Node）的状态信息。</li><li><code>kubectl get svc</code>： 查看当前命名空间下所有 Service（服务）资源的配置信息。</li><li><code>kubectl get cs</code>： 查看集群核心组件（ComponentStatus，如 Scheduler、Controller Manager 等）的运行状态，已过时不推荐使用。</li></ul></div><h3 id="YAML-资源编排清单"><a href="#YAML-资源编排清单" class="headerlink" title="YAML 资源编排清单"></a>YAML 资源编排清单</h3><p>在 Kubernetes 集群中，资源管理和资源对象的编排部署可以通过声明式的 YAML 文件来实现。用户可以将对资源对象的操作需求编写到 YAML 格式的配置文件中，这种文件称为资源清单文件。通过 kubectl 命令直接调用这些资源清单文件，就能够高效地完成大量资源对象的编排和部署工作。</p><h4 id="YAML-的概述"><a href="#YAML-的概述" class="headerlink" title="YAML 的概述"></a>YAML 的概述</h4><ul><li>YAML 是一个可读性高，用来表达数据序列的格式。</li><li>YAML 仍是一种标记语言，为了强调这种语言以数据作为中心，而不是以标记语言为重点。</li></ul><h4 id="YAML-的基本语法"><a href="#YAML-的基本语法" class="headerlink" title="YAML 的基本语法"></a>YAML 的基本语法</h4><ul><li>使用空格作为缩进；</li><li>缩进的空格数量不重要，只要相同层级的元素左侧对齐即可；</li><li>低版本缩进时，不允许使用 Tab 键，只允许使用空格；</li><li>使用 <code>---</code> 作为文档分隔符，表示一个 YAML 文件中的多文档边界；</li><li>使用 <code>#</code> 标识注释，从这个字符一直到行尾，都会被 YAML 解释器忽略。</li></ul><h4 id="YAML-支持的数据结构"><a href="#YAML-支持的数据结构" class="headerlink" title="YAML 支持的数据结构"></a>YAML 支持的数据结构</h4><ul><li>对象：键值对的集合，又称为映射 (Mapping) / 哈希 (Hash) / 字典 (Dictionary)</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对象类型：对象的一组键值对，使用冒号结构表示</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yaml 也允许另一种写法，将所有键值对写成一个行内对象</span></span><br><span class="line"><span class="attr">hash:</span> {<span class="attr">name:</span> <span class="string">Tom</span>, <span class="attr">age:</span> <span class="number">18</span>}</span><br></pre></td></tr></tbody></table></figure><ul><li>数组：一组按次序排列的值，又称为序列 (Sequence) / 列表 (List)</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 横向写法（行内数组）</span></span><br><span class="line"><span class="attr">fruits:</span> [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 纵向写法（可读性更好，推荐）</span></span><br><span class="line"><span class="attr">fruits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cherry</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合对象的数组（数组中每个元素都是一个对象）</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Alice</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">25</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Peter</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">30</span></span><br></pre></td></tr></tbody></table></figure><ul><li>多行字符串可以使用 <code>|</code> 保留换行符，也可以使用 <code>&gt;</code> 折叠换行 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 `|` 保留换行符</span></span><br><span class="line"><span class="attr">this:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br></pre></td></tr></tbody></table></figure><ul><li>多个 YAML 文档之间可以使用 <code>---</code> 文档分隔符分隔 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个文档（例如定义一个 ConfigMap）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">config1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 第二个文档（例如定义一个 Secret）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret1</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">BASE64_ENCODED_DATA</span></span><br></pre></td></tr></tbody></table></figure><h4 id="YAML-资源清单的描述方法"><a href="#YAML-资源清单的描述方法" class="headerlink" title="YAML 资源清单的描述方法"></a>YAML 资源清单的描述方法</h4><p>在 Kubernetes 中，用户通常使用 YAML 格式的配置文件来定义和创建符合预期状态的集群资源（如 Pod、Deployment 等）。这类遵循 Kubernetes API 规范、用于描述资源对象及其期望状态的 YAML 文件，被称为资源清单（Manifest）。</p><ul><li>常用字段（<strong>必须存在的属性</strong>）</li></ul><table><thead><tr><th>参数名</th><th>字段类型</th><th>说明</th></tr></thead><tbody><tr><td><code>version</code></td><td>String</td><td>K8s API 的版本，目前基本是 <code>v1</code>，可以用 <code>kubectl api-versions</code> 命令查询</td></tr><tr><td><code>kind</code></td><td>String</td><td>YAML 文件定义的资源类型和角色，例如：<code>Pod</code></td></tr><tr><td><code>metadata</code></td><td>Object</td><td> 元数据对象，固定值写 <code>metadata</code></td></tr><tr><td><code>metadata.name</code></td><td>String</td><td> 元数据对象的名字，由用户定义，例如命名 Pod 的名字</td></tr><tr><td><code>metadata.namespace</code></td><td>String</td><td> 元数据对象的命名空间，由用户定义</td></tr><tr><td><code>spec</code></td><td>Object</td><td> 详细定义对象，固定值写 <code>spec</code></td></tr><tr><td><code>spec.containers[]</code></td><td>list</td><td>spec 对象的容器列表定义，是一个列表</td></tr><tr><td><code>spec.containers[].name</code></td><td>String</td><td> 定义容器的名称</td></tr><tr><td><code>spec.containers[].image</code></td><td>String</td><td> 定义容器使用的镜像名称</td></tr></tbody></table><ul><li>资源清单的定义示例（创建一个 Nginx 的 Pod）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>更完整的资源清单定义示例（创建一个 Nginx 的 Deployment）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>最后可以使用 <code>kubectl apply -f xxxx.yaml</code> 命令来执行这个资源清单</li></ul><h4 id="快速生成-YAML-资源清单"><a href="#快速生成-YAML-资源清单" class="headerlink" title="快速生成 YAML 资源清单"></a>快速生成 YAML 资源清单</h4><ul><li>(1) 第一种方式：使用 <code>kubectl create</code> 命令快速生成 YAML 的配置模板内容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速生成 YAML 配置模板内容，--dry-run=client 表示只在客户端进行验证和生成请求，而不把资源真正提交到 API Server</span></span><br><span class="line"><span class="keyword"># kubectl</span> create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者将生成 YAML 配置模板内容输出到文件中</span></span><br><span class="line"><span class="keyword"># kubectl</span> create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> {}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line"><span class="attr">status:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 第二种方式：使用 <code>kubectl get</code> 命令导出正在运行的资源对象的 YAML 配置内容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前正在运行的 Deployment</span></span><br><span class="line"><span class="keyword"># kubectl</span> get deployments</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   1/1     1            1           2d12h</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出当前正在运行的 Deployment 的 YAML 配置内容</span></span><br><span class="line"><span class="keyword"># kubectl</span> get deployment nginx<span class="params"> -o</span> yaml &gt; nginx.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">deployment.kubernetes.io/revision:</span> <span class="string">"1"</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">  <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:labels:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:app:</span> {}</span><br><span class="line">      <span class="attr">f:spec:</span></span><br><span class="line">        <span class="attr">f:progressDeadlineSeconds:</span> {}</span><br><span class="line">        <span class="attr">f:replicas:</span> {}</span><br><span class="line">        <span class="attr">f:revisionHistoryLimit:</span> {}</span><br><span class="line">        <span class="attr">f:selector:</span></span><br><span class="line">          <span class="attr">f:matchLabels:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:app:</span> {}</span><br><span class="line">        <span class="attr">f:strategy:</span></span><br><span class="line">          <span class="attr">f:rollingUpdate:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:maxSurge:</span> {}</span><br><span class="line">            <span class="attr">f:maxUnavailable:</span> {}</span><br><span class="line">          <span class="attr">f:type:</span> {}</span><br><span class="line">        <span class="attr">f:template:</span></span><br><span class="line">          <span class="attr">f:metadata:</span></span><br><span class="line">            <span class="attr">f:labels:</span></span><br><span class="line">              <span class="string">.:</span> {}</span><br><span class="line">              <span class="attr">f:app:</span> {}</span><br><span class="line">          <span class="attr">f:spec:</span></span><br><span class="line">            <span class="attr">f:containers:</span></span><br><span class="line">              <span class="string">k:{"name":"nginx"}:</span></span><br><span class="line">                <span class="string">.:</span> {}</span><br><span class="line">                <span class="attr">f:image:</span> {}</span><br><span class="line">                <span class="attr">f:imagePullPolicy:</span> {}</span><br><span class="line">                <span class="attr">f:name:</span> {}</span><br><span class="line">                <span class="attr">f:resources:</span> {}</span><br><span class="line">                <span class="attr">f:terminationMessagePath:</span> {}</span><br><span class="line">                <span class="attr">f:terminationMessagePolicy:</span> {}</span><br><span class="line">            <span class="attr">f:dnsPolicy:</span> {}</span><br><span class="line">            <span class="attr">f:restartPolicy:</span> {}</span><br><span class="line">            <span class="attr">f:schedulerName:</span> {}</span><br><span class="line">            <span class="attr">f:securityContext:</span> {}</span><br><span class="line">            <span class="attr">f:terminationGracePeriodSeconds:</span> {}</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubectl-create</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:annotations:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:deployment.kubernetes.io/revision:</span> {}</span><br><span class="line">      <span class="attr">f:status:</span></span><br><span class="line">        <span class="attr">f:availableReplicas:</span> {}</span><br><span class="line">        <span class="attr">f:conditions:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="string">k:{"type":"Available"}:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> {}</span><br><span class="line">            <span class="attr">f:lastUpdateTime:</span> {}</span><br><span class="line">            <span class="attr">f:message:</span> {}</span><br><span class="line">            <span class="attr">f:reason:</span> {}</span><br><span class="line">            <span class="attr">f:status:</span> {}</span><br><span class="line">            <span class="attr">f:type:</span> {}</span><br><span class="line">          <span class="string">k:{"type":"Progressing"}:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> {}</span><br><span class="line">            <span class="attr">f:lastUpdateTime:</span> {}</span><br><span class="line">            <span class="attr">f:message:</span> {}</span><br><span class="line">            <span class="attr">f:reason:</span> {}</span><br><span class="line">            <span class="attr">f:status:</span> {}</span><br><span class="line">            <span class="attr">f:type:</span> {}</span><br><span class="line">        <span class="attr">f:observedGeneration:</span> {}</span><br><span class="line">        <span class="attr">f:readyReplicas:</span> {}</span><br><span class="line">        <span class="attr">f:replicas:</span> {}</span><br><span class="line">        <span class="attr">f:updatedReplicas:</span> {}</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kube-controller-manager</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"300851"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/apis/apps/v1/namespaces/default/deployments/nginx</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">f8edd19f-3292-45ac-ad16-932611f528a8</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line">        <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">        <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">      <span class="attr">securityContext:</span> {}</span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">availableReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">    <span class="attr">lastUpdateTime:</span> <span class="string">"2025-07-22T14:10:24Z"</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">ReplicaSet</span> <span class="string">"nginx-6799fc88d8"</span> <span class="string">has</span> <span class="string">successfully</span> <span class="string">progressed.</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">NewReplicaSetAvailable</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">"True"</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Progressing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">    <span class="attr">lastUpdateTime:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">Deployment</span> <span class="string">has</span> <span class="string">minimum</span> <span class="string">availability.</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">"True"</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Available</span></span><br><span class="line">  <span class="attr">observedGeneration:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">readyReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">updatedReplicas:</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Kubernetes-扩展知识"><a href="#Kubernetes-扩展知识" class="headerlink" title="Kubernetes 扩展知识"></a>Kubernetes 扩展知识</h2><h3 id="无状态和有状态应用"><a href="#无状态和有状态应用" class="headerlink" title="无状态和有状态应用"></a>无状态和有状态应用</h3><blockquote><p>无状态和有状态应用的概念</p></blockquote><ul><li>无状态应用（Stateless）：<ul><li>应用实例之间没有任何区别，不依赖本地存储或唯一身份。</li><li>任何一个实例都可以处理任何请求，并且可以被随时替换或扩展而不影响整体应用。</li><li>这是云原生和微服务架构的默认假设。</li><li>典型代表：Nginx、Web 服务、后端接口、无状态微服务。</li></ul></li><li>有状态应用（Stateful）：<ul><li>应用实例有唯一身份（比如节点一、节点二）、需要稳定的持久化存储，或者实例之间有主从等依赖关系。</li><li>替换或重新调度实例时，需要保持其身份和对应的数据。</li><li>典型代表：MySQL、Kafka、ZooKeeper、ElasticSearch、Redis Cluster。</li></ul></li></ul><blockquote><p>无状态应用的部署</p></blockquote><p>在 Kubernetes 中，无状态应用通常使用 Deployment 来部署。</p><ul><li><p>部署特点</p><ul><li>所有 Pod 副本共享同一个持久化存储（如果需要）或完全不持久化数据。</li><li>Pod 的名称和网络标识是不稳定的（例如 <code>web-app-7dfd644c7b-abcx5</code>）。</li><li>服务的访问方式是随机的，任何一个 Pod 都可以处理请求。</li></ul></li><li><p>部署例子</p><ul><li>Web 前端应用：例如 React、Vue、Angular 应用。它们通常只是提供静态文件，会话数据（Session）可能存储在外部的 Cookie 或 Redis 中。</li><li>简单的 RESTful API / 微服务：比如一个用户查询服务、商品详情服务，这些服务本身不存储任何数据，状态（数据）保存在后端的数据库（如 MySQL、PostgreSQL）或缓存（如 Redis）中。</li><li>反向代理 / 负载均衡器：例如 Nginx 或 Traefik，它们根据规则路由流量，自身不会产生需要持久化的数据。</li><li>无状态的计算：例如一个图像处理 Worker，它从消息队列（如 RabbitMQ、Kafka）中获取任务，处理完后将结果存入另一个数据库，任务本身与之前的状态无关。</li></ul></li><li><p>配置示例</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>    <span class="comment"># 使用 Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web-frontend</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web-frontend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>有状态应用的部署</p></blockquote><p>在 Kubernetes 中，有状态应用必须使用 StatefulSet 来部署。</p><ul><li><p>部署特点</p><ul><li>每个 Pod 有唯一且稳定的网络标识（主机名），例如 <code>kafka-0</code>、<code>kafka-1</code>、<code>kafka-2</code>。</li><li>每个 Pod 通常绑定一个专用的持久化存储卷（PVC），Pod 重启或调度后，仍然会挂载同一个存储卷，保证数据不丢失。</li><li>Pod 的启动、扩容、缩容和更新是有严格顺序的（例如顺序创建、逆序终止等）。</li></ul></li><li><p>部署例子</p><ul><li>数据库（这是最典型的例子）：<ul><li>MySQL / PostgreSQL 主从集群：主节点需要读写，从节点同步数据。每个节点的数据和身份至关重要，不能混淆。</li><li>MongoDB 副本集：节点有明确的角色（如 Primary、Secondary）。</li></ul></li><li>缓存：<ul><li>Redis Sentinel / 集群：包含不同角色的节点，身份固定，存储的数据不能丢失（如果开启了持久化）。</li></ul></li><li>消息队列：<ul><li>Kafka 集群：每个 Broker 有唯一的 Broker ID，消息主题（Topic）的分区（Partitions）分布在不同的 Broker 上，存储的数据不能丢失。</li><li>RabbitMQ 集群：每个节点有唯一的节点名称。</li></ul></li><li>分布式数据存储：<ul><li>Elasticsearch 集群：每个节点都有唯一的名称，存储特定的分片数据。</li><li>Etcd / ZooKeeper 集群：用于服务发现和配置共享，需要稳定的网络标识来组建集群。</li></ul></li><li>有状态的应用中间件：<ul><li>游戏服务器：每个实例管理一个特定的游戏房间或用户状态。</li></ul></li></ul></li><li><p>配置示例</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span> <span class="comment"># 使用StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kafka</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">"kafka-hs"</span> <span class="comment"># 必须有对应的无头服务</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kafka</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kafka</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">kafka:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9092</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/kafka</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span> <span class="comment"># 关键：存储卷申请模板，每个Pod都会按此模板自动创建唯一的PVC</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [ <span class="string">"ReadWriteOnce"</span> ]</span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">"ssd"</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">100Gi</span></span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>总结对比</p></blockquote><table><thead><tr><th>特性</th><th>无状态应用 (Deployment)</th><th> 有状态应用 (StatefulSet)</th></tr></thead><tbody><tr><td>Pod 身份</td><td>随机，不唯一</td><td>固定，有序且唯一</td></tr><tr><td>网络标识</td><td>共享 Service，随机负载均衡</td><td>稳定的 DNS 名称：<code>&lt;pod-name&gt;.&lt;svc-name&gt;.&lt;namespace&gt;.svc.cluster.local</code></td></tr><tr><td>存储</td><td>所有 Pod 共享持久化存储卷或无需存储</td><td>每个 Pod 有自己独立的持久化存储卷（<code>volumeClaimTemplates</code>）</td></tr><tr><td>部署 / 扩展</td><td>并行，无顺序</td><td>顺序操作（如：扩缩容时，从 0 到 N 顺序创建，从 N 到 0 逆序终止）</td></tr><tr><td>典型应用</td><td> Web 前端、API 微服务、无状态计算</td><td>数据库（如 MySQL、PostgreSQL）、消息队列（如 Kafka、RabbitMQ）、集群（ES、ZK、Etcd）</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
</feed>
