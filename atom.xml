<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术空间</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2025-09-17T13:12:19.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes 入门教程之六</title>
    <link href="https://www.techgrow.cn/posts/76121b26.html"/>
    <id>https://www.techgrow.cn/posts/76121b26.html</id>
    <published>2025-09-17T13:12:19.000Z</published>
    <updated>2025-09-17T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><span id="more"></span><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><h4 id="调度器的概述"><a href="#调度器的概述" class="headerlink" title="调度器的概述"></a>调度器的概述</h4><p>一个容器平台的核心功能是为容器分配运行所需的计算、存储和网络资源。其中，容器调度系统负责在最合适的主机上启动容器，并将相关容器进行关联。它必须能够自动处理容器故障，并在应用访问量增加时，自动在更多主机上启动容器以应对扩展需求。目前，主流的三大容器平台 Swarm、Mesos 和 Kubernetes 各自拥有不同的调度系统：</p><ul><li>Swarm：直接调度 Docker 容器，并提供与标准 Docker API 一致的接口，使用起来较为简单。</li><li>Mesos：采用多框架并行的调度模型，不同运行框架拥有相对独立的调度系统。其中，Marathon 框架对 Docker 容器提供了原生支持。</li><li>Kubernetes：引入 Pod 和 Label 的概念，将一组有依赖关系的容器组合成一个逻辑单元 Pod，并以 Pod 为基本单位进行部署和调度。同时，多个 Pod 可以通过 Service 形成一个完整的服务。</li></ul><p>Kubernetes 通过这种抽象，简化了集群范围内相关容器的共同调度和管理复杂度。从另一个角度看，这种设计使得 Kubernetes 更容易实现功能更强大、逻辑更复杂的容器调度算法，这也是其与 Swarm 和 Mesos 的主要区别所在。</p><h4 id="K8s-的资源分类"><a href="#K8s-的资源分类" class="headerlink" title="K8s 的资源分类"></a>K8s 的资源分类</h4><p>Kubernetes 调度器作为整个集群的 “大脑”，在提升集群资源利用率和保障服务稳定运行方面起着至关重要的作用，其重要性也会随着集群规模和复杂度的提升而不断增加。在 Kubernetes 中，资源可分为两类：</p><ul><li><p>可压缩资源（Compressible Resources）</p><ul><li>这类资源可以被限制或回收，例如 CPU 周期、磁盘 I/O 带宽等。</li><li>当 Pod 资源不足时，Kubernetes 可以通过降低资源分配的方式来限制 Pod 对这些资源的使用，而无需直接杀掉 Pod。</li></ul></li><li><p>不可压缩资源（Incompressible Resources）</p><ul><li>这类资源一旦被 Pod 占用，除非终止 Pod，否则无法回收，例如内存、硬盘空间等。</li><li>当 Pod 占用不可压缩资源过多且无法满足需求时，Kubernetes 只能通过驱逐（Eviction）或杀掉 Pod 来释放资源。</li></ul></li></ul><p>未来，Kubernetes 还将支持更多类型的资源，如网络带宽、存储 IOPS 等，使得调度和资源管理更加精细化和智能化。</p><h4 id="K8s-调度器的概述"><a href="#K8s-调度器的概述" class="headerlink" title="K8s 调度器的概述"></a>K8s 调度器的概述</h4><p><code>kube-scheduler</code> 是 Kubernetes 系统的核心组件之一，主要负责整个集群的资源调度工作。它通过特定的调度算法和调度策略，将 Pod 调度到最合适的 Node（工作节点） 上，从而更高效、更合理地利用集群资源。这也是企业选择 Kubernetes 的一个重要原因：如果一项新技术不能帮助企业节约成本、提升效率，那么它将很难被真正落地和推广。</p><h4 id="K8s-调度器的工作流程"><a href="#K8s-调度器的工作流程" class="headerlink" title="K8s 调度器的工作流程"></a>K8s 调度器的工作流程</h4><blockquote><p>K8s 调度器的简介</p></blockquote><p><code>kube-scheduler</code> 是一个独立的二进制程序，启动后会持续监听 API Server，获取所有 <code>PodSpec.NodeName</code> 为空的 Pod，并为其执行调度。每个成功调度的 Pod，调度器都会生成一个 Binding 对象 并存入 Etcd，随后目标节点上的 Kubelet 会根据调度结果创建 Pod。在默认情况下，<code>kube-scheduler</code> 内置的默认调度器已经能够满足大多数场景的需求。例如，默认策略可以保证 Pod 被分配到资源充足的节点上运行。但在实际生产环境中，企业往往对业务需求和应用特性有更深入的了解，因此需要更灵活、可控的调度策略，例如：</p><ul><li>限制某些 Pod 只能运行在特定节点上；</li><li>某些节点只允许运行特定类型的应用；</li><li>针对资源隔离、安全性或性能优化进行特殊调度。</li></ul><div class="admonition note"><p class="admonition-title">Pod 的创建流程</p><p>更多关于 Pod 的创建流程的介绍，可以看 <a href="/posts/c57e8370.html#Pod-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B">这里</a>。</p></div><blockquote><p>K8s 调度器的工作流程</p></blockquote><p>K8s 调度器的工作流程主要分为以下四个阶段：</p><ul><li><p>(1) 预选阶段（Predicates）— 节点过滤</p><ul><li>在该阶段，K8s 调度器会根据一系列规则过滤掉不符合要求的节点，形成候选节点列表。</li><li>例如，当 Pod 设置了资源 <code>requests</code>，如果某节点的可用资源不足，则该节点会被过滤掉。</li><li>常见的 Predicates 过滤算法：<table><thead><tr><th>算法名称</th><th>说明</th></tr></thead><tbody><tr><td><code>PodFitsResources</code></td><td>节点剩余资源是否满足 Pod 的资源请求（CPU / 内存等）。</td></tr><tr><td><code>PodFitsHost</code></td><td>如果 Pod 指定了 <code>NodeName</code>，检查节点名称是否匹配。</td></tr><tr><td><code>PodFitsHostPorts</code></td><td>节点上已使用的端口是否与 Pod 申请的端口冲突。</td></tr><tr><td><code>PodSelectorMatches</code></td><td>节点的标签是否与 Pod 指定的 <code>labelSelector</code> 匹配。</td></tr><tr><td><code>NoDiskConflict</code></td><td>检查 Pod 所需的 Volume 是否与节点上已挂载的 Volume 冲突（只读 Volume 除外）。</td></tr><tr><td><code>CheckNodeDiskPressure</code></td><td>节点磁盘压力是否过大，是否满足调度要求。</td></tr><tr><td><code>CheckNodeMemoryPressure</code></td><td>节点内存压力是否过大，是否满足调度要求。</td></tr></tbody></table></li></ul></li><li><p>(2) 优选阶段（Priorities）— 节点打分</p><ul><li>在该阶段，K8s 调度器会对通过预选阶段的节点进行打分，分数越高，表示该节点越适合部署该 Pod。</li><li>打分规则是由一组键值对组成的：<ul><li>键：优先级策略的名称</li><li>值：该策略的权重</li></ul></li><li>常见的 Priorities 优先级策略：<table><thead><tr><th>优先级策略</th><th>说明</th></tr></thead><tbody><tr><td><code>LeastRequestedPriority</code></td><td>根据 CPU 和内存使用率计算权重，使用率越低，权重越高，从而优先选择负载较低的节点。</td></tr><tr><td><code>SelectorSpreadPriority</code></td><td>为了实现高可用，将同一个 Deployment / Replica Set 下的多个 Pod 尽量分散到不同节点上。运行该类型 Pod 数量较少的节点权重更高。</td></tr><tr><td><code>ImageLocalityPriority</code></td><td>如果某节点已经存在 Pod 需要的镜像，且镜像总大小越大，则该节点权重越高，从而减少镜像拉取时间。</td></tr><tr><td><code>NodeAffinityPriority</code></td><td>根据 Node Affinity（节点亲和性）规则计算权重，优先调度到符合亲和性条件的节点上。</td></tr></tbody></table></li></ul></li><li><p>(3) 绑定阶段（Binding）</p><ul><li>K8s 调度器会从打分结果中选择分数最高的节点，将该 Pod 与该 Node（工作节点）进行绑定（Binding）。</li><li>绑定结果会被写入 Etcd，供集群其他组件使用。</li></ul></li><li><p>(4) Kubelet 执行</p><ul><li>最终被选定的 Node（工作节点）对应的 Kubelet 会接收到绑定信息，随后拉取容器镜像并创建 Pod。</li></ul></li></ul><blockquote><p>K8s 调度器的工作流程图</p></blockquote><p><img data-src="../../../asset/2025/09/k8s-scheduler-1.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p>K8s 调度器除了有上面介绍的 Predicates 过滤算法之外，还有一些其他的算法，更多更详细的过滤算法可以查看源码文件：<code>k8s.io/kubernetes/pkg/scheduler/algorithm/predicates/predicates.go</code>。</p></div><h4 id="K8s-调度器的核心特性"><a href="#K8s-调度器的核心特性" class="headerlink" title="K8s 调度器的核心特性"></a>K8s 调度器的核心特性</h4><div class="admonition note"><p class="admonition-title">提示</p><p>更多关于影响 Pod 调度的因素可以看<a href="/posts/c57e8370.html#%E5%BD%B1%E5%93%8D-Pod-%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9B%A0%E7%B4%A0">这里</a>。</p></div><h5 id="节点亲和性调度"><a href="#节点亲和性调度" class="headerlink" title="节点亲和性调度"></a>节点亲和性调度</h5><ul><li><p>概述：</p><ul><li>K8s 节点亲和性（Node Affinity）规则有两种：硬亲和性（<code>required</code>）、软亲和性（<code>preferred</code>）。</li></ul></li><li><p>特性：</p><ul><li>比 <code>nodeSelector</code> 字段更灵活的规则。</li><li>支持硬亲和性（约束条件必须满足）和软亲和性（尝试满足约束条件，但不保证满足）。</li><li>支持常用操作：<code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>Gt</code>、<code>Lt</code>、<code>DoesNotExist</code>。</li></ul></li><li><p>配置示例一：</p></li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span></span><br><span class="line">          <span class="comment"># 节点软亲和性：Pod 优先调度到符合条件的节点，但不是强制要求</span></span><br><span class="line">          <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">60</span></span><br><span class="line">              <span class="attr">preference:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">zone</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">foo</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">30</span></span><br><span class="line">              <span class="attr">preference:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">ssd</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br></pre></td></tr></tbody></table></figure><ul><li>配置示例二：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span></span><br><span class="line">          <span class="comment"># 节点硬亲和性：Pod 只能调度到满足条件的节点</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">env_role</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">          <span class="comment"># 节点软亲和性：Pod 优先调度到符合条件的节点，但不是强制要求</span></span><br><span class="line">          <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">              <span class="attr">preference:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">group</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">otherprod</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-亲和性调度"><a href="#Pod-亲和性调度" class="headerlink" title="Pod 亲和性调度"></a>Pod 亲和性调度</h5><p>K8s 的 Pod 亲和性（Pod Affinity）用于控制 Pod 倾向于与指定 Pod 调度到同一拓扑域，常用于需要紧密协作或低延迟通信的场景。</p><ul><li>可用于将相互依赖的 Pod 部署在同一机架（Rack）或同一可用区（Zone），以降低网络延迟、提升性能。</li><li>例如：<ul><li><code>topologyKey: kubernetes.io/hostname</code>：倾向于将 Pod 调度到同一 Node（工作节点）。</li><li><code>topologyKey: zone</code>：倾向于将 Pod 调度到同一可用区。</li></ul></li></ul><p>Pod 亲和性调度的配置示例：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="comment"># Pod 亲和性调度</span></span><br><span class="line">        <span class="attr">podAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">myapp</span></span><br><span class="line">              <span class="attr">topologyKey:</span> <span class="string">zone</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">busybox:latest</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"sleep 3600"</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li><p>配置说明：</p><ul><li>Kubernetes 调度器会强制保证，Pod 调度到与匹配 <code>labelSelector</code> 条件的 Pod 所在的同一 <code>zone</code> 中。</li><li>如果集群中所有 <code>zone</code> 都没有匹配的 Pod，则新 Pod 会一直处于 <code>Pending</code> 状态。</li></ul></li><li><p>配置参数：</p></li></ul><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td><code>requiredDuringSchedulingIgnoredDuringExecution</code></td><td>硬亲和性约束：必须满足条件，否则 Pod 无法被调度。</td></tr><tr><td><code>labelSelector.matchExpressions</code></td><td>指定匹配条件，比如匹配拥有 <code>app=myapp</code> 标签的 Pod。</td></tr><tr><td><code>topologyKey</code></td><td>定义拓扑域的维度，如 <code>zone</code>、<code>kubernetes.io/hostname</code> 等。</td></tr></tbody></table><h5 id="Pod-反亲和性调度"><a href="#Pod-反亲和性调度" class="headerlink" title="Pod 反亲和性调度"></a>Pod 反亲和性调度</h5><p>K8s 的 Pod 反亲和性（Pod AntiAffinity）用于控制 Pod 不与指定 Pod 调度到同一拓扑域，常用于高可用场景。</p><ul><li>可用于将 Pod 副本分布到不同机架（Rack）或可用区（Zone） 中，避免单点故障。</li><li>例如：<ul><li><code>topologyKey: kubernetes.io/hostname</code>：避免 Pod 调度到同一 Node（工作节点）。</li><li><code>topologyKey: zone</code>：避免 Pod 调度到同一可用区。</li></ul></li></ul><p>Pod 反亲和性调度的配置示例：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">busybox:latest</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"sleep 3600"</span>]</span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="comment"># Pod 反亲和性调度</span></span><br><span class="line">        <span class="attr">podAntiAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="string">myapp</span></span><br><span class="line">              <span class="attr">topologyKey:</span> <span class="string">zone</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>配置说明：</p><ul><li>Kubernetes 调度器会强制保证，同一 <code>zone</code> 下，不会与匹配 <code>labelSelector</code> 条件的 Pod 同时调度运行。</li><li>如果所有 <code>zone</code> 都有匹配的 Pod，则新 Pod 会一直处于 <code>Pending</code> 状态。</li></ul></li><li><p>配置参数：</p></li></ul><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td><code>requiredDuringSchedulingIgnoredDuringExecution</code></td><td>硬亲和性约束：必须满足条件，否则 Pod 无法被调度。</td></tr><tr><td><code>labelSelector.matchExpressions</code></td><td>指定匹配条件，比如匹配拥有 <code>app=myapp</code> 标签的 Pod。</td></tr><tr><td><code>topologyKey</code></td><td>定义拓扑域的维度，如 <code>zone</code>、<code>kubernetes.io/hostname</code> 等。</td></tr></tbody></table><h5 id="污点和容忍度"><a href="#污点和容忍度" class="headerlink" title="污点和容忍度"></a>污点和容忍度</h5><blockquote><p>污点（Taints）</p></blockquote><ul><li><p>污点的定义：</p><ul><li>定义在节点（Node）上的键值型属性数据。</li><li>即 <code>nodes.spec.taints</code>，语法是 <code>key=value:effect</code>。</li></ul></li><li><p>污点的作用：</p><ul><li>让节点拒绝调度 Pod 到其上，除非 Pod 显式声明可以容忍该污点。</li></ul></li><li><p>污点的适用场景：</p><ul><li>专用节点隔离：保留节点给特定 Pod（如 GPU 节点只运行 AI 任务）</li><li>节点维护：标记节点为不可调度（如 <code>NoSchedule）</code>，避免新 Pod 被分配到正在维护的节点</li><li>特殊硬件限制：防止普通 Pod 调度到带特殊硬件（如 FPGA）的节点</li></ul></li><li><p>污点的类型：</p></li></ul><table><thead><tr><th>污点类型（Effect）</th><th>作用</th><th>对已运行 Pod 的影响</th><th>典型场景</th></tr></thead><tbody><tr><td> NoSchedule</td><td> 新的 Pod 无法调度到该节点，除非 Pod 明确声明容忍该污点</td><td>不容忍此污点的 Pod 不会被驱逐</td><td>保留节点给特定用途（如 GPU 节点、生产环境专用节点）</td></tr><tr><td>PreferNoSchedule</td><td> 调度器尽量避免将 Pod 调度到该节点，但若无其他节点可选，仍可被调度</td><td>不容忍此污点的 Pod 不会被驱逐</td><td>软性隔离，如临时维护节点但不强制拒绝调度</td></tr><tr><td> NoExecute</td><td> 新的 Pod 无法调度到该节点（与 NoSchedule 相同）</td><td>不容忍此污点的 Pod 会被驱逐（Evict）</td><td>节点故障或紧急隔离，如磁盘损坏需立即迁移所有 Pod</td></tr></tbody></table><ul><li> 节点的污点操作示例：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给节点打污点</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;=&lt;value&gt;:NoSchedule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点的污点</span></span><br><span class="line">kubectl describe node &lt;node-name&gt; | grep Taint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的单个污点（末尾的 "-" 符号表示删除）</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;:NoSchedule-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的指定键的所有污点（末尾的 "-" 符号表示删除）</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的所有污点</span></span><br><span class="line">kubectl patch nodes &lt;node-name&gt;<span class="params"> -p</span> <span class="string">'{"spec":{"taints":[]}}'</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>容忍度（Tolerations）</p></blockquote><ul><li><p>容忍度的定义：</p><ul><li>定义在 Pod 上的键值型属性数据。</li><li>即 <code>pods.spec.tolerations</code>，语法是 <code>key=value:effect</code>。</li></ul></li><li><p>容忍度的作用：</p><ul><li>声明 Pod 可以容忍哪些污点，允许其被调度到具有这些污点的节点上。</li></ul></li><li><p>容忍度的调度规则：</p><ul><li>Pod 优先调度到没有污点的节点。</li><li>如果目标节点有污点，则 Pod 必须显式声明容忍该污点，否则无法被调度过去。</li></ul></li><li><p>容忍度的适用场景：</p><ul><li>特权 Pod 调度：允许关键 Pod（如日志收集组件）无视污点，调度到任意节点</li><li>故障恢复：容忍 <code>NoExecute</code> 污点，使 Pod 在节点故障时不被驱逐（如数据库 Pod）</li><li>共享特殊节点：让普通 Pod 通过容忍临时使用专用节点（如容忍 GPU 节点污点）</li></ul></li><li><p>容忍度的类型：</p></li></ul><table><thead><tr><th>容忍度类型（Effect）</th><th>作用</th><th>典型场景</th></tr></thead><tbody><tr><td> NoSchedule</td><td> 允许 Pod 调度到带有 <code>NoSchedule</code> 污点的节点，无视节点的硬性隔离规则</td><td>关键 Pod，如存储服务、核心系统组件</td></tr><tr><td> PreferNoSchedule</td><td> 允许 Pod 调度到带有 <code>PreferNoSchedule</code> 污点的节点，但调度器仍会优先选择其他节点</td><td>非关键 Pod 在资源不足时，仍可使用软隔离节点</td></tr><tr><td> NoExecute</td><td>1. 允许 Pod 调度到带有 <code>NoExecute</code> 污点的节点 <br>2. 豁免驱逐：即使节点新增 NoExecute 污点，Pod 也不会被驱逐</td><td>守护进程（如日志收集器、监控代理）需长期运行，无视节点维护状态</td></tr><tr><td>空值（未指定 Effect）</td><td>容忍所有类型的污点，包括未来新增的类型</td><td>超级特权 Pod，如集群管理组件、CNI/CSI 插件等需在所有节点运行</td></tr></tbody></table><ul><li> Pod 的容忍度配置示例：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="comment"># 仅容忍 NoSchedule 污点</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"dedicated"</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">"gpu"</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容忍 NoExecute 污点（并豁免驱逐）</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"node.kubernetes.io/unreachable"</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">"NoExecute"</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">600</span>  <span class="comment"># 延迟 600 秒后驱逐（可选）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容忍所有污点（危险！慎用！）</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>污点提供了让节点（Node）排斥运行特定 Pod 对象的能力。</li><li>节点亲和性（Node Affinity）调度使得 Pod 对象被吸引运行到一类特定的节点上。</li></ul></div><h5 id="Pod-优先级与抢占式调度"><a href="#Pod-优先级与抢占式调度" class="headerlink" title="Pod 优先级与抢占式调度"></a>Pod 优先级与抢占式调度</h5><p>在 Pod 上定义容忍度时，Pod 的优先级与抢占式调度机制如下：</p><ul><li><p>优先级（Pod Priority）</p><ul><li>表示 Pod 对象的重要程度。</li><li>作用：<ul><li>影响调度顺序：高优先级 Pod 会优先被调度。</li><li>影响驱逐次序：节点资源不足时，低优先级 Pod 会先被驱逐。</li></ul></li></ul></li><li><p>抢占机制（Preemption）</p><ul><li>当一个 Pod 无法被调度时，调度器会尝试驱逐节点上优先级更低的 Pod，为当前高优先级 Pod 腾出资源。</li><li>适合关键业务 Pod 需要资源保障的场景。</li></ul></li><li><p>默认状态</p><ul><li>Pod 优先级与抢占式调度机制默认处于禁用状态，需要手动开启。</li></ul></li><li><p>启用方法</p><ul><li>在以下组件的启动参数中增加 <code>--feature-gates=PodPriority=true</code>：<ul><li><code>kube-apiserver</code></li><li><code>kube-scheduler</code></li><li><code>kubelet</code></li></ul></li></ul></li><li><p>使用步骤</p><ul><li><p>(1) 创建优先级类别（<code>PriorityClass</code>）</p><ul><li>定义不同的优先级，如关键业务、高优先级、低优先级等。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">scheduling.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">high-priority</span>                               <span class="comment"># 优先级类别名称</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">1000</span>                                         <span class="comment"># 优先级值，数值越大优先级越高</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span>                                <span class="comment"># 是否为默认优先级类别</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"用于关键业务 Pod，例如存储、网络组件"</span>      <span class="comment"># 优先级的描述信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">scheduling.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">low-priority</span>                                <span class="comment"># 优先级类别名称</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">100</span>                                          <span class="comment"># 优先级值，数值越大优先级越高</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span>                                <span class="comment"># 是否为默认优先级类别</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"用于低优先级 Pod，例如测试或批处理任务"</span>     <span class="comment"># 优先级的描述信息</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>(2) 在 Pod 中指定优先级</p><ul><li>创建 Pod 时，通过 <code>priorityClassName</code> 属性绑定到对应的优先级类别。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">critical-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">priorityClassName:</span> <span class="string">high-priority</span>    <span class="comment"># Pod 绑定高优先级类别</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">critical-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">Pod 的优先级与抢占式调度总结</p><p>高优先级 Pod 无法被调度 → 调度器检查目标节点 → 驱逐低优先级 Pod → 为高优先级 Pod 腾出资源 → 高优先级 Pod 调度成功。</p></div>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之五</title>
    <link href="https://www.techgrow.cn/posts/6bf07963.html"/>
    <id>https://www.techgrow.cn/posts/6bf07963.html</id>
    <published>2025-09-13T13:12:19.000Z</published>
    <updated>2025-09-13T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="Servcie"><a href="#Servcie" class="headerlink" title="Servcie"></a>Servcie</h3><h4 id="Servcie-的概念"><a href="#Servcie-的概念" class="headerlink" title="Servcie 的概念"></a>Servcie 的概念</h4><p>Service 是 Kubernetes 的核心概念之一。<strong>通过创建 Service，可以为一组具备相同功能的 Pod 提供统一的访问入口（即暴露服务），并将请求流量负载均衡地分发到后端各个 Pod 上。</strong>Pod 与 Service 之间是通过 Label（标签）和 Label Selector（标签选择器）建立关联关系的。值得一提的是，在 Kubernetes 中，Service + EndpointController 的配合实现了类似注册中心的功能：当 Pod 创建后，Kubernetes 控制器会自动将其加入对应 Service 的 Endpoints 列表，并通过 Readiness Probe（就绪探针）动态更新，确保只有可用的 Pod 接收流量。Pod 可以通过 DNS 直接访问 Service 名称（如 <code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>），而流量则由 kube-proxy 负责负载均衡。整体上，Service 提供了 DNS 名称 + 虚拟 IP（ClusterIP）的抽象，真正存储服务实例信息的是 EndpointSlice，整个过程完全自动化，Pod 无需显式注册，从而实现了透明的服务注册与发现。</p><span id="more"></span><div class="admonition note"><p class="admonition-title">提示</p><p>Kubernetes 中的 Service + EndpointController 机制，提供了与注册中心类似的自动注册和服务发现能力，但 Pod 无需显式注册，且数据由 Kubernetes 控制平面自动维护，主要面向集群内部的服务（Pod）注册与发现。</p></div><h4 id="Service-的作用"><a href="#Service-的作用" class="headerlink" title="Service 的作用"></a>Service 的作用</h4><ul><li><p>服务发现（Service Discovery）</p><ul><li>Pod 间互相通信的唯一入口：<ul><li>为一组 Pod 提供一个固定的访问入口，解决 Pod IP 动态变化的问题。</li></ul></li><li>DNS 服务发现：<ul><li>集群内部 Pod 可通过 <code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code> 访问目标服务，无需感知 Pod 的 IP。</li></ul></li><li>自动注册与维护：<ul><li>Pod 创建或销毁时，Kubernetes 会自动更新 Service 对应的 <code>EndpointSlice</code>，应用无需显式注册。</li></ul></li></ul></li><li><p>负载均衡（Load Balancing）</p><ul><li>集群内负载均衡：<ul><li>kube-proxy 会自动将访问 Service 的流量分发到后端多个 Pod。</li></ul></li><li>负载策略：<ul><li>默认采用轮询（Round Robin）。</li><li>结合 <code>SessionAffinity</code> 可以实现会话保持。</li></ul></li><li>Service 类型扩展：<ul><li><code>ClusterIP</code>：仅集群内访问，内部负载均衡。</li><li><code>NodePort</code>：通过每个节点固定端口暴露服务。</li><li><code>LoadBalancer</code>：集成云厂商的外部负载均衡器。</li></ul></li></ul></li><li><p>对外暴露服务</p><ul><li>集群外访问能力：<ul><li><code>NodePort</code>：通过节点 IP + 端口访问。</li><li><code>LoadBalancer</code>：借助云厂商负载均衡对外暴露。</li><li><code>ExternalName</code>：将集群内部访问映射到外部域名。</li></ul></li></ul></li><li><p>解耦应用与底层 Pod</p><ul><li>稳定访问地址：<ul><li>应用通过 Service 名称访问后端服务，不依赖具体 Pod IP。</li></ul></li><li>支持滚动升级：<ul><li>Pod 替换过程中，Service 始终提供不变的入口，保障请求不中断。</li></ul></li><li>简化业务逻辑：<ul><li>业务代码不需要实现服务注册、心跳检测、路由等逻辑。</li></ul></li></ul></li><li><p>健康检查与流量控制</p><ul><li>与 Readiness Probe（就绪探针）结合：<ul><li>只将健康的 Pod 添加到 <code>EndpointSlice</code>，自动摘除异常 Pod。</li></ul></li><li>支持蓝绿发布 / 灰度发布：<ul><li>结合标签选择器（<code>selector</code>），灵活管理流量转发目标。</li></ul></li></ul></li><li><p>服务注册中心的替代方案</p><ul><li>自动化注册与发现：<ul><li>无需像 Zookeeper / Eureka 那样主动注册，Pod 生命周期事件由 Kubernetes 控制器接管。</li></ul></li><li>真实的 “注册表”：<ul><li>Pod 实例信息存储在 <code>EndpointSlice</code> 中，Service 只是抽象层，负责提供 DNS 和虚拟 IP（ClusterIP）。</li></ul></li></ul></li></ul><h4 id="Service-的类型"><a href="#Service-的类型" class="headerlink" title="Service 的类型"></a>Service 的类型</h4><h5 id="五大类型"><a href="#五大类型" class="headerlink" title="五大类型"></a>五大类型</h5><p>在 Kubernetes 中，Service 有以下几种类型：</p><ul><li><strong>ClusterIP</strong><ul><li> 概述<ul><li> ClusterIP 是 Service 的默认类型。</li></ul></li><li>作用：<ul><li>为一组 Pod 提供一个集群内部虚拟 IP，只能通过集群内部的 Pod 或 Service 访问。</li></ul></li><li>使用场景：<ul><li>内部微服务之间通信。</li><li>数据库、内部 API 等只在集群内部访问的服务。</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;service-name&gt;</span>          <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span>           <span class="comment"># Service 类型为 ClusterIP，集群内部可访问</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span>             <span class="comment"># 选择标签为 app=my-app 的 Pod 作为后端</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>              <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>      <span class="comment"># Pod 内容器实际监听的端口</span></span><br></pre></td></tr></tbody></table></figure></li><li>访问方式：<ul><li>外部访问：<ul><li><code>ClusterIP</code> 类型的 Service 默认无法被外部访问，它只在集群内部有效。</li><li>如果需要外部访问，则必须通过 Ingress、LoadBalancer 或 NodePort 将流量引入集群，再访问集群内的 Pod 或 Service。</li></ul></li><li>集群内部访问：<ul><li>通过虚拟 IP（ClusterIP）访问：<ul><li>集群内 Pod 可以直接访问 Service 的 ClusterIP：<code>http://&lt;clusterIp&gt;:&lt;port&gt;</code></li></ul></li><li>通过 DNS 名称访问：<ul><li>Kubernetes 会自动为 Service 创建 DNS 名称（域名）。</li><li>Pod 内部可以通过这个 DNS 名称访问 Service：<code>http://&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local:&lt;port&gt;</code>。</li><li>Service 的默认命名空间（<code>namespace</code>）是 <code>default</code>，可以通过 <code>kubectl get svc -A</code> 命令查看。</li><li>kube-proxy 会将流量转发到对应 Pod 的 <code>targetPort</code>。</li></ul></li></ul></li></ul></li></ul></li></ul><hr><ul><li><strong>NodePort</strong><ul><li> 概述：<ul><li>将 Service 暴露在每个集群节点的固定端口上。</li></ul></li><li>作用：<ul><li>外部流量可以通过集群节点的 IP 和 NodePort 访问到集群内的 Pod。</li></ul></li><li>端口范围：<ul><li>默认 <code>30000 ~ 32767</code>。</li></ul></li><li>使用场景：<ul><li>测试环境或临时访问集群服务。</li><li>没有 Ingress 或云负载均衡器时，简单暴露服务。</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;service-name&gt;</span>        <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>          <span class="comment"># Service 类型为 NodePort，可通过节点 IP 访问</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span>           <span class="comment"># 选择标签为 app=my-app 的 Pod 作为后端</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>            <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>    <span class="comment"># Pod 内容器实际监听的端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span>     <span class="comment"># 映射到物理机的端口号，默认范围 30000 - 32767</span></span><br></pre></td></tr></tbody></table></figure></li><li>访问方式：<ul><li>外部访问：<ul><li>通过任意一个集群节点的 IP 和 <code>nodePort</code> 访问集群内的 Pod：<code>http://&lt;nodeIP&gt;:&lt;nodePort&gt;</code>。</li></ul></li><li>集群内部访问：<ul><li>Kubernetes 会自动为 Service 创建 DNS 名称（域名）。</li><li>集群内部 Pod 可以通过这个 DNS 名称访问 Service：<code>http://&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local:&lt;port&gt;</code>。</li><li>Service 的默认命名空间（<code>namespace</code>）是 <code>default</code>，可以通过 <code>kubectl get svc -A</code> 命令查看。</li><li>kube-proxy 会将流量路由到对应 Pod 的 <code>targetPort</code>。</li></ul></li></ul></li></ul></li></ul><hr><ul><li><strong>LoadBalancer</strong><ul><li> 概述：<ul><li>依赖云厂商的负载均衡器，将外部流量分发到集群。</li></ul></li><li>作用：<ul><li>自动向云平台申请一个外部负载均衡器（如 AWS ELB、阿里云 SLB）。</li></ul></li><li>特点：<ul><li>会自动分配到一个公网 IP。</li><li>负载均衡器将流量转发到后端 NodePort。</li></ul></li><li>使用场景：<ul><li>云环境生产集群中，外部流量访问的标准方式。</li><li>对外提供 API 网关、Web 服务、支付网关等服务。</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;service-name&gt;</span>          <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span>        <span class="comment"># Service 类型为 LoadBalancer，自动申请外部负载均衡器（LB）</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span>             <span class="comment"># 选择标签为 app=my-app 的 Pod 作为后端</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>              <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>      <span class="comment"># Pod 内容器实际监听的端口</span></span><br></pre></td></tr></tbody></table></figure></li><li>访问方式：<ul><li>外部访问：<ul><li>外部通过云负载均衡器的公网 IP 或域名访问：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于公网 IP 访问</span></span><br><span class="line">curl http://&lt;loadbalancer-ip&gt;:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于域名访问</span></span><br><span class="line">curl http://&lt;service-name&gt;.example.com</span><br></pre></td></tr></tbody></table></figure></li><li><code>&lt;LoadBalancer-IP&gt;</code> 由云平台自动分配。</li><li>可绑定自定义域名，通过 DNS 解析访问。</li></ul></li><li>集群内部访问：<ul><li>Kubernetes 会自动为 Service 创建 DNS 名称（域名）。</li><li>集群内部 Pod 可以通过这个 DNS 名称访问 Service：<code>http://&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local:&lt;port&gt;</code>。</li><li>Service 的默认命名空间（<code>namespace</code>）是 <code>default</code>，可以通过 <code>kubectl get svc -A</code> 命令查看。</li><li>kube-proxy 会将流量路由到对应 Pod 的 <code>targetPort</code>。</li></ul></li></ul></li></ul></li></ul><hr><ul><li><strong>ExternalName</strong><ul><li> 概述：<ul><li>通过 DNS 将 Service 名称映射到集群外部服务域名，不做流量代理。</li></ul></li><li>作用：<ul><li>通过 Kubernetes 内部的 DNS 把 Service 映射为外部域名，Pod 通过访问 Service 名称即可访问外部服务。</li></ul></li><li>特点：<ul><li>不会创建虚拟 IP（ClusterIP）。</li><li>只是一个 DNS CNAME 解析，流量不经过 Kubernetes 负载均衡或代理（kube-proxy）。</li></ul></li><li>使用场景：<ul><li>访问外部数据库、外部 API 服务等。</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-service</span>            <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span>                <span class="comment"># Service 类型为 ExternalName，将 Service 名称映射到外部域名</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">db.example.com</span>      <span class="comment"># 集群内部访问 Service 时，DNS 解析到的外部域名</span></span><br></pre></td></tr></tbody></table></figure></li><li>访问方式：<ul><li>外部访问：<ul><li><code>ExternalName</code> 类型的 Service 本身不提供外部访问入口，它只是 Kubernetes 内部的 DNS 映射，外部无法通过 Service 名称访问集群内的 Pod 或 Service。</li><li>如果需要外部访问，则必须通过 Ingress、LoadBalancer 或 NodePort 将流量引入集群，再访问集群内的 Pod 或 Service。</li></ul></li><li>集群内部访问：<ul><li>Kubernetes 会自动为 Service 创建 DNS 名称（域名）。</li><li>集群内部 Pod 可以通过这个 DNS 名称访问 Service：<code>http://&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>，实际上会解析到 <code>db.example.com</code>。</li><li>Service 的默认命名空间（<code>namespace</code>）是 <code>default</code>，可以通过 <code>kubectl get svc -A</code> 命令查看。</li></ul></li></ul></li></ul></li></ul><hr><ul><li><strong>None</strong><ul><li> 概述：<ul><li>无虚拟 IP（ClusterIP）的 Service（Headless Service - 无头服务），是一种没有 ClusterIP 的特殊 Service 类型。</li><li>用于暴露 K8s 集群内 Pod 的真实 IP 和 DNS 名称（域名），而不是通过一个统一的虚拟 IP（ClusterIP）进行负载均衡，即 K8s 不会做流量负载均衡。</li></ul></li><li>作用：<ul><li>不需要虚拟 IP（ClusterIP）和负载均衡时使用。</li><li>客户端可以直接感知 Pod 的 IP，实现自定义的负载均衡或服务发现。</li></ul></li><li>定义方式：<ul><li>在 Service 配置中设置：<code>clusterIP: None</code>。</li></ul></li><li>使用场景：<ul><li>部署有状态服务（StatefulSet），如 MySQL、ZooKeeper、Kafka 等。</li><li>客户端需要自己实现负载均衡或服务发现的场景。</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">headless-service</span>      <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span>             <span class="comment"># 设置为 None 表示无虚拟 IP（ClusterIP），直接返回 Pod 的 IP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span>               <span class="comment"># 选择标签为 app=my-app 的 Pod 作为后端</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>                <span class="comment"># Service 对外暴露的端口，客户端访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>        <span class="comment"># Pod 内容器实际监听的端口</span></span><br></pre></td></tr></tbody></table></figure></li><li>访问方式：<ul><li>外部访问：<ul><li>由于 <code>None</code> 类型的 Service 不提供虚拟 IP，Kubernetes 不做负载均衡，因此外部不能直接访问 Service。</li><li>如果外部需要访问 <code>None</code> 类型的 Service，可以使用以下方式实现：<ul><li>通过 Pod 的 Node IP + 容器端口（Pod 暴露端口需要通过 NodePort 或其他方式实现）。</li><li>或者借助 Ingress 或 LoadBalancer 将流量引入集群，再由客户端自行选择 Pod。</li></ul></li></ul></li><li>集群内部访问：<ul><li>通过 DNS 名称访问：<ul><li>Kubernetes 会自动为 Service 创建 DNS 名称（域名）。</li><li>Service 的默认命名空间（<code>namespace</code>）是 <code>default</code>，可以通过 <code>kubectl get svc -A</code> 命令查看。</li><li>第一种 DNS 访问方式：<ul><li>集群内部 Pod，可以通过 Service 的 DNS 名称（域名）查询所有匹配 Pod 的 IP，域名格式：<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nslookup mysql.default.svc.cluster.<span class="built_in">local</span></span><br><span class="line">10.244.1.5</span><br><span class="line">10.244.1.6</span><br><span class="line">10.244.1.7</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>第二种 DNS 访问方式（StatefulSet 专用访问）<ul><li>ClusterIP 为 <code>None</code> 的 Service，每个 Pod 都有固定的 DNS 名称（域名），适用于数据库或分布式系统访问（比如 MySQL、ZooKeeper），保证客户端可以稳定访问指定 Pod。</li><li>集群内部 Pod，可以通过 Pod 的 DNS 名称（域名）直接访问指定的 Pod，域名格式：<code>&lt;pod-name&gt;.&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nslookup mysql-statefulset-0.mysql.default.svc.cluster.<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">telnet mysql-statefulset-0.mysql.default.svc.cluster.<span class="built_in">local</span> 3306</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li>直接访问 Pod 的 IP：<ul><li>客户端可根据自定义的负载均衡策略（轮询、随机、哈希等）直接访问 Pod 的 <code>targetPort</code>：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://10.244.1.5:8080</span><br><span class="line">curl http://10.244.1.6:8080</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul><hr><table><thead><tr><th>类型</th><th>访问范围</th><th>是否需要 kube-proxy</th><th> 是否有虚拟 IP（ClusterIP）</th><th>典型场景</th></tr></thead><tbody><tr><td> ClusterIP</td><td> 仅集群内部</td><td>✅ 是</td><td>✅ 有</td><td>微服务内部通信</td></tr><tr><td> NodePort</td><td> 外部可访问，通过集群节点的 IP</td><td>✅ 是</td><td>✅ 有</td><td>简单对外暴露服务</td></tr><tr><td> LoadBalancer</td><td> 外部可访问，通过 LB 公网 IP</td><td>✅ 是</td><td>✅ 有</td><td>生产外部访问</td></tr><tr><td> ExternalName</td><td> 集群内部访问外部域名</td><td>❌ 否</td><td>❌ 无</td><td>外部服务映射</td></tr><tr><td> None</td><td> 集群内部直接返回 Pod 的 IP</td><td>✅ 是</td><td>❌ 无</td><td>有状态服务访问（如 MySQL、ZooKeeper）</td></tr></tbody></table><h5 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h5><div class="admonition warning"><p class="admonition-title">特别注意</p><p><code>ClusterIP</code> 类型的 Service 只能在 Kubernetes 集群内部访问，如果在集群外部机器（比如直接在集群的 Master 节点）上，通过 Service 的 DNS 名称直接访问 Pod（比如 <code>http://nginx.default.svc.cluster.local:80</code>），肯定是无法访问成功的。</p></div><blockquote><p>在 Kubernetes 中，创建一个 Nginx 的 Pod，使用 ClusterIP 类型的 Service 来暴露服务</p></blockquote><ul><li>创建一个 Nginx 的 Deployment</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Nginx</span></span><br><span class="line">kubectl create deployment nginx<span class="params"> --image</span>=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露 Nginx 的端口（Service 的默认类型是 ClusterIP，可以通过 --type 参数指定类型）</span></span><br><span class="line">kubectl expose deployment nginx<span class="params"> --port</span>=80<span class="params"> --target</span>-port=80</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Pod 列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-6799fc88d8-dkltf   1/1     Running   0          12m   10.244.2.2   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Service 列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc<span class="params"> -A</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAMESPACE     NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">default       kubernetes   ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP                  42d</span><br><span class="line">default       nginx        ClusterIP   10.0.0.231   &lt;none&gt;        80/TCP                   12s</span><br><span class="line">kube-system   kube-dns     ClusterIP   10.0.0.2     &lt;none&gt;        53/UDP,53/TCP,9153/TCP   25m</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 Kubernetes 集群内部，通过 Service 的 DNS 名称访问 Nginx 的 Pod</p></blockquote><ul><li>创建一个临时 Pod，并进入 Pod 内部的交互式 Shell</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 --rm 参数，为了在 Shell 中执行 exit 命令退出后自动销毁 Pod</span></span><br><span class="line">kubectl run <span class="built_in">test</span>-pod<span class="params"> --image</span>=busybox:1.35<span class="params"> --restart</span>=Never<span class="params"> -it</span><span class="params"> --rm</span> -- sh</span><br></pre></td></tr></tbody></table></figure><ul><li>在临时 Pod 的内部，通过 Service 的 DNS 名称访问 Nginx 的 Pod（必须保证临时 Pod 与 Service 处于同一个命名空间），域名格式：<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup nginx.default.svc.cluster.<span class="built_in">local</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Server:10.0.0.2</span><br><span class="line">Address:10.0.0.2:53</span><br><span class="line"></span><br><span class="line">Name:nginx.default.svc.cluster.local</span><br><span class="line">Address: 10.0.0.231</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者通过 Service 的 DNS 名称访问 Nginx 的首页面</span></span><br><span class="line">wget<span class="params"> -qO</span>- http://nginx.default.svc.cluster.<span class="built_in">local</span>:80</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>nslookup</code> 或者 <code>wget</code> 工具无法通过 Service 的 DNS 名称来访问 Nginx 的 Pod，建议重点检查 CoreDNS（Kubernetes 官方提供的 DNS 服务）是否正常运行（也可能没有<a href="/posts/ccd6f2d4.html#%E9%83%A8%E7%BD%B2-CoreDNS%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89">安装 CoreDNS</a>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 CoreDNS 的运行状态</span></span><br><span class="line">kubectl get pod<span class="params"> -n</span> kube-system<span class="params"> -l</span> k8s-app=kube-dns</span><br></pre></td></tr></tbody></table></figure><ul><li>预期输出以下内容，如果 CoreDNS 的 <code>STATUS</code> 不是 <code>Running</code> 或 Pod 不存在，则说明 CoreDNS 服务没有正常运行 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-6b9bb479b9-g6t6f   1/1     Running   0          34m</span><br><span class="line">coredns-6b9bb479b9-lfd7j   1/1     Running   0          34m</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 删除 Deployment 和 Service</p></blockquote><ul><li>如果需要删除上面创建的 Deployment 和 Service，可以执行以下命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除Service</span></span><br><span class="line">kubectl delete service nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除Deployment</span></span><br><span class="line">kubectl delete deployment nginx</span><br></pre></td></tr></tbody></table></figure><h4 id="Servcie-的定义"><a href="#Servcie-的定义" class="headerlink" title="Servcie 的定义"></a>Servcie 的定义</h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span>                     <span class="comment"># Service 的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">production</span>                   <span class="comment"># 所属命名空间，例如生产环境</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>                            <span class="comment"># 标签，标识该服务属于哪个应用</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span>                        <span class="comment"># 层级标签，例如前端、后端</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">"Nginx Web Service for production"</span>  <span class="comment"># 业务描述信息</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>                               <span class="comment"># 匹配后端 Pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>                            <span class="comment"># 必须与 Pod 的 labels 匹配</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>                          <span class="comment"># Service 类型：ClusterIP / NodePort / LoadBalancer / ExternalName</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.15</span>                    <span class="comment"># 集群内部 IP（可选，默认自动分配）</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span>                   <span class="comment"># 会话亲和性，可选值：None / ClientIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span>                          <span class="comment"># 端口名称（可选）</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span>                       <span class="comment"># 协议类型：TCP 或 UDP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>                            <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>                    <span class="comment"># Pod 内容器实际监听的端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span>                     <span class="comment"># 映射到物理机的端口号，默认范围 30000 - 32767</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>                 <span class="comment"># 外部负载均衡器分配的 IP</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">lb-prod.example.com</span>     <span class="comment"># 外部负载均衡器的域名</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>属性名称</th><th>取值类型</th><th>是否必选</th><th>取值说明</th></tr></thead><tbody><tr><td><code>spec.ports[].targetPort</code></td><td><code>int</code></td><td></td><td>需要转发到后端 Pod 的端口号</td></tr><tr><td><code>spec.ports[].nodePort</code></td><td><code>int</code></td><td></td><td>当 <code>spec.type=NodePort</code> 时，指定映射到物理机的端口号</td></tr><tr><td><code>status</code></td><td><code>object</code></td><td></td><td>当 <code>spec.type=LoadBalance</code> 时，设置外部负载均衡器的地址，用于公有云环境</td></tr><tr><td><code>status.loadBalancer</code></td><td><code>object</code></td><td></td><td>外部负载均衡器</td></tr><tr><td><code>status.loadBalancer.ingress</code></td><td><code>object</code></td><td></td><td>外部负载均衡器</td></tr><tr><td><code>status.loadBalancer.ingress.ip</code></td><td><code>string</code></td><td></td><td>外部负载均衡器的 IP 地址</td></tr><tr><td><code>status.loadBalancer.ingress.hostname</code></td><td><code>string</code></td><td></td><td>外部负载均衡器的主机名</td></tr></tbody></table><h4 id="Service-的使用"><a href="#Service-的使用" class="headerlink" title="Service 的使用"></a>Service 的使用</h4><h5 id="Service-基础使用"><a href="#Service-基础使用" class="headerlink" title="Service 基础使用"></a>Service 基础使用</h5><p>一般来说，对外提供服务的应用程序需要通过一定的机制来实现暴露，而对于容器化应用，最简便的方式就是通过 TCP/IP 协议，并结合监听 IP 和端口号来对外提供服务。比如，创建一个带基本功能的 Controller：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mywebapp</span>                       <span class="comment"># RC 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span>                          <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">template:</span>                            <span class="comment"># Pod 的模板</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">mywebapp</span>                   <span class="comment"># Pod 的名称</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mywebapp</span>                  <span class="comment"># Pod 的标签，用于 Service 或 RC 选择器</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mywebapp</span>               <span class="comment"># 容器的名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">tomcat</span>                <span class="comment"># 容器使用的镜像</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span>      <span class="comment"># 容器监听的端口</span></span><br></pre></td></tr></tbody></table></figure><p>可以通过 <code>kubectl get pods -l app=mywebapp -o yaml | grep podIP</code> 命令获取 Pod 的 IP 地址，然后使用 Pod 的 IP 地址和端口号来访问 Tomcat 服务。但是，直接通过 Pod 的 IP 来访问服务是不可靠的，因为当 Pod 所在的 Node（工作节点）发生故障时，Kubernetes 会将该 Pod 重新调度到其他 Node（工作节点），此时 Pod 的 IP 地址会发生变化，导致原有访问地址失效。为了解决这一问题，可以通过 YAML 配置文件再定义一个 Service，并使用以下命令来创建：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mywebAppService</span>          <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>                      <span class="comment"># 选择器，匹配后端 Pod 的标签（labels）</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mywebapp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8081</span>                 <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>           <span class="comment"># Pod 内容器实际监听的端口</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据指定的 YAML 配置文件创建 Service</span></span><br><span class="line">kubectl create<span class="params"> -f</span> service.yaml</span><br></pre></td></tr></tbody></table></figure><h5 id="多端口-Service"><a href="#多端口-Service" class="headerlink" title="多端口 Service"></a>多端口 Service</h5><p>有时，一个容器应用可能需要对外提供多个端口的服务，这时可以在 Service 的定义中配置多个端口，将每个端口映射到对应的应用服务，如下所示：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mywebAppService</span>            <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>                        <span class="comment"># 选择器，匹配后端 Pod 的标签（labels）</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mywebapp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span>                    <span class="comment"># 第一个端口的名称</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span>                   <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>             <span class="comment"># Pod 内容器实际监听的端口</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">management</span>             <span class="comment"># 第二个端口的名称</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8005</span>                   <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8005</span>             <span class="comment"># Pod 内容器实际监听的端口</span></span><br></pre></td></tr></tbody></table></figure><h5 id="外部服务-Service"><a href="#外部服务-Service" class="headerlink" title="外部服务 Service"></a>外部服务 Service</h5><p>在某些特殊场景下，应用系统可能需要将外部数据库作为后端服务，或者将其他集群或命名空间中的服务作为后端服务。这时候，可以通过创建一个不带 Label Selector（标签选择器）的 Service 来实现对这些外部服务的访问，如下所示：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Service 定义</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;service-name&gt;</span>                  <span class="comment"># Service 的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span>                 <span class="comment"># 协议类型</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>                      <span class="comment"># Service 对外暴露的端口，集群内部访问时使用</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>              <span class="comment"># Pod 容器或 Endpoints 实际监听的端口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># Endpoints 定义</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;service-name&gt;</span>                  <span class="comment"># 对应的 Service 的名称</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.254</span><span class="number">.74</span><span class="number">.3</span>             <span class="comment"># 外部服务的 IP</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span>                  <span class="comment"># 外部服务实际监听的端口</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>当 Service 有 <code>selector</code> 时，Service 会自动匹配 Pod，并自动生成 Endpoints。</li><li>当 Service 没有 <code>selector</code> 时，它会通过 Endpoints 的 <code>metadata.name</code> 与 Service 的 <code>metadata.name</code> 相同（一致）来建立关联。</li></ul></div><h3 id="Probe"><a href="#Probe" class="headerlink" title="Probe"></a>Probe</h3><p>为了监控容器的运行状态，Kubernetes 提供了探针（Probe）。</p><h4 id="Probe-的类型"><a href="#Probe-的类型" class="headerlink" title="Probe 的类型"></a>Probe 的类型</h4><p>Kubernetes 提供了三种类型的探针：Liveness Probe（存活探针）、Readiness Probe（就绪探针）、Startup Probe（启动探针）。</p><h5 id="Liveness-Probe"><a href="#Liveness-Probe" class="headerlink" title="Liveness Probe"></a>Liveness Probe</h5><p><strong>Liveness Probe（存活探针）用于判断容器是否处于健康状态，即 Pod 是否真正处于 <code>Running</code> 状态。</strong>如果 Liveness Probe 探测到容器不健康，kubelet 会将该容器 Kill 掉，并根据 Pod 的重启策略决定是否重启它。<strong>Liveness Probe 可用于修复死锁、无响应的应用（如数据库卡死）。</strong>如果容器未配置 Liveness Probe，kubelet 会默认认为其探测结果始终为成功。在实际场景中，应用程序可能由于某些原因（例如后端服务故障）暂时无法对外提供服务，但进程本身仍在运行。这种情况下，Kubernetes 无法识别并隔离这个有故障的 Pod，调用方仍可能访问到该 Pod，导致业务不稳定。为解决这一问题，Kubernetes 提供了 Liveness Probe 来检测应用程序的运行健康状况，并在检测到异常时执行相应的补救措施，例如重启容器，以保证系统的整体稳定性。Liveness Probe 的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">exec:</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"cat"</span>, <span class="string">"/tmp/healthy"</span>]  <span class="comment"># 执行命令检查文件是否存在</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">5</span>              <span class="comment"># 容器启动后等待5秒开始检查</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span>                    <span class="comment"># 每5秒检查一次</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">3</span>                 <span class="comment"># 连续失败3次后判定为不健康</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Readiness-Probe"><a href="#Readiness-Probe" class="headerlink" title="Readiness Probe"></a>Readiness Probe</h5><p><strong>Readiness Probe（就绪探针）用于判断容器是否已经启动完成并能够对外提供服务，即容器的 <code>Ready</code> 状态是否为 <code>true</code>。</strong>如果 Readiness Probe 探测失败，容器的 <code>Ready</code> 状态会被置为 <code>False</code>，Kubernetes 控制器会将该 Pod 的 Endpoint 从对应 Service 的 Endpoint 列表中移除，从而停止将任何请求调度到该 Pod，直到下一次探测成功为止。<strong>Readiness Probe 可用于控制流量进入（如应用启动时需要加载大量数据，导致容器启动后无法立刻对外提供服务）。</strong>通过 Readiness Probe，Kubernetes 可以在应用完全就绪之前，阻止流量被路由到尚未准备好的 Pod 副本，确保服务稳定性。例如，对于基于 Tomcat 的应用来说，Tomcat 进程启动成功并不代表应用可以立即对外提供服务，可能还需要等待 Spring 容器初始化、数据库连接建立等操作完成。在 Spring Boot 应用中，可以使用 Actuator 提供的 <code>/health</code> 接口作为 Readiness Probe 的检测目标，用于判断应用是否已经准备好对外提供服务。Readiness Probe 的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/healthz</span>                    <span class="comment"># 发送 HTTP 请求进行检测</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">10</span>             <span class="comment"># 容器启动后等待10秒开始检查</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">3</span>                    <span class="comment"># 每3秒检查一次</span></span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">1</span>                 <span class="comment"># 成功1次即标记为就绪</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Startup-Probe"><a href="#Startup-Probe" class="headerlink" title="Startup Probe"></a>Startup Probe</h5><p><strong>Startup Probe（启动探针）是在 Kubernetes <code>1.16+</code> 版本中引入的，主要用于检测慢启动应用是否完成初始化。在 Startup Probe 检测成功之前，Liveness Probe 和 Readiness Probe 都不会生效</strong>；从而避免因应用启动过慢，被存活探针或就绪探针误判为异常并提前终止容器。<strong>Startup Probe 非常适合启动时间较长的应用，例如 Java / SpringBoot 应用、需要加载大量数据或复杂初始化逻辑的服务。</strong>通过配置合适的 Startup Probe，可以为应用提供足够的启动缓冲时间，确保在应用真正完成初始化之前，Kubernetes 不会对其进行健康检查或流量调度，从而保证系统的稳定性。Startup Probe 的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">startupProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health</span>             <span class="comment"># Spring Boot 健康检查端点</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">30</span>                 <span class="comment"># 允许的最大失败次数</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">10</span>                    <span class="comment"># 每10秒检查一次</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Probe-的核心参数"><a href="#Probe-的核心参数" class="headerlink" title="Probe 的核心参数"></a>Probe 的核心参数</h4><ul><li>探针（Probe）可配置的核心参数（用于精确控制探针的行为）</li></ul><table><thead><tr><th>参数</th><th>作用</th><th>默认值</th><th>最小值</th><th>适用探针类型</th></tr></thead><tbody><tr><td><code>initialDelaySeconds</code></td><td>容器启动后，等待多少秒才开始第一次执行探测，避免容器未完成启动就被误判为失败。</td><td>0 秒</td><td> 0 秒</td><td> liveness、readiness、startup</td></tr><tr><td><code>periodSeconds</code></td><td>探测的执行频率，即两次探测之间的间隔时间。</td><td>10 秒</td><td> 1 秒</td><td> liveness、readiness</td></tr><tr><td><code>timeoutSeconds</code></td><td>单次探测的超时时间，超过该时间未响应则判定为探测失败。</td><td>1 秒</td><td> 1 秒</td><td> liveness、readiness</td></tr><tr><td><code>failureThreshold</code></td><td>探测成功后，连续失败多少次才会被认定为容器不健康。</td><td>3</td><td>1</td><td>liveness、readiness、startup</td></tr><tr><td><code>successThreshold</code></td><td>对于已标记为不健康的容器，需要连续成功多少次才会重新标记为健康。对于 Liveness Probe，该值必须为 <code>1</code>。</td><td>1</td><td>1</td><td>liveness、readiness</td></tr></tbody></table><h4 id="Probe-的检测方法"><a href="#Probe-的检测方法" class="headerlink" title="Probe 的检测方法"></a>Probe 的检测方法</h4><ul><li>Kubernetes 的三类探针都支持以下三种检测方法</li></ul><table><thead><tr><th>检测方法</th><th>说明</th><th>配置示例</th></tr></thead><tbody><tr><td><code>exec</code></td><td>- 在容器内执行命令，返回状态码为 <code>0</code> 表示检测成功。<br> - 适用于复杂检测逻辑或没有 HTTP 接口的服务。</td><td><code>command: ["cat", "/tmp/healthy"]</code></td></tr><tr><td><code>httpGet</code></td><td>- 通过发送 HTTP 请求检查服务是否正常。<br> - 返回状态码 <code>200 ~ 399</code> 表示检测成功。</td><td><code>httpGet: { path: /health, port: 80 }</code></td></tr><tr><td><code>tcpSocket</code></td><td>- 通过容器 IP + 端口建立 TCP 连接，<br> - 连接成功，即表示容器健康。</td><td><code>tcpSocket: { port: 3306 }</code></td></tr></tbody></table><h4 id="Probe-的检测结果"><a href="#Probe-的检测结果" class="headerlink" title="Probe 的检测结果"></a>Probe 的检测结果</h4><ul><li>探针（Probe）的三种检测结果状态</li></ul><table><thead><tr><th>检测结果状态</th><th>说明</th></tr></thead><tbody><tr><td><code>Success</code></td><td>容器通过检查，状态正常。</td></tr><tr><td><code>Failure</code></td><td>容器未通过检查，状态异常。</td></tr><tr><td><code>Unknown</code></td><td>无法执行检查，因此不采取任何措施。</td></tr></tbody></table><blockquote><p>Pod 的重启策略有以下三种（如果 Liveness Probe 探测到容器不健康，kubelet 会将该容器 Kill 掉，并根据 Pod 的重启策略决定是否重启它）</p></blockquote><table><thead><tr><th>重启策略</th><th>说明</th></tr></thead><tbody><tr><td><code>Always</code></td><td>默认值，当容器退出时，总是由 kubelet 自动重启该容器（适用于长期运行的 Pod，如 Web 服务）。</td></tr><tr><td><code>OnFailure</code></td><td>仅在容器异常退出（非 0 状态码）时，由 kubelet 自动重启该容器（适合批处理任务）。</td></tr><tr><td><code>Never</code></td><td>无论容器如何退出，kubelet 都不会重启该容器（适合一次性任务）。</td></tr></tbody></table><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mynginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span>  <span class="comment"># Pod 的重启策略</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Probe-的配置示例"><a href="#Probe-的配置示例" class="headerlink" title="Probe 的配置示例"></a>Probe 的配置示例</h4><ul><li>基于 Liveness Probe（存活探针）检测容器健康 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-exec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">touch</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">30</span><span class="string">;</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/healthy</span></span><br><span class="line">    <span class="comment"># 存活检查</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><ul><li>存活探针、就绪探针二者配合使用 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">goproxy</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">goproxy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">goproxy</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s.gcr.io/goproxy:0.1</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="comment"># 存活检查</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">tcpSocket:</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 就绪检查</span></span><br><span class="line">      <span class="attr">readinessProbe:</span></span><br><span class="line">        <span class="attr">tcpSocket:</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><ul><li>启动探针、存活探针和就绪探针三者配合使用 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">springboot-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-springboot-app:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="comment"># 启动探针（给予充足启动时间）</span></span><br><span class="line">    <span class="attr">startupProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="comment"># 存活检查（启动探针成功后生效）</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment"># 就绪检查（启动探针成功后生效）</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health/readiness</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Gateway 实现动态路由和灰度发布</title>
    <link href="https://www.techgrow.cn/posts/d806b69a.html"/>
    <id>https://www.techgrow.cn/posts/d806b69a.html</id>
    <published>2025-09-12T14:33:05.000Z</published>
    <updated>2025-09-12T14:33:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Gateway-动态路由"><a href="#Gateway-动态路由" class="headerlink" title="Gateway 动态路由"></a>Gateway 动态路由</h2><span id="more"></span><ul><li>创建数据库表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `gateway_api_route` (</span><br><span class="line">   `id` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `path` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `service_id` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `url` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `retryable` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `enabled` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `strip_prefix` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `api_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"> ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></tbody></table></figure><ul><li>插入表数据 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO gateway_api_route (id, path, service_id, retryable, strip_prefix, url, enabled) VALUES (<span class="string">'order-service'</span>, <span class="string">'/order/**'</span>, <span class="string">'order-service'</span>,0,1, NULL, 1);</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>企业项目中可以使用 Spring MVC 结合前端页面，开发一个可视化网关管理工作台。当新服务开发完成后，可以通过这个工作台对网关配置进行管理，比如为某个服务绑定对应的 URL 路径，并支持增删改查操作，实现服务路由配置的可视化管理。</p></div><h2 id="Gateway-灰度发布"><a href="#Gateway-灰度发布" class="headerlink" title="Gateway 灰度发布"></a>Gateway 灰度发布</h2><ul><li>创建数据库表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `gray_release_config` (</span><br><span class="line">   `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">   `service_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `path` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   `enable_gray_release` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"> ) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/distributed-system/dynamic-route.md">Zuul 网关实现动态路由</a></li><li><a href="https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/distributed-system/gray-environment.md">Zuul 网关实现灰度发布</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Spring Cloud Gateway 实现动态路由和灰度发布。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之三</title>
    <link href="https://www.techgrow.cn/posts/2722157d.html"/>
    <id>https://www.techgrow.cn/posts/2722157d.html</id>
    <published>2025-09-10T13:12:19.000Z</published>
    <updated>2025-09-10T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><span id="more"></span><h3 id="Controller（控制器）"><a href="#Controller（控制器）" class="headerlink" title="Controller（控制器）"></a>Controller（控制器）</h3><div class="admonition note"><p class="admonition-title">Pod 与 Controller（控制器）的关系</p><ul><li>Pod 通过 Controller 进行运维管理，包括创建、扩缩容、滚动更新等操作。</li><li>Pod 与 Controller 之间是通过 Label（标签）和 Label Selector（标签选择器）机制建立关联关系。</li><li>Controller 通过识别 Pod 的 Label（标签）来实现对一组 Pod 的集中管理。</li></ul></div><h4 id="Replication-Controller（RC）"><a href="#Replication-Controller（RC）" class="headerlink" title="Replication Controller（RC）"></a>Replication Controller（RC）</h4><h5 id="RC-的概念"><a href="#RC-的概念" class="headerlink" title="RC 的概念"></a>RC 的概念</h5><p>Replication Controller（RC）是 Kubernetes 系统中的核心概念之一。当定义一个 RC 并将其提交到 Kubernetes 集群后，Master 节点上的 Controller Manager 组件会接收到通知，并持续监控集群中 Pod 的运行状态。</p><h5 id="RC-的作用"><a href="#RC-的作用" class="headerlink" title="RC 的作用"></a>RC 的作用</h5><ul><li><p>Pod 的副本数量管理</p><ul><li>确保集群中实际运行的 Pod 副本数量与 RC 定义的期望值（<code>spec.replicas</code>）保持一致：<ul><li>如果运行的 Pod 副本数量 过多，RC 会自动停止并删除多余的 Pod；</li><li>如果运行的 Pod 副本数量 不足，RC 会自动创建新的 Pod 来补足数量。</li></ul></li></ul></li><li><p>Pod 的自动修复能力</p><ul><li>当 Pod 因故障或异常退出时，RC 会自动创建新的 Pod 来替代，确保服务始终可用。</li></ul></li><li><p>Pod 的弹性伸缩能力</p><ul><li>用户可以通过调整 RC 定义中的副本数，实现 Pod 的动态扩缩容（Scaling），从而根据业务需求灵活提升或降低服务处理能力。</li><li>比如：<code>kubectl scale rc nginx --replicas=5</code></li></ul></li></ul><h5 id="RS-替代-RC"><a href="#RS-替代-RC" class="headerlink" title="RS 替代 RC"></a>RS 替代 RC</h5><p>从 Kubernetes <code>1.2</code> 版本开始，Replica Set（RS）已经逐渐取代 Replication Controller（RC），成为更常用的 Pod 副本管理控制器。二者的演进说明如下：</p><ul><li><p>命名冲突</p><ul><li>由于 Replication Controller 与 Kubernetes 代码模块中同名，在 Kubernetes <code>1.2</code> 版本中，RC 升级为新的概念 Replica Set ，官方将其定义为 RC 的下一代版本。  </li></ul></li><li><p>主要区别  </p><ul><li>Replication Controller：只支持基于等式的 Label Selector，如 <code>app=nginx</code>。</li><li>Replica Set ：除了支持等式的 Label Selector 外，还支持基于集合式的 Label Selector，如 <code>in</code>、<code>notin</code>、<code>exists</code> 等更复杂的匹配规则。</li></ul></li><li><p>使用场景</p><ul><li>在实际工作中，很少单独使用 Replica Set，它通常由 Deployment 管理。Deployment 提供了更高层次的功能，包括 Pod 创建、删除、更新 的完整编排与滚动升级机制。</li><li>在生产环境中，通常通过 Deployment → Replica Set → Pod 这一管理链路进行编排和管理。</li></ul></li></ul><blockquote><p>使用 RC / RS 管理 Pod 的原因</p></blockquote><ul><li><p>避免直接创建 Pod</p><ul><li>不建议越过 RC / RS 直接创建 Pod，因为直接创建的 Pod 无法自动修复或扩缩容。</li><li>RC 或 RS 通过副本管理机制，可以实现 Pod 的自动创建、补足、替换和删除。</li></ul></li><li><p>提升容灾能力</p><ul><li>当节点故障或 Pod 异常退出时，RC / RS 会自动创建新的 Pod，确保服务稳定可用，减少因节点崩溃等意外带来的损失。</li></ul></li><li><p>适用于单副本场景</p><ul><li>即使应用只有一个 Pod 副本，也强烈建议使用 RC / RS 来管理 Pod，以获得自动恢复和高可用能力。</li></ul></li></ul><h4 id="Replica-Set（RS）"><a href="#Replica-Set（RS）" class="headerlink" title="Replica Set（RS）"></a>Replica Set（RS）</h4><h5 id="RS-的概念"><a href="#RS-的概念" class="headerlink" title="RS 的概念"></a>RS 的概念</h5><p>从 Kubernetes <code>1.2</code> 版本开始，Replica Set（RS）已经逐渐取代 Replication Controller（RC），成为更常用的 Pod 副本管理控制器。Replica Set 是 Replication Controller 的升级版本，支持更强大的 Label Selector，二者的关系如下：</p><ul><li><p>功能一致</p><ul><li>Replica Set 与 Replication Controller 在功能上没有本质的区别，二者的核心作用都是确保 Pod 副本数量与预期值保持一致。</li></ul></li><li><p>用法差异</p><ul><li>Replication Controller 只支持基于等式的 Label Selector，例如 <code>app=nginx</code>。</li><li>Replica Set 除了支持等式的 Label Selector 外，还支持基于集合式的 Label Selector，如 <code>in</code>、<code>notin</code>、<code>exists</code> 等更复杂的匹配规则。</li></ul></li><li><p>官方建议</p><ul><li>Kubernetes 官方强烈建议避免直接使用 Replica Set，而是通过 Deployment 来创建和管理 Replica Set 及其 Pod，以此获得滚动更新、回滚等高级功能。</li><li>在生产环境中，通常通过 Deployment → Replica Set → Pod 这一管理链路进行编排和管理。</li></ul></li></ul><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><h5 id="Deployment-的概念"><a href="#Deployment-的概念" class="headerlink" title="Deployment 的概念"></a>Deployment 的概念</h5><p>Deployment 控制器是 Kubernetes 在 <code>1.2</code> 版本中引入的新概念，主要目的是为了更好地解决 Pod 的编排问题 。</p><ul><li><p>主要功能</p><ul><li>部署和管理无状态应用；</li><li>维护期望数量的 Pod 实例，支持自动修复异常 Pod；</li><li>提供滚动升级、灰度发布、快速回滚 等版本管理功能；</li><li>支持自动扩缩容（结合 HPA 使用）；</li><li>与 Service 配合，实现应用的高可用与负载均衡。</li></ul></li><li><p>实现机制</p><ul><li>Deployment 内部通过 Replica Set 管理 Pod 副本：<ul><li>Replica Set 负责 Pod 的实际创建、扩容和缩容；</li><li>Deployment 作为更高一层控制器，可以管理多个 Replica Set，从而支持版本管理和回滚。</li></ul></li><li>当更新镜像或配置时，Deployment 会创建新的 Replica Set 并逐步替换旧 Pod，实现平滑升级。</li></ul></li><li><p>定义特点</p><ul><li>定义结构与 Replica Set 类似，但提供了更高层的编排能力：<ul><li>Replica Set 的 Kind 类型：<code>ReplicaSet</code>；</li><li>Deployment 的 Kind 类型：<code>Deployment</code>，支持滚动更新、回滚、暂停、恢复、历史版本管理等高级功能。</li></ul></li><li>可通过 YAML 文件、命令行等多种方式定义，易于集成到 CI/CD 流水线中。</li></ul></li><li><p>适用场景</p><ul><li>部署无状态 Web 应用，如 Nginx、前端服务、API 网关；结合 Service 实现高可用和负载均衡，支持滚动更新不中断访问；</li><li>部署微服务中的业务服务实例，支持自动扩缩容，满足不同流量需求；通过滚动更新和灰度发布，保证服务持续迭代；</li><li>部署无状态的计算或处理任务，如日志收集、ETL、数据清洗等；</li><li>部署一些无状态的基础设施，如 Prometheus、Grafana、Fluentd；</li><li>通过 Deployment 的版本控制能力，实现持续交付流程；支持分批滚动更新、A/B 测试和金丝雀发布。</li></ul></li></ul><h4 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h4><h5 id="StatefulSet-的概念"><a href="#StatefulSet-的概念" class="headerlink" title="StatefulSet 的概念"></a>StatefulSet 的概念</h5><p>StatefulSet 控制器是 Kubernetes 在 <code>1.5</code> 版本中引入的控制器，主要用于管理有状态应用，为每个 Pod 提供固定身份标识、稳定的网络标识符和持久化存储，确保 Pod 的部署和管理有序进行。</p><ul><li><p>主要功能</p><ul><li>部署和管理有状态应用；</li><li>保证每个 Pod 具有固定的标识符（名称、网络标识）；</li><li>按照顺序有序创建、有序扩容、有序删除 Pod；</li><li>结合 PersistentVolume 为每个 Pod 提供独立的持久化存储；</li><li>确保 Pod 在重启或迁移后仍能保持原有的存储和网络标识。</li></ul></li><li><p>实现机制</p><ul><li>StatefulSet 内部通过 Headless Service 实现固定 DNS 解析，为 Pod 提供稳定的网络标识；</li><li>每个 Pod 会被分配一个有序的编号，例如 <code>mysql-0</code>、<code>mysql-1</code>；</li><li>Pod 与 PersistentVolumeClaim（PVC）绑定，确保数据不会因 Pod 重建而丢失；</li><li>Pod 创建、扩容、更新、删除等操作严格按照顺序进行，保证集群一致性。</li></ul></li><li><p>定义特点</p><ul><li>StatefulSet 的定义与 Deployment 类似，但支持更多有状态特性：<ul><li>Pod 命名固定：Pod 名称由 StatefulSet 名称 + 编号组成，如 <code>mysql-0</code>；</li><li>网络标识稳定：通过 Headless Service 绑定，Pod 拥有固定 DNS，如 <code>mysql-0.mysql</code>；</li><li>持久化存储：每个 Pod 自动绑定独立 PVC，与 Pod 生命周期解耦；</li><li>严格的顺序控制：Pod 启动、扩容和删除过程严格有序。</li></ul></li></ul></li><li><p>适用场景</p><ul><li>部署数据库服务，如 MySQL 主从、PostgreSQL；</li><li>部署分布式存储，如 HDFS、Ceph；</li><li>部署分布式协调服务，如 ZooKeeper、Etcd；</li><li>部署需要稳定网络标识的集群，如 Kafka、RabbitMQ。</li></ul></li></ul><h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><h5 id="DaemonSet-的概念"><a href="#DaemonSet-的概念" class="headerlink" title="DaemonSet 的概念"></a>DaemonSet 的概念</h5><p>DaemonSet 控制器是 Kubernetes 在 <code>1.2</code> 版本中引入的重要控制器，主要用于确保集群中每个（或指定）Node（工作节点）上都运行一个 Pod，非常适合运行节点级的后台服务或守护进程。</p><ul><li><p>主要功能</p><ul><li>确保集群中每个节点（Node）都运行一个 Pod，Node 新增或删除时，DaemonSet 会自动创建或清理对应的 Pod；</li><li>常用于部署节点级的系统组件，如日志收集、监控、网络插件等；</li><li>与普通 Deployment 不同，DaemonSet 不支持水平扩缩容，Pod 数量取决于匹配的节点数量；</li><li>可结合 Node Selector（节点选择器）、Node Affinity（节点亲和性）、Taints/Tolerations（污点 / 容忍）等策略，选择特定节点进行部署；</li><li>节点出现故障或被驱逐时，DaemonSet 会自动在新节点或健康节点上重新调度 Pod。</li></ul></li><li><p>实现机制</p><ul><li>DaemonSet 控制器实时监听集群节点变化：<ul><li>当新节点加入时，DaemonSet 会根据调度规则自动为该节点创建一个 Pod；</li><li>当节点下线或被删除时，DaemonSet 会清理对应的 Pod；</li><li>通过 <code>updateStrategy</code> 配置支持滚动更新，保证节点上的 Pod 平滑升级；</li></ul></li><li>一个 DaemonSet 只能管理一组相同功能的 Pod，不会像 Deployment 那样创建多个 Replica Set（RS）；</li><li>与 Deployment 不同，DaemonSet 的 Pod 不通过调度器进行普通调度，而是直接绑定到目标节点。</li></ul></li><li><p>定义特点</p><ul><li>Kind 类型是 <code>DaemonSet</code>；</li><li>Pod 数量等于匹配规则的节点数量；</li><li>支持的更新策略：<ul><li><code>RollingUpdate</code>：逐个节点更新 Pod，保证服务连续性；</li><li><code>OnDelete</code>：需要手动删除旧 Pod 时，DaemonSet 才会创建新 Pod；</li></ul></li><li>可通过节点标签、节点亲和性、污点 / 容忍等配置精确控制 Pod 的分布；</li><li>YAML 文件定义结构与 Deployment 类似，但 <code>spec.strategy</code> 配置略有不同。</li><li>使用 <code>kubectl delete daemonset</code> 删除 DaemonSet 时，可通过 <code>--cascade=orphan</code> 参数控制是否保留关联的 Pod。</li></ul></li><li><p>适用场景</p><ul><li>日志收集：如 Fluentd、Logstash、Filebeat，保证每个节点日志都能被采集。</li><li>监控代理：如 Prometheus Node Exporter、Datadog Agent、cAdvisor 等，采集节点和 Pod 的监控指标。</li><li>网络插件：如 Flannel、Calico、Cilium 等 CNI 插件，需要在所有节点上运行网络代理；</li><li>存储插件：如 Ceph、GlusterFS、CSI Driver 等，部署存储卷管理进程；</li><li>安全与合规审计：如 Falco、Sysdig Secure 等安全审计、防护 Agent；</li><li>节点运维任务：自动在每个节点运行健康检查、系统运维脚本或运维工具；</li><li>边缘计算场景：在特定节点部署边缘服务或代理。</li></ul></li><li><p>总结对比</p><table><thead><tr><th>特性</th><th> Deployment</th><th>DaemonSet</th></tr></thead><tbody><tr><td>Pod 数量控制</td><td>支持自定义 Pod 的副本数量</td><td>每个节点部署 1 个 Pod，自动匹配节点</td></tr><tr><td>调度机制</td><td>由调度器调度</td><td>直接绑定到目标节点</td></tr><tr><td>适用场景</td><td>无状态应用、微服务、Web 服务</td><td>节点级服务、日志、监控、网络插件等</td></tr><tr><td>支持扩缩容</td><td>支持 HPA 自动扩缩容</td><td>不支持扩缩容，Pod 数量由节点数决定</td></tr><tr><td>更新策略</td><td>滚动更新、回滚、暂停、恢复</td><td>滚动更新，或者手动删除更新</td></tr></tbody></table></li></ul><h4 id="Horizontal-Pod-Autoscaler"><a href="#Horizontal-Pod-Autoscaler" class="headerlink" title="Horizontal Pod Autoscaler"></a>Horizontal Pod Autoscaler</h4><h5 id="HPA-的概念"><a href="#HPA-的概念" class="headerlink" title="HPA 的概念"></a>HPA 的概念</h5><p>Horizontal Pod Autoscaler（Pod 横向自动扩容，简称 HPA）与 Replication Controller（RC）、Deployment 一样，都是 Kubernetes 的资源对象。HPA 的实现原理是：通过持续追踪和分析 Replication Controller（RC）或 Deployment 控制的目标 Pod 的负载变化，判断是否需要针对性地调整 Pod 的副本数量（自动扩容和缩容）。</p><h5 id="HPA-的两种模式"><a href="#HPA-的两种模式" class="headerlink" title="HPA 的两种模式"></a>HPA 的两种模式</h5><p>Kubernetes 对 Pod 的扩容与缩容提供了手动和自动两种模式。</p><ul><li><p>手动扩容和缩容：</p><ul><li>通过 <code>kubectl scale</code> 命令对 Deployment 或 Replication Controller 的 Pod 副本数量进行设置；</li><li>比如：<code>kubectl scale deployment frontend --replicas 1</code>。</li></ul></li><li><p>自动扩容和缩容（HPA）：</p><ul><li>用户需要根据某个性能指标或自定义业务指标，指定 Pod 副本数量的最小值和最大值范围，Kubernetes 会根据实时指标变化，在这个范围内自动调整 Pod 的副本数量。</li><li>HPA 控制器通过 Master 节点的 <code>kube-controller-manager</code> 服务的启动参数 <code>--horizontal-pod-autoscaler-sync-period</code>（默认值为 30 秒）来周期性运行，包括：<ul><li>HPA 控制器会定期监测目标 Pod 的 CPU 使用率；</li><li>当 Pod 的 CPU 平均使用率达到用户设定的阈值条件时，HPA 控制器会自动调整 Replication Controller 或 Deployment 中的 Pod 副本数量，以使实际 Pod 副本数满足用户定义的 CPU 平均使用率要求。</li></ul></li></ul></li></ul><h5 id="HPA-的扩容配置示例"><a href="#HPA-的扩容配置示例" class="headerlink" title="HPA 的扩容配置示例"></a>HPA 的扩容配置示例</h5><ul><li>配置示例 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">50m</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">50</span>    <span class="comment"># 当 Pod 的 CPU 平均使用率超过 50% 时扩容</span></span><br></pre></td></tr></tbody></table></figure><ul><li>配置说明：<ul><li>Deployment（<code>nginx-deployment</code>）<ul><li>核心作用：<ul><li>创建并管理 Nginx Pod，实现副本管理、自动恢复。</li></ul></li><li>核心配置：<ul><li><code>replicas: 1</code>：初始创建 1 个 Pod 副本。</li><li><code>selector.matchLabels</code>：用于匹配 Pod 的标签，这里为 <code>app: nginx</code>，确保 Deployment 管理正确的 Pod。</li><li><code>template.metadata.labels</code>：Pod 模板的标签，与 <code>selector</code> 对应。</li><li><code>containers</code>：定义容器信息<ul><li><code>name</code> / <code>image</code>：容器名称及镜像（nginx）</li><li><code>resources.requests.cpu: 50m</code>：CPU 请求资源，保证 Pod 调度时的资源预留（<code>50m</code> 表示 <code>0.05</code> 个 CPU 核心）</li><li><code>ports.containerPort: 80</code>：容器端口</li></ul></li></ul></li></ul></li><li> Service（<code>nginx-svc</code>）<ul><li>核心作用：<ul><li>为 Pod 提供统一访问入口，实现负载均衡。</li></ul></li><li>核心配置：<ul><li><code>ports.port: 80</code>：Service 暴露的端口</li><li><code>ports.targetPort: 80</code>：转发到 Pod 的容器端口</li><li><code>selector.app: nginx</code>：Service 选择带有 <code>app=nginx</code> 标签的 Pod 作为后端</li></ul></li></ul></li><li> HorizontalPodAutoscaler（<code>nginx-hpa</code>）<ul><li>核心作用：<ul><li>基于 CPU 使用率自动调整 Pod 副本数量，实现弹性伸缩（自动扩容和缩容）。</li></ul></li><li>核心配置：<ul><li><code>scaleTargetRef</code>：指定 HPA 控制器管理的对象，这里为 <code>Deployment/nginx-deployment</code></li><li><code>minReplicas: 1</code>：Pod 副本数量的最小值</li><li><code>maxReplicas: 5</code>：Pod 副本数量的最大值</li><li><code>targetCPUUtilizationPercentage: 50</code>：HPA 控制器会根据 Pod 的 CPU 平均使用率是否达到 <code>50%</code> 来自动扩缩容</li></ul></li></ul></li></ul></li></ul><h5 id="HPA-的扩容高级配置"><a href="#HPA-的扩容高级配置" class="headerlink" title="HPA 的扩容高级配置"></a>HPA 的扩容高级配置</h5><p>在 HPA 中，除了 <code>targetCPUUtilizationPercentage</code> 这种基于 CPU 使用率的扩缩容条件外，还可以配置更多维度的指标，例如内存、Pod 自定义指标、外部 Kubernetes 对象指标、外部监控系统指标等。</p><hr><ul><li><p>API 版本 <code>autoscaling/v1</code>（最基础版本）</p><ul><li>核心作用：<ul><li>只支持 CPU 使用率指标；</li><li>无法基于内存或自定义指标来扩容或缩容，只适用于简单场景。</li></ul></li><li>配置字段：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">50</span>    <span class="comment"># 当 Pod 的 CPU 平均使用率超过 50% 时扩容</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>API 版本 <code>autoscaling/v2beta2</code> 或者 <code>autoscaling/v2</code>（推荐版本）</p><ul><li>核心作用：<ul><li>支持基于多种指标类型来扩容或缩容，通过 <code>metrics</code> 字段配置。</li></ul></li><li>四种核心指标类型：</li></ul><table><thead><tr><th>指标类型</th><th>用途</th><th>示例场景</th><th>是否需要结合 Metrics Adapter（比如 Prometheus Adapter）使用</th></tr></thead><tbody><tr><td> Resource</td><td> 基于 Pod 资源指标（CPU、内存等）</td><td>当 Pod 的 CPU 平均使用率超过 <code>50%</code> 时扩容</td><td>不需要</td></tr><tr><td> Pods</td><td> 基于每个 Pod 计算出的指标</td><td>当每个 Pod 处理的业务请求数超过 1000 时扩容</td><td>需要</td></tr><tr><td> Object</td><td> 基于外部 Kubernetes 对象指标</td><td>根据某个 Service 的 QPS 来扩容</td><td>需要</td></tr><tr><td> External</td><td> 基于外部监控系统指标</td><td>根据 Prometheus 或外部监控系统的 QPS 扩容</td><td>需要</td></tr></tbody></table></li></ul><hr><ul><li>基于资源指标（CPU / 内存）自动扩容和缩容，不需要结合 Metrics Adapter（比如 Prometheus Adapter）使用 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">      <span class="attr">resource:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">          <span class="attr">averageUtilization:</span> <span class="number">50</span>   <span class="comment"># 当 Pod 的 CPU 平均使用率超过 50% 时扩容</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">      <span class="attr">resource:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">memory</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">          <span class="attr">averageValue:</span> <span class="string">200Mi</span>      <span class="comment"># 当 Pod 的内存平均使用量超过 200Mi 时扩容</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>配置字段</th><th>配置作用</th></tr></thead><tbody><tr><td><code>averageUtilization</code></td><td>百分比，基于 Pod CPU 或内存的使用率</td></tr><tr><td><code>averageValue</code></td><td>绝对值，基于 Pod CPU 或内存的使用量</td></tr></tbody></table><ul><li>基于每个 Pod 的自定义指标来自动扩容和缩容，需要结合 Metrics Adapter（比如 Prometheus Adapter）使用，适用于：根据每个 Pod 处理的业务请求数、活跃连接数等指标来扩容 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">      <span class="attr">pods:</span></span><br><span class="line">        <span class="attr">metric:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">requests_per_second</span>    <span class="comment"># Prometheus Adapter 暴露的指标名称</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">          <span class="attr">averageValue:</span> <span class="string">"1000"</span>   <span class="comment"># 当每个 Pod 每秒所处理的业务请求数大于 1000 时扩容</span></span><br></pre></td></tr></tbody></table></figure><ul><li>基于外部 Kubernetes 对象指标来自动扩容和缩容，需要结合 Metrics Adapter（比如 Prometheus Adapter）使用，适用于：根据 Service、Ingress 等对象的指标来扩容 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Object</span></span><br><span class="line">      <span class="attr">object:</span></span><br><span class="line">        <span class="attr">describedObject:</span></span><br><span class="line">          <span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line">          <span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">my-ingress</span></span><br><span class="line">        <span class="attr">metric:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">requests_per_second</span>    <span class="comment"># Prometheus Adapter 暴露的指标名称</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">Value</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"1000"</span>   <span class="comment"># 当该 Ingress 的每秒请求数超过 1000 时扩容</span></span><br></pre></td></tr></tbody></table></figure><ul><li>基于外部监控系统指标来自动扩容和缩容，需要结合 Metrics Adapter（比如 Prometheus Adapter）使用，适用于：根据 Prometheus、CloudWatch、阿里云 ARMS 等外部监控系统指标来扩容 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">External</span></span><br><span class="line">      <span class="attr">external:</span></span><br><span class="line">        <span class="attr">metric:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx_ingress_qps</span>   <span class="comment"># Prometheus Adapter 暴露的指标名称</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">          <span class="attr">averageValue:</span> <span class="string">"2000"</span>  <span class="comment"># 当外部系统的 QPS 大于 2000 时扩容</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">总结说明</p><ul><li>Kubernetes 的 Metrics Server：仅提供 CPU、内存指标，适用于简单扩缩容场景。</li><li>推荐使用 Prometheus + Prometheus Adapter：采集并适配 QPS、连接数、延迟等复杂业务指标供 HPA 使用。</li><li>多个指标组合使用：HPA 支持同时配置 CPU、内存、QPS 等多个指标，最终副本数取最大值，确保系统稳定性。</li><li>生产最佳实践：统一部署 Metrics Server + Prometheus + Prometheus Adapter，构建完整的自动扩缩容体系。</li></ul></div><h5 id="HPA-的缩容高级配置"><a href="#HPA-的缩容高级配置" class="headerlink" title="HPA 的缩容高级配置"></a>HPA 的缩容高级配置</h5><p>在 Kubernetes 的 Horizontal Pod Autoscaler（HPA） 中，自动缩容实际上是自动扩容机制的一部分，一般不需要单独写一个专门的 “缩容配置”。HPA 会根据用户设定的 Metrics 指标，自动计算目标 Pod 副本数量，既包括扩容，也包括缩容。</p><ul><li><p><strong>缩容的核心逻辑</strong></p><ul><li>HPA 会根据当前负载和目标值计算期望 Pod 副本数量：<ul><li>计算公式：<code>desiredReplicas = ceil(currentReplicas × currentMetricValue ÷ targetMetricValue)</code></li><li>如果 <code>desiredReplicas &gt; currentReplicas</code>，HPA 会进行扩容</li><li>如果 <code>desiredReplicas &lt; currentReplicas</code>，HPA 会进行缩容</li></ul></li><li>假设配置里有以下内容，这意味着 Pod 缩容最小会缩到 1 个副本，不会被缩容到 0 个副本 <figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">maxReplicas:</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>如何让缩容生效</strong></p><ul><li><p>(1) HPA 默认就支持缩容，一般不需要额外配置</p><ul><li>比如，当 CPU 或内存使用率持续低于目标值时，Pod 的数量会被逐步缩减，直到达到 <code>minReplicas</code> 限制</li></ul></li><li><p> (2) 如果想控制 Pod 缩容的速度和行为，可以在 <code>spec.behavior</code> 中配置策略</p><ul><li>必须使用 API 版本 <code>autoscaling/v2</code> 或者 <code>autoscaling/v2beta2</code></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">      <span class="attr">resource:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">          <span class="attr">averageUtilization:</span> <span class="number">50</span>             <span class="comment"># 当 Pod 的 CPU 平均使用率超过 50% 时扩容</span></span><br><span class="line">  <span class="attr">behavior:</span></span><br><span class="line">    <span class="attr">scaleDown:</span></span><br><span class="line">      <span class="attr">stabilizationWindowSeconds:</span> <span class="number">300</span>        <span class="comment"># 缩容前观察 5 分钟，避免波动</span></span><br><span class="line">      <span class="attr">policies:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">50</span>                          <span class="comment"># 每次最多缩减 50%</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">60</span>                  <span class="comment"># 每 60 秒评估一次缩容</span></span><br></pre></td></tr></tbody></table></figure></li><li>配置字段：<ul><li><code>stabilizationWindowSeconds</code>：稳定窗口，只有指标持续低于目标值这段时间后才缩容，避免频繁抖动</li><li><code>policies</code>：定义缩容速率，可以按百分比或固定数量缩减 Pod 的数量</li><li><code>periodSeconds</code>：缩容策略评估的时间间隔</li></ul></li></ul></li></ul></li><li><p><strong> Pod 缩容为 0 个副本</strong></p><ul><li>在 Kubernetes 中，当 Pod 缩容到 0 个副本时，指的是 Pod 数量为 0，即一个 Pod 都不会存在（相当于删除所有正在运行的 Pod）。</li><li>如果希望 Pod 完全缩到 0 个副本，HPA 本身做不到，需要配合 KEDA 或 VPA 或 Deployment 的 <code>scale-to-zero</code> 机制。</li><li>但是，如果只是普通业务场景，直接设置 <code>minReplicas: 0</code> 即可让 HPA 在负载极低时将 Pod 缩到 0 个副本：<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure></li><li>注意：当 Pod 缩容到 0 个副本后<ul><li>如果没有请求进来，这个服务将处于完全停机状态</li><li>如果之后有请求到达，Kubernetes 不会自动重建 Pod</li><li> 必须由 HPA 再次检测到指标上升，将 Pod 的副本数量从 0 调整为 1 或更多，Pod 才会被重新启动</li><li>这期间会有冷启动延迟（Pod 拉取镜像、启动应用、健康检查等）</li></ul></li></ul></li><li><p><strong>完整的扩缩容配置示例</strong></p><ul><li>配置示例：<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">      <span class="attr">resource:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">          <span class="attr">averageUtilization:</span> <span class="number">50</span>             <span class="comment"># 当 Pod 的 CPU 平均使用率超过 50% 时扩容</span></span><br><span class="line">  <span class="attr">behavior:</span></span><br><span class="line">    <span class="attr">scaleDown:</span></span><br><span class="line">      <span class="attr">stabilizationWindowSeconds:</span> <span class="number">300</span>        <span class="comment"># 缩容前观察 5 分钟，避免波动</span></span><br><span class="line">      <span class="attr">policies:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">50</span>                          <span class="comment"># 每次最多缩减 50%</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">60</span>                  <span class="comment"># 每 60 秒评估一次缩容</span></span><br></pre></td></tr></tbody></table></figure></li><li>配置效果<ul><li>当 Pod 的 CPU 平均使用率超过 50% 时扩容 </li><li>当 Pod 的 CPU 平均使用率低于 50% 且持续 5 分钟时，每 60 秒最多缩容 50%，直到达到 <code>minReplicas</code> 限制</li></ul></li><li>验证缩容<ul><li>实时查看 HPA 的决策过程：<code>kubectl get hpa nginx-hpa -w</code>，命令的输出结果如下：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME        REFERENCE          TARGETS         MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">nginx-hpa   Deployment/nginx   10%/50%, 80Mi   1         10        3          10m</span><br></pre></td></tr></tbody></table></figure></li><li><code>TARGETS</code>：当前值 VS 目标值</li><li>当 <code>10%/50%</code> 持续低于目标值，<code>REPLICAS</code>（Pod 的副本数量）会逐步减少。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之四</title>
    <link href="https://www.techgrow.cn/posts/37a21b7b.html"/>
    <id>https://www.techgrow.cn/posts/37a21b7b.html</id>
    <published>2025-09-10T13:12:19.000Z</published>
    <updated>2025-09-10T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="Controller-的实战"><a href="#Controller-的实战" class="headerlink" title="Controller 的实战"></a>Controller 的实战</h3><h4 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h4><h5 id="部署无状态应用"><a href="#部署无状态应用" class="headerlink" title="部署无状态应用"></a>部署无状态应用</h5><div class="admonition note"><p class="admonition-title">学习目标</p><p>本节将演示在 Kubernetes 集群中，如何通过 Deployment 部署一个 Nginx 的 Pod，并通过 Service 暴露端口，以便从 Kubernetes 集群外部访问 Nginx。</p></div><blockquote><p>Kubernetes 无状态应用（Stateless）的特点</p></blockquote><ul><li>主要特点：<ul><li>Pod 之间完全一致<ul><li>所有 Pod 完全等价，没有区别，任意一个 Pod 都可以处理请求。</li></ul></li><li>没有启动顺序要求<ul><li> Pod 启动、停止的先后顺序不影响整体业务。</li></ul></li><li>不依赖固定 Node 节点<ul><li> Pod 可以在任意 Node 节点上调度和运行，不需要绑定特定节点。</li></ul></li><li>可随意扩缩容<ul><li> Pod 数量可以随时增加或减少，自动水平扩容（HPA）非常适合。</li></ul></li><li>无持久化存储依赖<ul><li>不保存本地状态，数据通常存储在外部系统中，例如：数据库、对象存储、缓存服务等。</li></ul></li><li>Kubernetes 控制器<ul><li>通常使用 Deployment 管理，支持滚动升级和回滚。</li></ul></li></ul></li><li>典型代表：<ul><li>Nginx、Web 服务、后端接口、无状态微服务。</li></ul></li></ul><blockquote><p>Kubernetes 通过 Deployment 部署无状态应用</p></blockquote><ul><li>生成用于部署一个 Nginx 的 Deployment 的 YAML 配置文件，其中 Deployment 的名称为 <code>nginx</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>自动生成的 YAML 配置文件的内容如下所示 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span>             <span class="comment"># 标签：标识 Deployment 自身</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># 标签：在 Deployment 与 Pod 之间建立管理关系</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> {}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span>         <span class="comment"># 标签：定义 Pod 的身份（标签）</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line"><span class="attr">status:</span> {}</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>配置信息</th><th>作用对象</th><th>核心作用</th><th>简单解释</th></tr></thead><tbody><tr><td><code>metadata.labels</code></td><td>Deployment 自身</td><td>标识 Deployment 自身</td><td>给 Deployment 资源对象自己打上标签，用于被其他资源（如 Service、HPA）查询和选择，或者方便用户管理。它说：” 我是谁。”</td></tr><tr><td><code>spec.selector.matchLabels</code></td><td>Deployment 的选择器</td><td>在 Deployment 与 Pod 之间建立管理关系</td><td> Deployment 用来寻找和管理拥有指定标签的 Pod 的规则。它说：” 哪些 Pod 归我管。”</td></tr><tr><td><code>spec.template.metadata.labels</code></td><td>Pod 模板</td><td>定义 Pod 的身份（标签）</td><td>规定了 Deployment 在创建新 Pod 时会为其打上的标签。它确保了新 Pod 都带有能被选择器识别的标签。它说：” 我创建的 Pod 长这样。”</td></tr></tbody></table><ul><li> 创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Deployment）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-6799fc88d8-jwp6g   1/1     Running   0          29m   10.244.2.18   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 通过 Service 暴露无状态应用</p></blockquote><ul><li>生成 YAML 配置文件，用于为名称为 <code>nginx</code> 的 Deployment 创建一个 NodePort 类型的 Service，将该 Deployment 的 <code>80</code> 端口暴露到 Kubernetes 集群每个节点的静态端口上，以便从集群外部访问 Nginx</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment nginx<span class="params"> --port</span>=80<span class="params"> --type</span>=NodePort<span class="params"> --target</span>-port=80<span class="params"> --name</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx_service.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>自动生成的 YAML 配置文件的内容如下所示 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2025-09-11T10:15:16Z"</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:labels:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:app:</span> {}</span><br><span class="line">      <span class="attr">f:spec:</span></span><br><span class="line">        <span class="attr">f:externalTrafficPolicy:</span> {}</span><br><span class="line">        <span class="attr">f:ports:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="string">k:{"port":80,"protocol":"TCP"}:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:port:</span> {}</span><br><span class="line">            <span class="attr">f:protocol:</span> {}</span><br><span class="line">            <span class="attr">f:targetPort:</span> {}</span><br><span class="line">        <span class="attr">f:selector:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:app:</span> {}</span><br><span class="line">        <span class="attr">f:sessionAffinity:</span> {}</span><br><span class="line">        <span class="attr">f:type:</span> {}</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubectl-expose</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">"2025-09-11T10:15:16Z"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"491002"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/services/nginx</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">e3729f4c-17f9-4100-86dd-2178fe1aa65f</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.106</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">30754</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Service）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_service.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Servcie 列表 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP        38d</span><br><span class="line">nginx        NodePort    10.0.0.106   &lt;none&gt;        80:30754/TCP   30s</span><br></pre></td></tr></tbody></table></figure><ul><li>通过浏览器访问 <code>http://192.168.2.112:30754</code>，请自行更改 IP 和端口；其中 IP 可以是 Kubernetes 集群任意节点的 IP 地址，端口由 <code>kubectl get svc</code> 命令可得知。若 Ngninx 容器在 Kubernetes 集群中创建并启动成功，则默认会打开 Nginx 的首页。</li></ul><blockquote><p>Kubernetes 删除 Deployment 和 Service</p></blockquote><ul><li>如果需要删除上面创建的 Deployment 和 Service，可以执行以下命令：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除Service</span></span><br><span class="line">kubectl delete service nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除Deployment</span></span><br><span class="line">kubectl delete deployment nginx</span><br></pre></td></tr></tbody></table></figure><h5 id="部署有状态应用"><a href="#部署有状态应用" class="headerlink" title="部署有状态应用"></a>部署有状态应用</h5><div class="admonition note"><p class="admonition-title">学习目标</p><p>本节将演示在 Kubernetes 集群中，如何通过 StatefulSet 部署一个 Nginx 的 Pod，并通过 Headless Service（无头服务）暴露应用，以便从 Kubernetes 集群内部访问。</p></div><blockquote><p>Kubernetes 有状态应用（Stateful）的特点</p></blockquote><ul><li><p>主要特点：</p><ul><li>每个 Pod 独立且不可互换<ul><li>每个 Pod 都有自己的身份、配置、存储，不能随意替换或重建。</li></ul></li><li>需要固定的网络标识<ul><li> Pod 需要固定的名称（DNS）或网络标识符，便于集群内通信，比如 <code>mysql-0.mysql</code>。</li></ul></li><li>有启动和停止顺序<ul><li> Pod 必须按照特定顺序启动或停止。</li><li>例如，先启动主节点，再启动从节点。</li></ul></li><li>需要持久化存储<ul><li>必须使用 PersistentVolume（PV）保证数据不随 Pod 删除而丢失。</li></ul></li><li>Pod 调度位置需要考虑<ul><li> Pod 可能需要绑定特定的 Node 节点，确保存储卷挂载一致性或性能需求。</li></ul></li><li>Kubernetes 控制器<ul><li>使用 StatefulSet 管理，支持：<ul><li>固定的 Pod 命名（如 <code>mysql-0</code>, <code>mysql-1</code>）；</li><li>有序部署、有序扩容和缩容；</li><li>持久化存储与 Pod 一一对应。</li></ul></li></ul></li></ul></li><li><p>典型代表：</p><ul><li>MySQL、Kafka、ZooKeeper、ElasticSearch、Redis Cluster。</li></ul></li></ul><blockquote><p>Kubernetes 通过 StatefulSet 部署有状态应用</p></blockquote><ul><li>创建 YAML 配置文件（比如 <code>nginx_statefulset.yaml</code>），用于通过 StatefulSet 部署一个 Nginx 的 Pod</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-statefulset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 StatefulSet）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_statefulset.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态，可以看到 Pod 的名称是根据一定规则生成的（全局唯一）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-statefulset-0   1/1     Running   0          77s   10.244.2.29   k8s-node3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-statefulset-1   1/1     Running   0          65s   10.244.3.11   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-statefulset-2   1/1     Running   0          37s   10.244.0.15   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 通过 Service 暴露有状态应用</p></blockquote><ul><li>创建 YAML 配置文件（如 <code>nginx_service.yaml</code>），用于通过 Service 暴露有状态应用 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">60</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span>   <span class="comment"># None 表示无头服务（Headless Service）</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">无头服务（Headless Service）是什么</p><ul><li>无头服务是没有虚拟 IP（ClusterIP）的 Service（Headless Service），是一种没有 ClusterIP 的特殊 Service 类型，详细介绍请看 <a href="/posts/6bf07963.html#%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B">这里</a>。</li><li>无头服务可以用于暴露 Kubernetes 集群内 Pod 的真实 IP 和 DNS 名称（域名），而不是通过一个统一的虚拟 IP（ClusterIP）进行负载均衡，即 Kubernetes 不会做流量负载均衡。</li></ul></div><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Service）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_service.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Servcie 列表，可以看到有状态应用的 ClusterIP 为 <code>None</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP   53d</span><br><span class="line">nginx        ClusterIP   None         &lt;none&gt;        60/TCP    2m12s</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>通过 Headless Service 暴露 Pod 后，每个 Pod 都有一个唯一的名称和 DNS 名称（域名），域名格式：<code>&lt;pod-name&gt;.&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>，默认的命名空间（<code>namespace</code>）是 <code>default</code>。</li><li>在 Kubernetes 集群内，可以通过 Pod 的 DNS 域名直接访问 Pod（前提是已经<a href="/posts/ccd6f2d4.html#%E9%83%A8%E7%BD%B2-CoreDNS%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89">部署 CoreDNS</a>），比如：<code>http:://nginx-statefulset-0.nginx.default.svc.cluster.local:80</code>。</li></ul></div><blockquote><p>在 Kubernetes 集群内部，通过 Service 的 DNS 名称（域名）访问有状态应用</p></blockquote><div class="admonition warning"><p class="admonition-title">特别注意</p><p>ClusterIP 为 <code>None</code> 的 Service（Headless Service）只能在 Kubernetes 集群内部访问，如果在集群外部机器（比如直接在集群的 Master 节点）上，通过 Pod 的 DNS 名称直接访问 Pod（比如 <code>http://nginx-statefulset-0.nginx.default.svc.cluster.local:80</code>），肯定是无法访问成功的。</p></div><ul><li>创建一个临时 Pod，并进入 Pod 内部的交互式 Shell</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 --rm 参数，为了在 Shell 中执行 exit 命令退出后自动销毁 Pod</span></span><br><span class="line">kubectl run <span class="built_in">test</span>-pod<span class="params"> --image</span>=busybox:1.35<span class="params"> --restart</span>=Never<span class="params"> -it</span><span class="params"> --rm</span> -- sh</span><br></pre></td></tr></tbody></table></figure><ul><li>在临时 Pod 的内部，可以通过 Service 的 DNS 名称（域名）查询所有匹配 Pod 的 IP（必须保证临时 Pod 与 Service 处于同一个命名空间），域名格式：<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup nginx.default.svc.cluster.<span class="built_in">local</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Server:10.0.0.2</span><br><span class="line">Address:10.0.0.2:53</span><br><span class="line"></span><br><span class="line">Name:nginx.default.svc.cluster.local</span><br><span class="line">Address: 10.244.3.11</span><br><span class="line">Name:nginx.default.svc.cluster.local</span><br><span class="line">Address: 10.244.2.29</span><br><span class="line">Name:nginx.default.svc.cluster.local</span><br><span class="line">Address: 10.244.0.15</span><br></pre></td></tr></tbody></table></figure><ul><li>在临时 Pod 的内部，还可以通过 Pod 的 DNS 名称（域名）直接访问指定的 Pod，域名格式：<code>&lt;pod-name&gt;.&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup nginx-statefulset-0.nginx.default.svc.cluster.<span class="built_in">local</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Server:10.0.0.2</span><br><span class="line">Address:10.0.0.2:53</span><br><span class="line"></span><br><span class="line">Name:nginx-statefulset-0.nginx.default.svc.cluster.local</span><br><span class="line">Address: 10.244.2.29</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者通过 Pod 的 DNS 名称（域名）访问 Nginx 的首页面</span></span><br><span class="line">wget<span class="params"> -qO</span>- http://nginx-statefulset-0.nginx.default.svc.cluster.<span class="built_in">local</span>:80</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 删除 StatefulSet 和 Service</p></blockquote><ul><li>如果需要删除上面创建的 StatefulSet 和 Service，可以执行以下命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 Service</span></span><br><span class="line">kubectl delete service nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 StatefulSet，--cascade=true 参数表示连同 Pod 一起删除，但 PVC 默认不会被删除（如果存在）</span></span><br><span class="line">kubectl delete statefulset nginx-statefulset<span class="params"> --cascade</span>=<span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><h5 id="部署守护进程"><a href="#部署守护进程" class="headerlink" title="部署守护进程"></a>部署守护进程</h5><div class="admonition note"><p class="admonition-title">note</p><p>本节将演示在 Kubernetes 集群中，如何通过 DaemonSet 在每个 Node（工作节点）上分别部署一个 Nginx 的 Pod。</p></div><blockquote><p>Kubernetes 中 DaemonSet 的特点和使用场景</p></blockquote><ul><li><p>主要特点：</p><ul><li>每个节点运行一个 Pod<ul><li> 自动在集群中每个符合条件的节点上部署且只运行一个 Pod 实例。</li></ul></li><li>节点加入自动部署<ul><li>当新节点加入集群时，DaemonSet 会自动在该节点上调度并启动 Pod。</li></ul></li><li>节点移除自动回收<ul><li>节点被移除或不可用时，对应 Pod 会自动删除，保持一致性。</li></ul></li><li>不支持手动扩容 / 缩容<ul><li> Pod 的副本数量与节点数量直接关联，不支持手动管理 <code>replicas</code>。</li></ul></li><li>支持滚动更新与回滚<ul><li>可平滑升级版本，并在出现问题时快速回滚。</li></ul></li><li>可结合节点选择器、节点亲和性、污点 / 容忍等使用<ul><li>支持精确控制 DaemonSet Pod 部署在哪些节点上。</li></ul></li><li>与 Deployment 区别<ul><li> Deployment：通常用于无状态服务，副本数固定，由用户定义。</li><li>DaemonSet：与节点数量绑定，强调 “每个节点一个 Pod”。</li></ul></li><li>删除行为可控<ul><li>使用 <code>kubectl delete daemonset</code> 删除 DaemonSet 时，可通过 <code>--cascade=orphan</code> 参数控制是否保留关联的 Pod。</li></ul></li></ul></li><li><p>适用场景：</p><ul><li>日志收集<ul><li>部署日志收集 Agent（如 Fluentd、Logstash、Filebeat），保证每个节点日志都能被采集。</li></ul></li><li>监控与指标采集<ul><li>例如 Prometheus Node Exporter、Datadog Agent、cAdvisor 等，采集节点和 Pod 的监控指标。</li></ul></li><li>网络插件或 CNI 管理<ul><li> Kubernetes CNI 插件通常以 DaemonSet 运行，例如 Calico、Flannel、Cilium 等。</li></ul></li><li>存储插件或 CSI 驱动<ul><li>如 Ceph、Rook 等分布式存储系统的节点守护进程。</li></ul></li><li>安全与合规审计<ul><li>如 Falco、Sysdig Secure 等安全审计或防护 Agent。</li></ul></li><li>节点运维任务<ul><li>自动在每个节点运行健康检查、系统维护脚本或运维工具。</li></ul></li></ul></li></ul><blockquote><p>Kubernetes 通过 DaemonSet 部署守护进程</p></blockquote><ul><li>创建 YAML 配置文件（比如 <code>nginx_daemonset.yaml</code>），用于通过 DaemonSet 在每个节点上分别部署一个 Nginx 的 Pod，，并将宿主机内的 <code>/var/log</code> 目录挂载到容器内部的 <code>/tmp/log</code> 目录（可选操作）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-daemonset</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># DaemonSet 资源自身的标签，用于标识和选择这个 DaemonSet 资源</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># DaemonSet 选择器标签，用于匹配和管理具有此标签的 Pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># Pod 模板标签，DaemonSet 创建的每个 Pod 都会被打上这个标签</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/tmp/log</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/log</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 DaemonSet）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_daemonset.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 DaemonSet 的状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get daemonset nginx-daemonset</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME              DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">nginx-daemonset   4         4         4       4            4           &lt;none&gt;          6m17s</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                    READY   STATUS    RESTARTS   AGE   IP            NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-daemonset-mhxpg   1/1     Running   0          4s    10.244.2.35   k8s-node3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-daemonset-nsb7r   1/1     Running   0          4s    10.244.1.16   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-daemonset-p9k2d   1/1     Running   0          4s    10.244.3.17   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>进入某个 Pod 内部查看挂载的日志文件 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入某个 Pod 的内部</span></span><br><span class="line">kubectl <span class="built_in">exec</span><span class="params"> -it</span> nginx-daemonset-p9k2d bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod 内部的日志文件</span></span><br><span class="line">ls /tmp/<span class="built_in">log</span>/</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Kubernetes 删除 DaemonSet</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 DaemonSet，同时会自动删除它创建的所有 Pod</span></span><br><span class="line">kubectl delete daemonset nginx-daemonset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 --cascade=orphan 参数，只删除 DaemonSet，但保留它创建的所有 Pod</span></span><br><span class="line">kubectl delete daemonset nginx-daemonset<span class="params"> --cascade</span>=orphan</span><br></pre></td></tr></tbody></table></figure><h5 id="部署一次任务"><a href="#部署一次任务" class="headerlink" title="部署一次任务"></a>部署一次任务</h5><h5 id="部署定时任务"><a href="#部署定时任务" class="headerlink" title="部署定时任务"></a>部署定时任务</h5><h4 id="应用升级回滚"><a href="#应用升级回滚" class="headerlink" title="应用升级回滚"></a>应用升级回滚</h4><div class="admonition note"><p class="admonition-title">学习目标</p><p>本节将演示在 Kubernetes 集群中部署 Nginx 后，如何升级 Nginx 的版本，还有如何回滚 Nginx 的版本。</p></div><h5 id="部署应用-1"><a href="#部署应用-1" class="headerlink" title="部署应用"></a>部署应用</h5><ul><li>生成用于部署一个 Nginx 的 Deployment 的 YAML 配置文件，其中 Deployment 的名称为 <code>nginx</code>，Nginx 的版本号为 <code>1.14</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx<span class="params"> --image</span>=nginx:1.14<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>更改自动生成的 YAML 配置文件内容（如下所示），将 <code>replicas</code> 改为 <code>2</code>（表示 Pod 有两个副本）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span>             <span class="comment"># 标签：标识 Deployment 自身</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># 标签：在 Deployment 与 Pod 之间建立管理关系</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> {}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span>         <span class="comment"># 标签：定义 Pod 的身份（标签）</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line"><span class="attr">status:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Deployment）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5658bdf5d4-6sbmg   1/1     Running   0          31m   10.244.1.2   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-5658bdf5d4-ksjgm   1/1     Running   0          31m   10.244.3.2   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><h5 id="升级应用版本"><a href="#升级应用版本" class="headerlink" title="升级应用版本"></a>升级应用版本</h5><ul><li>当执行完上述步骤将 Nginx 部署到 Kubernetes 集群后，可以执行以下命令来升级 Nginx 的版本（比如，将 Nginx 升级到 <code>1.15</code> 版本）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment nginx nginx=nginx:1.15</span><br></pre></td></tr></tbody></table></figure><ul><li>查看应用升级版本的状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout status deployment nginx</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-764b95f4c5-f744r   1/1     Running   0          31m   10.244.1.2   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-764b95f4c5-w96gl   1/1     Running   0          31m   10.244.3.2   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><hr><ul><li>若执行完应用升级版本的命令后，在查看所有 Pod 的运行状态时，新 Pod 的 <code>STATUS</code> 一直显示 <code>ContainerCreating</code>，则说明应用升级版本存在问题 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS              RESTARTS   AGE     IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5658bdf5d4-6sbmg   1/1     Running             0          77m     10.244.1.2    k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-764b95f4c5-f744r   1/1     Running             0          27m     10.244.2.19   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-764b95f4c5-w96gl   0/1     ContainerCreating   0          3m36s   &lt;none&gt;        k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>可以执行以下命令来排查问题（比如，原因是一直卡在拉取镜像的环节上）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod nginx-764b95f4c5-w96gl</span><br></pre></td></tr></tbody></table></figure><ul><li>若无法排查应用升级版本的问题，则可以删除卡住的 Pod 以触发重建 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod nginx-764b95f4c5-w96gl</span><br></pre></td></tr></tbody></table></figure><ul><li>若无法排查应用升级版本的问题，又急需恢复服务，最快捷的方法是回滚（回退）到上一个版本（即用旧版本的 Pod 替换掉所有新版本的 Pod），之后服务会逐渐恢复正常 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment nginx</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Kubernetes 在升级应用的版本时，是不会中断服务的（比如，升级期间 Nginx 依然可以对外提供服务），这主要归功于其精细的流量控制和渐进的替换过程。具体是通过 Deployment 控制器，先启动新版本的 Pod 并确认其就绪，然后逐步终止旧版本的 Pod，同时 Service 的负载均衡器会确保流量只路由到健康的 Pod 上，从而实现了服务的平滑升级。</p></div><h5 id="回滚应用版本"><a href="#回滚应用版本" class="headerlink" title="回滚应用版本"></a>回滚应用版本</h5><ul><li>当执行完上述步骤将 Nginx 的版本从 <code>1.14</code> 升级到 <code>1.15</code> 后，若希望回滚到旧的版本（即用旧版本的 Pod 替换掉所有新版本的 Pod），可以执行以下命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Deployment 的所有历史版本</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment nginx</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回滚 Deployment 到上一个版本</span></span><br><span class="line">kubectl rollout undo deployment nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚 Deployment 到指定的版本</span></span><br><span class="line">kubectl rollout undo deployment nginx<span class="params"> --to</span>-revision=2</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5658bdf5d4-6sbmg   1/1     Running   0          31m   10.244.1.2   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-5658bdf5d4-ksjgm   1/1     Running   0          31m   10.244.3.2   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="应用弹性伸缩"><a href="#应用弹性伸缩" class="headerlink" title="应用弹性伸缩"></a>应用弹性伸缩</h4><div class="admonition note"><p class="admonition-title">学习目标</p><p>本节将演示在 Kubernetes 集群中部署 Nginx 后，如何对 Nginx 进行扩容（即增加 Pod 的副本数量）。</p></div><h5 id="部署应用-2"><a href="#部署应用-2" class="headerlink" title="部署应用"></a>部署应用</h5><ul><li>生成用于部署一个 Nginx 的 Deployment 的 YAML 配置文件，其中 Deployment 的名称为 <code>nginx</code></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>自动生成的 YAML 配置文件的内容如下所示 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span>             <span class="comment"># 标签：标识 Deployment 自身</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># 标签：在 Deployment 与 Pod 之间建立管理关系</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> {}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span>         <span class="comment"># 标签：定义 Pod 的身份（标签）</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line"><span class="attr">status:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或更新 YAML 文件中定义的 Kubernetes 资源对象（比如 Deployment）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="params"> -f</span> nginx_deployment.yaml</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5658bdf5d4-kt6fv   1/1     Running   0          29m   10.244.2.18   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><h5 id="应用扩缩容"><a href="#应用扩缩容" class="headerlink" title="应用扩缩容"></a>应用扩缩容</h5><ul><li>当执行完上述步骤将 Nginx 部署到 Kubernetes 集群后，可以执行以下命令来对 Pod 的副本数进行扩缩容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 Pod 的副本进行扩容（比如，扩容至 3 个副本）</span></span><br><span class="line">kubectl scale deployment nginx<span class="params"> --replicas</span>=3</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 Pod 的运行状态 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods<span class="params"> -o</span> wide</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP           NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5658bdf5d4-kt6fv   1/1     Running   0          29m     10.244.0.7   k8s-node3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-5658bdf5d4-tbvzz   1/1     Running   0          2m55s   10.244.1.3   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-5658bdf5d4-z48mx   1/1     Running   0          2m57s   10.244.3.6   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>如何设计可以动态扩容缩容的分库分表方案</title>
    <link href="https://www.techgrow.cn/posts/af97a1f4.html"/>
    <id>https://www.techgrow.cn/posts/af97a1f4.html</id>
    <published>2025-08-22T13:12:19.000Z</published>
    <updated>2025-08-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/af97a1f4.html">如何设计可以动态扩容缩容的分库分表方案</a></li><li><a href="/posts/2df884fd.html">分库分表后，生产环境如何实现不停机迁移数据</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线上系统已经完成了分库分表方案的落地：库表建好、基于分库分表中间件的开发与测试也都顺利完成，数据能够均匀分布到各个库表中，系统也通过双写方案平滑迁移并成功切换到分库分表架构上。然而，随着业务持续增长，现有的库表再次面临瓶颈：单库容量接近上限、单表数据量过大、单库写入并发压力过高等问题，必须进行进一步的扩容。比如，原来是 3 个库，每个库 4 个表，现在需要扩容成 6 个库，每个库 8 个表。问题是：如何在不影响线上业务（即不停机）的情况下，进行动态扩容或缩容呢？</p><span id="more"></span><h2 id="停机扩容"><a href="#停机扩容" class="headerlink" title="停机扩容"></a>停机扩容</h2><p>停机扩容与 <a href="/posts/2df884fd.html#%E5%81%9C%E6%9C%BA%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE">停机迁移数据</a> 类似，步骤基本相同，唯一的区别是需要使用数据导入工具，将现有库表中的数据抽取并导入到新的库表中。但这种方式并不推荐，原因在于：既然已经采用了分库分表，说明数据量非常庞大，可能达到数亿甚至几十亿条记录，此时再采用停机迁移的方式风险极高。从单库单表迁移到分库分表架构时，数据量尚可接受，单表最多两三千万条，通过开发数据迁移工具，使用多台机器并行处理，1 小时内就能完成导入。但当系统基于分库分表架构运行一段时间后，例如当前有一共 3 个库和 12 个表，数据量达到 1 亿 ～ 2 亿条，仅导入数据就需要数小时。假设 6 点开始导入数据，直到导入完成，后续还要修改数据库连接配置、重新部署系统、业务测试验证，往往到 10 点才能完成，停机时间过长，线上业务无法承受。</p><h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><p>一开始就将分库分表架构规划为 32 个库，每个库 32 张表，共 1024 张表。这种设计基本能够满足国内大多数互联网公司的需求，无论是支撑并发能力还是数据容量都没有问题。通过一次性规划足够的库表数量（如 32 个库，每个库 32 张表）+ 固定取模路由规则（<code>2^n</code>）+ DBA 库级迁移工具支持，既能保证早期部署简单，又能支持后期平滑扩容或缩容，避免频繁停机迁移和复杂的数据重新分片工作。</p><ul><li>性能预估：<ul><li>每个库可承载约 1000 TPS（写入并发），则 32 个库总共可支撑 32000 TPS。</li><li>如果每个库承载到 1500 TPS，则总共可达 48000 TPS，接近 5 万 /s。</li><li>前端再加一个消息队列（MQ）进行削峰：<ul><li>MQ 写入 QPS 可达 8 万 /s，MQ 消费 QPS 可达 5 万 /s，可平滑处理高并发写入。</li></ul></li></ul></li><li>容量规划：<ul><li>32 个库，每个库 32 张表。</li><li>一共 1024 张表，每表存 500 万条数据，总容量可达 50 亿条数据。</li><li>对于国内绝大多数互联网公司，这个规模一般足够支撑多年。</li></ul></li><li>路由规则：<ul><li>库路由：<code>orderId % 32</code> → 确定库。</li><li>表路由：<code>(orderId / 32) % 32</code> → 确定表，必须先将 <code>orderId</code> 除以库数量，再对表数量进行取模运算，目的是：<ul><li>避免表内数据分布不均，导致热点数据集中在某几个表或库；</li><li>将数据均匀打散到 32 个库 × 32 张表，每个库内部的 32 张表都能均匀分布数据；</li><li>避免表的分布就和库的分布耦合在一起，比如库 0 里永远只会使用到表 0，库 1 永远只会使用到表 1；</li></ul></li><li>这种 基于 <code>2^n</code> 的取模方案，天然支持倍数扩容和缩容，减少扩容时路由规则变更的复杂度。</li></ul></li><li>扩容策略：<ul><li>首次分库分表就 “一步到位”，建立 32 个库，每个库 32 张表，避免频繁扩容。</li><li>早期阶段：<ul><li>可将多个逻辑库部署在同一台 MySQL 服务器上，例如 4 台 MySQL 服务器，每台 MySQL 服务器创建 8 个库，一共有 32 个库。</li></ul></li><li>后期扩展：<ul><li>当 MySQL 单机实例压力过大，可以申请多台 MySQL 服务器，进行倍数扩容（如从 4 台扩展至 8 台）；</li><li>扩容时只需要不断地在旧库和新的 MySQL 服务器之间做数据迁移，然后系统仅需更改库的连接地址，重新发布即可，路由规则无需变更；</li><li>最多可扩展至 32 台 MySQL 服务器（每台一个库，每个库 32 张表）。</li></ul></li></ul></li><li>缩容策略：<ul><li>如果需要减少 MySQL 服务器的数量，可以进行倍数缩容（如从 8 台扩展至 4 台），即物理合并 MySQL 服务器（保持逻辑库的总数量不变）；</li><li>比如，原来 32 个库分布在 8 台 MySQL 服务器上，现在迁移到 4 台 MySQL 服务器上，每台 MySQL 服务器上有 8 个库；</li><li>只需要将部分库的数据迁移到其他 MySQL 服务器，然后系统仅需更改库的连接地址，重新发布即可，路由规则无需变更。</li></ul></li><li>优势总结：<ul><li>DBA 通过成熟的工具迁移旧库至新的 MySQL 服务器即可完成扩缩容，业务代码无需处理复杂的数据迁移逻辑。</li><li>这种分库分表规划减少了后期频繁改造的成本，也能较好应对未来业务增长。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何设计可以动态扩容缩容的分库分表方案。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="架构设计" scheme="https://www.techgrow.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分库分表后，生产环境如何实现不停机迁移数据</title>
    <link href="https://www.techgrow.cn/posts/2df884fd.html"/>
    <id>https://www.techgrow.cn/posts/2df884fd.html</id>
    <published>2025-08-21T13:12:19.000Z</published>
    <updated>2025-08-21T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/af97a1f4.html">如何设计可以动态扩容缩容的分库分表方案</a></li><li><a href="/posts/2df884fd.html">分库分表后，生产环境如何实现不停机迁移数据</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假设，目前线上系统是单库单表（即未分库分表），单表已有约 600 万条数据。计划将数据迁移到 3 个库、每个库 4 张表的分库分表架构中，每张表存放约 50 万条数据。已经选定了分库分表的中间件（例如 Sharding-JDBC 或 Mycat），问题是：如何在不影响线上业务（即不停机）的情况下，将系统平滑迁移到新的分库分表架构上？</p><div class="admonition note"><p class="admonition-title">为什么要分库分表？</p><p>分库分表主要有两个原因，要不就是单库并发压力太高，要不就是单库数据量太大。</p></div><span id="more"></span><h2 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h2><h3 id="停机迁移数据"><a href="#停机迁移数据" class="headerlink" title="停机迁移数据"></a>停机迁移数据</h3><p>这里先介绍一种不常用的方案 - 停机迁移，相对比较简单、粗暴，技术含量不高。在网站或 App 提前发布公告，通知用户 0 点到 6 点期间系统停机维护。凌晨 0 点开始运维，到点后先停机，系统停止服务，不再有新的流量写入，此时旧的单库单表数据库保持静止。接着运行事先准备好的一次性数据迁移工具，把单库单表中的数据批量导出，并按照分库分表规则导入到新库中。数据导入完成后，更新系统的数据库连接配置，同时上线新版本代码（因为分库分表后 SQL 或数据访问逻辑可能有改动）。最后启动系统，连接新的分库分表架构，进行业务验证。如果业务验证通过，就算迁移完成。不过，这种 “停机迁移” 的方案相对比较简单、粗暴，技术含量不高。</p><p><img data-src="../../../asset/2025/08/database-split-1.png"></p><blockquote><p>停机迁移方案通常包括以下几个核心步骤：</p></blockquote><ul><li>(1) 读取数据<ul><li>按分页（<code>limit/offset</code> 或者主键范围）从旧表里分批读取数据，避免一次性读 600 万导致 OOM 或锁表。</li><li>典型做法：<ul><li>根据主键（比如自增 ID）按范围扫描：<code>select * from old_table where id between x and y</code></li><li>每次取 1w ~ 5w 条，批量处理。</li></ul></li></ul></li><li>(2) 路由规则计算（分库分表规则映射）<ul><li>根据预设的分库分表规则（比如 <code>user_id % 6</code> → 定位到某个库某个表）。</li><li>数据迁移工具对每一条数据计算：<ul><li>属于哪个分库</li><li>属于哪个分表</li></ul></li><li>举个例子： <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user_id = 1025</span><br><span class="line">库号 = user_id % 3   （0 ~ 2）</span><br><span class="line">表号 = user_id % 4   （0 ~ 3）</span><br><span class="line">最终落点 = db_2.user_table_1</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>(3) 写入新库<ul><li>批量插入目标分表（<code>batch insert</code>），减少网络往返。</li><li>写入前可能需要做：<ul><li>字段映射（比如旧表字段和新表字段不完全一致）</li><li>数据清洗（处理非法数据、空值等）</li><li>主键处理（旧表用自增 ID，新表可能使用雪花 ID 或 UUID，需要重新生成）</li></ul></li></ul></li><li>(4) 数据校验<ul><li>迁移完一批数据后，进行校验：<ul><li>数量校验：源表 10 万条数据，目标表分散后总和也应该是 10 万条数据。</li><li>抽样校验：随机抽几条数据，对比新旧库的字段值是否一致。</li><li>全量校验（可选）：做 MD5 校验，或者比对哈希值。</li></ul></li></ul></li><li>(5) 日志与容错<ul><li>每批迁移要有日志，记录成功或者失败。</li><li>失败的数据要单独写入 “重试队列”。</li><li>支持断点续传（例如数据迁移中断，可以从上次 ID 继续跑）。</li></ul></li><li>(6) 收尾工作<ul><li>所有数据迁移完毕，全量校验通过。</li><li>更新系统的数据库连接配置，让系统指向新的分库分表架构。</li><li>上线新版本代码（因为分库分表后 SQL 或数据访问逻辑可能有调整）。</li><li>重启服务，进行业务验证，确认无误后切换工作正式完成。</li></ul></li></ul><h2 id="不停机迁移方案"><a href="#不停机迁移方案" class="headerlink" title="不停机迁移方案"></a>不停机迁移方案</h2><h3 id="双写迁移数据"><a href="#双写迁移数据" class="headerlink" title="双写迁移数据"></a>双写迁移数据</h3><p>双写迁移是目前最常用且较为稳妥的一种迁移方式，优点是不需要停机，也不用熬夜等凌晨运维窗口。核心思路：在系统中对所有写库操作（增、删、改）进行改造，不仅写入旧库，同时也写入新库，即所谓的 “双写”。这样可以保证在迁移期间，新库持续写入最新数据。在此基础上，通常需要配合以下机制：</p><ul><li><code>数据同步</code>：迁移启动前，先通过全量复制将旧库的历史数据导入新库，再通过 Binlog 或数据同步程序保证新旧库实时增量同步。这样新库能够与旧库保持一致性，不会出现 “有新数据但未同步” 的情况。</li><li><code>数据比对</code>：迁移过程中，需要定期进行新旧库的数据校验（例如按主键范围抽样比对行数、字段值校验、聚合校验等），确保两边数据在数量和内容上保持一致，避免出现漏同步、同步延迟或数据不一致的问题。</li><li><code>补偿机制</code>：若比对过程中发现差异，可通过重放 Binlog、补偿 SQL 或自动修复任务进行数据回补，保证最终一致性。补偿一般在后台异步执行，不影响业务正常运行。</li></ul><p><img data-src="../../../asset/2025/08/database-split-2.png"></p><blockquote><p>双写迁移方案通常包括以下几个核心步骤：</p></blockquote><ul><li>(1) 数据实时同步<ul><li>首先开发并部署一个数据同步程序，将旧库的历史数据全量复制到新库中。由于旧库仍然在对外提供写服务（例如订单持续写入），同步程序还需要实时捕获旧库的增量变更并写入新库。核心思路是 “全量复制 + 增量实时同步”。</li><li>数据实时同步的常见做法是基于 MySQL Binlog 实时同步，通过解析 Binlog 日志捕获 <code>INSERT/UPDATE/DELETE</code> 操作，再写入新库，从而保证新旧库数据基本保持一致。</li><li>写入新库时，可以通过 <code>gmt_modified</code> 等时间戳字段进行判断：若新库不存在该数据，则直接插入；若新库已有该数据，但旧库的版本更新（修改时间更晚），则覆盖写入。</li><li>这一过程对旧库和业务系统无侵入性，不需修改应用代码，也无需回滚，仅需额外部署新库和同步程序；即使同步程序对旧库产生影响，也可随时停掉，不影响线上业务。</li></ul></li><li>(2) 双写改造与部署<ul><li>在业务系统中改造写操作，使所有增删改操作同时作用于旧库和新库。常见方案包括：<ul><li><code>数据库中间件拦截</code>：利用 ShardingSphere、MyCAT 等支持双写或路由功能的中间件，在代理层统一拦截写操作，实现业务层零改动即可完成双写。但需关注复杂 SQL 与事务支持情况，确保中间件稳定可靠。</li><li><code>ORM/AOP 层拦截</code>：在 ORM 框架或 AOP 拦截器层统一实现双写逻辑，例如通过 MyBatis 插件 + 多数据源实现。业务层透明感知数据库操作即可完成双写，同时可顺带处理幂等、异常重试和事务顺序控制，前提是系统使用统一的 ORM 框架。</li><li><code>Binlog 增量同步</code>：也可继续使用 Binlog 方式（Canal、Maxwell、Debezium 等）捕获旧库变更并实时写入新库，这种方式对业务无侵入，适合大数据量场景，但需保证 Binlog、网络和同步工具的稳定性，并结合全量导入和校验机制保障数据完整性。</li></ul></li><li>上线部署系统完成双写改造的新版本代码，然后停掉前期的数据同步程序，确保新写入数据由业务逻辑直接写入新库。</li></ul></li><li>(3) 数据比对与补偿<ul><li>由于双写策略也不保证新旧库的强一致性，此时需要上线一个数据比对与补偿程序。</li><li>数据比对与补偿程序会对比旧库近期的数据变更，逐表逐行校验新旧库的数据是否一致。</li><li>若发现不一致的数据，则从旧库读取并写入新库进行补偿。</li><li>该过程可能需要多轮循环，直至新旧库数据完全一致。</li></ul></li><li>(4) 切换到新库<ul><li>当确认新旧库数据完全一致后，可以停掉数据比对和补偿程序。</li><li>上线部署仅依赖分库分表、去掉双写逻辑的新版本代码。</li><li>重新部署系统，此时所有读写流量切换到新库，旧库逐步进入下线流程。</li></ul></li></ul><blockquote><p>双写迁移方案需要注意以下地方：</p></blockquote><ul><li>事务一致性<ul><li>旧库与新库之间无法保证强一致事务，必须容忍 “临时不一致”。</li><li>遇到异常时，至少要保证旧库优先成功，新库可以重试补偿。</li></ul></li><li>异常与补偿机制<ul><li>双写失败时（例如新库宕机），要记录失败日志或写入消息队列，后续重试补偿。</li><li>可设计一个数据补偿任务（定时比对旧库与新库的数据），保证最终一致性。</li></ul></li><li>顺序与幂等<ul><li>确保双写执行顺序与业务一致（例如先 <code>INSERT</code> 再 <code>UPDATE</code>），避免错序写入。</li><li>所有操作必须支持幂等，防止重试引起脏数据。</li><li>建议使用幂等写入，比如 MySQL 的 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</li></ul></li><li>更新操作特殊处理<ul><li>新库数据可能不存在，直接执行 <code>UPDATE</code> 可能更新不到任何行。</li><li>建议采用 “存在则更新，否则插入” 的更新策略，例如 MySQL 的 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</li></ul></li><li>全量迁移与增量校验<ul><li>在正式双写之前，最好先做一次全量迁移（减少新库缺少数据的概率）。</li><li>启用双写后，后台跑比对和补偿任务，抽查或全量校验新旧库数据，自动补偿不一致的数据。</li></ul></li></ul><p>这种方案在迁移过程中业务不会中断，用户几乎无感知，可靠性高。因此，目前大多数公司在迁移生产系统的数据时，都会采用这种 “双写 + 校验” 的方案。</p><h2 id="扩展知识内容"><a href="#扩展知识内容" class="headerlink" title="扩展知识内容"></a>扩展知识内容</h2><h3 id="数据库在线迁移工具"><a href="#数据库在线迁移工具" class="headerlink" title="数据库在线迁移工具"></a>数据库在线迁移工具</h3><p>主流的数据库在线迁移工具有以下几种，支持迁移在线业务，通常依赖 “全量复制 + 增量实时同步 + 切换” 的方案。</p><ul><li><p><strong>(1) MySQL 原生工具</strong></p><ul><li>MySQL Replication (主从复制)<ul><li> 概述：<ul><li>将新库作为旧库的从库，开启基于 Binlog 的主从复制。通常先做全量数据同步，再实时同步增量数据，追平后切换主库。</li></ul></li><li>优点：<ul><li>MySQL 自带、成熟稳定、社区支持广、对业务代码零侵入。</li><li>基于 Binlog，增量数据实时同步，保证数据一致性。</li></ul></li><li>缺点：<ul><li>跨机房或网络延迟大时，复制延迟问题明显。</li><li>切换为主库需要停写或短暂停机（秒级）。</li><li>不适用于大规模 DDL 变更或 MySQL 版本跨度过大的迁移。</li></ul></li></ul></li><li>MySQL Group Replication / InnoDB Cluster<ul><li> 概述：<ul><li>基于 MySQL 官方的高可用集群，支持多主、多从、动态扩容。</li><li>严格来说，这不是专门的 “在线迁移工具”，本质上是 MySQL 的高可用方案，只是可以顺便解决迁移问题。</li></ul></li><li>优点：<ul><li>支持多主写入、自动故障转移。</li><li>支持自动处理节点加入 / 离开，迁移过程中可降低人为操作风险。</li></ul></li><li>缺点：<ul><li>部署复杂，对网络延迟和数据库版本有严格要求。</li><li>多主模式下存在冲突处理问题。</li><li>性能相对普通主从复制略差。</li><li>跨机房支持不理想。</li></ul></li></ul></li></ul></li><li><p><strong>(2) 企业常用迁移工具</strong></p><ul><li><a href="https://github.com/percona/percona-xtrabackup">Percona XtraBackup</a><ul><li> 概述：<ul><li>用于 MySQL 的热备份，全量复制旧库数据到新库，然后结合 Binlog 或其他增量方案追平。</li></ul></li><li>优点：<ul><li>支持热备份，不锁表。</li><li>备份速度快，适合大数据量（TB 级别）场景。</li><li>一致性好，可与 MySQL 主从复制结合实现无缝切换。</li><li>开源、社区成熟，企业使用广泛。</li></ul></li><li>缺点：<ul><li>只解决全量迁移问题，增量追平仍需依赖 Binlog 或其他方案；</li><li>对磁盘空间和 I/O 有较高要求。</li></ul></li></ul></li><li><a href="https://github.com/percona/percona-toolkit">pt-table-sync（Percona Toolkit）</a><ul><li>概述：<ul><li>用于全量数据校验、增量数据同步和比对，基于对比源库和目标库数据差异，按需补齐。</li></ul></li><li>优点：<ul><li>支持在线比对数据差异，自动修复，保证一致性。</li><li>支持断点续传，适合长时间迁移。</li><li>可用作双写迁移、切换后的数据一致性保障。</li><li>可以作为 Binlog 同步之后的校验工具。</li></ul></li><li>缺点：<ul><li>性能开销大，对源库影响明显，尤其是大表，适合流量低峰期运行。</li><li>仅适合 MySQL，且在大表场景下校验速度慢。</li><li>配置和使用复杂，需要 DBA 熟悉其工作原理。</li></ul></li></ul></li></ul></li><li><p><strong>(3) 增量同步中间件</strong></p><ul><li><a href="https://github.com/alibaba/canal">Canal（阿里开源）</a><ul><li>基于 Binlog 订阅，支持异构同步（MySQL → MySQL / ElasticSearch / Kafka）。</li></ul></li><li><a href="https://github.com/debezium/debezium">Debezium（国外开源）</a><ul><li>基于 CDC（Change Data Capture），是一个开源的分布式平台，支持多种数据库实时同步。</li></ul></li><li><a href="https://github.com/alibaba/otter">Otter（阿里开源）</a><ul><li>基于 Canal + 分布式调度，适合分库分表场景。</li></ul></li><li>DTS（阿里云数据库传输服务） / DMS（腾讯云数据库传输服务）</li><li>主流云厂商的在线迁移工具，支持断点续传、实时增量同步。</li></ul></li></ul><blockquote><p>数据库在线迁移工具的最佳实践</p></blockquote><ul><li>自建环境推荐使用 XtraBackup（全量复制） + MySQL Replication（增量追平） + Canal（增量消费、双写）</li><li>云环境推荐使用云厂商的 DTS / DMS，直接提供 “全量 + 增量 + 切换” 的托管能力。</li></ul><blockquote><p>数据库在线迁移数据的典型步骤如下：</p></blockquote><ul><li>(1) 新增 MySQL 服务器，创建好库表结构（与现有表结构保持一致）。</li><li>(2) 全量迁移历史数据（XtraBackup / 全量 Dump）。</li><li>(3) 开启 Binlog 增量订阅（Canal / DTS / MySQL 原生主从复制）。</li><li>(4) 实时同步增量数据，并进行数据校验。</li><li>(5) 业务切换流量到新库（通过中间件配置或 DNS / 服务发现）。</li><li>(6) 平滑下线旧库。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cloud.tencent.com/developer/article/2204209">不停机迁移数据库的解决方案</a></li><li><a href="https://blog.csdn.net/2301_78858041/article/details/147819741">如何零停机、零丢失迁移数据库</a></li><li><a href="https://cloud.tencent.com/developer/article/1663946">分库分表后，生产环境怎么实现不停机数据迁移</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍分库分表后，生产环境如何实现不停机迁移数据。</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="架构设计" scheme="https://www.techgrow.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之二</title>
    <link href="https://www.techgrow.cn/posts/c57e8370.html"/>
    <id>https://www.techgrow.cn/posts/c57e8370.html</id>
    <published>2025-08-15T13:12:19.000Z</published>
    <updated>2025-08-15T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li></ul><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><h4 id="Pod-的基础概念"><a href="#Pod-的基础概念" class="headerlink" title="Pod 的基础概念"></a>Pod 的基础概念</h4><h5 id="Pod-的概述"><a href="#Pod-的概述" class="headerlink" title="Pod 的概述"></a>Pod 的概述</h5><p>Pod 是 Kubernetes 中可以创建和管理的最小资源单元，是用户在资源对象模型中创建或部署的基本单位，也是 Kubernetes 上运行容器化应用的直接载体。Kubernetes 并不会直接管理容器，而是通过管理 Pod 来间接管理容器。一个 Pod 通常由一个或多个容器组成，这些容器共享网络、存储等资源，并作为一个整体被调度和管理。在 Kubernetes 中，其他资源对象主要用于支撑或扩展 Pod 的功能，例如：Controller 资源用于管理和控制 Pod 的生命周期；Service 或 Ingress 资源用于暴露和访问 Pod；而 PersistentVolume (PV) 等存储资源用于为 Pod 提供持久化存储支持。此外，每个 Pod 都包含一个特殊的系统容器，称为 Pause 容器，它作为 Pod 的 “根容器” 存在，用于占据 Pod 的网络命名空间等资源。除了 Pause 容器，Pod 中还包含一个或多个紧密相关的用户业务容器，所有业务容器都在同一个 Namespace 里面，可以实现网络共享；这些容器协同工作，共同完成某项具体的业务功能。</p><span id="more"></span><h5 id="Pod-的特性"><a href="#Pod-的特性" class="headerlink" title="Pod 的特性"></a>Pod 的特性</h5><ul><li><p><strong>资源共享</strong></p><ul><li>一个 Pod 里的多个容器可以共享存储和网络，可以看作一个逻辑的主机（服务器），共享 Namespace（命名空间）、Cgroups（控制组）或者其他的隔离资源。</li><li>同一个 Pod 中的多个容器共享同一个 Network Namespace，因此它们共享同一个 IP 地址和端口空间。也就是说，Pod 内的容器可以通过 <code>localhost</code> 进行通信。需要注意的是，多个容器在同一个 Pod 中运行时，应避免端口冲突。不同的 Pod 之间具有各自独立的 IP 地址，默认情况下，不同 Pod 中的容器之间不能通过 IPC 机制通信（除非做了特殊配置），通常使用 Pod 的 IP 地址进行网络通信。</li><li>一个 Pod 中的多个容器可以共享同一个存储卷，该存储卷作为 Pod 的一部分被定义，并可以挂载到该 Pod 内所有容器的文件系统中，从而实现数据共享和持久化存储。</li></ul></li><li><p><strong>生命周期短暂</strong></p><ul><li>Pod 是生命周期相对短暂的组件，例如当 Pod 所在的节点发生故障时，该节点上的 Pod 会被重新调度到其他节点上运行。但需要注意的是，重新调度后创建的是一个全新的 Pod，与原来的 Pod 没有任何关联，原有的状态、数据和标识都会丢失，二者之间没有任何直接关系。</li></ul></li><li><p><strong>平坦的网络</strong></p><ul><li>Kubernetes 集群中的所有 Pod 都处于同一个共享的网络地址空间中，这意味着每个 Pod 都可以通过其他 Pod 的 IP 地址直接进行访问和通信，无需进行额外的网络配置。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Docker 容器与宿主机进程的关系</p><ul><li>Docker 容器里的进程没有独立 Linux 内核，使用的是宿主机内核，它本质就是宿主机进程。</li><li>Docker 容器只是由 Linux 内核提供的隔离（Namespace） + 资源限制（Cgroups）环境。</li><li>当宿主机关掉 Docker 容器主进程，容器就会退出运行（容器生命周期依赖主进程）。换言之，Docker 容器主进程如果挂掉，容器就会停止运行。</li><li>Docker 容器的 Linux 内核版本永远等于宿主机的内核版本，更换镜像也换不掉内核。比如，当宿主机内核版本低（例如 <code>3.3</code>），容器里即使是最新版本的 Ubuntu，也无法使用高版本内核才有的特性（比如一些新 Cgroup 特性、eBPF）。</li></ul></div><h5 id="Pod-的分类"><a href="#Pod-的分类" class="headerlink" title="Pod 的分类"></a>Pod 的分类</h5><p>Pod 有两种类型：</p><ul><li><p><strong>普通 Pod</strong>  </p><ul><li> 普通 Pod 被创建后会被存储到 Etcd 中，随后由 Kubernetes Master 调度到某个特定的 Node（工作节点）上并与之绑定。该 Node（工作节点）上的 kubelet 进程会负责将 Pod 实例化为一组相关的容器（如 Docker 容器）并启动它们。默认情况下，如果 Pod 中的某个容器停止运行，Kubernetes 会自动检测并重启该 Pod 内的所有容器。如果 Pod 所在的 Node（工作节点）发生宕机，Kubernetes 会将该 Node（工作节点）上的所有 Pod 重新调度到其他可用节点上。</li></ul></li><li><p><strong>静态 Pod</strong>  </p><ul><li> 静态 Pod 是由 kubelet 直接管理的特殊 Pod，仅存在于特定的 Node（工作节点）上。它们不受 API Server 管理，也无法与 Replication Controller、Deployment 或 DaemonSet 等控制器关联。此外，kubelet 对静态 Pod 的健康检查能力有限，通常仅能监控其运行状态，而不会像普通 Pod 那样提供完整的健康检查机制。</li></ul></li></ul><h5 id="Pod-的定义"><a href="#Pod-的定义" class="headerlink" title="Pod 的定义"></a>Pod 的定义</h5><p>定义 Pod 的 YAML 配置示例如下（<code>&lt;string&gt;</code> 是占位符，需要根据实际情况填写）：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="comment"># 元数据</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="comment"># 时间配置</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">0</span>            <span class="comment"># 检查间隔时间</span></span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 安全配置</span></span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span>       <span class="comment"># 重启策略，可选值: Always、Never、OnFailure，默认 Always</span></span><br><span class="line">  <span class="attr">nodeSelector:</span>               <span class="comment"># 节点选择，将 Pod 调度到包含这些 Label 的 Node（工作节点）上</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">value</span>                <span class="comment"># 以 key:value 格式指定</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span>          <span class="comment"># 是否使用主机网络模式，默认 false（不使用）</span></span><br><span class="line">  <span class="comment"># 共享存储卷列表</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">      <span class="attr">emptyDir:</span> {}</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">host-volume</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/path/on/host</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">configmap-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&lt;string&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-的运行方式"><a href="#Pod-的运行方式" class="headerlink" title="Pod 的运行方式"></a>Pod 的运行方式</h5><p><strong>在 Kubernetes 中，运行的容器要求其主程序必须始终在前台运行，而不能以后台方式执行。如果应用默认是以后台运行的方式启动，就需要进行修改，使其在前台运行。否则，当 kubelet 创建包含该容器的 Pod 并执行启动命令后，会因为容器立即退出而认为该 Pod 已经结束，从而立刻销毁该 Pod。</strong>如果该 Pod 是由控制器（如 Replication Controller）管理的，那么就会不断尝试重新创建和销毁 Pod，陷入无限循环。需要注意的是，一个 Pod 可以由一个或多个容器组成。</p><ul><li>下面的 YAML 配置内容定义了一个包含单个容器的 Pod，容器使用的是官方 Tomcat 镜像，并包含基本的端口和挂载配置 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mytomcat</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">tomcat:9.0</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/local/tomcat/webapps</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-data</span></span><br><span class="line">      <span class="attr">emptyDir:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>YAML 配置内容的详细说明</li></ul><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td><code>metadata.name</code></td><td>Pod 的名称，必须唯一</td></tr><tr><td><code>metadata.labels</code></td><td>标签，用于标识和选择 Pod</td></tr><tr><td><code>spec.containers</code></td><td>容器列表，一个 Pod 可包含一个或多个容器</td></tr><tr><td><code>spec.containers[].name</code></td><td>容器的名称，在 Pod 内部唯一</td></tr><tr><td><code>spec.containers[].image</code></td><td>容器使用的镜像，这里是 <code>tomcat:9.0</code></td></tr><tr><td><code>spec.containers[].ports</code></td><td>容器开放的端口列表</td></tr><tr><td><code>spec.containers[].ports[].containerPort</code></td><td>容器内部监听的端口号（如 Tomcat 默认 8080）</td></tr><tr><td><code>spec.containers[].volumeMounts</code></td><td>容器内挂载的卷配置</td></tr><tr><td><code>spec.containers[].volumeMounts[].name</code></td><td>要挂载的卷名称，对应 <code>spec.volumes</code> 中定义的名称</td></tr><tr><td><code>spec.containers[].volumeMounts[].mountPath</code></td><td>挂载点路径，如 <code>/usr/local/tomcat/webapps</code></td></tr><tr><td><code>spec.volumes</code></td><td>定义 Pod 中使用的卷</td></tr><tr><td><code>spec.volumes[].name</code></td><td>卷的名称，与 <code>volumeMounts</code> 中的名称对应</td></tr><tr><td><code>spec.volumes[].emptyDir</code></td><td>使用一个空目录卷，Pod 删除时数据也会被清除</td></tr></tbody></table><h5 id="Pod-的生命周期"><a href="#Pod-的生命周期" class="headerlink" title="Pod 的生命周期"></a>Pod 的生命周期</h5><p>Pod 的生命周期状态有以下几种：</p><table><thead><tr><th>生命周期状态</th><th>说明</th></tr></thead><tbody><tr><td> Pending</td><td>API Server 已创建该 Pod，但 Pod 中的一个或多个容器的镜像尚未创建（包括镜像下载过程）。</td></tr><tr><td>Running</td><td>Pod 内所有容器已创建，且至少有一个容器处于运行状态（包括正在启动或重启的状态）。</td></tr><tr><td>Completed</td><td>Pod 内所有容器均已成功执行并退出，且不会再重启。</td></tr><tr><td>Failed</td><td>Pod 内所有容器均已退出，但至少有一个容器退出失败。</td></tr><tr><td>Unknown</td><td> 由于某些原因（如网络通信不畅）无法获取 Pod 的状态。</td></tr></tbody></table><h5 id="Pod-的状态条件"><a href="#Pod-的状态条件" class="headerlink" title="Pod 的状态条件"></a>Pod 的状态条件</h5><p>Pod 的状态条件（Conditions）有以下几种：</p><table><thead><tr><th>状态条件</th><th>触发时机</th><th>正常状态</th><th>说明</th></tr></thead><tbody><tr><td><code>PodScheduled</code></td><td>当 Scheduler 为 Pod 分配了目标 Node（工作节点）后</td><td><code>True</code></td><td>表示 Pod 已被调度到某个 Node（工作节点）上。如果为 <code>False</code>，可能是集群资源不足或调度约束冲突。</td></tr><tr><td><code>Initialized</code></td><td>当所有 Init 容器（如果有）成功执行完成后</td><td><code>True</code></td><td>仅对包含 Init 容器的 Pod 有意义。若 Init 容器失败，此条件会显示 <code>False</code> 并记录原因。</td></tr><tr><td><code>ContainersReady</code></td><td>当 Pod 内所有主容器（非 Init 容器）的状态均为 <code>Running</code> 时</td><td><code>True</code></td><td>仅表示容器已启动，但不保证容器内应用已就绪（需结合 Readiness Probe（就绪探针）判断）。</td></tr><tr><td><code>Ready</code></td><td>当 Pod 满足以下条件时：<br>1. 所有主容器 <code>Running</code>；<br>2. 通过 Readiness Probe（就绪探针）检测（如果配置了）。</td><td><code>True</code></td><td>表示 Pod 可正常接收流量。若为 <code>False</code>，该 Pod 会被从 Service 的 Endpoints 中移除。</td></tr></tbody></table><p>Pod 状态条件的附加说明</p><ul><li>(1) 状态值：<ul><li>每个 Condition 的状态可能是 <code>True</code>、<code>False</code> 或 <code>Unknown</code>。</li></ul></li><li>(2) 依赖关系：  <ul><li><code>PodScheduled</code> → <code>Initialized</code> → <code>ContainersReady</code> → <code>Ready</code>（存在先后顺序）。  </li></ul></li><li>(3) 常见问题：  <ul><li>若 <code>PodScheduled=False</code>，需检查节点资源或亲和性规则。  </li><li>若 <code>Initialized=False</code>，需排查 Init 容器的日志。  </li><li>若 <code>Ready=False</code> 但 <code>ContainersReady=True</code>，通常是 Readiness Probe（就绪探针）配置问题。  </li></ul></li><li>(4) 查看命令：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以结构化格式提取 Pod 状态条件（Conditions）的详细信息</span></span><br><span class="line">kubectl get pod &lt;pod-name&gt;<span class="params"> -o</span> jsonpath=<span class="string">'{.status.conditions}'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用 describe 查看 Pod 的详细状态</span></span><br><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="Pod-的重启策略"><a href="#Pod-的重启策略" class="headerlink" title="Pod 的重启策略"></a>Pod 的重启策略</h5><p>Pod 的重启策略包括 Always、OnFailure 和 Never，默认值是 Always。</p><table><thead><tr><th>重启策略</th><th>说明</th></tr></thead><tbody><tr><td> Always</td><td> 默认值，当容器退出时，总是由 kubelet 自动重启该容器（适用于长期运行的 Pod，如 Web 服务）。</td></tr><tr><td>OnFailure</td><td> 仅在容器异常退出（非 0 状态码）时，由 kubelet 自动重启该容器（适合批处理任务）。</td></tr><tr><td>Never</td><td> 无论容器如何退出，kubelet 都不会重启该容器（适合一次性任务）。</td></tr></tbody></table><p>Pode 重启策略的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mynginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span>  <span class="comment"># Pod 的重启策略</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-的状态转换"><a href="#Pod-的状态转换" class="headerlink" title="Pod 的状态转换"></a>Pod 的状态转换</h5><p>Pod 生命周期状态的转换表（基于容器事件和重启策略）如下：</p><table><thead><tr><th>Pod 包含的容器数</th><th> Pod 当前的运行状态</th><th>发生的事件</th><th> Pod 的结果状态（RestartPolicy = Always）</th><th>Pod 的结果状态（RestartPolicy = OnFailure）</th><th>Pod 的结果状态（RestartPolicy = Never）</th></tr></thead><tbody><tr><td>1 个容器</td><td> Running</td><td> 容器成功退出</td><td> Running</td><td>Succeeded</td><td>Succeeded</td></tr><tr><td>1 个容器</td><td> Running</td><td> 容器失败退出</td><td> Running</td><td>Running</td><td>Failed</td></tr><tr><td>2 个容器</td><td> Running</td><td> 其中 1 个容器失败退出</td><td> Running</td><td>Running</td><td>Running</td></tr><tr><td>2 个容器</td><td> Running</td><td>2 个容器被 OOM 终止</td><td> Running</td><td>Running</td><td>Failed</td></tr></tbody></table><ul><li> 关键说明：<ul><li><strong>OOM</strong>：表示容器因内存不足（Out Of Memory）被系统终止</li><li>状态转换规则：<ul><li><code>Always</code>：任何容器终止都会触发重启（保持 Running 状态）</li><li><code>OnFailure</code>：仅当容器异常退出（非 0 状态码 / OOM）时重启</li><li><code>Never</code>：容器终止后直接反映最终状态（Succeeded/Failed）</li></ul></li><li>多容器 Pod 的状态由所有容器的综合状态决定</li></ul></li></ul><h5 id="Pod-的健康检查"><a href="#Pod-的健康检查" class="headerlink" title="Pod 的健康检查"></a>Pod 的健康检查</h5><p>Kubernetes 提供以下三种探针（Probe）来监控容器的运行状态：</p><ul><li><p>存活探针（<code>livenessProbe</code>）</p><ul><li>作用：检测容器是否正常运行。如果检测不通过，Kubernetes 会杀死容器并根据 <code>restartPolicy（重启策略）</code> 重启容器。</li><li>适用场景：用于修复死锁、无响应的应用（如数据库卡死）。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">exec:</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"cat"</span>, <span class="string">"/tmp/healthy"</span>]  <span class="comment"># 执行命令检查文件是否存在</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">5</span>              <span class="comment"># 容器启动后等待5秒开始检查</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span>                    <span class="comment"># 每5秒检查一次</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">3</span>                 <span class="comment"># 连续失败3次后判定为不健康</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>就绪探针（<code>readinessProbe</code>）</p><ul><li>作用：检测容器是否准备好接收流量。如果检测不通过，Kubernetes 会将 Pod 从 Service 的 Endpoints 中剔除，并且 Pod 会被标记为 <code>NotReady</code>，但不会被重启。</li><li>适用场景：用于控制流量进入（如应用启动时需要加载大量数据，导致容器启动后无法立刻对外提供服务</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/healthz</span>                    <span class="comment"># 发送 HTTP 请求进行检测</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">10</span>             <span class="comment"># 容器启动后等待10秒开始检查</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">3</span>                    <span class="comment"># 每3秒检查一次</span></span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">1</span>                 <span class="comment"># 成功1次即标记为就绪</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>启动探针（<code>startupProbe</code>）</p><ul><li>作用：从 Kubernetes <code>1.16+</code> 版本开始引入，专门检测慢启动应用是否完成初始化。在启动探针成功之前，其他探针不会生效。可以避免因应用启动过慢，导致被存活 / 就绪探针误杀。</li><li>适用场景：启动时间较长的应用（如 Java/SpringBoot 应用、需要加载大数据量的服务）。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">startupProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health</span>             <span class="comment"># Spring Boot 健康检查端点</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">30</span>                 <span class="comment"># 允许的最大失败次数</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">10</span>                    <span class="comment"># 每10秒检查一次</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><hr><p>探针（Probe）支持以下三种检测方法（三种类型的探针都支持）：</p><table><thead><tr><th>检测方法</th><th>说明</th><th>配置示例</th></tr></thead><tbody><tr><td><code>exec</code></td><td>- 在容器内执行命令，返回状态码为 <code>0</code> 表示检测成功。<br> - 适用于复杂检测逻辑或没有 HTTP 接口的服务。</td><td><code>command: ["cat", "/tmp/healthy"]</code></td></tr><tr><td><code>httpGet</code></td><td>- 通过发送 HTTP 请求检查服务是否正常。<br> - 返回状态码 <code>200 ~ 399</code> 表示检测成功。</td><td><code>httpGet: { path: /health, port: 80 }</code></td></tr><tr><td><code>tcpSocket</code></td><td>- 通过容器 IP + 端口建立 TCP 连接，<br> - 连接成功，即表示容器健康。</td><td><code>tcpSocket: { port: 3306 }</code></td></tr></tbody></table><p>探针（Probe）的三种探测结果状态：</p><table><thead><tr><th>探测结果状态</th><th>说明</th></tr></thead><tbody><tr><td><code>Success</code></td><td>容器通过检查，状态正常。</td></tr><tr><td><code>Failure</code></td><td>容器未通过检查，状态异常。</td></tr><tr><td><code>Unknown</code></td><td>无法执行检查，因此不采取任何措施。</td></tr></tbody></table><p>探针（Probe）的关键参数：</p><table><thead><tr><th>参数</th><th>作用</th><th>默认值</th><th>最小值</th><th>适用探针类型</th></tr></thead><tbody><tr><td><code>initialDelaySeconds</code></td><td>容器启动后，等待多少秒才开始第一次执行探测，避免容器未完成启动就被误判为失败。</td><td>0 秒</td><td> 0 秒</td><td> liveness、readiness、startup</td></tr><tr><td><code>periodSeconds</code></td><td>探测的执行频率，即两次探测之间的间隔时间。</td><td>10 秒</td><td> 1 秒</td><td> liveness、readiness</td></tr><tr><td><code>timeoutSeconds</code></td><td>单次探测的超时时间，超过该时间未响应则判定为探测失败。</td><td>1 秒</td><td> 1 秒</td><td> liveness、readiness</td></tr><tr><td><code>failureThreshold</code></td><td>探测成功后，连续失败多少次才会被认定为容器不健康。</td><td>3</td><td>1</td><td>liveness、readiness、startup</td></tr><tr><td><code>successThreshold</code></td><td>对于已标记为不健康的容器，需要连续成功多少次才会重新标记为健康。对于 Liveness Probe，该值必须为 <code>1</code>。</td><td>1</td><td>1</td><td>liveness、readiness</td></tr></tbody></table><p>基于存活探针检测容器的健康状态</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-exec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">touch</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">30</span><span class="string">;</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/healthy</span></span><br><span class="line">    <span class="comment"># 存活检查</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><p>启动探针、存活探针和就绪探针三者可以配合使用：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">springboot-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-springboot-app:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="comment"># 启动探针（给予充足启动时间）</span></span><br><span class="line">    <span class="attr">startupProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="comment"># 存活检查（启动探针成功后生效）</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment"># 就绪检查（启动探针成功后生效）</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health/readiness</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-的资源限制"><a href="#Pod-的资源限制" class="headerlink" title="Pod 的资源限制"></a>Pod 的资源限制</h5><p>每个 Pod 都可以对其可使用的 Node（工作节点）计算资源设置限额。Kubernetes 支持对以下两种计算资源进行配额限制：</p><ul><li><p>资源类型  </p><ul><li>CPU 资源：以绝对值的 CPU 数量为单位（比如 <code>500m</code> 表示 0.5 个 CPU 核心）。</li><li>Memory 资源：内存大小以字节数为单位（比如 <code>512Mi</code> 表示 512 MiB 内存）。</li></ul></li><li><p>配额参数  </p><ul><li>每种资源需要定义两个关键参数：  </li><li>Requests<ul><li> 表示该资源的最小申请量。</li><li>Kubernetes 调度器会确保 Node（工作节点）剩余资源大于等于 Requests 值，否则 Pod 无法被调度。</li></ul></li><li>Limits<ul><li> 表示该资源的最大允许使用量。若容器尝试使用超过 Limits 的资源：<ul><li>对于 CPU 资源，容器会被限制（Throttled）。</li><li>对于 Memory 资源，容器可能被 Kubernetes 终止（OOM Kill）并重启。</li></ul></li></ul></li></ul></li></ul><p>Pod 资源限制的配置示例如下，表示 MySQL 容器申请最少 <code>0.25</code> 个 CPU 以及 <code>64MiB</code> 内存，在运行过程中容器所能使用的最大资源配额为 <code>0.5</code> 个 CPU 以及 <code>128MiB</code> 内存。</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"128Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"500m"</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">CPU 资源限制的单位</p><ul><li>(1) 在 Kubernetes 的资源限制配置中，<code>cpu: "500m"</code> 表示 500 毫核（millicores）。</li><li>(2) <code>1m = 0.001 个 CPU 核心</code>，而 <code>500m</code> 等价于 <code>0.5</code> 个 CPU 核心（即 50% 的单核算力）。</li><li>(3) Kubernetes 常见的 CPU 单位如下表所示：</li></ul></div><table><thead><tr><th>CPU 单位</th><th>含义</th><th>配置示例</th></tr></thead><tbody><tr><td><code>1</code></td><td>1 个完整的 CPU 核心</td><td><code>cpu: "1"</code></td></tr><tr><td><code>1000m</code></td><td>1 个完整的 CPU 核心</td><td><code>cpu: "1000m"</code></td></tr><tr><td><code>500m</code></td><td>0.5 核（即 50% 的单核算力）</td><td><code>cpu: "500m"</code></td></tr><tr><td><code>250m</code></td><td>0.25 核（即 25% 的单核算力）</td><td><code>cpu: "250m"</code></td></tr></tbody></table><h5 id="Pod-的镜像拉取策略"><a href="#Pod-的镜像拉取策略" class="headerlink" title="Pod 的镜像拉取策略"></a>Pod 的镜像拉取策略</h5><p>Pod 有以下几种镜像拉取策略：</p><table><thead><tr><th>策略名称</th><th>描述</th></tr></thead><tbody><tr><td><code>IfNotPresent</code></td><td>默认值，只有当镜像在宿主机上不存在时才会拉取</td></tr><tr><td><code>Always</code></td><td>每次创建 Pod 时都会重新拉取一次镜像（即使宿主机上已存在）</td></tr><tr><td><code>Never</code></td><td>Pod 永远不会主动拉取镜像，仅使用宿主机上已有的镜像（若宿主机上不存在，则报错）</td></tr></tbody></table><p>Pode 镜像拉取策略的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mynginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>   <span class="comment"># Pod 的镜像拉取策略</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Pod-的调度策略"><a href="#Pod-的调度策略" class="headerlink" title="Pod 的调度策略"></a>Pod 的调度策略</h4><h5 id="Pod-的创建流程"><a href="#Pod-的创建流程" class="headerlink" title="Pod 的创建流程"></a>Pod 的创建流程</h5><p><img data-src="../../../asset/2025/08/k8s-pod-create.png"></p><ul><li><p>(1) 用户提交 Pod 创建请求</p><ul><li>用户通过 <code>kubectl</code> 命令行工具或其他客户端工具提交 Pod 创建请求</li><li>请求会发送到 Master 节点的 API Server</li></ul></li><li><p>(2) API Server 处理</p><ul><li>API Server 接收并验证请求</li><li>将 Pod 配置信息写入 Etcd 进行持久化存储</li></ul></li><li><p> (3) Scheduler 调度</p><ul><li>Scheduler 组件监控 API Server，发现有未调度的新 Pod</li><li>Scheduler 通过调度算法（考虑资源需求、节点亲和性等）选择最适合的 Node（工作节点）</li><li>Scheduler 将调度决策（绑定信息）通过 API Server 更新到 Etcd</li></ul></li><li><p>(4) Node（工作节点）执行</p><ul><li>目标 Node（工作节点）上的 kubelet 组件会定期查询 API Server</li><li>kubelet 发现分配给本节点的 Pod 信息（从 Etcd 读取）</li><li>kubelet 根据 Pod 描述文件:<ul><li> 通过容器运行时（如 Docker、Containerd）创建容器</li><li>配置容器网络、存储等资源</li><li>启动容器</li></ul></li></ul></li><li><p> (5) Pod 状态更新</p><ul><li>kubelet 监控容器状态，并将容器最新状态报告给 API Server</li><li>API Server 将 Pod 状态信息写入 Etcd</li><li> 用户可以通过 <code>kubectl</code> 命令行工具查看 Pod 的运行状态</li></ul></li></ul><h5 id="影响-Pod-调度的因素"><a href="#影响-Pod-调度的因素" class="headerlink" title="影响 Pod 调度的因素"></a>影响 Pod 调度的因素</h5><p>在 Kubernetes 中，影响 Pod 调度的主要因素有以下几种。</p><h6 id="Pod-资源限制"><a href="#Pod-资源限制" class="headerlink" title="Pod 资源限制"></a>Pod 资源限制</h6><ul><li><strong>Pod 资源限制（Resource Requests）</strong><ul><li>核心机制：<ul><li>Pod 通过 <code>resources.requests</code> 声明所需的最小资源量</li><li>调度器（Scheduler）根据这些请求寻找有足够资源的节点</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br></pre></td></tr></tbody></table></figure></li><li>调度行为：<ul><li>调度器会排除所有可用资源（Allocatable）小于请求值的节点</li><li>资源包括 CPU、内存、GPU 等</li><li>实际调度基于节点的剩余资源（Allocatable - Requested）</li></ul></li></ul></li></ul><h6 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器"></a>节点选择器</h6><ul><li><strong>节点选择器（Node Selector）</strong><ul><li>核心机制：<ul><li>通过 <code>nodeSelector</code> 字段指定 Pod 必须运行在具有特定标签的节点上</li><li>这是简单的节点选择约束方式</li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">env_role:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br></pre></td></tr></tbody></table></figure></li><li>节点的标签操作：<ul><li>给节点打上标签：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes &lt;node-name&gt; env_role=prod</span><br></pre></td></tr></tbody></table></figure></li><li>查看节点上的标签：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes<span class="params"> --show</span>-labels</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><h6 id="节点亲和性"><a href="#节点亲和性" class="headerlink" title="节点亲和性"></a>节点亲和性</h6><ul><li><strong>节点亲和性（Node Affinity）</strong><ul><li>概述：<ul><li>K8s 节点亲和性（Node Affinity）规则有两种：硬亲和性（<code>required</code>）、软亲和性（<code>preferred</code>）</li></ul></li><li>特性：<ul><li>比 <code>nodeSelector</code> 字段更灵活的规则</li><li>支持硬亲和性（约束条件必须满足）和软亲和性（尝试满足约束条件，但不保证满足）</li><li>支持常用操作：<code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>Gt</code>、<code>Lt</code>、<code>DoesNotExist</code></li></ul></li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="comment"># 硬亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">env_role</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">      <span class="comment"># 软亲和性</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">group</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">otherprod</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h6 id="污点和容忍"><a href="#污点和容忍" class="headerlink" title="污点和容忍"></a>污点和容忍</h6><blockquote><p>污点（Taints）</p></blockquote><ul><li>污点的概述：<ul><li>节点可以设置污点（Taints）来拒绝普通 Pod 的调度</li></ul></li><li>污点的定义：<ul><li>定义在节点（Node）上的键值型属性数据</li><li>即 <code>nodes.spec.taints</code>，语法是 <code>key=value:effect</code></li></ul></li><li>污点的类型：<ul><li><code>NoSchedule</code>  <ul><li>作用：<ul><li>默认值，新 Pod 无法调度到该节点（除非明确容忍此污点）</li><li>已运行的 Pod 若不容忍此污点，不会被驱逐（Evict）</li></ul></li><li>场景：保留节点给特定用途（如 GPU 节点、生产环境专用节点）</li></ul></li><li><code>PreferNoSchedule</code>  <ul><li>作用：<ul><li>调度器尽量避免将 Pod 分配到该节点，但若无其他可用节点仍会调度，不驱逐已运行的 Pod</li><li> 已运行的 Pod 若不容忍此污点，不会被驱逐（Evict）</li></ul></li><li>场景：软性隔离（如临时维护节点，但不强制拒绝调度）</li></ul></li><li><code>NoExecute</code>  <ul><li>作用：  <ul><li>新 Pod 无法调度到该节点（同 <code>NoSchedule</code>）</li><li>已运行的 Pod 若不容忍此污点，会被驱逐（Evict）</li></ul></li><li>场景：节点故障维护或紧急隔离（如节点磁盘故障需立即迁移所有 Pod）</li></ul></li></ul></li><li>污点的适用场景：<ul><li>专用节点隔离：保留节点给特定 Pod（如 GPU 节点只运行 AI 任务）</li><li>节点维护：标记节点为不可调度（如 <code>NoSchedule</code>），避免新 Pod 被分配到正在维护的节点</li><li>特殊硬件限制：防止普通 Pod 调度到带特殊硬件（如 FPGA）的节点</li></ul></li><li>节点的污点操作示例：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给节点打污点</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;=&lt;value&gt;:NoSchedule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点的污点</span></span><br><span class="line">kubectl describe node &lt;node-name&gt; | grep Taint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的单个污点（末尾的 "-" 符号表示删除）</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;:NoSchedule-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的指定键的所有污点（末尾的 "-" 符号表示删除）</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的所有污点</span></span><br><span class="line">kubectl patch nodes &lt;node-name&gt;<span class="params"> -p</span> <span class="string">'{"spec":{"taints":[]}}'</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>容忍（Tolerations）</p></blockquote><ul><li>容忍的概述：<ul><li>节点设置污点后，Pod 必须声明相应容忍（Tolerations）才能被调度</li></ul></li><li>容忍的定义：<ul><li>定义在 Pod 上的键值型属性数据</li><li>即 <code>pods.spec.tolerations</code>，语法是 <code>key=value:effect</code></li></ul></li><li>容忍的类型<ul><li><code>NoSchedule</code>  <ul><li>作用：允许 Pod 调度到带有 <code>NoSchedule</code> 污点的节点 </li><li>场景：让关键 Pod（如存储服务）无视节点的硬性隔离规则</li></ul></li><li><code>PreferNoSchedule</code>  <ul><li>作用：允许 Pod 调度到带有 <code>PreferNoSchedule</code> 污点的节点（但调度器仍可能优先选择其他节点）</li><li>场景：非关键 Pod 在资源不足时仍可使用软隔离节点</li></ul></li><li><code>NoExecute</code>  <ul><li>作用：<ul><li>允许 Pod 调度到带有 <code>NoExecute</code> 污点的节点</li><li>豁免驱逐：即使节点新增 <code>NoExecute</code> 污点，Pod 也不会被驱逐</li></ul></li><li>场景：守护进程（如日志收集器）需长期运行，无视节点维护状态</li></ul></li><li><code>空值</code>（不指定 <code>effect</code> 字段）<ul><li>作用：容忍所有污点类型（包括未来可能新增的类型）</li><li>场景：超级特权 Pod（如集群管理组件）需在任何节点运行</li></ul></li></ul></li><li>容忍的适用场景：<ul><li>特权 Pod 调度：允许关键 Pod（如日志收集组件）无视污点，调度到任意节点</li><li>故障恢复：容忍 <code>NoExecute</code> 污点，使 Pod 在节点故障时不被驱逐（如数据库 Pod）</li><li>共享特殊节点：让普通 Pod 通过容忍临时使用专用节点（如容忍 GPU 节点污点）</li></ul></li><li>Pod 的容忍配置示例：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="comment"># 仅容忍 NoSchedule 污点</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"dedicated"</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">"gpu"</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 容忍 NoExecute 污点（并豁免驱逐）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"node.kubernetes.io/unreachable"</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">"NoExecute"</span></span><br><span class="line">    <span class="attr">tolerationSeconds:</span> <span class="number">600</span>  <span class="comment"># 延迟 600 秒后驱逐（可选）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 容忍所有污点（危险！慎用！）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br></pre></td></tr></tbody></table></figure><h6 id="Pod-亲和性和反亲和性"><a href="#Pod-亲和性和反亲和性" class="headerlink" title="Pod 亲和性和反亲和性"></a>Pod 亲和性和反亲和性</h6><ul><li><strong>Pod 亲和性</strong><ul><li>控制 Pod 倾向于与指定 Pod 调度到同一拓扑域（共存关系）。</li><li>适用于需要紧密协作或低延迟通信的场景，以降低网络延迟、提升性能。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="comment"># Pod 亲和性</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">"cache"</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">"kubernetes.io/hostname"</span></span><br></pre></td></tr></tbody></table></figure></li><li>配置说明：<ul><li>Kubernetes 调度器会强制保证，Pod 调度到与匹配 <code>labelSelector</code> 条件的 Pod 所在的同一 <code>zone</code> 中。</li><li>如果集群中所有 <code>zone</code> 都没有匹配的 Pod，则新 Pod 会一直处于 <code>Pending</code> 状态。</li></ul></li></ul></li><li><strong>Pod 反亲和性</strong><ul><li>控制 Pod 不与指定 Pod 调度到同一拓扑域（互斥关系）。</li><li>适用于高可用场景，比如：将 Pod 副本分布到不同机架（Rack）或可用区（Zone） 中，避免单点故障。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="comment"># Pod 反亲和性</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">cache</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">zone</span></span><br></pre></td></tr></tbody></table></figure></li><li>配置说明：<ul><li>Kubernetes 调度器会强制保证，同一 <code>zone</code> 下，不会与匹配 <code>labelSelector</code> 条件的 Pod 同时调度运行。</li><li>如果所有 <code>zone</code> 都有匹配的 Pod，则新 Pod 会一直处于 <code>Pending</code> 状态。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>Pod 亲和性和反亲和性的更详细介绍，可以看<a href="/posts/76121b26.html#Pod-%E4%BA%B2%E5%92%8C%E6%80%A7%E8%B0%83%E5%BA%A6">这里</a>。</p></div><h6 id="Pod-优先级与抢占式调度"><a href="#Pod-优先级与抢占式调度" class="headerlink" title="Pod 优先级与抢占式调度"></a>Pod 优先级与抢占式调度</h6><p>在 Pod 上定义容忍（Tolerations）时，Pod 的优先级与抢占式调度机制如下：</p><ul><li><p>优先级（Pod Priority）</p><ul><li>表示 Pod 对象的重要程度。</li><li>作用：<ul><li>影响调度顺序：高优先级 Pod 会优先被调度。</li><li>影响驱逐次序：节点资源不足时，低优先级 Pod 会先被驱逐。</li></ul></li></ul></li><li><p>抢占机制（Preemption）</p><ul><li>当一个 Pod 无法被调度时，调度器会尝试驱逐节点上优先级更低的 Pod，为当前高优先级 Pod 腾出资源。</li><li>适合关键业务 Pod 需要资源保障的场景。</li></ul></li><li><p>默认状态</p><ul><li>Pod 优先级与抢占式调度机制默认处于禁用状态，需要手动开启。</li></ul></li><li><p>启用方法</p><ul><li>在以下组件的启动参数中增加 <code>--feature-gates=PodPriority=true</code>：<ul><li><code>kube-apiserver</code></li><li><code>kube-scheduler</code></li><li><code>kubelet</code></li></ul></li></ul></li><li><p>使用步骤</p><ul><li><p>(1) 创建优先级类别（<code>PriorityClass</code>）</p><ul><li>定义不同的优先级，如关键业务、高优先级、低优先级等。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">scheduling.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">high-priority</span>                               <span class="comment"># 优先级类别名称</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">1000</span>                                         <span class="comment"># 优先级值，数值越大优先级越高</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span>                                <span class="comment"># 是否为默认优先级类别</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"用于关键业务 Pod，例如存储、网络组件"</span>      <span class="comment"># 优先级的描述信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">scheduling.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">low-priority</span>                                <span class="comment"># 优先级类别名称</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">100</span>                                          <span class="comment"># 优先级值，数值越大优先级越高</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span>                                <span class="comment"># 是否为默认优先级类别</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"用于低优先级 Pod，例如测试或批处理任务"</span>     <span class="comment"># 优先级的描述信息</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>(2) 在 Pod 中指定优先级</p><ul><li>创建 Pod 时，通过 <code>priorityClassName</code> 属性绑定到对应的优先级类别。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">critical-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">priorityClassName:</span> <span class="string">high-priority</span>    <span class="comment"># Pod 绑定高优先级类别</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">critical-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">Pod 的优先级与抢占式调度总结</p><p>高优先级 Pod 无法被调度 → 调度器检查目标节点 → 驱逐低优先级 Pod → 为高优先级 Pod 腾出资源 → 高优先级 Pod 调度成功。</p></div><h5 id="Pod-的调度决策流程"><a href="#Pod-的调度决策流程" class="headerlink" title="Pod 的调度决策流程"></a>Pod 的调度决策流程</h5><ul><li>(1) 预选阶段：排除不满足条件的节点（资源不足、标签不匹配等）。</li><li>(2) 优选阶段：对剩余节点打分 (考虑资源平衡、亲和性等因素)。</li><li>(3) 绑定阶段：选择最高分节点，将绑定信息写入 API Server。</li><li>(4) 执行阶段：目标 Node（工作节点）的 Kubelet 拉起 Pod。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>Kubernetes 调度器的详细工作流程，可以看<a href="/posts/76121b26.html#K8s-%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">这里</a>。</p></div><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><h4 id="Label-的概念"><a href="#Label-的概念" class="headerlink" title="Label 的概念"></a>Label 的概念</h4><p>Label 是 Kubernetes 中的核心概念之一，用于为集群中的各种资源对象打上自定义的标记。</p><ul><li><p>Label 的核心概念：</p><ul><li>一个 Label 是一个 <code>key=value</code> 形式的键值对，其中 <code>key</code> 和 <code>value</code> 由用户自定义。</li><li>Label 可以附加到各种 Kubernetes 资源对象上，例如 Node、Pod、Service、Replication Controller（RC）等。</li><li>一个资源对象可以拥有任意数量的 Label，同一个 Label 也可以被应用到任意数量的资源对象上。</li><li>Label 通常在资源对象创建时通过 <code>metadata.labels</code> 字段定义，也可以在对象创建后动态添加或删除。</li></ul></li><li><p>Label 的核心作用</p><ul><li>Label 附加到 Kubernetes 资源对象上的主要目的是对这些对象进行分组管理。</li><li>Kubernetes 分组管理的核心机制是 Label Selector（标签选择器）：<ul><li>Label Selector 根据指定的匹配规则筛选出符合条件的资源对象，实现分组控制和管理。</li><li>Label 和 Label Selector 都不能单独存在，必须附加在某些资源对象的定义文件中，才能发挥作用。</li><li>在实际使用中，Label 通常附加在 Pod 上，而 Label Selector 则常用于 Replication Controller（RC）、Replica Set（RS） 或 Service 等资源定义文件中，通过匹配特定 Label 来选择和管理 Pod。</li></ul></li></ul></li><li><p>Label 的常见用途</p><ul><li>通过在对象的定义中添加 <code>metadata.labels</code>，为对象打上标签。</li><li>其他资源（如 Service、Deployment）可以通过 <code>spec.selector</code> 来选择和关联具有特定 Label 的对象，实现分组管理和调度。</li></ul></li><li><p>Label 的注意事项</p><ul><li>Label 和 Label Selector 都不能单独存在，必须附加在某些资源对象的定义文件中，常见组合是：<ul><li>Pod + Label</li><li>Replication Controller（RC） / Replica Set（RS） / Service + Label Selector</li></ul></li></ul></li></ul><h4 id="Label-的使用"><a href="#Label-的使用" class="headerlink" title="Label 的使用"></a>Label 的使用</h4><ul><li>配置示例 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Replication</span> <span class="string">Controller</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">3333</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></tbody></table></figure><ul><li>配置说明：<ul><li>Replication Controller（RC）：<ul><li>通过 <code>selector</code> 选择并管理所有带有 <code>app=nginx</code> 标签的 Pod。</li><li>确保 Pod 的副本数量维持在 3 个，由 RC 创建的 Pod 会包含 <code>app=nginx</code> 标签。</li></ul></li><li>Service：<ul><li>通过 <code>selector</code> 匹配同样带有 <code>app=nginx</code> 标签的 Pod，并将流量分发给这些 Pod。</li><li>通过 <code>nodePort: 3333</code> 在集群外部暴露服务。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">Node（工作节点）的标签操作</p><ul><li>给 Node（工作节点）打上标签：<code>kubectl label nodes &lt;node-name&gt; env_role=prod</code></li><li>查看 Node（工作节点）上的标签：<code>kubectl get nodes --show-labels</code></li></ul></div>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Youtube 视频下载工具使用</title>
    <link href="https://www.techgrow.cn/posts/3f99e39.html"/>
    <id>https://www.techgrow.cn/posts/3f99e39.html</id>
    <published>2025-08-09T13:16:21.000Z</published>
    <updated>2025-08-09T13:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/yt-dlp/yt-dlp">yt-dlp</a> 是一个功能丰富的命令行音频 / 视频下载器，支持<a href="https://github.com/yt-dlp/yt-dlp/blob/master/supportedsites.md">数千个站点</a>，支持断点续传和网络代理等功能。</p><span id="more"></span><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li><a href="https://github.com/yt-dlp/yt-dlp">yt-dlp</a></li><li><a href="https://github.com/ytdl-org/youtube-dl">youtube-dl</a></li></ul><h2 id="yt-dlp-安装步骤"><a href="#yt-dlp-安装步骤" class="headerlink" title="yt-dlp 安装步骤"></a>yt-dlp 安装步骤</h2><ul><li>Pip 安装（依赖 Python）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Linux</span> / Mac</span><br><span class="line">pip install<span class="params"> -U</span> yt-dlp</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 安装（二进制方式）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Linux</span> (可直接下载可执行文件)</span><br><span class="line"><span class="keyword"># https</span>://github.com/yt-dlp/yt-dlp/releases</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">wget<span class="params"> -O</span> yt-dlp https://github.com/yt-dlp/yt-dlp/releases/download/2025.07.21/yt-dlp_linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line">sudo mv yt-dlp /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件授权</span></span><br><span class="line">sudo chmod +x /usr/bin/yt-dlp</span><br></pre></td></tr></tbody></table></figure><ul><li>Windows 安装（二进制方式）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Windows</span> (可直接下载 Exe 可执行文件)</span><br><span class="line"><span class="keyword"># https</span>://github.com/yt-dlp/yt-dlp/releases</span><br></pre></td></tr></tbody></table></figure><h2 id="yt-dlp-使用方法"><a href="#yt-dlp-使用方法" class="headerlink" title="yt-dlp 使用方法"></a>yt-dlp 使用方法</h2><h3 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h3><ul><li>下载命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span> <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理 + 多线程加速）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> -N</span> 4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理 + 多线程加速 + 安全文件名）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> --restrict</span>-filenames<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> -N</span> 4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>参数说明</li></ul><table><thead><tr><th>参数</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td><code>-N</code></td><td>指定线程数量</td><td>使用多个线程进行下载，可以加快下载速度</td></tr><tr><td><code>-c</code></td><td>支持断点续传</td><td>从已下载部分直接接着下载，不会重头开始下载</td></tr><tr><td><code>--restrict-filenames</code></td><td>使用安全文件名</td><td>文件名最终会变成类似 <code>2_HOUR_STUDY_WITH_ME.mp4</code></td></tr><tr><td><code>--proxy "http://127.0.0.1:7890"</code></td><td>指定代理</td><td>支持 <code>http://</code>、<code>https://</code>、<code>socks5://</code> 等代理格式</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>YouTube 视频通常分成音频 + 视频两个流下载，<code>yt-dlp</code> 会自动合并处理。</li><li>如果是长视频，建议 <code>yt-dlp</code> 配合 <code>-c</code> 断点续传和 <code>-N</code> 多线程加速，这样即使下载中途断了，也能很快恢复。</li><li><code>-N</code> 参数对大部分 HTTP 分片流（DASH、HLS）有效，对单个 MP4 文件直链无效。有些代理或网络环境下，如果线程数太高，可能触发 YouTube 限制。</li></ul></div><h3 id="查看视频格式"><a href="#查看视频格式" class="headerlink" title="查看视频格式"></a>查看视频格式</h3><ul><li>查看视频支持的格式 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -F</span><span class="params"> --cookies</span>-from-browser chrome<span class="params">  -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:6860"</span> <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>查看视频支持的格式（指定代理和 Cookie）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -F</span><span class="params"> --cookies</span>-from-browser chrome<span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:6860"</span> <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="yt-dlp-使用问题"><a href="#yt-dlp-使用问题" class="headerlink" title="yt-dlp 使用问题"></a>yt-dlp 使用问题</h2><h3 id="缺少-Cookie-信息"><a href="#缺少-Cookie-信息" class="headerlink" title="缺少 Cookie 信息"></a>缺少 Cookie 信息</h3><blockquote><p>问题描述：下载 YouTube 视频时，触发了人机验证 / 登录验证（如下所示），<code>yt-dlp</code> 没法直接绕过，所以它提示要用浏览器 Cookie 来模拟已登录的状态。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: [youtube] 5Q2Pc-e-8Qc: Sign in to confirm you’re not a bot. Use --cookies-from-browser or --cookies for the authentication. See  https://github.com/yt-dlp/yt-dlp/wiki/FAQ#how-do-i-pass-cookies-to-yt-dlp  for how to manually pass cookies. Also see  https://github.com/yt-dlp/yt-dlp/wiki/Extractors#exporting-youtube-cookies  for tips on effectively exporting YouTube cookies</span><br></pre></td></tr></tbody></table></figure><blockquote><p>解决方法一：使用浏览器插件</p></blockquote><ul><li><p>(1) 安装浏览器插件</p><ul><li>推荐用 <code>Get cookies.txt</code>（Chrome）或 Firefox 的同类扩展插件。</li></ul></li><li><p>(2) 导出 Cookie 文件</p><ul><li>浏览器打开 <code>https://www.youtube.com</code></li><li>确保已经登录 Youtube</li><li> 点击扩展插件 → 导出 Cookies → 保存成 <code>cookies.txt</code> 文件</li></ul></li><li><p> (3) 让 <code>yt-dlp</code> 用 Cookie 文件下载</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> --cookies</span> cookies.txt <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>解决方法二：从浏览器自动读取 Cookie</p></blockquote><ul><li><p>(1) <code>yt-dlp</code> 支持直接读取浏览器的 Cookie（需要本地环境支持）</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> --cookies</span>-from-browser chrome<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span> <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>(2) 参数说明</p><ul><li><code>--cookies-from-browser chrome</code> 表示从 Chrome 读取 Cookie，也支持用 <code>firefox</code>、<code>edge</code> 等。</li><li>要求本地浏览器已经登录了 YouTube，并且浏览器没有关掉 Cookie 保存功能。</li></ul></li></ul><h3 id="音频和视频合并失败"><a href="#音频和视频合并失败" class="headerlink" title="音频和视频合并失败"></a>音频和视频合并失败</h3><p>YouTube 视频通常分成音频 + 视频两个流下载，<code>yt-dlp</code> 会在两者下载完成后自动合并处理。但是，如果 <code>.webm</code> 音频是 Opus 编码，直接合并进 <code>.mp4</code> 会报错，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading webpage</span><br><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading tv client config</span><br><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading tv player API JSON</span><br><span class="line">[info] 5Q2Pc-e-8Qc: Downloading 1 format(s): 401+251</span><br><span class="line">[download] 2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].f401.mp4 has already been downloaded</span><br><span class="line">[download] 100% of    3.27GiB</span><br><span class="line">[download] 2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].f251.webm has already been downloaded</span><br><span class="line">[download] 100% of  111.71MiB</span><br><span class="line">[Merger] Merging formats into "2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].webm"</span><br><span class="line">ERROR: Postprocessing: Conversion failed!  </span><br></pre></td></tr></tbody></table></figure><p>这种情况需要使用 Ffmpeg 先将音频转成 AAC 编码，然后再进行合并（前提是 <code>yt-dlp</code> 已经将 <code>.webm</code> 和 <code>.mp4</code> 文件都完整地下载到本地）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg<span class="params"> -i</span> video.mp4<span class="params"> -i</span> audio.webm<span class="params"> -c</span>:v copy<span class="params"> -c</span>:a aac<span class="params"> -b</span>:a 192k output.mp4</span><br></pre></td></tr></tbody></table></figure><h3 id="下载时合并音频和视频"><a href="#下载时合并音频和视频" class="headerlink" title="下载时合并音频和视频"></a>下载时合并音频和视频</h3><p>YouTube 视频通常分成音频 + 视频两个流下载，若希望 <code>yt-dlp</code> 在下载两者的时候直接合并，可以参考以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> <span class="string">"bv*+ba"</span><span class="params"> --merge</span>-output-format mp4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数 <code>-f "bv*+ba"</code> 是 <code>yt-dlp</code> 里的格式选择表达式，意思是：</p><ul><li><code>bv*</code> = best video stream（最好画质的视频流），<code>*</code> 表示不限编码类型（AV1、VP9、H.264 都可以）</li><li><code>ba</code> = best audio stream（最好音质的音频流）</li><li><code>+</code> = 选择视频流和音频流，并在下载后合并成一个文件</li></ul><h3 id="下载时指定视频的分辨率"><a href="#下载时指定视频的分辨率" class="headerlink" title="下载时指定视频的分辨率"></a>下载时指定视频的分辨率</h3><ul><li>查看视频支持的格式 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -F</span><span class="params"> --cookies</span>-from-browser chrome<span class="params">  -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:6860"</span> <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[info] Available formats for DXT9dF-WK-I:</span><br><span class="line">ID      EXT   RESOLUTION FPS CH │   FILESIZE   TBR PROTO │ VCODEC          VBR ACODEC      ABR ASR MORE INFO</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">249-drc webm  audio only      2 │   89.74MiB   51k https │ audio only          opus        51k 48k low, DRC, webm_dash</span><br><span class="line">250-drc webm  audio only      2 │  119.84MiB   67k https │ audio only          opus        67k 48k low, DRC, webm_dash</span><br><span class="line">249     webm  audio only      2 │   88.83MiB   50k https │ audio only          opus        50k 48k low, webm_dash</span><br><span class="line">250     webm  audio only      2 │  118.56MiB   67k https │ audio only          opus        67k 48k low, webm_dash</span><br><span class="line">140-drc m4a   audio only      2 │  229.94MiB  129k https │ audio only          mp4a.40.2  129k 44k medium, DRC, m4a_dash</span><br><span class="line">251-drc webm  audio only      2 │  241.29MiB  136k https │ audio only          opus       136k 48k medium, DRC, webm_dash</span><br><span class="line">140     m4a   audio only      2 │  229.94MiB  129k https │ audio only          mp4a.40.2  129k 44k medium, m4a_dash</span><br><span class="line">251     webm  audio only      2 │  239.12MiB  135k https │ audio only          opus       135k 48k medium, webm_dash</span><br><span class="line">244     webm  854x480     24    │  568.95MiB  320k https │ vp9            320k video only          480p, webm_dash</span><br><span class="line">397     mp4   854x480     24    │  342.40MiB  193k https │ av01.0.04M.08  193k video only          480p, mp4_dash</span><br><span class="line">136     mp4   1280x720    24    │  385.71MiB  217k https │ avc1.4d401f    217k video only          720p, mp4_dash</span><br><span class="line">247     webm  1280x720    24    │    1.05GiB  603k https │ vp9            603k video only          720p, webm_dash</span><br><span class="line">398     mp4   1280x720    24    │  653.15MiB  368k https │ av01.0.05M.08  368k video only          720p, mp4_dash</span><br><span class="line">137     mp4   1920x1080   24    │    1.59GiB  915k https │ avc1.640028    915k video only          1080p, mp4_dash</span><br><span class="line">248     webm  1920x1080   24    │    1.62GiB  934k https │ vp9            934k video only          1080p, webm_dash</span><br><span class="line">399     mp4   1920x1080   24    │    1.21GiB  699k https │ av01.0.08M.08  699k video only          1080p, mp4_dash</span><br><span class="line">271     webm  2560x1440   24    │    4.40GiB 2540k https │ vp9           2540k video only          1440p, webm_dash</span><br><span class="line">400     mp4   2560x1440   24    │    3.72GiB 2146k https │ av01.0.12M.08 2146k video only          1440p, mp4_dash</span><br><span class="line">313     webm  3840x2160   24    │   14.92GiB 8602k https │ vp9           8602k video only          2160p, webm_dash</span><br><span class="line">401     mp4   3840x2160   24    │    8.33GiB 4805k https │ av01.0.12M.08 4805k video only          2160p, mp4_dash</span><br></pre></td></tr></tbody></table></figure><ul><li>下载视频时指定分辨率 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> 137+140 <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><code>137</code> 表示 1920x1080 视频（<code>avc1</code> 编码标记，即 H.264 视频编码）</li><li><code>140</code> 表示 MP4 音频（<code>m4a</code> 音频编码）</li></ul><h3 id="下载时指定视频编码为-H-264"><a href="#下载时指定视频编码为-H-264" class="headerlink" title="下载时指定视频编码为 H.264"></a>下载时指定视频编码为 H.264</h3><p>若希望指定 <code>yt-dlp</code> 下载视频的编码格式为 H.264（在 YouTube 格式代码中，H.264 编码视频通常带有 <code>avc1</code> 标签），可以参考以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> <span class="string">"bv[codec^=avc1]+ba"</span><span class="params"> --merge</span>-output-format mp4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><code>-f "bv[codec^=avc1]+ba"</code><ul><li><code>bv</code> = best video stream（最好画质的视频流）</li><li><code>[codec^=avc1]</code> = <code>codec</code> 字段以 <code>avc1</code> 开头（H.264 的编码标记）</li><li><code>ba</code> = best audio stream（最好音质的音频流）</li><li><code>+</code> = 选择视频流和音频流，并在下载后合并成一个文件</li></ul></li><li><code>--merge-output-format mp4</code><ul><li>限制输出容器是 MP4（和 H.264 配合更好）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Youtube 视频下载工具的使用。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Redis 哨兵机制详解</title>
    <link href="https://www.techgrow.cn/posts/660eca58.html"/>
    <id>https://www.techgrow.cn/posts/660eca58.html</id>
    <published>2025-07-27T13:15:32.000Z</published>
    <updated>2025-07-27T13:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="哨兵机制的概念"><a href="#哨兵机制的概念" class="headerlink" title="哨兵机制的概念"></a>哨兵机制的概念</h2><p>Redis 有三种模式：分别是主从复制、哨兵模式、集群模式，后两者可以保证高可用。</p><ul><li><strong>哨兵（Sentinel）机制是什么</strong><ul><li>哨兵机制主要用于 Redis 主从架构下的故障检测与自动主从切换。</li><li>哨兵一个专门用于高可用的 Redis 组件（节点），不是用于存储数据的。</li><li>哨兵不参与数据同步和读写，而是专门负责监控、故障切换和通知客户端谁是主节点。</li><li>哨兵进程通常和 Redis 节点分开部署（也可以部署在同一台机器上，但进程独立）。</li><li>通常运行多个哨兵实例（即哨兵集群），实现冗余和仲裁。每个哨兵都会连接至 Master 节点和所有 Slave 节点，监控它们的状态信息。</li></ul></li></ul><span id="more"></span><ul><li><p><strong>哨兵（Sentinel）节点的作用是什么</strong></p><ul><li>监控（Monitor）：持续检查主节点和从节点是否存活（通过 PING 等）。</li><li>通知（Notification）：检测到故障后通知系统管理员或其他服务。</li><li>自动故障转移（Failover）：如果主节点不可用，选举一个从节点提升为新主节点。</li><li>服务发现（Discovery）：提供主节点的地址信息给客户端（可供自动重连）；如果发生了故障转移，会通知客户端新的主节点地址。</li></ul></li><li><p><strong>哨兵（Sentinel）节点不是从节点（Slave）</strong></p><ul><li>哨兵节点不负责同步数据，也不参与数据读写。</li><li>它只是通过 Redis 协议连接 Redis 实例，执行命令如 INFO、PING 来感知状态。</li><li>哨兵节点不保存业务数据，最多保存一些监控状态（内存中）。</li></ul></li><li><p><strong>为什么需要哨兵（Sentinel）机制</strong></p><ul><li>Redis 的主从复制机制主要用于实现数据备份和读请求的负载分担，但它本身并不具备自动容错和主节点自动切换的能力。因此，单纯依赖主从复制并不能保证系统的高可用性。具体表现如下：<ul><li>需要人工介入：当主节点发生故障时，Redis 本身无法自动完成故障切换，需要运维人员手动将某个从节点提升为新的主节点，并重新配置其他从节点同步新的主节点。</li><li>单点故障风险：主节点作为写操作的唯一入口，一旦宕机，系统的写操作将完全中断，严重影响服务可用性。</li><li>主节点写入能力受限：Redis 是单线程模型，主节点的写入吞吐受限于单机性能，无法横向扩展。</li><li>单机节点存储容量有限：Redis 通常运行在内存中，主节点的物理内存限制了存储能力。</li></ul></li><li>Redis 哨兵机制应运而生，用于增强 Redis 在主从架构下的高可用性。它具备以下能力：<ul><li>哨兵节点自动监控 Redis 实例状态（包括主节点和从节点）。</li><li>主节点宕机时，自动完成主从切换（Failover）。</li><li>通知支持 Sentinel 机制的客户端连接新的主节点。</li><li>协助管理 Redis 主从结构并确保一致性。</li></ul></li><li>若需要进一步提高 Redis 的可用性与扩展性，还可以使用 Redis Cluster（集群），它支持数据分片（水平扩展），具备原生的多主多从架构、高可用、以及容错能力。</li></ul></li></ul><h2 id="哨兵机制的原理"><a href="#哨兵机制的原理" class="headerlink" title="哨兵机制的原理"></a>哨兵机制的原理</h2><p>Redis 哨兵机制是通过在独立的哨兵节点上运行特定的哨兵进程来实现的。这些哨兵进程监控主从节点的状态，并在出现故障时自动完成故障转移，并通知应用方，实现高可用性。</p><ul><li><p><strong>(1) 哨兵选举：</strong></p><ul><li>在启动时，每个哨兵节点都会参与选举，其中一个哨兵节点会被选为领导者（Leader），负责协调其他哨兵节点执行故障转移。选举过程如下：<ul><li>每个在线的哨兵节点都有资格成为领导者。当某个哨兵判断主节点不可用后，会向其他哨兵节点发送 <code>is-master-down-by-addr</code> 命令，请求判断主节点状态并征求选票，希望被选为本轮的领导者。</li><li>其他哨兵节点在收到该命令后，会根据自身判断和是否已经投票的情况，决定是否同意对方成为领导者（每个哨兵在同一轮选举中只能投票一次）。</li><li>如果某个哨兵节点获得的选票数达到或超过 <code>总哨兵节点数 / 2 + 1</code>（即超过半数），则该哨兵节点将成为本轮选举的领导者；如果未能获得足够票数，则会进入下一轮选举，直到选出领导者为止。</li></ul></li></ul></li><li><p><strong>(2) 哨兵监控主从节点:</strong></p><ul><li>哨兵节点通过发送命令周期性地检查主从节点的健康状态，包括主节点是否在线、从节点是否同步等。</li><li>如果哨兵节点发现主节点不可用，它会触发一次故障转移操作，而且是由哨兵领导者负责处理主节点的故障转移。</li></ul></li><li><p><strong>(3) 哨兵执行故障转移：</strong></p><ul><li>一旦主节点被判定为不可用，哨兵节点会执行故障转移操作。它会从当前的从节点中选出一个新的主节点，并将其他从节点切换到新的主节点。这样，缓存系统可以继续提供服务，而无需人工介入。</li><li>故障转移过程：<ul><li>由哨兵节点定期监控主节点是否出现故障，哨兵节点会定期向主节点发送心跳 PING 来确认主节点是否存活。</li><li>如果主节点在 “一定时间范围” 内不响应 PONG 或者是回复了一个错误消息，那么这个哨兵节点会主观地（单方面地）认为这个主节点已经不可用了。</li></ul></li><li>确认新主节点：<ul><li>过滤掉不健康的从节点（如已下线、网络断连、长时间未响应哨兵 PING 命令的节点）。</li><li>在剩余的健康从节点中，优先选择优先级（Priority）最高的节点。</li><li>如果有多个从节点优先级相同，则选择复制偏移量（Replication Offset）最大的节点，即数据最接近原主节点的从节点。</li><li>若优先级和复制偏移量都相等，则选择节点 ID 字典序最小的节点作为新主节点。</li></ul></li></ul></li><li><p><strong>(4) 客户端重定向：</strong></p><ul><li>当主节点出现故障时，哨兵节点会自动发起主从切换（故障转移），选举一个新的从节点作为新的主节点。</li><li>哨兵节点不会直接通知客户端新的主节点地址，而是提供一个服务发现机制。客户端需要通过支持哨兵机制的客户端，从哨兵节点动态获取当前的主节点地址。</li><li>这样一来，客户端可以在主节点切换后，通过哨兵节点重新获取主节点信息，从而无感知地完成主节点重连，保证业务连续性。</li><li>此外，哨兵节点还会持续监控所有主节点和所有从节点的运行状态，如果某个从节点出现故障，哨兵节点会将其标记为下线；一旦从节点恢复，哨兵节点会自动将其重新加入主从复制架构，并使其同步当前主节点的数据，以维持整个架构的完整性。</li></ul></li></ul><h2 id="哨兵的部署架构"><a href="#哨兵的部署架构" class="headerlink" title="哨兵的部署架构"></a>哨兵的部署架构</h2><p>Redis Sentinel（哨兵）本身是一个分布式系统，通常以哨兵集群的形式部署，多个哨兵节点之间可以协同工作，保障系统的高可用性（如下图所示）。</p><p><img data-src="../../../asset/2025/07/redis-sentinel-3.png"></p><ul><li><strong>哨兵（Sentinel）故障转移的核心概念</strong></li></ul><table><thead><tr><th>概念</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td><code>quorum</code>（法定票数）</td><td>Master 节点从主观下线（sdown）到客观下线（odown）所需的同意哨兵数（即最少 N 个哨兵同时判断 Master 为宕机）</td><td>确保哨兵对 Master 宕机的判断具有一定共识，避免误判</td></tr><tr><td><code>majority</code>（多数哨兵）</td><td>执行故障转移操作时，要求同意执行故障转移的哨兵数量必须达到总数的一半以上，否则不会执行故障转移</td><td>为了避免「脑裂」现象，即多个哨兵在不同网络分区中同时尝试进行故障转移，导致系统不一致或混乱</td></tr></tbody></table><ul><li><p><strong>哨兵（Sentinel）的部署架构是什么</strong></p><ul><li>Redis Sentinel（哨兵）本身是一个分布式系统，通常以哨兵集群的形式部署，多个哨兵节点之间可以协同工作，保障系统的高可用性。<ul><li>哨兵通常以集群的形式部署，这样是为了保证哨兵的高可用性<ul><li><strong>哨兵集群要求至少需要部署 3 个哨兵实例，否则可能无法保证故障转移的正常执行，同时也为了实现多数投票机制，并提高容错能力。</strong></li><li><strong>哨兵集群 + Redis 主从架构能够提供高可用性，但无法做到数据零丢失。故障转移过程中可能存在数据未完整同步到从节点的风险，因此仅适用于对可用性要求高、但允许少量数据丢失的场景。</strong></li><li>由于哨兵 + Redis 主从是一种相对复杂的部署架构，建议在测试环境和生产环境中都进行充分的测试与故障演练，确保系统在各种异常情况下都能稳定运行。</li></ul></li><li>在发生故障转移时，是否将一个主节点判定为宕机，必须经过多数哨兵节点（Quorum）的同意。这涉及到分布式选举机制，用于确保故障转移的判断和执行具备一致性和可靠性。</li><li>即使部分哨兵节点发生故障，哨兵集群仍然能够正常工作。这是因为哨兵本身作为高可用机制的一部分，必须具备容错能力，若其自身是单点的，那就违背了其设计初衷。</li><li>目前使用的是 Sentinel <code>2.x 版本</code>。与 Sentinel <code>1.x</code> 相比，Sentinel <code>2.x</code> 重写了大量核心代码，主要目的是简化故障转移流程、提升算法健壮性和系统稳定性，使其更适用于生产环境中的高可用场景。</li></ul></li></ul></li><li><p><strong>为什么 Redis 哨兵集群只有 2 个节点会无法正常工作</strong></p><ul><li>以部署了 2 个哨兵实例的场景为例（配置：<code>quorum = 1</code>）：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></tbody></table></figure></li><li>当主节点 M1 宕机时，只要 S1 和 S2 中任意一个哨兵认为 M1 宕机，就可以发起主观下线（Subjective Down，简称 sdown）判断。接着，两个哨兵会通过选举机制，选举出其中一个哨兵来执行故障转移操作。</li><li>但是，哨兵系统执行真正的故障转移时，还需要满足 <code>majority</code> 要求，也就是多数哨兵节点同意执行故障转移。例如：<ul><li>2 个哨兵时，要求 <code>majority = 2</code></li><li>3 个哨兵时，要求 <code>majority = 2</code></li><li>4 个哨兵时，要求 <code>majority = 3</code></li><li>5 个哨兵时，要求 <code>majority = 3</code></li></ul></li><li>因此在 2 个哨兵节点的场景中，只有当两个哨兵都正常运行时，才满足 <code>majority</code> 的要求，才允许执行故障转移操作。</li><li>如果运行主节点 M1 和哨兵 S1 的那台机器宕机了，意味着主节点 M1 和哨兵 S1 同时失效，只剩下从节点 R1 和哨兵 S2 仍在运行。此时虽然还有一个哨兵存在（S2），但由于无法满足 <code>majority</code> 要求，故障转移将不会被执行，导致缓存系统始终处于不可用状态。</li></ul></li><li><p><strong>Redis 经典的 3 节点哨兵集群架构</strong></p><ul><li>以部署了 3 个哨兵实例的场景为例（配置：<code>quorum = 2</code>）：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       +----+</span><br><span class="line">       | M1 |</span><br><span class="line">       | S1 |</span><br><span class="line">       +----+</span><br><span class="line">          |</span><br><span class="line">+----+    |    +----+</span><br><span class="line">| R2 |----+----| R3 |</span><br><span class="line">| S2 |         | S3 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></tbody></table></figure></li><li>如果主节点 M1 所在的机器宕机，意味着主节点 M1 和哨兵 S1 同时失效，剩下的两个哨兵 S2 和 S3 仍在运行。此时：<ul><li>哨兵 S2 和 S3 可以一致地判断主节点 M1 宕机了（满足 <code>quorum = 2</code>），从而形成客观下线（odown）判断；</li><li>接着，S2 和 S3 两个哨兵会通过选举机制，选举出其中一个哨兵负责执行故障转移操作；</li><li>因为 3 个哨兵的 <code>majority</code> 要求为 2，而当前恰好有 2 个哨兵仍然存活，所以满足故障转移所需的条件。</li></ul></li><li>因此，在这种经典的 3 节点哨兵集群架构下，即使一台机器宕机，只要剩余的 2 个哨兵还在正常运行，依然可以完成故障转移，从而保证整个哨兵集群的高可用性。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>无论 Redis 是一主一从、一主多从的复制架构，都可以使用 Redis 的哨兵机制，官方更推荐使用一主多从的复制架构，这样可用性更高。</li></ul></div><h2 id="哨兵机制的使用"><a href="#哨兵机制的使用" class="headerlink" title="哨兵机制的使用"></a>哨兵机制的使用</h2><p>在 SpringBoot 项目中，使用 Lettuce 客户端连接 Redis 的一主多从 + 哨兵模式时，只需要在 <code>application.yml</code> 正确配置哨兵信息，SpringBoot 就会自动识别并创建 Lettuce 连接。</p><ul><li>SpringBoot 配置文件示例（<code>application.yml</code>）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span>             <span class="comment"># 主节点名称，对应哨兵配置中的 sentinel monitor 的名称</span></span><br><span class="line">      <span class="attr">nodes:</span>                       <span class="comment"># 哨兵节点列表（ip:port）</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourRedisPassword</span>    <span class="comment"># Redis 认证密码（如果开启了）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><ul><li>若希望使用从节点读取数据（主节点默认可以读写，但从节点只读不可写），可以使用以下 SpringBoot 配置信息 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span>             <span class="comment"># 主节点名称，对应哨兵配置中的 sentinel monitor 的名称</span></span><br><span class="line">      <span class="attr">nodes:</span>                       <span class="comment"># 哨兵节点列表（ip:port）</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourRedisPassword</span>    <span class="comment"># Redis 认证密码（如果开启了）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">read-from:</span> <span class="string">REPLICA_PREFERRED</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>Lettuce 的配置值</th><th>含义</th></tr></thead><tbody><tr><td><code>MASTER</code></td><td>所有请求都从主节点读取（默认）</td></tr><tr><td><code>MASTER_PREFERRED</code></td><td>优先主节点，主节点不可用时才从从节点读取</td></tr><tr><td><code>REPLICA</code>（或 <code>SLAVE</code>）</td><td>所有请求都从从节点读取</td></tr><tr><td><code>REPLICA_PREFERRED</code></td><td>优先从从节点读取，从节点不可用时回退到主节点</td></tr><tr><td><code>NEAREST</code></td><td>从网络延迟最小的节点读取（需要集群拓扑支持）</td></tr></tbody></table><ul><li>Redis 哨兵配置文件示例（<code>redis-sentinel.conf</code>）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控名为 mymaster 的主节点，IP 是 192.168.1.100，端口 6379，</span></span><br><span class="line"><span class="comment"># 至少有 2 个哨兵同时判断该主节点不可达时，才会被判定为主观下线（sdown）</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span> <span class="number">6379 </span><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 5000 毫秒（5 秒）内没有收到主节点的响应，哨兵就认为主节点已主观下线</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个故障转移（Failover）过程的超时时间：10 秒</span></span><br><span class="line"><span class="comment"># 包括选举新主节点、通知其他从节点进行复制、通知客户端更新配置等</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移时，最多同时有 1 个从节点并行地从新的主节点复制数据（同步）</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><ul><li>引入 Lettuce 依赖，使用 Lettuce 的默认连接工厂 </li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot 默认使用 Lettuce 作为 Redis 客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Redis 连接验证代码 </li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"testKey"</span>, <span class="string">"hello from sentinel"</span>);</span><br><span class="line">    String value = stringRedisTemplate.opsForValue().get(<span class="string">"testKey"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Redis 返回: "</span> + value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>SpringBoot 配置（<code>application.yml</code>）的注意事项<ul><li>主从节点的 IP 和端口不需要配置，哨兵模式下 Lettuce 客户端能自动发现主从拓扑结构。</li><li><code>mymaster</code> 一定要和哨兵配置文件（<code>redis-sentinel.conf</code>）里设置的一致。</li><li>Lettuce 默认支持哨兵模式，一般不需要额外配置；但是，如果哨兵模式使用 SSL，则需要显式配置连接工厂。</li><li>SpringBoot 的默认连接池支持读写分离，只需要配置 Lettuce 的 <code>read-from</code> 属性即可生效。</li><li>在 Redis 的主从复制或者集群架构中，主节点可以读写，但从节点默认是只读的，即可以响应读请求（如 <code>GET</code>、<code>MGET</code> 等），但不能写入数据。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>无论 Redis 是一主一从、一主多从还是集群架构，Redis 的主节点都可以读写，从节点默认是可以读（只读，不能写入）；但如果想实现真正的读写分离或者读负载均衡，还需要在客户端进行配置或开发支持（比如 Jedis、Lettuce 都支持手动配置是否访问从节点），因为 Redis 本身不会自动将读请求发送给从节点。由于 Redis 的主从同步可能存在延迟，如果业务对读取一致性要求较高（如读取后马上更新），那么就不要使用从节点读取数据。</p></div><h2 id="哨兵机制的问题"><a href="#哨兵机制的问题" class="headerlink" title="哨兵机制的问题"></a>哨兵机制的问题</h2><h3 id="如何避免脑裂现象"><a href="#如何避免脑裂现象" class="headerlink" title="如何避免脑裂现象"></a>如何避免脑裂现象</h3><ul><li><p><strong>Redis 哨兵集群的脑裂现象是指什么</strong></p><ul><li>指在出现网络分区或者部分哨兵节点失联的情况下，多个哨兵节点在没有达到 <code>majority</code>（多数哨兵）共识的前提下，分别认为 Master 节点宕机并发起故障转移，导致出现两个或多个 Master 节点，从而造成数据不一致或系统混乱。</li><li>值得一提的是，除了主从同步延迟外，脑裂现象也会导致 Redis 集群丢失部分缓存数据。</li></ul></li><li><p><strong>Redis 哨兵集群如何避免脑裂现象</strong></p><ul><li>设置合适的 <code>quorum</code>（法定票数），即某个哨兵要认为主节点下线，必须要有至少 <code>quorum</code> 个哨兵达成共识。</li><li>真正的故障转移必须经过 <code>majority</code> 个哨兵（多数哨兵）投票通过，避免少数哨兵单方面误判。</li><li>因此，只要哨兵总数为奇数（如 3 个或 5 个），且大多数哨兵能互通，就不会发生脑裂现象。<ul><li>举个例子，假设集群中有 3 个哨兵，并配置 <code>quorum = 2</code>，那么：<ul><li>只有至少 2 个哨兵都判断主节点不可用，才会触发故障转移；</li><li>此时，还需要过半（即至少 2 个）的哨兵同意发起故障转移，才能选出新的主节点；</li><li>如果由于网络问题分区成 <code>1 + 2</code> 的两组哨兵，单独的哨兵将无法满足 <code>quorum</code> 和 <code>majority</code> 条件，这样就不会误判，从而避免脑裂。</li></ul></li></ul></li></ul></li></ul><table><thead><tr><th>概念</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td><code>quorum</code>（法定票数）</td><td>Master 节点从主观下线（SDOWN）到客观下线（ODOWN）所需的同意哨兵数（即最少 N 个哨兵同时判断 Master 为宕机）</td><td>确保哨兵对 Master 宕机的判断具有一定共识，避免误判</td></tr><tr><td><code>majority</code>（多数哨兵）</td><td>执行故障转移操作时，要求同意执行故障转移的哨兵数量必须达到总数的一半以上，否则不会执行故障转移</td><td>为了避免「脑裂」现象，即多个哨兵在不同网络分区中同时尝试进行故障转移，导致系统不一致或混乱</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">网络分区是指什么</p><p>网络分区（Network Partition）是指由于网络故障，集群中的一部分节点之间无法正常通信，被分隔成了两个或多个 "孤岛"，每个孤岛只能看到自身可达的节点，看不到其他节点。在 Redis 的哨兵集群架构中，网络分区通常指的是：部分哨兵与主节点失去连接、部分哨兵之间失去通信、主从节点之间断联。这些都可能导致：误判主节点下线、多个哨兵同时发起故障转移、出现多个主节点（脑裂）。</p></div><h3 id="如何避免数据丢失"><a href="#如何避免数据丢失" class="headerlink" title="如何避免数据丢失"></a>如何避免数据丢失</h3><p>Redis 的哨兵机制主要用于主从架构下的故障检测与自动主备切换，但在某些特殊场景下，哨兵机制可能会导致数据丢失，主要包括以下两种情况：</p><ul><li><p><strong>(1) 异步复制导致的数据丢失</strong></p><ul><li>Redis 主从节点之间的数据同步是异步复制，这意味着主节点写入的数据不会立即同步到从节点。<ul><li>当主节点（Master）宕机时，可能仍有部分数据尚未同步写入到从节点（Slave）。</li><li>此时，如果哨兵进行故障转移，从节点被提升为新的主节点，那么这些未同步的数据将永久丢失。</li></ul></li><li>这种情况的本质是主从延迟造成的数据不一致，属于设计上的权衡（异步复制换取更高性能和低延迟）。</li></ul></li><li><p><strong>(2) 脑裂（Split-Brain）导致的数据丢失</strong></p><ul><li>脑裂指的是：主节点与其他哨兵和从节点之间发生网络分区，导致其在局部网络中 “孤岛运行”，而在整体视角下却被认为已宕机。<ul><li>在发生网络分区期间，哨兵可能判定主节点不可用（ODOWN - 客观不可用），并发起故障转移，将某个从节点提升为新的主节点。</li><li>但由于旧主节点实际上仍在运行，客户端可能仍将数据写入旧主节点，形成了两个 “主节点”（双主）。</li><li>当网络恢复时，旧主节点会被哨兵强制转为从节点，并从新主节点复制数据，这会导致旧主节点上的数据被清空。</li></ul></li><li>因此，在发生网络分区的这段时间内，写入旧主节点的数据会丢失，因为它从未被同步到新主节点上，并且在旧主节点恢复后被覆盖掉。</li></ul></li></ul><hr><p>Redis 提供以下两个配置项用于控制写请求行为，从而减少异步复制和脑裂导致的数据丢失。</p><ul><li><code>min-slaves-to-write 1</code>：要求至少有 1 个从节点处于正常连接状态，主节点才允许写入数据。</li><li><code>min-slaves-max-lag 10</code>：要求从节点的复制延迟（ACK 返回的时间）不能超过 10 秒，主节点才允许写入数据。</li></ul><p>当主节点检测到可以正常连接的从节点数量不足，或者所有从节点的复制延迟都超过 10 秒，那么主节点将拒绝客户端的写请求。</p><ul><li><p><strong>(1) 减少异步复制导致的数据丢失</strong></p><ul><li>Redis 的主从复制是异步的。如果主节点宕机，而有些数据尚未同步到从节点，那么这些数据将永久丢失。</li><li>通过设置 <code>min-slaves-max-lag</code>，主节点可以感知从节点复制数据的延迟。如果从节点响应太慢（比如都超过了 10 秒），主节点会拒绝客户端的写入请求，防止继续写入大量数据而无法同步，从而将主节点宕机时可能丢失的数据限制在一个可控的范围（如 10 秒）内。</li></ul></li><li><p><strong>(2) 减少脑裂导致的数据丢失</strong></p><ul><li>在出现脑裂的情况下，客户端可能仍向旧主节点写入数据，形成两个主节点（双主），导致数据不一致和丢失。</li><li>通过 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 这两个配置项，可以防止脑裂主节点继续接受写请求：<ul><li>如果旧主节点失去了所有从节点的连接；</li><li>且在 <code>min-slaves-max-lag</code> 时间（如 10 秒）内未收到任何从节点的 ACK 消息；</li><li>那么主节点将自动停止接受写请求。</li></ul></li><li>这样，即使发生脑裂，旧主节点也会在 10 秒内拒绝写入数据，最多只会丢失 10 秒的数据，大大降低了数据丢失的风险。</li></ul></li></ul><p>当 Redis 主节点拒绝写请求时，客户端可以采取如下策略进行容灾处理：</p><ul><li><strong>(1) 客户限流处理</strong><ul><li>对接口请求进行限流处理，减慢请求涌入的速度，防止请求堆积或爆发式增长。</li></ul></li><li><strong>(2) 异步重试机制</strong><ul><li>将待写入的数据缓存在本地磁盘或者 Kafka 消息队列中。</li><li>客户端定时从本地磁盘或者 Kafka 队列中获取数据（例如每隔 10 分钟），然后尝试将数据重新写回 Redis 主节点。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Redis 的哨兵机制，包括 SpringBoot 项目使用哨兵机制。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="缓存" scheme="https://www.techgrow.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Higress 入门教程 - 基础篇（2025 年）</title>
    <link href="https://www.techgrow.cn/posts/63cc9919.html"/>
    <id>https://www.techgrow.cn/posts/63cc9919.html</id>
    <published>2025-07-22T13:12:19.000Z</published>
    <updated>2025-07-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Higress 是基于阿里内部的 Envoy Gateway 实践沉淀、以开源 Istio + Envoy 为核心构建的下一代云原生网关，实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力，深度集成 Dubbo、Nacos、Sentinel 等微服务技术栈，能够帮助用户极大的降低网关的部署及运维成本。在标准上全面支持 Ingress 与 Gateway API，积极拥抱云原生下的标准 API 规范；同时，Higress Controller 也支持 Nginx Ingress 平滑迁移，可以帮助用户零成本快速迁移到 Higress。</p><span id="more"></span><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li><a href="https://github.com/alibaba/higress">Higress 官方项目</a></li><li><a href="https://higress.cn/docs/latest/overview/what-is-higress/">Higress 官方文档</a></li><li><a href="https://higress.cn/">Higress 官方网站</a></li></ul><h3 id="网关的分类"><a href="#网关的分类" class="headerlink" title="网关的分类"></a>网关的分类</h3><p>行业中通常把网关分为两个大类：流量网关与业务网关，流量网关主要提供全局性的、与后端业务无关的策略配置，例如阿里内部的的统一接入网关 Tengine 就是典型的流量网关；业务网关顾名思义主要提供独立业务域级别的、与后端业务紧耦合策略配置，随着应用架构模式从单体演进到现在的微服务，业务网关也有了新的叫法 - 微服务网关。</p><p><img data-src="../../../asset/2025/07/higress-7.png"></p><p>在虚拟化时期的微服务架构下，业务通常采用流量网关 + 微服务网关的两层架构，流量网关负责南北向流量调度和安全防护，微服务网关负责东西向流量调度和服务治理，而在容器和 K8s 主导的云原生时代，Ingress 成为 K8s 生态的网关标准，赋予了网关新的使命，使得流量网关 + 微服务网关合二为一成为可能。作为面向南北向的公网网关，使用 Waf 防护异常流量是很常规的需求，而且随着互联网环境变得越来越复杂，用户对防护的诉求是持续增强的，常规做法是将流量先接入 Waf 安全网关，过滤后再将流量转发给流量网关，最后到达微服务网关；Higress 希望通过内置 Waf 模块，使得用户的请求链接只经过 Higress 就可以同时完成 Waf 防护、流量分发、微服务治理，既可以降低链路 RT，也可以降低网关的运维复杂度。因此 Higress 实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力。</p><p><img data-src="../../../asset/2025/07/higress-8.png"></p><h2 id="Higress-简介"><a href="#Higress-简介" class="headerlink" title="Higress 简介"></a>Higress 简介</h2><h3 id="Higress-是什么"><a href="#Higress-是什么" class="headerlink" title="Higress 是什么"></a>Higress 是什么</h3><ul><li>Higress 是一款云原生 API 网关，内核基于 Istio 和 Envoy，可以用 Go/Rust/JS 等编写 Wasm 插件，提供了数十个现成的通用插件，以及开箱即用的控制台。</li><li>Higress 在阿里内部为解决 Tengine Reload 对长连接业务有损，以及 gRPC/Dubbo 负载均衡能力不足而诞生。</li><li>阿里云基于 Higress 构建了云原生 API 网关产品，为大量企业客户提供 99.99% 的网关高可用保障服务能力。</li><li>Higress 基于 AI 网关能力，支撑了通义千问 APP、百炼大模型 API、机器学习 PAI 平台等 AI 业务。同时服务国内头部的 AIGC 企业（如零一万物），以及 AI 产品（如 FastGPT）。</li></ul><p><img data-src="../../../asset/2025/07/higress-1.png"></p><h3 id="什么是-AI-网关"><a href="#什么是-AI-网关" class="headerlink" title="什么是 AI 网关"></a>什么是 AI 网关</h3><p>AI Gateway = AI Native API GatewayAI，网关的本质依然是 API 网关，AI 原生的意义在于，在这样的 API 网关里，AI 是一等公民。API 研发、API 供应、API 消费、以及 API 观测都基于 AI 场景下的需求，演进出全新的能力。</p><blockquote><p>这是传统 API 网关的功能范畴，AI 场景下仍然有其通用价值：</p></blockquote><p><img data-src="../../../asset/2025/07/higress-2.png"></p><blockquote><p>在 AI 场景下，基于 Higress 可以将 API 网关的功能范畴进一步扩展：</p></blockquote><p><img data-src="../../../asset/2025/07/higress-3.png"></p><h3 id="Higress-核心优势"><a href="#Higress-核心优势" class="headerlink" title="Higress 核心优势"></a>Higress 核心优势</h3><ul><li><p>生产等级</p><ul><li>脱胎于阿里巴巴多年生产验证的内部产品，支持每秒请求量达数十万级的大规模场景。</li><li>彻底摆脱 Nginx Reload 引起的流量抖动，配置变更毫秒级生效且业务无感。对 AI 业务等长连接场景特别友好。</li></ul></li><li><p>便于扩展</p><ul><li>提供丰富的官方插件库，涵盖 AI、流量管理、安全防护等常用功能，满足 90% 以上的业务场景需求。</li><li>主打 Wasm 插件扩展，通过沙箱隔离确保内存安全，支持多种编程语言，允许插件版本独立升级，实现流量无损热更新网关逻辑。</li></ul></li><li><p>安全易用</p><ul><li>基于 Ingress API 和 Gateway API 标准，提供开箱即用的 UI 控制台，WAF 防护插件、IP/Cookie CC 防护插件开箱即用。</li><li>支持对接 Let’s Encrypt 自动签发和续签免费证书，并且可以脱离 K8s 部署，一行 Docker 命令即可启动，方便个人开发者使用。</li></ul></li><li><p>流式处理</p><ul><li>支持真正的完全流式处理请求 / 响应 Body，Wasm 插件很方便地自定义处理 SSE（Server-Sent Events）等流式协议的报文。</li><li>在 AI 业务等大带宽场景下，可以显著降低内存开销。</li></ul></li></ul><h3 id="Higress-使用场景"><a href="#Higress-使用场景" class="headerlink" title="Higress 使用场景"></a>Higress 使用场景</h3><h4 id="AI-网关"><a href="#AI-网关" class="headerlink" title="AI 网关"></a>AI 网关</h4><p>Higress 能够用统一的协议对接国内外所有 LLM 模型厂商，同时具备丰富的 AI 可观测、多模型负载均衡 / Fallback、AI Token 流控、AI 缓存等能力：</p><p><img data-src="../../../asset/2025/07/higress-4.png"></p><h4 id="K8s-Ingress-网关"><a href="#K8s-Ingress-网关" class="headerlink" title="K8s Ingress 网关"></a>K8s Ingress 网关</h4><p>Higress 可以作为 K8s 集群的 Ingress 入口网关，并且兼容了大量 K8s Nginx Ingress 的注解，可以从 K8s Nginx Ingress 快速平滑迁移到 Higress。支持 Gateway API 标准，支持用户从 Ingress API 平滑迁移到 Gateway API。相比 ingress-nginx，资源开销大幅下降，路由变更生效速度有十倍提升。</p><p><img data-src="../../../asset/2025/07/higress-5.png"></p><h4 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h4><p>Higress 可以作为微服务网关，能够对接多种类型的注册中心发现服务配置路由，例如 Nacos、ZooKeeper、Consul、Eureka 等。并且深度集成了 Dubbo、Nacos、Sentinel 等微服务技术栈，基于 Envoy C++ 网关内核的出色性能，相比传统 Java 类微服务网关，可以显著降低资源使用率，减少成本。</p><p><img data-src="../../../asset/2025/07/higress-6.png"></p><h4 id="安全防护网关"><a href="#安全防护网关" class="headerlink" title="安全防护网关"></a>安全防护网关</h4><p>Higress 可以作为安全防护网关，提供 WAF 的能力，并且支持多种认证鉴权策略，例如 key-auth、hmac-auth、jwt-auth、basic-auth、oidc 等。</p><h3 id="Higress-整体架构"><a href="#Higress-整体架构" class="headerlink" title="Higress 整体架构"></a>Higress 整体架构</h3><ul><li>整体上 Higress 网关由控制面组件 Higress-Controller 和数据面组件 Higress-Gateway 组成。Higress-Gateway 负责承载数据流量，Higress-Controller 负责管理配置下发。</li><li>数据面组件 Higress-Gateway 是基于 Envoy 开发的网关组件，负责接收和处理流量，支持 HTTP/1.1、HTTP/2、gRPC 等协议，支持 TLS、mTLS、WAF、限流、熔断、重试、负载均衡、路由、转发、重定向、跨域等功能，也就是说真正的流量处理都是在 Higress-Gateway 中完成的。</li><li>控制面组件 Higress-Controller 负责管理配置下发，支持 Ingress API、Gateway API、Istio API，支持多种注册中心，支持多种认证鉴权策略，支持多种插件扩展机制，支持多种 CRD 实现流量精细化管理，也就是说所有的配置都是通过 Higress-Controller 下发到 Higress-Gateway 中的。</li></ul><p><img data-src="../../../asset/2025/07/higress-9.png"></p><h3 id="Higress-开发语言"><a href="#Higress-开发语言" class="headerlink" title="Higress 开发语言"></a>Higress 开发语言</h3><p>Higress 主要是基于 Envoy Proxy 开发的，核心是用 C++（Envoy 内核）和 Go（控制面、插件、扩展部分）组合实现的。</p><table><thead><tr><th>组件</th><th>语言</th><th>作用</th></tr></thead><tbody><tr><td> Envoy Proxy（数据面）</td><td>C++</td><td>Higress 的流量转发核心，负责 HTTP/TCP 代理、路由、负载均衡，使用 Envoy 做高性能转发。</td></tr><tr><td>控制面 / 插件 / 扩展逻辑</td><td> Go</td><td>Higress 提供了 Ingress、Gateway API 的控制逻辑、配置管理、Wasm 插件管理等，这部分主要用 Go 实现。</td></tr><tr><td>Wasm 插件（可选）</td><td>WebAssembly（多语言）</td><td>Higress 支持流量治理的 Wasm 扩展，用户可以用 Rust、C++、AssemblyScript 编写。</td></tr></tbody></table><p>为什么采用这种语言组合？</p><ul><li>C++（Envoy 内核）：高性能、云原生友好，成熟的代理框架。</li><li>Go（控制面、插件）：易于集成 Kubernetes，开发效率高，社区有大量的 Ingress/Gateway 生态。</li><li>Wasm（扩展能力）：支持动态扩展，不用重启服务。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/qq_45038038/article/details/136005591">下一代云原生网关 Higress</a></li><li><a href="https://www.51cto.com/article/786706.html">Higress 或许是目前最好的云原生网关</a></li><li><a href="https://zhuanlan.zhihu.com/p/21624794301">使用 Higress 统一替代 APISIX/Kong/Istio Ingress</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Higress 的基础使用。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门教程之一</title>
    <link href="https://www.techgrow.cn/posts/99bf51b3.html"/>
    <id>https://www.techgrow.cn/posts/99bf51b3.html</id>
    <published>2025-07-22T13:12:19.000Z</published>
    <updated>2025-07-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门教程之一</a>、<a href="/posts/c57e8370.html">Kubernetes 入门教程之二</a>、<a href="/posts/2722157d.html">Kubernetes 入门教程之三</a></li><li><a href="/posts/37a21b7b.html">Kubernetes 入门教程之四</a>、<a href="/posts/6bf07963.html">Kubernetes 入门教程之五</a>、<a href="/posts/76121b26.html">Kubernetes 入门教程之六</a></li></ul><h2 id="Kubernetes-简单介绍"><a href="#Kubernetes-简单介绍" class="headerlink" title="Kubernetes 简单介绍"></a>Kubernetes 简单介绍</h2><h3 id="各种部署方式的区别"><a href="#各种部署方式的区别" class="headerlink" title="各种部署方式的区别"></a>各种部署方式的区别</h3><p>传统的应用部署方式是通过插件或脚本来安装应用，这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新、回滚等操作；当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能够快速部署，由于容器与底层设施、机器文件系统解耦的，所以它能在不同云、不同版本操作系统间进行迁移。容器占用资源少、部署快，每个应用可以被打包成一个容器镜像，每个应用与容器间成一对一关系也使容器有更大优势，使用容器可以在 <code>build</code> 或 <code>release</code> 的阶段，为应用创建容器镜像，因为每个应用不需要与其余的应用堆栈组合，也不依赖于生产环境基础结构，这使得从研发到测试、生产能提供一致环境。类似地，容器比虚拟机轻量、更 “透明”，这更便于监控和管理。</p><span id="more"></span><h3 id="Kubernetes-基本介绍"><a href="#Kubernetes-基本介绍" class="headerlink" title="Kubernetes 基本介绍"></a>Kubernetes 基本介绍</h3><p>Kubernetes 是 Google 于 2014 年 6 月正式开源的一个容器编排引擎，简称 K8s，是用 8 代替 8 个字符 <code>ubernete</code> 而成的缩写。Kubernetes 可用于管理云平台中多个主机上的容器化的应用，支持自动化部署、大规模扩缩容、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。Kubernetes 提供了应用部署、规划、更新、维护的一种机制。在 Kubernetes 中，可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p><h3 id="Kubernetes-功能介绍"><a href="#Kubernetes-功能介绍" class="headerlink" title="Kubernetes 功能介绍"></a>Kubernetes 功能介绍</h3><p>Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过 Kubernetes 能够进行应用的自动化部署和扩缩容。在 Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes 积累了作为 Google 生产环境运行工作负载 15 年的经验，并吸收了来自于社区的最佳想法和实践。Kubernetes 的核心功能如下：</p><ul><li>自动装箱：基于容器对应用运行环境的资源配置要求自动部署应用容器</li><li>自我修复：当容器运行失败时，会对容器进行重启；当所部署的 Node（工作节点）有问题时，会对容器进行重新部署和重新调度；当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</li><li>水平扩展：通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</li><li>服务发现：用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡</li><li>滚动更新：可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</li><li>版本回退：可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</li><li>密钥和配置管理：在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署</li><li>存储编排：自动实现存储系统挂载及应用，这特别对有状态应用实现数据持久化非常重要；存储系统可以来自于本地目录、网络存储（NFS、Gluster、Ceph 等）、公共云存储服务</li><li>批处理：提供一次性任务，定时任务，满足批量数据处理和分析的场景</li></ul><h3 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h3><table><thead><tr><th>技术名称</th><th>技术描述</th></tr></thead><tbody><tr><td> YAML 配置文件</td><td>使用 YAML 文件定义 Kubernetes 资源，如 Pod、Service、Deployment 等，是声明式管理的基础。</td></tr><tr><td>kubectl 命令工具</td><td> Kubernetes 的命令行客户端工具，用于操作集群、部署资源、排查故障等。</td></tr><tr><td>Pod</td><td>Kubernetes 中最小的可调度单元，通常封装一个或多个容器，容器共享网络和存储。</td></tr><tr><td>Controller（控制器）</td><td>自动化资源管理的核心组件，如 Deployment、ReplicaSet、StatefulSet、DaemonSet 等控制器。</td></tr><tr><td>Service</td><td> 定义一组 Pod 的统一访问入口，支持负载均衡和服务发现。</td></tr><tr><td>Label</td><td> 给资源打标签的机制，支持资源的分类、选择、分组管理等，用于调度和服务发现。</td></tr><tr><td>Volume</td><td> 提供容器持久化或共享数据的机制，支持本地存储、NFS、云存储等。</td></tr><tr><td>PVC 和 PV</td><td>PVC（Persistent Volume Claim）是用户请求的存储资源，PV（Persistent Volume）是实际存储资源，解耦用户和存储实现。</td></tr><tr><td>Secret 和 ConfigMap</td><td>Secret 用于管理敏感数据，ConfigMap 用于存储配置数据，都可挂载进容器或作为环境变量使用。</td></tr><tr><td>Namespace</td><td> 提供资源隔离的逻辑空间，用于多租户环境或资源分类管理。</td></tr><tr><td>Probes（探针）</td><td>包括存活探针（liveness）和就绪探针（readiness），用于健康检查和控制流量转发。</td></tr><tr><td>API Server</td><td>Kubernetes 控制平面的核心组件，负责处理来自 kubectl 或其他客户端的请求，并与 Etcd、Controller（控制器）、Scheduler（调度器）等交互。</td></tr><tr><td>Scheduler（调度器）</td><td>根据资源需求、约束条件和策略将 Pod 分配到合适的节点。</td></tr><tr><td>集群安装机制与 RBAC</td><td> 安装机制包括 kubeadm、Kops、RKE 等，RBAC（基于角色的访问控制）用于权限管理和安全控制。</td></tr><tr><td>Helm</td><td>Kubernetes 的包管理工具，用于简化应用部署，支持版本管理、参数化配置等。</td></tr></tbody></table><h3 id="Kubernetes-核心概念"><a href="#Kubernetes-核心概念" class="headerlink" title="Kubernetes 核心概念"></a>Kubernetes 核心概念</h3><p>Kubernetes 三个核心概念（Pod、Controller、Service）的介绍（<a href="../../../asset/2025/09/k8s-core.png">如图所示</a>）：</p><ul><li><p>Pod（最小部署单元）</p><ul><li>Pod 是 Kubernetes 中最小的调度和运行单元。</li><li>本质上是一组容器的集合（通常是一个容器）。</li><li>容器之间共享网络（IP、端口）和存储卷。</li><li>Pod 的生命周期可以是短暂的，比如用于运行临时任务或被控制器自动重建。</li></ul></li><li><p>Controller（控制器）</p><ul><li>用于管理和自动化 Pod 的部署与副本数量。</li><li>支持无状态应用部署（如 Deployment）。</li><li>支持有状态应用部署（如 StatefulSet）。</li><li>可实现以下功能：<ul><li>保证指定数量的 Pod 实例持续运行。</li><li>在多个节点上部署同一类 Pod（如 DaemonSet）。</li><li>支持一次性任务（Job）和定时任务（CronJob）。</li></ul></li></ul></li><li><p>Service（服务）</p><ul><li>负责定义一组 Pod 的访问规则。</li><li>提供统一的访问入口（Cluster IP、NodePort、LoadBalancer 等），实现服务发现与负载均衡。</li><li>解决 Pod 动态 IP 和短生命周期带来的访问不稳定问题。</li></ul></li></ul><p>Pod、Controller、Service 这三个核心概念的关系：</p><ul><li>Pod 是具体运行的实例。</li><li>Controller 管理 Pod 的创建、副本和调度。</li><li>Service 让外部或内部服务可以稳定地访问 Pod。</li></ul><h2 id="Kubernetes-集群搭建"><a href="#Kubernetes-集群搭建" class="headerlink" title="Kubernetes 集群搭建"></a>Kubernetes 集群搭建</h2><h3 id="集群架构组件"><a href="#集群架构组件" class="headerlink" title="集群架构组件"></a>集群架构组件</h3><p><img data-src="../../../asset/2025/07/k8s-1.png"></p><ul><li><p><code>Master（主控节点）</code>：Kubernetes 集群控制节点，负责对集群进行调度管理，接受集群外的用户去集群操作请求。Master 由 API Server、Scheduler、Controller Manager、Etcd 存储系统组成</p><ul><li>Scheduler：节点调度，选择 Node（工作节点）来应用部署</li><li> API Server：集群统一入口，以 RESTful 接口将数据交给 Etcd 进行存储</li><li> Controller Manager：处理集群中的常规后台任务，一个资源对应一个控制器</li><li> Etcd 存储系统：用于存储集群相关的数据</li></ul></li><li><p><code>Node（工作节点）</code>：Kubernetes 集群工作节点，负责运行用户业务应用容器，Node 由 Kubelet、Kube-Proxy 和 Container Runtime 组成</p><ul><li>Kubelet：负责 Pod 对应的容器的创建、启停管理，与 Master 节点协作，实现集群管理的基本功能</li><li> Kube-Proxy：提供 Kubernetes 的通信与负载均衡功能的重要组件</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Etcd 是什么</p><ul><li>在分布式系统中，Etcd 是一个高可用、强一致性的分布式键值存储系统，在 Kubernetes 等系统中扮演着核心元数据存储和协调中心的角色。</li><li>Etcd 属于更底层的基础组件，使用 Raft 算法实现强一致性（满足 CAP 中的 C 和 P），提供了一致性的 KV 存储、watch、lease、事务等机制。</li></ul></div><h3 id="集群搭建规划"><a href="#集群搭建规划" class="headerlink" title="集群搭建规划"></a>集群搭建规划</h3><p>Kubernetes 集群有两种类型，包括单 Master 集群和多 Master 集群，为了提高集群的高可用性，生产环境一般采用多 Master 集群方案，如下图所示：</p><p><img data-src="../../../asset/2021/03/kubernetes-cluster-plan.png"></p><h3 id="集群搭建要求"><a href="#集群搭建要求" class="headerlink" title="集群搭建要求"></a>集群搭建要求</h3><p>搭建 Kubernetes 集群需要满足以下几个条件：</p><ul><li>一台或多台机器，建议操作系统 CentOS 7（64 位）</li><li>Master 节点的硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 20GB 或更多</li><li> Node（工作节点）的硬件配置：4GB 或更多 RAM，4 个 CPU 或更多 CPU，硬盘 40GB 或更多</li><li>集群中所有机器之间的网络可以互通</li><li>系统内可以访问外网，需要拉取镜像</li><li>禁用 Swap 分区（必须）</li></ul><h3 id="集群搭建方式"><a href="#集群搭建方式" class="headerlink" title="集群搭建方式"></a>集群搭建方式</h3><p>目前生产环境搭建 Kubernetes 集群主要有以下两种方式：</p><ul><li><p><strong>Kubeadm</strong></p><ul><li><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">Kubeadm</a> 是一个 Kubernetes 部署工具，提供 <code>kubeadm init</code> 和 <code>kubeadm join</code> 命令，可用于快速搭建 Kubernetes 集群。</li></ul></li><li><p><strong>二进制包</strong></p><ul><li>从 Github 下载发行版的二进制包，手动部署每个组件，组成 Kubernetes 集群。Kubeadm 虽然降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。</li><li>如果想集群整体更可控，生产环境推荐使用二进制包搭建 Kubernetes 集群，虽然手动部署比较麻烦，但期间可以学习很多工作原理，也利于后期维护。</li></ul></li></ul><h3 id="集群搭建步骤"><a href="#集群搭建步骤" class="headerlink" title="集群搭建步骤"></a>集群搭建步骤</h3><h4 id="二进制包方式搭建集群"><a href="#二进制包方式搭建集群" class="headerlink" title="二进制包方式搭建集群"></a>二进制包方式搭建集群</h4><ul><li><a href="/posts/ccd6f2d4.html">基于二进制包方式搭建 Kubernetes 集群</a></li></ul><h4 id="Kubeadm-方式搭建集群"><a href="#Kubeadm-方式搭建集群" class="headerlink" title="Kubeadm 方式搭建集群"></a>Kubeadm 方式搭建集群</h4><ul><li><a href="/posts/b728042a.html">基于 Kubeadm 方式搭建 Kubernetes 集群</a></li></ul><h2 id="Kubernetes-核心技术-1"><a href="#Kubernetes-核心技术-1" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="kubectl-命令行工具"><a href="#kubectl-命令行工具" class="headerlink" title="kubectl 命令行工具"></a>kubectl 命令行工具</h3><p>kubectl 是 Kubernetes 集群的命令行工具，通过 kubectl 能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。</p><h4 id="kubectl-的语法"><a href="#kubectl-的语法" class="headerlink" title="kubectl 的语法"></a>kubectl 的语法</h4><ul><li><p>命令语法：<code>kubectl [command] [type] [name] [flags]</code></p></li><li><p><code>command</code>：</p><ul><li>指定要对资源执行的操作</li><li>例如：<code>create</code>、<code>get</code>、<code>describe</code> 和 <code>delete</code></li></ul></li><li><p><code>type</code>：</p><ul><li>指定资源类型，资源类型是大小写敏感的，开发者能够以单数、复数和缩略的形式。例如:</li><li><code>kubectl get pod pod1</code></li><li><code>kubectl get pods pod1</code></li><li><code>kubectl get po pod1</code></li><li><code>kubectl get nodes K8s-node1</code></li></ul></li><li><p><code>name</code>：</p><ul><li>指定资源的名称，名称大小写敏感。如果省略资源名称，则会显示所有的资源。例如：</li><li><code>kubectl get pods</code></li><li><code>kubectl get nodes</code></li><li><code>kubectl get nodes K8s-node1</code></li></ul></li><li><p><code>flags</code>：</p><ul><li>指定可选的参数。例如，可以使用 <code>-s</code> 或者 <code>-server</code> 参数指定 Kubernetes API Server 的地址和端口。</li></ul></li></ul><h4 id="kubectl-的使用帮助手册"><a href="#kubectl-的使用帮助手册" class="headerlink" title="kubectl 的使用帮助手册"></a>kubectl 的使用帮助手册</h4><p>可以使用 <code>kubectl --help</code> 命令查看 kubectl 命令的整体使用帮助，包括所有可用的主命令及其简要说明；还可以通过 <code>kubectl &lt;command&gt; --help</code> 获取某个具体子命令的详细使用手册和参数说明。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 kubectl 的所有主命令和帮助信息</span></span><br><span class="line"><span class="keyword"># kubectl</span><span class="params"> --help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kubectl get 子命令的详细用法和参数说明</span></span><br><span class="line"><span class="keyword"># kubectl</span> get<span class="params"> --help</span></span><br></pre></td></tr></tbody></table></figure><p>比如，<code>kubectl help</code> 命令输出的帮助内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">kubectl controls the Kubernetes cluster manager.</span><br><span class="line"></span><br><span class="line"> Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/</span><br><span class="line"></span><br><span class="line">Basic Commands (Beginner):</span><br><span class="line">  create        Create a resource from a file or from stdin.</span><br><span class="line">  expose        使用 replication controller, service, deployment 或者 pod 并暴露它作为一个 新的 Kubernetes</span><br><span class="line">Service</span><br><span class="line">  run           在集群中运行一个指定的镜像</span><br><span class="line">  set           为 objects 设置一个指定的特征</span><br><span class="line"></span><br><span class="line">Basic Commands (Intermediate):</span><br><span class="line">  explain       查看资源的文档</span><br><span class="line">  get           显示一个或更多 resources</span><br><span class="line">  edit          在服务器上编辑一个资源</span><br><span class="line">  delete        Delete resources by filenames, stdin, resources and names, or by resources and label selector</span><br><span class="line"></span><br><span class="line">Deploy Commands:</span><br><span class="line">  rollout       Manage the rollout of a resource</span><br><span class="line">  scale         Set a new size for a Deployment, ReplicaSet or Replication Controller</span><br><span class="line">  autoscale     自动调整一个 Deployment, ReplicaSet, 或者 Replication Controller 的副本数量</span><br><span class="line"></span><br><span class="line">Cluster Management Commands:</span><br><span class="line">  certificate   修改 certificate 资源.</span><br><span class="line">  cluster-info  显示集群信息</span><br><span class="line">  top           Display Resource (CPU/Memory/Storage) usage.</span><br><span class="line">  cordon        标记 node 为 unschedulable</span><br><span class="line">  uncordon      标记 node 为 schedulable</span><br><span class="line">  drain         Drain node in preparation for maintenance</span><br><span class="line">  taint         更新一个或者多个 node 上的 taints</span><br><span class="line"></span><br><span class="line">Troubleshooting and Debugging Commands:</span><br><span class="line">  describe      显示一个指定 resource 或者 group 的 resources 详情</span><br><span class="line">  logs          输出容器在 pod 中的日志</span><br><span class="line">  attach        Attach 到一个运行中的 container</span><br><span class="line">  exec          在一个 container 中执行一个命令</span><br><span class="line">  port-forward  Forward one or more local ports to a pod</span><br><span class="line">  proxy         运行一个 proxy 到 Kubernetes API server</span><br><span class="line">  cp            复制 files 和 directories 到 containers 和从容器中复制 files 和 directories.</span><br><span class="line">  auth          Inspect authorization</span><br><span class="line"></span><br><span class="line">Advanced Commands:</span><br><span class="line">  diff          Diff live version against would-be applied version</span><br><span class="line">  apply         通过文件名或标准输入流(stdin)对资源进行配置</span><br><span class="line">  patch         使用 strategic merge patch 更新一个资源的 field(s)</span><br><span class="line">  replace       通过 filename 或者 stdin替换一个资源</span><br><span class="line">  wait          Experimental: Wait for a specific condition on one or many resources.</span><br><span class="line">  convert       在不同的 API versions 转换配置文件</span><br><span class="line">  kustomize     Build a kustomization target from a directory or a remote url.</span><br><span class="line"></span><br><span class="line">Settings Commands:</span><br><span class="line">  label         更新在这个资源上的 labels</span><br><span class="line">  annotate      更新一个资源的注解</span><br><span class="line">  completion    Output shell completion code for the specified shell (bash or zsh)</span><br><span class="line"></span><br><span class="line">Other Commands:</span><br><span class="line">  alpha         Commands for features in alpha</span><br><span class="line">  api-resources Print the supported API resources on the server</span><br><span class="line">  api-versions  Print the supported API versions on the server, in the form of "group/version"</span><br><span class="line">  config        修改 kubeconfig 文件</span><br><span class="line">  plugin        Provides utilities for interacting with plugins.</span><br><span class="line">  version       输出 client 和 server 的版本信息</span><br><span class="line"></span><br><span class="line">Use "kubectl &lt;command&gt; --help" for more information about a given command.</span><br><span class="line">Use "kubectl options" for a list of global command-line options (applies to all commands).</span><br></pre></td></tr></tbody></table></figure><h4 id="kubectl-的子命令使用分类"><a href="#kubectl-的子命令使用分类" class="headerlink" title="kubectl 的子命令使用分类"></a>kubectl 的子命令使用分类</h4><ul><li>基础命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>create</code></td><td>通过文件名或标注输入创建资源</td></tr><tr><td><code>expose</code></td><td>将一个资源公开为一个新的 Service</td></tr><tr><td><code>run</code></td><td>在集群中运行一个特定的镜像</td></tr><tr><td><code>set</code></td><td>在对象上设置特定的功能</td></tr><tr><td><code>get</code></td><td>显示一个或多个资源</td></tr><tr><td><code>explain</code></td><td>文档参考资料</td></tr><tr><td><code>edit</code></td><td>使用默认的编辑器编辑一个资源</td></tr><tr><td><code>delete</code></td><td>通过文件名、标注输入、资源名或标注选择来删除资源</td></tr></tbody></table><ul><li> 部署命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>rollout</code></td><td>管理资源的发布</td></tr><tr><td><code>rolling-update</code></td><td>对某些类型的副本控制器滚动更新</td></tr><tr><td><code>scale</code></td><td>扩容或缩容 Pod 数量，Deployment、ReplicaSet、Replication Controller 或 Job</td></tr><tr><td><code>autoscale</code></td><td>创建一个自动选择扩容或缩容容器并设置 Pod 数量</td></tr></tbody></table><ul><li> 集群管理命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>certificate</code></td><td>修改证书资源</td></tr><tr><td><code>cluster-info</code></td><td>显示集群信息</td></tr><tr><td><code>top</code></td><td>显示资源（CPU/Memory/Storage）使用情况，需要 Heapster 运行</td></tr><tr><td><code>cordon</code></td><td>标记节点不可调度</td></tr><tr><td><code>uncordon</code></td><td>标记节点可调度</td></tr><tr><td><code>drain</code></td><td>驱逐节点上的应用，准备下线维护</td></tr><tr><td><code>taint</code></td><td>修改节点 Taint 标记</td></tr></tbody></table><ul><li>故障和调试命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>describe</code></td><td>显示特定资源或资源组的详细信息</td></tr><tr><td><code>logs</code></td><td>在一个 Pod 中打印一个容器日志。如 Pod 只有一个容器，容器名称是可选的</td></tr><tr><td><code>attach</code></td><td>附加到一个运行的容器</td></tr><tr><td><code>exec</code></td><td>执行命令到容器</td></tr><tr><td><code>port-forward</code></td><td>转发一个或多个本地端口到一个 Pod</td></tr><tr><td><code>proxy</code></td><td>运行一个 Proxy 到 Kubernetes API server</td></tr><tr><td><code>cp</code></td><td>拷贝文件和目录到容器中或从容器中拷贝出来</td></tr><tr><td><code>auth</code></td><td>检查授权</td></tr></tbody></table><ul><li>其他高级命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>apply</code></td><td>通过文件名或标准输入对资源应用配置</td></tr><tr><td><code>patch</code></td><td>使用补丁修改、更新资源的字段</td></tr><tr><td><code>replace</code></td><td>通过文件名或标准输入替换一个资源</td></tr><tr><td><code>convert</code></td><td>不同的 API 版本之间转换配置文件</td></tr></tbody></table><ul><li>其他设置命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>label</code></td><td>更新资源上的标签</td></tr><tr><td><code>annotate</code></td><td>更新资源上的注释</td></tr></tbody></table><ul><li>其他常用命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>completion</code></td><td>用于实现 kubectl 工具自动补全</td></tr><tr><td><code>api-versions</code></td><td>打印可用的 API 版本</td></tr><tr><td><code>config</code></td><td>修改 kubeconfig 文件（用于访问 API，比如凭证信息配置）</td></tr><tr><td><code>help</code></td><td>所有命令帮助</td></tr><tr><td><code>plugin</code></td><td>运行一个可执行插件</td></tr><tr><td><code>version</code></td><td>打印客户端和服务端的版本信息</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">最常用的命令</p><ul><li><code>kubectl get pods</code>：查看当前命名空间下所有 Pod 的状态信息。</li><li><code>kubectl get nodes</code>：查看集群中所有节点（Node）的状态信息。</li><li><code>kubectl get svc</code>： 查看当前命名空间下所有 Service（服务）资源的配置信息。</li><li><code>kubectl get cs</code>： 查看集群核心组件（ComponentStatus，如 Scheduler、Controller Manager 等）的运行状态，已过时不推荐使用。</li></ul></div><h3 id="YAML-资源编排清单"><a href="#YAML-资源编排清单" class="headerlink" title="YAML 资源编排清单"></a>YAML 资源编排清单</h3><p>在 Kubernetes 集群中，资源管理和资源对象的编排部署可以通过声明式的 YAML 文件来实现。用户可以将对资源对象的操作需求编写到 YAML 格式的配置文件中，这种文件称为资源清单文件。通过 kubectl 命令直接调用这些资源清单文件，就能够高效地完成大量资源对象的编排和部署工作。</p><h4 id="YAML-的概述"><a href="#YAML-的概述" class="headerlink" title="YAML 的概述"></a>YAML 的概述</h4><ul><li>YAML 是一个可读性高，用来表达数据序列的格式。</li><li>YAML 仍是一种标记语言，为了强调这种语言以数据作为中心，而不是以标记语言为重点。</li></ul><h4 id="YAML-的基本语法"><a href="#YAML-的基本语法" class="headerlink" title="YAML 的基本语法"></a>YAML 的基本语法</h4><ul><li>使用空格作为缩进；</li><li>缩进的空格数量不重要，只要相同层级的元素左侧对齐即可；</li><li>低版本缩进时，不允许使用 Tab 键，只允许使用空格；</li><li>使用 <code>---</code> 作为文档分隔符，表示一个 YAML 文件中的多文档边界；</li><li>使用 <code>#</code> 标识注释，从这个字符一直到行尾，都会被 YAML 解释器忽略。</li></ul><h4 id="YAML-支持的数据结构"><a href="#YAML-支持的数据结构" class="headerlink" title="YAML 支持的数据结构"></a>YAML 支持的数据结构</h4><ul><li>对象：键值对的集合，又称为映射 (Mapping) / 哈希 (Hash) / 字典 (Dictionary)</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对象类型：对象的一组键值对，使用冒号结构表示</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yaml 也允许另一种写法，将所有键值对写成一个行内对象</span></span><br><span class="line"><span class="attr">hash:</span> {<span class="attr">name:</span> <span class="string">Tom</span>, <span class="attr">age:</span> <span class="number">18</span>}</span><br></pre></td></tr></tbody></table></figure><ul><li>数组：一组按次序排列的值，又称为序列 (Sequence) / 列表 (List)</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 横向写法（行内数组）</span></span><br><span class="line"><span class="attr">fruits:</span> [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 纵向写法（可读性更好，推荐）</span></span><br><span class="line"><span class="attr">fruits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cherry</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合对象的数组（数组中每个元素都是一个对象）</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Alice</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">25</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Peter</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">30</span></span><br></pre></td></tr></tbody></table></figure><ul><li>多行字符串可以使用 <code>|</code> 保留换行符，也可以使用 <code>&gt;</code> 折叠换行 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 `|` 保留换行符</span></span><br><span class="line"><span class="attr">this:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br></pre></td></tr></tbody></table></figure><ul><li>多个 YAML 文档之间可以使用 <code>---</code> 文档分隔符分隔 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个文档（例如定义一个 ConfigMap）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">config1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 第二个文档（例如定义一个 Secret）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret1</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">BASE64_ENCODED_DATA</span></span><br></pre></td></tr></tbody></table></figure><h4 id="YAML-资源清单的描述方法"><a href="#YAML-资源清单的描述方法" class="headerlink" title="YAML 资源清单的描述方法"></a>YAML 资源清单的描述方法</h4><p>在 Kubernetes 中，用户通常使用 YAML 格式的配置文件来定义和创建符合预期状态的集群资源（如 Pod、Deployment 等）。这类遵循 Kubernetes API 规范、用于描述资源对象及其期望状态的 YAML 文件，被称为资源清单（Manifest）。</p><ul><li>常用字段（<strong>必须存在的属性</strong>）</li></ul><table><thead><tr><th>参数名</th><th>字段类型</th><th>说明</th></tr></thead><tbody><tr><td><code>version</code></td><td>String</td><td>K8s API 的版本，目前基本是 <code>v1</code>，可以用 <code>kubectl api-versions</code> 命令查询</td></tr><tr><td><code>kind</code></td><td>String</td><td>YAML 文件定义的资源类型和角色，例如：<code>Pod</code></td></tr><tr><td><code>metadata</code></td><td>Object</td><td> 元数据对象，固定值写 <code>metadata</code></td></tr><tr><td><code>metadata.name</code></td><td>String</td><td> 元数据对象的名字，由用户定义，例如命名 Pod 的名字</td></tr><tr><td><code>metadata.namespace</code></td><td>String</td><td> 元数据对象的命名空间，由用户定义</td></tr><tr><td><code>spec</code></td><td>Object</td><td> 详细定义对象，固定值写 <code>spec</code></td></tr><tr><td><code>spec.containers[]</code></td><td>list</td><td>spec 对象的容器列表定义，是一个列表</td></tr><tr><td><code>spec.containers[].name</code></td><td>String</td><td> 定义容器的名称</td></tr><tr><td><code>spec.containers[].image</code></td><td>String</td><td> 定义容器使用的镜像名称</td></tr></tbody></table><ul><li>资源清单的定义示例（创建一个 Nginx 的 Pod）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>更完整的资源清单定义示例（创建一个 Nginx 的 Deployment）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>最后可以使用 <code>kubectl apply -f xxxx.yaml</code> 命令来执行这个资源清单</li></ul><h4 id="快速生成-YAML-资源清单"><a href="#快速生成-YAML-资源清单" class="headerlink" title="快速生成 YAML 资源清单"></a>快速生成 YAML 资源清单</h4><ul><li>(1) 第一种方式：使用 <code>kubectl create</code> 命令快速生成 YAML 的配置模板内容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速生成 YAML 配置模板内容，--dry-run=client 表示只在客户端进行验证和生成请求，而不把资源真正提交到 API Server</span></span><br><span class="line"><span class="keyword"># kubectl</span> create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者将生成 YAML 配置模板内容输出到文件中</span></span><br><span class="line"><span class="keyword"># kubectl</span> create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> {}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line"><span class="attr">status:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 第二种方式：使用 <code>kubectl get</code> 命令导出正在运行的资源对象的 YAML 配置内容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前正在运行的 Deployment</span></span><br><span class="line"><span class="keyword"># kubectl</span> get deployments</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   1/1     1            1           2d12h</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出当前正在运行的 Deployment 的 YAML 配置内容</span></span><br><span class="line"><span class="keyword"># kubectl</span> get deployment nginx<span class="params"> -o</span> yaml &gt; nginx.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">deployment.kubernetes.io/revision:</span> <span class="string">"1"</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">  <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:labels:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:app:</span> {}</span><br><span class="line">      <span class="attr">f:spec:</span></span><br><span class="line">        <span class="attr">f:progressDeadlineSeconds:</span> {}</span><br><span class="line">        <span class="attr">f:replicas:</span> {}</span><br><span class="line">        <span class="attr">f:revisionHistoryLimit:</span> {}</span><br><span class="line">        <span class="attr">f:selector:</span></span><br><span class="line">          <span class="attr">f:matchLabels:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:app:</span> {}</span><br><span class="line">        <span class="attr">f:strategy:</span></span><br><span class="line">          <span class="attr">f:rollingUpdate:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:maxSurge:</span> {}</span><br><span class="line">            <span class="attr">f:maxUnavailable:</span> {}</span><br><span class="line">          <span class="attr">f:type:</span> {}</span><br><span class="line">        <span class="attr">f:template:</span></span><br><span class="line">          <span class="attr">f:metadata:</span></span><br><span class="line">            <span class="attr">f:labels:</span></span><br><span class="line">              <span class="string">.:</span> {}</span><br><span class="line">              <span class="attr">f:app:</span> {}</span><br><span class="line">          <span class="attr">f:spec:</span></span><br><span class="line">            <span class="attr">f:containers:</span></span><br><span class="line">              <span class="string">k:{"name":"nginx"}:</span></span><br><span class="line">                <span class="string">.:</span> {}</span><br><span class="line">                <span class="attr">f:image:</span> {}</span><br><span class="line">                <span class="attr">f:imagePullPolicy:</span> {}</span><br><span class="line">                <span class="attr">f:name:</span> {}</span><br><span class="line">                <span class="attr">f:resources:</span> {}</span><br><span class="line">                <span class="attr">f:terminationMessagePath:</span> {}</span><br><span class="line">                <span class="attr">f:terminationMessagePolicy:</span> {}</span><br><span class="line">            <span class="attr">f:dnsPolicy:</span> {}</span><br><span class="line">            <span class="attr">f:restartPolicy:</span> {}</span><br><span class="line">            <span class="attr">f:schedulerName:</span> {}</span><br><span class="line">            <span class="attr">f:securityContext:</span> {}</span><br><span class="line">            <span class="attr">f:terminationGracePeriodSeconds:</span> {}</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubectl-create</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:annotations:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:deployment.kubernetes.io/revision:</span> {}</span><br><span class="line">      <span class="attr">f:status:</span></span><br><span class="line">        <span class="attr">f:availableReplicas:</span> {}</span><br><span class="line">        <span class="attr">f:conditions:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="string">k:{"type":"Available"}:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> {}</span><br><span class="line">            <span class="attr">f:lastUpdateTime:</span> {}</span><br><span class="line">            <span class="attr">f:message:</span> {}</span><br><span class="line">            <span class="attr">f:reason:</span> {}</span><br><span class="line">            <span class="attr">f:status:</span> {}</span><br><span class="line">            <span class="attr">f:type:</span> {}</span><br><span class="line">          <span class="string">k:{"type":"Progressing"}:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> {}</span><br><span class="line">            <span class="attr">f:lastUpdateTime:</span> {}</span><br><span class="line">            <span class="attr">f:message:</span> {}</span><br><span class="line">            <span class="attr">f:reason:</span> {}</span><br><span class="line">            <span class="attr">f:status:</span> {}</span><br><span class="line">            <span class="attr">f:type:</span> {}</span><br><span class="line">        <span class="attr">f:observedGeneration:</span> {}</span><br><span class="line">        <span class="attr">f:readyReplicas:</span> {}</span><br><span class="line">        <span class="attr">f:replicas:</span> {}</span><br><span class="line">        <span class="attr">f:updatedReplicas:</span> {}</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kube-controller-manager</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"300851"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/apis/apps/v1/namespaces/default/deployments/nginx</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">f8edd19f-3292-45ac-ad16-932611f528a8</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line">        <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">        <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">      <span class="attr">securityContext:</span> {}</span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">availableReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">    <span class="attr">lastUpdateTime:</span> <span class="string">"2025-07-22T14:10:24Z"</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">ReplicaSet</span> <span class="string">"nginx-6799fc88d8"</span> <span class="string">has</span> <span class="string">successfully</span> <span class="string">progressed.</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">NewReplicaSetAvailable</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">"True"</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Progressing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">    <span class="attr">lastUpdateTime:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">Deployment</span> <span class="string">has</span> <span class="string">minimum</span> <span class="string">availability.</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">"True"</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Available</span></span><br><span class="line">  <span class="attr">observedGeneration:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">readyReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">updatedReplicas:</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Kubernetes-扩展知识"><a href="#Kubernetes-扩展知识" class="headerlink" title="Kubernetes 扩展知识"></a>Kubernetes 扩展知识</h2><h3 id="无状态和有状态应用"><a href="#无状态和有状态应用" class="headerlink" title="无状态和有状态应用"></a>无状态和有状态应用</h3><blockquote><p>无状态和有状态应用的概念</p></blockquote><ul><li>无状态应用（Stateless）：<ul><li>应用实例之间没有任何区别，不依赖本地存储或唯一身份。</li><li>任何一个实例都可以处理任何请求，并且可以被随时替换或扩展而不影响整体应用。</li><li>这是云原生和微服务架构的默认假设。</li><li>典型代表：Nginx、Web 服务、后端接口、无状态微服务。</li></ul></li><li>有状态应用（Stateful）：<ul><li>应用实例有唯一身份（比如节点一、节点二）、需要稳定的持久化存储，或者实例之间有主从等依赖关系。</li><li>替换或重新调度实例时，需要保持其身份和对应的数据。</li><li>典型代表：MySQL、Kafka、ZooKeeper、ElasticSearch、Redis Cluster。</li></ul></li></ul><blockquote><p>无状态应用的部署</p></blockquote><p>在 Kubernetes 中，无状态应用通常使用 Deployment 来部署。</p><ul><li><p>部署特点</p><ul><li>所有 Pod 副本共享同一个持久化存储（如果需要）或完全不持久化数据。</li><li>Pod 的名称和网络标识是不稳定的（例如 <code>web-app-7dfd644c7b-abcx5</code>）。</li><li>服务的访问方式是随机的，任何一个 Pod 都可以处理请求。</li></ul></li><li><p>部署例子</p><ul><li>Web 前端应用：例如 React、Vue、Angular 应用。它们通常只是提供静态文件，会话数据（Session）可能存储在外部的 Cookie 或 Redis 中。</li><li>简单的 RESTful API / 微服务：比如一个用户查询服务、商品详情服务，这些服务本身不存储任何数据，状态（数据）保存在后端的数据库（如 MySQL、PostgreSQL）或缓存（如 Redis）中。</li><li>反向代理 / 负载均衡器：例如 Nginx 或 Traefik，它们根据规则路由流量，自身不会产生需要持久化的数据。</li><li>无状态的计算：例如一个图像处理 Worker，它从消息队列（如 RabbitMQ、Kafka）中获取任务，处理完后将结果存入另一个数据库，任务本身与之前的状态无关。</li></ul></li><li><p>配置示例</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>    <span class="comment"># 使用 Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web-frontend</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web-frontend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>有状态应用的部署</p></blockquote><p>在 Kubernetes 中，有状态应用必须使用 StatefulSet 来部署。</p><ul><li><p>部署特点</p><ul><li>每个 Pod 有唯一且稳定的网络标识（主机名），例如 <code>kafka-0</code>、<code>kafka-1</code>、<code>kafka-2</code>。</li><li>每个 Pod 通常绑定一个专用的持久化存储卷（PVC），Pod 重启或调度后，仍然会挂载同一个存储卷，保证数据不丢失。</li><li>Pod 的启动、扩容、缩容和更新是有严格顺序的（例如顺序创建、逆序终止等）。</li></ul></li><li><p>部署例子</p><ul><li>数据库（这是最典型的例子）：<ul><li>MySQL / PostgreSQL 主从集群：主节点需要读写，从节点同步数据。每个节点的数据和身份至关重要，不能混淆。</li><li>MongoDB 副本集：节点有明确的角色（如 Primary、Secondary）。</li></ul></li><li>缓存：<ul><li>Redis Sentinel / 集群：包含不同角色的节点，身份固定，存储的数据不能丢失（如果开启了持久化）。</li></ul></li><li>消息队列：<ul><li>Kafka 集群：每个 Broker 有唯一的 Broker ID，消息主题（Topic）的分区（Partitions）分布在不同的 Broker 上，存储的数据不能丢失。</li><li>RabbitMQ 集群：每个节点有唯一的节点名称。</li></ul></li><li>分布式数据存储：<ul><li>Elasticsearch 集群：每个节点都有唯一的名称，存储特定的分片数据。</li><li>Etcd / ZooKeeper 集群：用于服务发现和配置共享，需要稳定的网络标识来组建集群。</li></ul></li><li>有状态的应用中间件：<ul><li>游戏服务器：每个实例管理一个特定的游戏房间或用户状态。</li></ul></li></ul></li><li><p>配置示例</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span> <span class="comment"># 使用StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kafka</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">"kafka-hs"</span> <span class="comment"># 必须有对应的无头服务</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kafka</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kafka</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">kafka:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9092</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/kafka</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span> <span class="comment"># 关键：存储卷申请模板，每个Pod都会按此模板自动创建唯一的PVC</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [ <span class="string">"ReadWriteOnce"</span> ]</span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">"ssd"</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">100Gi</span></span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>总结对比</p></blockquote><table><thead><tr><th>特性</th><th>无状态应用 (Deployment)</th><th> 有状态应用 (StatefulSet)</th></tr></thead><tbody><tr><td>Pod 身份</td><td>随机，不唯一</td><td>固定，有序且唯一</td></tr><tr><td>网络标识</td><td>共享 Service，随机负载均衡</td><td>稳定的 DNS 名称：<code>&lt;pod-name&gt;.&lt;svc-name&gt;.&lt;namespace&gt;.svc.cluster.local</code></td></tr><tr><td>存储</td><td>所有 Pod 共享持久化存储卷或无需存储</td><td>每个 Pod 有自己独立的持久化存储卷（<code>volumeClaimTemplates</code>）</td></tr><tr><td>部署 / 扩展</td><td>并行，无顺序</td><td>顺序操作（如：扩缩容时，从 0 到 N 顺序创建，从 N 到 0 逆序终止）</td></tr><tr><td>典型应用</td><td> Web 前端、API 微服务、无状态计算</td><td>数据库（如 MySQL、PostgreSQL）、消息队列（如 Kafka、RabbitMQ）、集群（ES、ZK、Etcd）</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AI 应用（AI-Agent）开发新范式</title>
    <link href="https://www.techgrow.cn/posts/a7fade9c.html"/>
    <id>https://www.techgrow.cn/posts/a7fade9c.html</id>
    <published>2025-07-22T11:41:00.000Z</published>
    <updated>2025-07-22T11:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><div class="row"><embed src="/pdf/AI应用（AI-Agent）开发新范式.pdf" width="100%" height="1024px" isolation="isolate" type="application/pdf"></div>]]></content>
    
    
    <summary type="html">AI 应用 与 AI Agent 开发新范式。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="AI" scheme="https://www.techgrow.cn/tags/AI/"/>
    
    <category term="在线电子书" scheme="https://www.techgrow.cn/tags/%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 手写高性能网络库（Muduo）</title>
    <link href="https://www.techgrow.cn/posts/dbb10768.html"/>
    <id>https://www.techgrow.cn/posts/dbb10768.html</id>
    <published>2025-07-15T13:55:33.000Z</published>
    <updated>2025-07-15T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写高性能网络库（Muduo）</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 实现类似于 Muduo 这样的高性能网路库。</p>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 开发一款高性能网络库（Muduo）。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMake 开发随笔</title>
    <link href="https://www.techgrow.cn/posts/5e16ffff.html"/>
    <id>https://www.techgrow.cn/posts/5e16ffff.html</id>
    <published>2025-06-25T15:36:32.000Z</published>
    <updated>2025-06-25T15:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="源文件路径"><a href="#源文件路径" class="headerlink" title="源文件路径"></a>源文件路径</h2><table><thead><tr><th>变量名</th><th>含义</th><th>会因 <code>add_subdirectory()</code> 变化</th><th>会因 <code>project()</code> 变化</th><th>用途</th><th>推荐使用场景</th></tr></thead><tbody><tr><td><code>CMAKE_SOURCE_DIR</code></td><td>顶层 CMake 项目的源代码目录（CMake 最初运行的目录）</td><td>❌ 否</td><td>❌ 否</td><td>全局设置、根路径引用</td><td>获取整个 CMake 项目的根目录</td></tr><tr><td><code>PROJECT_SOURCE_DIR</code></td><td>当前 <code>project()</code> 指令所在目录</td><td>✅ 是</td><td>✅ 是</td><td>模块级路径引用（推荐）</td><td>获取当前模块（Project）目录</td></tr><tr><td><code>CMAKE_CURRENT_SOURCE_DIR</code></td><td>当前 <code>CMakeLists.txt</code> 文件所在目录</td><td>✅ 是</td><td>❌ 否</td><td>当前目录相关文件引用（强烈推荐）</td><td>获取当前 CMakeLists 所在目录</td></tr></tbody></table><span id="more"></span>]]></content>
    
    
    <summary type="html">本文主要介绍记录 CMake 日常开发中的使用技巧和踩坑经历。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发随笔" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 实现 RPC 分布式网络通信框架</title>
    <link href="https://www.techgrow.cn/posts/5e6aa28a.html"/>
    <id>https://www.techgrow.cn/posts/5e6aa28a.html</id>
    <published>2025-06-08T13:55:33.000Z</published>
    <updated>2025-06-21T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写高性能网络库（Muduo）</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 Muduo 高性能网络库 + Protobuf 开发 RPC 框架，并使用中间件 ZooKeeper。</p><span id="more"></span><h3 id="开发工具列表"><a href="#开发工具列表" class="headerlink" title="开发工具列表"></a>开发工具列表</h3><table><thead><tr><th>软件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>17</code></td><td>高版本的 Protobuf 库依赖 C++ 17</td></tr><tr><td>Boost</td><td><code>1.74.0.3</code></td><td>Muduo 库依赖 Boost 库</td></tr><tr><td> Muduo</td><td><code>2.0.3</code></td><td><a href="https://github.com/chenshuo/muduo">Muduo 库</a>，基于 C++ 开发，用于网络编程</td></tr><tr><td> Protobuf</td><td><code>31.1</code></td><td><a href="https://github.com/protocolbuffers/protobuf">Protobuf 库</a>，核心代码主要是用 C++ 开发</td></tr><tr><td> ZooKeeper C API</td><td><code>3.8.0</code></td><td>ZooKeeper 提供的原生 C API，基于 C 语言开发</td></tr><tr><td> G++（GCC）</td><td><code>12.2.0</code></td><td>建议使用 <code>9</code> 版本的 G++（GCC） 编译器</td></tr><tr><td> CMake</td><td><code>3.25.1</code></td><td>C/C++ 项目构建工具</td></tr><tr><td> ZooKeeper</td><td><code>3.8.0</code></td><td>ZooKeeper 服务器</td></tr><tr><td> Linux</td><td><code>Debian 12</code></td><td>Muduo 库不支持 Windows 平台</td></tr><tr><td> Visual Studio Code</td><td><code>1.100.2</code></td><td>使用 VSCode 远程开发特性</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">平台兼容性说明</p><p>由于使用了 Muduo 库，且 Muduo 库仅支持 Linux 平台；因此本文提供的所有 RPC 框架代码支持在 Linux 平台运行，不支持 Windows 平台，默认是基于 Debian 12 进行远程开发。</p></div><h3 id="开源-RPC-框架"><a href="#开源-RPC-框架" class="headerlink" title="开源 RPC 框架"></a>开源 RPC 框架</h3><h4 id="大厂开源框架"><a href="#大厂开源框架" class="headerlink" title="大厂开源框架"></a>大厂开源框架</h4><ul><li><a href="https://github.com/grpc/grpc">gRPC</a> 是一个由 Google 开源、基于 HTTP/2 和 Protocol Buffers 的高性能 RPC 框架，使用 C++ 开发，支持多种语言（如 Go、Java、Python 等）。</li><li><a href="https://github.com/apache/brpc">bRPC</a> 是百度开源的高性能、可扩展的 RPC 框架，主要用于服务器间通信，采用 C++ 编写，广泛应用于百度内部大规模分布式系统中。</li><li><a href="https://github.com/Tencent/phxrpc">phxrpc</a> 是腾讯微信后台团队推出的一个非常简洁小巧的 RPC 框架，编译生成的库只有 450K。</li></ul><h4 id="个人开源框架"><a href="#个人开源框架" class="headerlink" title="个人开源框架"></a>个人开源框架</h4><ul><li><a href="https://github.com/Gooddbird/tinyrpc">tinyrpc</a> - c++ async rpc framework. 14w+ qps.</li><li><a href="https://github.com/Gooddbird/rocket">rocket</a> - c++ rpc framework, simplified version of tinyrpc.</li><li><a href="https://github.com/qicosmos/rest_rpc">rest_rpc</a>  - modern c++, simple, easy to use rpc framework.</li><li><a href="https://github.com/rpclib/rpclib">rpclib</a> - a modern c++ msgpack-RPC server and client library.</li><li><a href="https://github.com/TarsCloud/TarsCpp?tab=readme-ov-file">TarsCpp</a> - c++ language framework rpc source code implementation.</li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="集群和分布式"><a href="#集群和分布式" class="headerlink" title="集群和分布式"></a>集群和分布式</h3><ul><li><p><strong>集群</strong></p><ul><li>概念<ul><li>每一台服务器独立运行一个工程的所有模块。</li></ul></li><li>优点<ul><li>部署简单：每台机器部署一样的工程，维护相对简单。</li><li>容错性强：某台机器宕机，其它机器可以顶上，保证服务连续。</li><li>扩展方便：增加机器即可横向扩展，提高并发处理能力。</li><li>负载均衡容易：前端加个负载均衡器即可实现请求均衡分发。</li></ul></li><li>缺点<ul><li>资源浪费：每台机器都部署所有模块，某些模块可能资源使用率低。</li><li>维护更新不灵活：改动一个模块需要重新部署整个工程。</li><li>扩展粒度粗：不能单独扩展某个压力大的模块（有些模块是 CPU 密集型，有些模块是 I/O 密集型），只能整体扩容。</li></ul></li></ul></li><li><p><strong>分布式</strong></p><ul><li>概念<ul><li>一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务。</li><li>每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</li></ul></li><li>优点<ul><li>资源利用率高：按模块实际资源需求进行部署，提高系统整体资源使用效率。</li><li>扩展灵活：哪个模块压力大就单独扩展它，不影响其它模块。</li><li>服务解耦：模块之间独立部署、独立维护，开发和运维更灵活。</li><li>技术异构性好：不同模块可以使用不同的技术栈，更自由地选择工具。</li></ul></li><li>缺点<ul><li>系统复杂度高：涉及服务间通信、分布式事务、网络延迟等问题。</li><li>开发运维成本高：部署、调试、监控、容错等方面的技术要求更高。</li><li>依赖网络稳定性：模块之间通过网络通信，一旦网络出问题可能会引发级联故障。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">详细图解说明</p><ul><li><a href="../../../asset/2025/01/cluster-distribute-1.png">集群和分布式的理解</a></li><li><a href="../../../asset/2024/12/dubbo-16.png">单体架构的部署拓扑图</a></li><li><a href="../../../asset/2024/12/dubbo-15.png">集群架构的部署拓扑图</a></li><li><a href="../../../asset/2024/12/dubbo-14.png">分布式架构的部署拓扑图</a></li></ul></div><div class="admonition warning"><p class="admonition-title">特别注意</p><p><strong>在企业的生产环境中，集群和分布式是并存的，两者并不是分开的。</strong></p></div><h3 id="RPC-通信原理"><a href="#RPC-通信原理" class="headerlink" title="RPC 通信原理"></a>RPC 通信原理</h3><p>RPC（Remote Procedure Call）远程过程调用的工作流程如下图所示：</p><p><img data-src="../../../asset/2025/06/cxx-rpc-1.png"></p><ul><li><strong>黄色部分</strong>：设计 RPC 方法参数的打包和解析，也就是数据的序列化和反序列化，可以使用 Protobuf 实现。</li><li><strong>绿色部分</strong>：网络通信部分，包括寻找 RPC 服务主机、发起 RPC 调用请求和响应 RPC 调用结果，可以使用 Muduo 网络库和 ZooKeeper（用于服务注册与发现）实现 。</li></ul><h3 id="网络-I-O-模型"><a href="#网络-I-O-模型" class="headerlink" title="网络 I/O 模型"></a>网络 I/O 模型</h3><p>主流的网络 I/O 模型有以下几种，Muduo 采用的是第四种（<code>reactors in threads - one loop per thread</code>）。</p><ul><li><p>(1) <code>accept + read/write</code></p><ul><li>不适用于并发服务器</li></ul></li><li><p> (2) <code>accept + fork - process-pre-connection</code></p><ul><li>适合并发连接数不大，计算任务工作量大于 Fork 的开销。</li></ul></li><li><p>(3) <code>accept + thread - thread-pre-connection</code></p><ul><li>比第二种网络 I/O 模型的开销小了一点，但是并发造成的线程堆积过多。</li></ul></li><li><p>(4) <code>reactors in threads - one loop per thread</code></p><ul><li>这是 Muduo 库的网络设计方案，底层实质上是基于 Linux 的 <code>epoll</code> + <code>pthread</code> 线程池实现，且依赖了 Boost 库，适用于并发连接数较大的场景。</li><li>有一个 Main Reactor 负载 Accept 连接，然后将连接分发给某个 SubReactor（采用轮询的方式来选择 SubReactor），该连接的所用操作都在那个 SubReactor 所处的线程中完成。多个连接可能被分派到多个线程中被处理，以充分利用 CPU。</li><li>有一个 Base I/O Thread 负责 Accept 新的连接，接收到新的连接以后，使用轮询的方式在 Reactor Pool 中找到合适的 SubReactor 将这个连接挂载上去，这个连接上的所有任务都在这个 SubReactor  所处的线程中完成。</li><li>Reactor Poll 的大小是固定的，根据 CPU 的核心数量来确定。如果有过多的耗费 CPU 资源的计算任务，可以提交到 ThreadPool 线程池中专门处理耗时的计算任务。</li></ul></li><li><p>(5) <code>reactors in process - one loop pre process</code></p><ul><li>这是 Nginx 服务器的网络设计方案，基于进程设计，采用多个 Reactors 充当 I/O 进程和工作进程，通过一个 <code>accept</code> 锁，完美解决多个 Reactors 之间的 “惊群现象”。</li></ul></li></ul><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p>本文基于 C++ 实现 RPC 框架时，使用到以下框架，主要包括 Muduo、Protobuf、ZooKeeper C API。</p><h3 id="Muduo-的简介"><a href="#Muduo-的简介" class="headerlink" title="Muduo 的简介"></a>Muduo 的简介</h3><p>Muduo 是一个用 C++ 编写的高性能、基于事件驱动的网络库，专门设计用于构建 Linux 下高并发、低延迟的网络服务，特别适合开发分布式系统、微服务、消息中间件、网络游戏服务器等后端程序。</p><ul><li><p>核心特性</p><ul><li>基于事件驱动模型：使用 Reactor 模式，即单线程 I/O + 多线程计算。</li><li>高性能：使用 <code>epoll</code> I/O 多路复用技术、非阻塞 I/O、零内存拷贝技术。</li><li>线程安全：网络部分是线程安全的，使用线程池和回调。</li><li>C++ 11 标准：需要使用支持 C++ 11 的编译器。</li><li>仅支持 Linux 平台：利用 Linux 特性优化性能，不支持跨平台。</li><li>可组合性强：解耦的模块设计，便于扩展和组合。</li></ul></li><li><p>核心模块</p><ul><li><code>base</code>（基础模块）<ul><li>非网络相关的通用工具</li><li>如线程池、时间戳、日志系统、原子操作等</li></ul></li><li><code>net</code>（网络模块）<ul><li>TCP 服务器 / 客户端模型</li><li> Reactor 事件分发器</li><li> Buffer、Channel、EventLoop、TcpConnection 等核心组件</li></ul></li></ul></li><li><p>核心组件</p><ul><li>EventLoop<ul><li> 事件循环，是每个线程的核心对象</li><li>封装了 <code>epoll</code> 库，处理文件描述符的读写事件</li></ul></li><li> Channel<ul><li> 表示一个 <code>fd</code>（文件描述符）及其感兴趣的事件（如读写）</li><li>是 EventLoop 与具体 I/O 事件之间的桥梁</li></ul></li><li> Poller<ul><li> 封装 <code>epoll</code> 或 <code>poll</code> 的接口（Muduo 默认用 <code>epoll</code>）</li></ul></li><li>TcpServer / TcpClient<ul><li> 高层封装，简化服务端和客户端的使用</li><li>支持多线程连接处理</li></ul></li><li> Callback 机制<ul><li>所有 I/O 事件都通过用户注册的回调函数处理（高扩展性）</li></ul></li></ul></li><li><p>性能优势</p><ul><li>完全采用非阻塞、异步 I/O 模型</li><li>使用智能指针管理资源（如 <code>std::shared_ptr&lt;TcpConnection&gt;</code>）</li><li>零内存拷贝的数据缓冲机制（Buffer）</li><li>合理利用多线程资源（EventLoopThreadPool）</li></ul></li><li><p>适用场景</p><ul><li>高并发 TCP 服务器（如 Redis、MQTT、游戏网关）</li><li>微服务通信框架（可自定义通信协议）</li><li>高性能 HTTP 服务（支持 HTTP 1.0/1.1）</li><li>自研 RPC 系统</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">平台兼容性</p><ul><li>Muduo 库只支持 Linux 平台，不兼容 Windows 平台，因为其底层使用了 Linux 平台的 <code>pthread</code> 和 <code>epoll</code>。</li></ul></div><h3 id="Protobuf-的简介"><a href="#Protobuf-的简介" class="headerlink" title="Protobuf 的简介"></a>Protobuf 的简介</h3><ul><li><p>Protocol Buffers（简称 Protobuf）是 Google 提出的一种高效、可扩展的结构化数据序列化格式，用于数据交换。它独立于平台和编程语言，具有良好的跨平台兼容性和扩展性。</p></li><li><p>Google 为多种主流编程语言提供了 Protobuf 的官方实现，包括 Java、C#、C++、Go 和 Python 等。每种语言的实现都包含相应的编译器插件（<code>protoc</code>）和运行时库，使得开发者可以在不同语言间无缝进行数据通信。</p></li><li><p>由于 Protobuf 采用紧凑的二进制编码格式，其序列化和反序列化效率远高于基于文本的格式。相比 XML，Protobuf 的传输效率可提高约 20 倍；相比 JSON，也有近 10 倍的性能提升。这使得它特别适用于对性能要求高的场景。</p></li><li><p>Protobuf 广泛应用于分布式系统间的数据通信、异构平台的数据交换，也适合用作网络传输协议的数据格式、高效配置文件的载体、或用于数据持久化存储。作为一种兼具效率与可维护性的序列化方案，Protobuf 在大规模系统设计中具有极高的实用价值。</p></li></ul><h3 id="ZooKeeper-C-API-的简介"><a href="#ZooKeeper-C-API-的简介" class="headerlink" title="ZooKeeper C API 的简介"></a>ZooKeeper C API 的简介</h3><p>ZooKeeper C API 是 ZooKeeper 提供的一套原生 C 语言接口，它提供两个版本，包括 <code>libzookeeper_mt</code>（多线程版）和 <code>libzookeeper_st</code>（单线程版），可以用于 C/C++ 编写客户端程序，通常使用的是 <code>libzookeeper_mt</code>（多线程版）。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-Boost-库"><a href="#安装-Boost-库" class="headerlink" title="安装 Boost 库"></a>安装 Boost 库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Boost 的所有组件和头文件</span></span><br><span class="line">sudo apt-get install -y libboost-all-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Bootst 版本</span></span><br><span class="line">sudo dpkg -s libboost-all-dev | grep Version</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>由于 Muduo 使用了 Boost 库（如 <code>boost::any</code>），因此需要安装 Boost 库。</p></div><h3 id="安裝-Muduo-库"><a href="#安裝-Muduo-库" class="headerlink" title="安裝 Muduo 库"></a>安裝 Muduo 库</h3><ul><li>编译安装 Muduo 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chenshuo/muduo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入代码目录</span></span><br><span class="line"><span class="built_in">cd</span> muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Muduo 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Muduo 库的静态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep muduo</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Muduo 的编译依赖 CMake 和 Boost 库，默认编译生成的是静态库（<code>.a</code>），如果需要编译生成共享库（<code>.so</code>），可以自行修改 <code>CMakeLists.txt</code> 中的配置。</li><li>Muduo 支持 C++ 11，仅支持 Linux 平台，不支持 Windows 平台，建议使用 <code>7.x</code> 及以后版本的 <code>g++</code> 编译器。</li></ul></div><h3 id="安装-Protobuf-库"><a href="#安装-Protobuf-库" class="headerlink" title="安装 Protobuf 库"></a>安装 Protobuf 库</h3><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Protobuf 各个版本的源码包可以从 <a href="https://github.com/protocolbuffers/protobuf/releases">GitHub Release</a> 下载得到。</li><li>Protobuf 从 <code>3.21</code> 版本开始，Google 官方已经弃用了 <code>autogen.sh</code> 和 <code>configure</code> 构建系统，转而使用 CMake 作为主要构建系统。</li><li>Protobuf 从源码编译后，默认只会生成 <code>.a</code> 静态库文件，若希望生成 <code>.so</code> 动态库文件，需要在编译时添加 CMake 参数 <code>-DBUILD_SHARED_LIBS=ON</code>，加上参数后只会生成 <code>.so</code> 动态库文件。</li></ul></div><ul><li>安装依赖包 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install cmake g++ make git wget</span><br></pre></td></tr></tbody></table></figure><ul><li>编译安装 Protobuf 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://github.com/protocolbuffers/protobuf/archive/refs/tags/v31.1.tar.gz -O protobuf-v31.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf protobuf-v31.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cd</span> protobuf-31.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化子模块</span></span><br><span class="line">git init &amp;&amp; git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件（Makefile）</span></span><br><span class="line">cmake .. -DBUILD_SHARED_LIBS=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码（耗时较长）</span></span><br><span class="line">make -j2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装（包括可执行文件、头文件和库）</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 Protobuf 库安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Protobuf 库的版本</span></span><br><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Protobuf 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/google/protobuf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Protobuf 库的动态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib/libproto*</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-ZooKeeper-中间件"><a href="#安装-ZooKeeper-中间件" class="headerlink" title="安装 ZooKeeper 中间件"></a>安装 ZooKeeper 中间件</h3><h4 id="安装-ZooKeeper-服务器"><a href="#安装-ZooKeeper-服务器" class="headerlink" title="安装 ZooKeeper 服务器"></a>安装 ZooKeeper 服务器</h4><ul><li>安装 ZooKeeper 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ZooKeeper 客户端和服务器</span></span><br><span class="line">sudo apt install -y zookeeper zookeeperd</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 ZooKeeper 客户端的软链接 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 客户端的安装位置</span></span><br><span class="line">sudo dpkg -L zookeeper | grep -E <span class="string">'zkCli.sh|zkEnv.sh'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 ZooKeeper 客户端的软链接（方便以后直接运行客户端）</span></span><br><span class="line">sudo ln -s /usr/share/zookeeper/bin/zkCli.sh /usr/<span class="built_in">local</span>/bin/zkCli.sh</span><br><span class="line">sudo ln -s /usr/share/zookeeper/bin/zkEnv.sh /usr/<span class="built_in">local</span>/bin/zkEnv.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 ZooKeeper 服务器安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 服务器的运行状态</span></span><br><span class="line">sudo systemctl status zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 ZooKeeper 客户端连接 ZooKeeper 服务器</span></span><br><span class="line">zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></tbody></table></figure><ul><li>ZooKeeper 服务器的安装信息</li></ul><table><thead><tr><th>安装信息</th><th>说明</th></tr></thead><tbody><tr><td>默认的监听端口</td><td><code>2181</code></td></tr><tr><td>默认的数据目录</td><td><code>/tmp/zookeeper</code></td></tr><tr><td>默认配置文件的路径</td><td><code>/etc/zookeeper/conf/zoo.cfg</code></td></tr></tbody></table><h4 id="安装-ZooKeeper-C-API-库"><a href="#安装-ZooKeeper-C-API-库" class="headerlink" title="安装 ZooKeeper C API 库"></a>安装 ZooKeeper C API 库</h4><p>由于本文的 RPC 项目使用 ZooKeeper C API 库来实现 RPC 服务动态注册和发现，因此需要安装 ZooKeeper C API 库。值得一提的是，ZooKeeper 提供了一个 <code>libzookeeper_mt</code>（多线程版）或 <code>libzookeeper_st</code>（单线程版）原生 C API，可以用于 C/C++ 编写客户端程序，通常使用的是 <code>libzookeeper_mt</code>（多线程版）。在 Linux 系统上，除了可以通过 APT / YUM 包管理工具直接安装 ZooKeeper C API 库，还可以手动编译 ZooKeeper 的源码来安装 ZooKeeper C API 库，具体编译步骤为 <code>.configure</code> + <code>make</code> + <code>makeinstall</code>，默认会编译生成多线程版本的库（<code>libzookeeper_mt.so</code>）和单线程版的库（如 <code>libzookeeper_st.so</code>）。</p><ul><li>安装 ZooKeeper C API 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ZooKeeper 多线程版的开发包（单线程版本是：libzookeeper-st-dev）</span></span><br><span class="line">sudo apt install -y libzookeeper-mt-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 ZooKeeper C API 库安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 的头文件</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep zookeeper.h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 的静态库</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep <span class="string">'\.a$'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 的动态库</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep <span class="string">'\.so'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>ZooKeeper C API 库的安装信息</li></ul><table><thead><tr><th>安装信息</th><th>说明</th></tr></thead><tbody><tr><td>头文件的路径</td><td><code>/usr/include/zookeeper/zookeeper.h</code></td></tr><tr><td>静态库的路径</td><td><code>/usr/lib/x86_64-linux-gnu/libzookeeper_mt.a</code></td></tr><tr><td>动态库的路径</td><td><code>/usr/lib/x86_64-linux-gnu/libzookeeper_mt.so</code></td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">使用原生 ZooKeeper C API 库的注意事项</p><ul><li>(1) 设置监听 Watcher 是一次性的，监听事件触发后 Watch 会立即失效，ZooKeeper 不会自动重新注册。若希望持续监听同一个节点变化，需要在回调中手动再次注册 Watch。</li><li>(2) ZNode 节点仅支持存储简单的 <code>byte</code> 字节数组（最大 1MB），不具备结构化存储能力。如果需要存储结构体或对象，需要自行将其转换为字节数组，例如使用 JSON、Protobuf 等序列化方式进行编码与解码。</li></ul></div><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">c++-project-mprpc</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── conf</span><br><span class="line">│   └── rpc.conf</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── consumer</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── rpcconsumer.cc</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   ├── friend.pb.cc</span><br><span class="line">│   │   ├── friend.pb.h</span><br><span class="line">│   │   ├── user.pb.cc</span><br><span class="line">│   │   └── user.pb.h</span><br><span class="line">│   ├── proto</span><br><span class="line">│   │   ├── friend.proto</span><br><span class="line">│   │   └── user.proto</span><br><span class="line">│   └── provider</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">│       └── rpcprovider.cc</span><br><span class="line">├── lib</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   ├── rpcheader.pb.cc</span><br><span class="line">│   │   └── rpcheader.pb.h</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   ├── lockqueue.h</span><br><span class="line">│   │   ├── logger.h</span><br><span class="line">│   │   ├── mprpccontext.h</span><br><span class="line">│   │   ├── mprpcchannel.h</span><br><span class="line">│   │   ├── mprpcconfig.h</span><br><span class="line">│   │   ├── mprpccontroller.h</span><br><span class="line">│   │   ├── mprpcprovider.h</span><br><span class="line">│   │   ├── networkutil.h</span><br><span class="line">│   │   └── zookeeperclient.h</span><br><span class="line">│   ├── logger.cc</span><br><span class="line">│   ├── mprpccontext.cc</span><br><span class="line">│   ├── mprpcchannel.cc</span><br><span class="line">│   ├── mprpcconfig.cc</span><br><span class="line">│   ├── mprpccontroller.cc</span><br><span class="line">│   ├── mprpcprovider.cc</span><br><span class="line">│   ├── networkutil.cc</span><br><span class="line">│   ├── proto</span><br><span class="line">│   │   └── rpcheader.proto</span><br><span class="line">│   └── zookeeperclient.cc</span><br><span class="line">└── test</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── protobuf</span><br><span class="line">    │   ├── CMakeLists.txt</span><br><span class="line">    │   ├── generated</span><br><span class="line">    │   │   ├── addressbook.pb.cc</span><br><span class="line">    │   │   ├── addressbook.pb.h</span><br><span class="line">    │   │   ├── friendservice.pb.cc</span><br><span class="line">    │   │   ├── friendservice.pb.h</span><br><span class="line">    │   │   ├── groupservice.pb.cc</span><br><span class="line">    │   │   ├── groupservice.pb.h</span><br><span class="line">    │   │   ├── userservice.pb.cc</span><br><span class="line">    │   │   └── userservice.pb.h</span><br><span class="line">    │   ├── main.cc</span><br><span class="line">    │   └── proto</span><br><span class="line">    │       ├── addressbook.proto</span><br><span class="line">    │       ├── friendservice.proto</span><br><span class="line">    │       ├── groupservice.proto</span><br><span class="line">    │       └── userservice.proto</span><br><span class="line">    └── zookeeper</span><br><span class="line">        ├── CMakeLists.txt</span><br><span class="line">        └── main.cc</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>目录名称</th><th>目录说明</th></tr></thead><tbody><tr><td><code>build</code></td><td>CMake 编译构建项目的目录（项目首次编译后才会有）</td></tr><tr><td><code>bin</code></td><td>存放项目编译生成的可执行文件的目录（项目首次编译后才会有）</td></tr><tr><td><code>lib</code></td><td>存放项目编译生成的 RPC 框架头文件和静态库的目录（项目首次编译后才会有）</td></tr><tr><td><code>conf</code></td><td>存放 RPC 框架的配置文件</td></tr><tr><td><code>proto</code></td><td>存放 Protobuf 的 <code>.proto</code> 协议文件</td></tr><tr><td><code>generated</code></td><td>存放根据 <code>.proto</code> 协议文件生成的 C++ 头文件和源文件</td></tr><tr><td><code>src</code></td><td>RPC 框架源码</td></tr><tr><td><code>test</code></td><td>第三方库的测试代码</td></tr><tr><td><code>test/protobuf/</code></td><td>Protobuf 的测试代码</td></tr><tr><td><code>test/zookeeper/</code></td><td>ZooKeeper 的测试代码</td></tr><tr><td><code>example</code></td><td>RPC 框架的使用案例代码</td></tr><tr><td><code>example/provider</code></td><td>RPC 框架（服务提供者）的使用案例代码</td></tr><tr><td><code>example/consumer</code></td><td>RPC 框架（服务调用者）的使用案例代码</td></tr><tr><td><code>autobuild.sh</code></td><td>项目一键编译构建的脚本文件</td></tr></tbody></table><h3 id="项目原理"><a href="#项目原理" class="headerlink" title="项目原理"></a>项目原理</h3><p><img data-src="../../../asset/2025/06/cxx-rpc-2.png"></p><h3 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h3><p>基于 C++ 开发 RPC 框架时，使用到以下技术：</p><ul><li>单例模式</li><li> Conf 配置文件读取</li><li> Muduo 网络库编程</li><li> CMake 构建项目集成编译环境</li><li>异步日志记录（线程同步通信实现）</li><li>Protobuf 数据序列化和反序列化协议</li><li> ZooKeeper 分布式一致性协调服务应用以及编程</li></ul><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><h3 id="RPC-框架核心代码"><a href="#RPC-框架核心代码" class="headerlink" title="RPC 框架核心代码"></a>RPC 框架核心代码</h3><p>由于篇幅有限，下面只给出 RPC 框架项目的核心代码，完整的项目代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-mprpc">这里</a> 获取得到。</p><h4 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h4><ul><li><code>networkutil.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ifaddrs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络工具类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkUtil</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkUtil&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地的 IP 地址，可指定网络接口名称（比如 eth0）</span></span><br><span class="line">    <span class="function">std::string <span class="title">FindLocalIp</span><span class="params">(<span class="keyword">const</span> std::string&amp; network_interface = <span class="string">""</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个未被占用的端口，可指定端口区间（比如 [7000, 9000]）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindAvailablePort</span><span class="params">(<span class="keyword">int</span> low = <span class="number">7000</span>, <span class="keyword">int</span> high = <span class="number">9000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">NetworkUtil</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">NetworkUtil</span>(<span class="keyword">const</span> NetworkUtil&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    NetworkUtil&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NetworkUtil&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>networkutil.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"networkutil.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">NetworkUtil&amp; <span class="title">NetworkUtil::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> NetworkUtil instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本地的 IP 地址，可指定网络接口名称（比如 eth0）</span></span><br><span class="line"><span class="function">std::string <span class="title">NetworkUtil::FindLocalIp</span><span class="params">(<span class="keyword">const</span> std::string&amp; network_interface)</span> </span>{</span><br><span class="line">    std::string result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地网络接口的信息链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span>* <span class="title">ifaddr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getifaddrs</span>(&amp;ifaddr) == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// Fallback 处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历本地网络接口的信息链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* ifa = ifaddr; ifa; ifa = ifa-&gt;ifa_next) {</span><br><span class="line">        <span class="keyword">if</span> (!ifa-&gt;ifa_addr || ifa-&gt;ifa_addr-&gt;sa_family != AF_INET) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取网络接口的名称</span></span><br><span class="line">        <span class="function">std::string <span class="title">name</span><span class="params">(ifa-&gt;ifa_name)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过 lo 接口（回环接口）</span></span><br><span class="line">        <span class="keyword">if</span> (ifa-&gt;ifa_flags &amp; IFF_LOOPBACK) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指定了网络接口（如 eth0），且匹配上了，就直接使用</span></span><br><span class="line">        <span class="keyword">if</span> (!network_interface.<span class="built_in">empty</span>() &amp;&amp; name == network_interface) {</span><br><span class="line">            <span class="keyword">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;((struct sockaddr_in*)ifa-&gt;ifa_addr)-&gt;sin_addr, ip, <span class="built_in"><span class="keyword">sizeof</span></span>(ip));</span><br><span class="line">            result = ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认选择 eth0、ens33、enp0s3 等常见有线网卡</span></span><br><span class="line">        <span class="keyword">if</span> (network_interface.<span class="built_in">empty</span>() &amp;&amp; (name.<span class="built_in">find</span>(<span class="string">"eth"</span>) == <span class="number">0</span> || name.<span class="built_in">find</span>(<span class="string">"en"</span>) == <span class="number">0</span>)) {</span><br><span class="line">            <span class="keyword">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;((struct sockaddr_in*)ifa-&gt;ifa_addr)-&gt;sin_addr, ip, <span class="built_in"><span class="keyword">sizeof</span></span>(ip));</span><br><span class="line">            result = ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">freeifaddrs</span>(ifaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">empty</span>() ? <span class="string">"127.0.0.1"</span> : result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个未被占用的端口，可指定端口区间（比如 [7000, 9000]）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NetworkUtil::FindAvailablePort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历指定区间内的所有端口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> port = low; port &lt;= high; ++port) {</span><br><span class="line">        <span class="comment">// 创建一个 IPv4 TCP Socket</span></span><br><span class="line">        <span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 创建 Socket 失败，尝试下一个端口</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 Socket 地址，绑定到任意本地地址（0.0.0.0）和当前端口</span></span><br><span class="line">        sockaddr_in addr{};</span><br><span class="line">        addr.sin_family = AF_INET;</span><br><span class="line">        addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Socket 选项：SO_REUSEADDR 允许端口重复绑定（避免 TIME_WAIT 问题）</span></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in"><span class="keyword">sizeof</span></span>(opt));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试将 Socket 绑定到指定端口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (sockaddr*)&amp;addr, <span class="built_in"><span class="keyword">sizeof</span></span>(addr)) == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 绑定成功，释放资源（因为这里只是探测端口是否可用）</span></span><br><span class="line">            <span class="built_in">close</span>(sockfd);</span><br><span class="line">            <span class="comment">// 返回找到的可用端口</span></span><br><span class="line">            <span class="keyword">return</span> port;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 端口绑定失败，说明端口已被占用或其他错误，释放资源</span></span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历完指定的端口区间，没有找到可用端口，返回 -1 表示失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="异步日志记录"><a href="#异步日志记录" class="headerlink" title="异步日志记录"></a>异步日志记录</h4><ul><li><code>lockqueue.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步写日志的日志队列（线程安全）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 往队尾插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入数据</span></span><br><span class="line">        m_queue.<span class="built_in">push</span>(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒日志写入线程去消费队列中的数据</span></span><br><span class="line">        m_condvariable.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往队头弹出数据</span></span><br><span class="line">    <span class="function">T <span class="title">Pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到队列不为空或者已退出</span></span><br><span class="line">        m_condvariable.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>() || m_exit; });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视业务逻辑而定，可以返回空数据或者抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (m_exit &amp;&amp; m_queue.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">return</span> {};</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取队头元素</span></span><br><span class="line">        T data = m_queue.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出队头元素</span></span><br><span class="line">        m_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭队列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 设置退出标志</span></span><br><span class="line">        m_exit = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 唤醒正在等待的日志写入线程</span></span><br><span class="line">        m_condvariable.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取退出标志</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isExit</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> m_exit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex m_mutex;                      <span class="comment">// 互斥锁</span></span><br><span class="line">    std::queue&lt;T&gt; m_queue;                   <span class="comment">// 队列</span></span><br><span class="line">    std::condition_variable m_condvariable;  <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="keyword">bool</span> m_exit = <span class="literal">false</span>;                     <span class="comment">// 退出标志，用于避免发生线程死锁</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>logger.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lockqueue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG(logmsgformat, ...)                                \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= DEBUG) {                        \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {DEBUG, c, thread_id};                 \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO(logmsgformat, ...)                                 \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= INFO) {                         \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {INFO, c, thread_id};                  \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_WARN(logmsgformat, ...)                                 \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= WARN) {                         \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {WARN, c, thread_id};                  \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERROR(logmsgformat, ...)                                \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= ERROR) {                        \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {ERROR, c, thread_id};                 \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别（DEBUG &lt; INFO &lt; WARN &lt; ERROR）</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LogLevel</span> {</span></span><br><span class="line">    DEBUG,  <span class="comment">// 调试日志信息</span></span><br><span class="line">    INFO,   <span class="comment">// 普通日志信息</span></span><br><span class="line">    WARN,   <span class="comment">// 警告日志信息</span></span><br><span class="line">    ERROR,  <span class="comment">// 错误日志信息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LogMessage</span> {</span></span><br><span class="line">    LogLevel m_loglevel;         <span class="comment">// 日志级别</span></span><br><span class="line">    std::string m_logcontent;    <span class="comment">// 日志内容</span></span><br><span class="line">    std::thread::id m_threadid;  <span class="comment">// 打印日志的线程的 ID</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mprpc 框架提供的日志系统（单例对象，异步写入日志文件）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Logger&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入日志信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Log</span><span class="params">(<span class="keyword">const</span> LogMessage&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取日志级别</span></span><br><span class="line">    <span class="function">LogLevel <span class="title">GetLogLevel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetLogLevel</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LogLevel m_loglevel;             <span class="comment">// 记录日志级别</span></span><br><span class="line">    std::thread m_writeThread;       <span class="comment">// 日志写入线程</span></span><br><span class="line">    LockQueue&lt;LogMessage&gt; m_lckQue;  <span class="comment">// 日志缓冲队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="keyword">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算操作符</span></span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取日志级别的名称</span></span><br><span class="line">    <span class="function">std::string <span class="title">LogLevelToString</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>logger.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Logger::<span class="built_in">Logger</span>() {</span><br><span class="line">    <span class="comment">// 设置默认的日志级别</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_loglevel = INFO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动专门写日志文件的线程</span></span><br><span class="line">    m_writeThread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 获取当前日期</span></span><br><span class="line">            <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            tm* now_tm = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取日志文件的名称</span></span><br><span class="line">            <span class="keyword">char</span> file_name[<span class="number">128</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(file_name, <span class="string">"%d-%d-%d-log.txt"</span>, now_tm-&gt;tm_year + <span class="number">1900</span>, now_tm-&gt;tm_mon + <span class="number">1</span>, now_tm-&gt;tm_mday);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开日志文件</span></span><br><span class="line">            FILE* pf = <span class="built_in">fopen</span>(file_name, <span class="string">"a+"</span>);</span><br><span class="line">            <span class="keyword">if</span> (pf == <span class="literal">nullptr</span>) {</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"logger file "</span> &lt;&lt; file_name &lt;&lt; <span class="string">" open failed!"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从日志缓冲队列获取日志信息（会阻塞当前线程，直到日志队列不为空）</span></span><br><span class="line">            LogMessage message = m_lckQue.<span class="built_in">Pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查退出标志</span></span><br><span class="line">            <span class="keyword">if</span> (m_lckQue.<span class="built_in">isExit</span>()) {</span><br><span class="line">                <span class="comment">// 关闭日志文件</span></span><br><span class="line">                <span class="built_in">fclose</span>(pf);</span><br><span class="line">                <span class="comment">// 跳出外层 For 循环，结束日志写入线程的运行（会丢失未被写入的日志信息）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取打印日志信息的线程的 ID（可能为负数）</span></span><br><span class="line">            std::thread::id real_thread_id = message.m_threadid;</span><br><span class="line">            std::ostringstream oss;</span><br><span class="line">            oss &lt;&lt; real_thread_id;</span><br><span class="line">            std::string log_thread_id = oss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取日志内容和日志级别的名称</span></span><br><span class="line">            std::string&amp; log_content = message.m_logcontent;</span><br><span class="line">            std::string log_level_name = <span class="built_in">LogLevelToString</span>(message.m_loglevel);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前时间</span></span><br><span class="line">            <span class="keyword">char</span> time_buf[<span class="number">128</span>] = {<span class="number">0</span>};</span><br><span class="line">            <span class="built_in">sprintf</span>(time_buf, <span class="string">"%d-%d-%d %d:%d:%d =&gt; %d [%s] "</span>, now_tm-&gt;tm_year + <span class="number">1900</span>, now_tm-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                    now_tm-&gt;tm_mday, now_tm-&gt;tm_hour, now_tm-&gt;tm_min, now_tm-&gt;tm_sec, log_thread_id.<span class="built_in">c_str</span>(),</span><br><span class="line">                    log_level_name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加当前时间到日志内容的最前面</span></span><br><span class="line">            log_content.<span class="built_in">insert</span>(<span class="number">0</span>, time_buf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加换行符到日志内容的最后面</span></span><br><span class="line">            log_content.<span class="built_in">append</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志内容到控制台</span></span><br><span class="line">            std::cout &lt;&lt; log_content;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将日志内容写入日志文件</span></span><br><span class="line">            <span class="built_in">fputs</span>(log_content.<span class="built_in">c_str</span>(), pf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭日志文件</span></span><br><span class="line">            <span class="built_in">fclose</span>(pf);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Logger::~<span class="built_in">Logger</span>() {</span><br><span class="line">    <span class="comment">// 关闭队列，通知日志写入线程停止运行，避免发生线程死锁</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_lckQue.<span class="built_in">Stop</span>();</span><br><span class="line">    <span class="comment">// 等待日志线程安全退出</span></span><br><span class="line">    <span class="keyword">if</span> (m_writeThread.<span class="built_in">joinable</span>()) {</span><br><span class="line">        m_writeThread.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入日志信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::Log</span><span class="params">(<span class="keyword">const</span> LogMessage&amp; message)</span> </span>{</span><br><span class="line">    <span class="comment">// 将日志信息写入缓冲队列中</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_lckQue.<span class="built_in">Push</span>(message);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::SetLogLevel</span><span class="params">(LogLevel level)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_loglevel = level;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别</span></span><br><span class="line"><span class="function">LogLevel <span class="title">Logger::GetLogLevel</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_loglevel;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别的名称</span></span><br><span class="line"><span class="function">std::string <span class="title">Logger::LogLevelToString</span><span class="params">(LogLevel level)</span> </span>{</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (level) {</span><br><span class="line">        <span class="keyword">case</span> DEBUG:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DEBUG"</span>;</span><br><span class="line">        <span class="keyword">case</span> INFO:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"INFO"</span>;</span><br><span class="line">        <span class="keyword">case</span> WARN:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"WARN"</span>;</span><br><span class="line">        <span class="keyword">case</span> ERROR:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"UNKNOWN"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h4><ul><li><code>rpc.conf</code> 配置文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ZooKeeper的IP地址（必填）</span><br><span class="line">zk_server_host=127.0.0.1</span><br><span class="line"># ZooKeeper的端口号（必填）</span><br><span class="line">zk_server_port=2181</span><br><span class="line"># RPC服务提供者优先使用的网卡接口（可选）</span><br><span class="line">rpc_network_interface=eth1</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcconfig.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string ZK_SERVER_HOST_KEY = <span class="string">"zk_server_host"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string ZK_SERVER_PORT_KEY = <span class="string">"zk_server_port"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string RPC_NETWORK_INTERFACE_KEY = <span class="string">"rpc_network_interface"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 框架读取配置文件的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcConfig</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* config_file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">Load</span><span class="params">(<span class="keyword">const</span> std::string&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置信息（无需考虑线程安全问题）</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Trim</span><span class="params">(std::string&amp; str)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcconfig.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcconfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcConfig::LoadConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* config_file)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断是否已经加载过配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (!m_configMap.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开配置文件</span></span><br><span class="line">    FILE* pf = <span class="built_in">fopen</span>(config_file, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == pf) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"config file "</span> &lt;&lt; config_file &lt;&lt; <span class="string">" is not exist!"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析配置文件</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), pf)) {</span><br><span class="line">        <span class="function">std::string <span class="title">src_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line">        <span class="built_in">Trim</span>(src_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断注释内容</span></span><br><span class="line">        <span class="keyword">if</span> (src_buf.<span class="built_in">empty</span>() || src_buf[<span class="number">0</span>] == <span class="string">'#'</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        <span class="keyword">int</span> idx = src_buf.<span class="built_in">find_first_of</span>(<span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">-1</span>) {</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置项的 Key</span></span><br><span class="line">        std::string key = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置项的 Value</span></span><br><span class="line">        std::string value = src_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查配置项的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (key.<span class="built_in">empty</span>() || value.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储配置项</span></span><br><span class="line">        m_configMap.<span class="built_in">insert</span>({key, value});</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s=%s"</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(pf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::Load</span><span class="params">(<span class="keyword">const</span> std::string&amp; key)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">return</span> it != m_configMap.<span class="built_in">end</span>() ? it-&gt;second : <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcConfig::Trim</span><span class="params">(std::string&amp; str)</span> </span>{</span><br><span class="line">    <span class="comment">// 定义空白字符</span></span><br><span class="line">    <span class="keyword">const</span> std::string whitespace = <span class="string">" \n\r\t"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除字符串前面多余的空白字符</span></span><br><span class="line">    <span class="keyword">size_t</span> start = str.<span class="built_in">find_first_not_of</span>(whitespace);</span><br><span class="line">    <span class="keyword">if</span> (start != std::string::npos) {</span><br><span class="line">        str = str.<span class="built_in">substr</span>(start);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 字符串全是空白字符</span></span><br><span class="line">        str.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除字符串后面多余的空白字符</span></span><br><span class="line">    <span class="keyword">size_t</span> end = str.<span class="built_in">find_last_not_of</span>(whitespace);</span><br><span class="line">    <span class="keyword">if</span> (end != std::string::npos) {</span><br><span class="line">        str = str.<span class="built_in">substr</span>(<span class="number">0</span>, end + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Protobuf-协议文件"><a href="#Protobuf-协议文件" class="headerlink" title="Protobuf 协议文件"></a>Protobuf 协议文件</h4><ul><li><code>rpcheader.proto</code> 协议文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package mprpc;</span><br><span class="line"></span><br><span class="line">message RpcHeader {</span><br><span class="line">    // RPC 调用的服务名称</span><br><span class="line">    bytes service_name = 1;</span><br><span class="line"></span><br><span class="line">    // RPC 调用的方法名称</span><br><span class="line">    bytes method_name = 2;</span><br><span class="line"></span><br><span class="line">    // RPC 调用的参数长度（参数的序列化字符串的长度）</span><br><span class="line">    uint32 args_size = 3;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的初始化"><a href="#RPC-框架的初始化" class="headerlink" title="RPC 框架的初始化"></a>RPC 框架的初始化</h4><ul><li><code>mprpccontext.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcchannel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcconfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeper 节点的路径前缀</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> std::string ZNODE_PATH_PREFIX = <span class="string">"/mprpc/services"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MPRPC 框架的上下文类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcContext</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MprpcContext&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 RPC 框架</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MprpcConfig&amp; <span class="title">GetConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置信息</span></span><br><span class="line">    <span class="keyword">static</span> MprpcConfig m_config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">MprpcContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">MprpcContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MprpcContext</span>(<span class="keyword">const</span> MprpcContext&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    MprpcContext&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MprpcContext&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpccontext.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员变量</span></span><br><span class="line">MprpcConfig MprpcContext::m_config;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">MprpcContext::<span class="built_in">MprpcContext</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MprpcContext::~<span class="built_in">MprpcContext</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">MprpcContext&amp; <span class="title">MprpcContext::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> MprpcContext singleton;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印命令帮助内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowArgsHelp</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"format: command -i &lt;configfile&gt;"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 RPC 框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcContext::Init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">        <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">        <span class="comment">// 退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令行获取配置文件的路径</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">"i:"</span>)) != <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (c) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"invalid command args!"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">                <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">':'</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"need &lt;configfile&gt;"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">                <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"loading rpc config file %s"</span>, config_file.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置文件内容</span></span><br><span class="line">    m_config.<span class="built_in">LoadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置信息</span></span><br><span class="line"><span class="function">MprpcConfig&amp; <span class="title">MprpcContext::GetConfig</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_config;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的服务注册"><a href="#RPC-框架的服务注册" class="headerlink" title="RPC 框架的服务注册"></a>RPC 框架的服务注册</h4><ul><li><code>mprpcprovider.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"google/protobuf/service.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 框架专门提供用来发布 RPC 服务的网络对象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RpcProvider</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PublishService</span><span class="params">(google::protobuf::Service* service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// TCP 服务器的事件回环</span></span><br><span class="line">    muduo::net::EventLoop m_eventloop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 服务信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ServiceInfo</span> {</span></span><br><span class="line">        <span class="comment">// RPC 服务</span></span><br><span class="line">        google::protobuf::Service* m_service;</span><br><span class="line">        <span class="comment">// RPC 服务拥有的方法</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="keyword">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储注册成功的 RPC 服务的集合</span></span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 TCP 连接的创建和断开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理已建立 TCP 连接的读写事件（比如接收客户端发送的数据）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于序列化 RPC 调用的响应结果和发送网络响应数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcprovider.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcprovider.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"networkutil.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpcheader.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布 RPC 服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::PublishService</span><span class="params">(google::protobuf::Service* service)</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 服务的信息</span></span><br><span class="line">    ServiceInfo servcieInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的描述信息</span></span><br><span class="line">    <span class="keyword">const</span> google::protobuf::ServiceDescriptor* pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的完整名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">serviceName</span><span class="params">(pserviceDesc-&gt;full_name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的方法数量</span></span><br><span class="line">    <span class="keyword">int</span> methodCount = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 RPC 服务的所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) {</span><br><span class="line">        <span class="comment">// 获取 RPC 服务的方法的描述信息</span></span><br><span class="line">        <span class="keyword">const</span> google::protobuf::MethodDescriptor* pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        <span class="comment">// 获取 RPC 服务的方法的名称</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> std::string <span class="title">methodName</span><span class="params">(pmethodDesc-&gt;name())</span></span>;</span><br><span class="line">        <span class="comment">// 存储 RPC 服务的方法的描述信息</span></span><br><span class="line">        servcieInfo.m_methodMap.<span class="built_in">insert</span>({methodName, pmethodDesc});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 RPC 服务的信息</span></span><br><span class="line">    servcieInfo.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>({serviceName, servcieInfo});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取配置信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_host = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_HOST_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_port = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_PORT_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_network_interface =</span><br><span class="line">        MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(RPC_NETWORK_INTERFACE_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务提供者的 IP 和端口</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_server_ip = NetworkUtil::<span class="built_in">GetInstance</span>().<span class="built_in">FindLocalIp</span>(rpc_network_interface);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rpc_server_port = NetworkUtil::<span class="built_in">GetInstance</span>().<span class="built_in">FindAvailablePort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 服务提供者的端口是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == rpc_server_port) {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"not found available port for rpc server!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 TCP 服务器</span></span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(rpc_server_ip, rpc_server_port)</span></span>;</span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">tcpServer</span><span class="params">(&amp;m_eventloop, address, <span class="string">"RpcProvider"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP 连接创建和断开的回调</span></span><br><span class="line">    tcpServer.<span class="built_in">setConnectionCallback</span>(<span class="built_in">bind</span>(&amp;RpcProvider::onConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置已建立 TCP 连接读写事件的回调</span></span><br><span class="line">    tcpServer.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        <span class="built_in">bind</span>(&amp;RpcProvider::onMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 EventLoop 的线程数量（比如：1 个 I/O 线程，3 个 Worker 线程）</span></span><br><span class="line">    tcpServer.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ZK 客户端</span></span><br><span class="line">    ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="keyword">bool</span> started = zkClient.<span class="built_in">Start</span>(zk_server_host, <span class="built_in">atoi</span>(zk_server_port.<span class="built_in">c_str</span>()));</span><br><span class="line">    <span class="comment">// ZK 服务端连接失败</span></span><br><span class="line">    <span class="keyword">if</span> (!started) {</span><br><span class="line">        <span class="comment">// 停止往下继续执行，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有已发布的 RPC 服务注册进 ZK 服务端</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; service : m_serviceMap) {</span><br><span class="line">        <span class="comment">// RPC 服务的 IP 和端口信息</span></span><br><span class="line">        <span class="keyword">const</span> std::string rpc_address = rpc_server_ip + <span class="string">":"</span> + std::<span class="built_in">to_string</span>(rpc_server_port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RPC 服务的名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">        <span class="keyword">const</span> std::string service_name = service.first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的路径前缀，比如 /mprpc/services/user.UserServiceRpc</span></span><br><span class="line">        <span class="keyword">const</span> std::string path_prefix = ZNODE_PATH_PREFIX + <span class="string">"/"</span> + service_name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的完整路径，比如 /mprpc/services/user.UserServiceRpc/127.0.0.1:7070</span></span><br><span class="line">        <span class="keyword">const</span> std::string node_full_path = path_prefix + <span class="string">"/"</span> + rpc_address;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的数据，比如 127.0.0.1:7070</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* node_data = rpc_address.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的数据长度</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> node_data_len = rpc_address.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ZNode 节点（临时节点）</span></span><br><span class="line">        <span class="keyword">const</span> std::string created_path =</span><br><span class="line">            zkClient.<span class="built_in">CreateRecursive</span>(node_full_path.<span class="built_in">c_str</span>(), node_data, node_data_len, ZOO_EPHEMERAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 ZNode 节点是否创建成功（即 RPC 服务是否注册成功）</span></span><br><span class="line">        <span class="keyword">if</span> (!created_path.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="comment">// ZNode 节点创建成功</span></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"success to register rpc service, name: %s, path: %s, data: %s"</span>, service_name.<span class="built_in">c_str</span>(),</span><br><span class="line">                     node_full_path.<span class="built_in">c_str</span>(), node_data);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// ZNode 节点创建失败</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"failed to register rpc service, name: %s, path: %s, data: %s"</span>, service_name.<span class="built_in">c_str</span>(),</span><br><span class="line">                      node_full_path.<span class="built_in">c_str</span>(), node_data);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"rpc provider start at %s:%d"</span>, rpc_server_ip.<span class="built_in">c_str</span>(), rpc_server_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 TCP 服务器</span></span><br><span class="line">    tcpServer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以阻塞方式等待新客户端的连接、已连接客户端的读写事件等</span></span><br><span class="line">    m_eventloop.<span class="built_in">loop</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 TCP 连接的创建和断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;<span class="built_in">connected</span>()) {</span><br><span class="line">        <span class="comment">// 断开连接（释放资源）</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 TCP 连接的读写事件（比如接收客户端发送的数据）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 接收到的字符流，数据格式：header_size（4 字节） + header_str（service_name + method_name + args_size） + args_str</span></span><br><span class="line">    <span class="keyword">const</span> std::string recv_buf = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前 4 个字节的内容</span></span><br><span class="line">    <span class="keyword">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="keyword">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 header_size 读取请求数据头的原始字符流</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的基础信息</span></span><br><span class="line">    std::string service_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="keyword">uint32_t</span> args_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 请求数据头的反序列化</span></span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    <span class="keyword">if</span> (rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str)) {</span><br><span class="line">        <span class="comment">// 数据反序列化成功</span></span><br><span class="line">        service_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 数据反序列化失败</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc header string %s unserialize error!"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的参数的字符流数据</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"header_size: %u"</span>, header_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"rpc_header_str: %s"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"service_name: %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"method_name: %s"</span>, method_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_size: %u"</span>, args_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_str: %s"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 RPC 服务</span></span><br><span class="line">    <span class="keyword">auto</span> sit = m_serviceMap.<span class="built_in">find</span>(service_name);</span><br><span class="line">    <span class="comment">// 如果找不到对应的 RPC 服务</span></span><br><span class="line">    <span class="keyword">if</span> (sit == m_serviceMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc service %s is not exist!"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 RPC 服务的方法</span></span><br><span class="line">    <span class="keyword">auto</span> mit = sit-&gt;second.m_methodMap.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span> (mit == sit-&gt;second.m_methodMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc method %s::%s is not exist!"</span>, service_name.<span class="built_in">c_str</span>(), method_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的服务和方法</span></span><br><span class="line">    google::protobuf::Service* service = sit-&gt;second.m_service;</span><br><span class="line">    <span class="keyword">const</span> google::protobuf::MethodDescriptor* method = mit-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反序列化生成本地 RPC 方法调用的请求参数</span></span><br><span class="line">    google::protobuf::Message* request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span> (!request-&gt;<span class="built_in">ParseFromString</span>(rpc_args_str)) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc request args '%s' unserialize error!"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成本地 RPC 方法调用的响应结果</span></span><br><span class="line">    google::protobuf::Message* response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地 RPC 方法调用的回调，实际上调用的是 RpcProvider::SendRpcResponse()</span></span><br><span class="line">    google::protobuf::Closure* done =</span><br><span class="line">        google::protobuf::NewCallback&lt;RpcProvider, <span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp;, google::protobuf::Message*&gt;(</span><br><span class="line">            <span class="keyword">this</span>, &amp;RpcProvider::SendRpcResponse, conn, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 节点的本地方法</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于序列化 RPC 调用的响应结果和发送网络响应数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::SendRpcResponse</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span> </span>{</span><br><span class="line">    <span class="comment">// 序列化 RPC 调用的响应结果</span></span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span> (response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str)) {</span><br><span class="line">        <span class="comment">// 通过网络将本地 RPC 方法的执行结果发送给 RPC 服务调用方</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc response serialize error!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 模拟 HTTP 的短连接服务，由 RPC 服务提供方主动断开连接</span></span><br><span class="line">    conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的服务调用"><a href="#RPC-框架的服务调用" class="headerlink" title="RPC 框架的服务调用"></a>RPC 框架的服务调用</h4><ul><li><code>mprpccontroller.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcController</span> :</span> <span class="keyword">public</span> google::protobuf::RpcController {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MprpcController</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Failed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">ErrorText</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFailed</span><span class="params">(<span class="keyword">const</span> std::string&amp; reason)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前未实现具体的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartCancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsCanceled</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_failed;          <span class="comment">// RPC 方法执行过程中的状态</span></span><br><span class="line">    std::string m_errText;  <span class="comment">// RPC 方法执行过程中的错误信息</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpccontroller.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"></span><br><span class="line">MprpcController::<span class="built_in">MprpcController</span>() {</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errText = <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::Reset</span><span class="params">()</span> </span>{</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errText = <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MprpcController::Failed</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_failed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">MprpcController::ErrorText</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_errText;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::SetFailed</span><span class="params">(<span class="keyword">const</span> std::string&amp; reason)</span> </span>{</span><br><span class="line">    m_failed = <span class="literal">true</span>;</span><br><span class="line">    m_errText = reason;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(reason.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::StartCancel</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MprpcController::IsCanceled</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcchannel.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/message.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcChannel</span> :</span> <span class="keyword">public</span> google::protobuf::RpcChannel {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 随机生成一个整数，范围 [0, range-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomInt</span><span class="params">(<span class="keyword">int</span> range)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一实现 RPC 方法调用的数据序列化和网络数据发送（针对 RPC 服务调用者）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CallMethod</span><span class="params">(<span class="keyword">const</span> google::protobuf::MethodDescriptor* method, google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> google::protobuf::Message* request, google::protobuf::Message* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                    google::protobuf::Closure* done)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcchannel.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcchannel.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpcheader.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成一个整数，范围 [0, range-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MprpcChannel::randomInt</span><span class="params">(<span class="keyword">int</span> range)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (range &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::mt19937 <span class="title">gen</span><span class="params">(std::random_device{}())</span></span>;</span><br><span class="line">        std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>, range - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dis</span>(gen);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一实现 RPC 方法调用的数据序列化和网络数据发送（针对 RPC 服务调用者）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcChannel::CallMethod</span><span class="params">(<span class="keyword">const</span> google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                              google::protobuf::RpcController* controller, <span class="keyword">const</span> google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                              google::protobuf::Message* response, google::protobuf::Closure* done)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 RPC 服务的完整名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">service_name</span><span class="params">(method-&gt;service()-&gt;full_name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的方法名称</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">method_name</span><span class="params">(method-&gt;name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用参数的序列化字符串的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> args_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_args_str;</span><br><span class="line">    <span class="keyword">if</span> (request-&gt;<span class="built_in">SerializeToString</span>(&amp;rpc_args_str)) {</span><br><span class="line">        args_size = rpc_args_str.<span class="built_in">size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"rpc request serialize error!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 RPC 调用的请求数据头</span></span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    rpcHeader.<span class="built_in">set_service_name</span>(service_name);</span><br><span class="line">    rpcHeader.<span class="built_in">set_method_name</span>(method_name);</span><br><span class="line">    rpcHeader.<span class="built_in">set_args_size</span>(args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 请求数据头的序列化字符串的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    <span class="keyword">if</span> (rpcHeader.<span class="built_in">SerializeToString</span>(&amp;rpc_header_str)) {</span><br><span class="line">        header_size = rpc_header_str.<span class="built_in">size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"rpc header serialize error!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络发送的数据，格式：header_size（4 字节） + header_str（service_name + method_name + args_size） + args_str</span></span><br><span class="line">    std::string rpc_send_str;</span><br><span class="line">    rpc_send_str.<span class="built_in">insert</span>(<span class="number">0</span>, std::<span class="built_in">string</span>((<span class="keyword">char</span>*)&amp;header_size, <span class="number">4</span>));</span><br><span class="line">    rpc_send_str += rpc_header_str;</span><br><span class="line">    rpc_send_str += rpc_args_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"header_size: %u"</span>, header_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"rpc_header_str: %s"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"service_name: %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"method_name: %s"</span>, method_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_size: %u"</span>, args_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_str: %s"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地创建一个 TCP 客户端</span></span><br><span class="line">    <span class="keyword">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clientfd) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"create socket failed, errno is %d"</span>, errno);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ZK 服务端的连接信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_host = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_HOST_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_port = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_PORT_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ZK 客户端</span></span><br><span class="line">    ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="keyword">bool</span> started = zkClient.<span class="built_in">Start</span>(zk_server_host, <span class="built_in">atoi</span>(zk_server_port.<span class="built_in">c_str</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ZK 服务端启动失败</span></span><br><span class="line">    <span class="keyword">if</span> (!started) {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"zookeeper client connect failed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 服务对应的 ZNode 节点的路径，比如 /mprpc/services/user.UserServiceRpc</span></span><br><span class="line">    <span class="keyword">const</span> std::string node_path = ZNODE_PATH_PREFIX + <span class="string">"/"</span> + service_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ZNode 子节点列表（即已注册的 RPC 服务列表），比如 127.0.0.1:7070</span></span><br><span class="line">    std::vector&lt;std::string&gt; child_list = zkClient.<span class="built_in">GetChildren</span>(node_path.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ZNode 子节点列表为空（即查找不到已注册的 RPC 服务）</span></span><br><span class="line">    <span class="keyword">if</span> (child_list.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"not found rpc service %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机获取一个 RPC 服务提供者的地址，比如 127.0.0.1:7070</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = child_list.<span class="built_in">size</span>() == <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">randomInt</span>(child_list.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_addr = child_list[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 PRC 服务提供者的 IP 和端口</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> pos = rpc_provider_addr.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="comment">// 如果 RPC 服务提供者的地址无效</span></span><br><span class="line">    <span class="keyword">if</span> (std::string::npos == pos) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"invalid rpc service address %s"</span>, rpc_provider_addr.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_ip = rpc_provider_addr.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_port = rpc_provider_addr.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"ready to invoke rpc service, name: %s, address: %s"</span>, service_name.<span class="built_in">c_str</span>(), rpc_provider_addr.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装 TCP 客户端的连接信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(rpc_provider_port.<span class="built_in">c_str</span>()));</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(rpc_provider_ip.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 TCP 客户端连接 RPC 服务节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">connect</span>(clientfd, (struct sockaddr*)&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr))) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"connect server failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络发送 RPC 调用的请求参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">send</span>(clientfd, rpc_send_str.<span class="built_in">c_str</span>(), rpc_send_str.<span class="built_in">size</span>(), <span class="number">0</span>)) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"send rpc rquest failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络接收 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">int</span> recv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> recv_buf[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (recv_size = <span class="built_in">recv</span>(clientfd, recv_buf, <span class="number">1024</span>, <span class="number">0</span>))) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"receive rpc response failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (!response-&gt;<span class="built_in">ParseFromArray</span>(recv_buf, recv_size)) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"rpc response unserialize failed, response content is %s"</span>, recv_buf);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ZooKeeper-的访问操作"><a href="#ZooKeeper-的访问操作" class="headerlink" title="ZooKeeper 的访问操作"></a>ZooKeeper 的访问操作</h4><ul><li><code>zookeeperclient.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zookeeper/zookeeper.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ZNode 节点的状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ZNodeStatus</span> {</span></span><br><span class="line">    EXIST,     <span class="comment">// 已存在</span></span><br><span class="line">    NOTEXIST,  <span class="comment">// 不存在</span></span><br><span class="line">    UNKNOWN    <span class="comment">// 未知状态</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeper 客户端的封装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Start</span><span class="params">(<span class="keyword">const</span> std::string &amp;host, <span class="keyword">const</span> <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 创建 ZNode 节点</span></span><br><span class="line">    <span class="function">std::string <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen = <span class="number">0</span>, <span class="keyword">int</span> mode = ZOO_PERSISTENT)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 递归创建 ZNode 节点</span></span><br><span class="line">    <span class="function">std::string <span class="title">CreateRecursive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen = <span class="number">0</span>, <span class="keyword">int</span> mode = ZOO_PERSISTENT)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取子节点列表</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">GetChildren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的数据</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的状态</span></span><br><span class="line">    <span class="function">Stat <span class="title">GetStat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="function">ZNodeStatus <span class="title">Exist</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">zhandle_t</span> *m_zhandle;  <span class="comment">// ZK 的客户端句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>zookeeperclient.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////// ZK 客户端同步操作扩展代码 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步检查 ZNode 节点是否存在的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncExistsContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;              <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;  <span class="comment">// 检查结果</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步检查 ZNode 是否存在的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_exists_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> struct Stat *stat, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    SyncExistsContext *ctx = (SyncExistsContext *)data;</span><br><span class="line">    <span class="comment">// 存储检查结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line">    <span class="comment">// 唤醒正在等待检查结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步检查 ZNode 节点是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_exists_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncExistsContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aexists</span>(zh, path, watch, znode_exists_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待检查结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回检查结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建 ZNode 节点的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncCreateContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                 <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;     <span class="comment">// 创建结果</span></span><br><span class="line">    <span class="keyword">char</span> path_buf[<span class="number">512</span>] = {<span class="number">0</span>};  <span class="comment">// 用于返回实际创建的节点路径</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步创建 ZNode 节点的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_create_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncCreateContext *ctx = (SyncCreateContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储创建结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储实际创建的节点路径</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; path) {</span><br><span class="line">        <span class="built_in">strncpy</span>(ctx-&gt;path_buf, path, <span class="built_in"><span class="keyword">sizeof</span></span>(ctx-&gt;path_buf) - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待创建结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建 ZNode 节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_create_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">const</span> struct ACL_vector *acl,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> mode, <span class="keyword">char</span> *path_buf_out, <span class="keyword">int</span> path_buf_out_len)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncCreateContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_acreate</span>(zh, path, data, datalen, acl, mode, znode_create_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待检查结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回实际创建的节点路径</span></span><br><span class="line">    <span class="keyword">if</span> (path_buf_out &amp;&amp; path_buf_out_len &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">strncpy</span>(path_buf_out, ctx.path_buf, path_buf_out_len - <span class="number">1</span>);</span><br><span class="line">        path_buf_out[path_buf_out_len - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回检查结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 节点数据和状态的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncGetContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                    <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;        <span class="comment">// 操作结果</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="literal">nullptr</span>;          <span class="comment">// 数据缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> buf_len = <span class="number">0</span>;              <span class="comment">// 数据缓冲区的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> *<span class="title">stat</span> =</span> <span class="literal">nullptr</span>;  <span class="comment">// ZNode 节点的状态</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取 ZNode 节点数据和状态的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_get_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> value_len, <span class="keyword">const</span> struct Stat *stat, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetContext *ctx = (SyncGetContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储操作结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 ZNode 节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (rc == ZOK &amp;&amp; stat &amp;&amp; ctx-&gt;stat) {</span><br><span class="line">        *ctx-&gt;stat = *stat;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 ZNode 节点的数据</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; value &amp;&amp; value_len &gt; <span class="number">0</span> &amp;&amp; ctx-&gt;buf &amp;&amp; ctx-&gt;buf_len &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> copy_len = (value_len &lt; ctx-&gt;buf_len - <span class="number">1</span>) ? value_len : ctx-&gt;buf_len - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ctx-&gt;buf, value, copy_len);</span><br><span class="line">        ctx-&gt;buf[copy_len] = <span class="string">'\0'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待获取结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 节点的数据和状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_get_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch, <span class="keyword">char</span> *buf_out, <span class="keyword">int</span> buf_out_len, struct Stat *stat_out)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetContext ctx;</span><br><span class="line">    ctx.stat = stat_out;</span><br><span class="line">    ctx.buf = buf_out;</span><br><span class="line">    ctx.buf_len = buf_out_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aget</span>(zh, path, watch, znode_get_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待获取结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回操作结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 子节点列表的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncGetChildrenContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                          <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;              <span class="comment">// 操作结果</span></span><br><span class="line">    std::vector&lt;std::string&gt; children;  <span class="comment">// 子节点列表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取 ZNode 子节点列表的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zoo_get_children_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> struct String_vector *strings, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetChildrenContext *ctx = (SyncGetChildrenContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储操作结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储子节点列表</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; strings) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings-&gt;count; i++) {</span><br><span class="line">            ctx-&gt;children.<span class="built_in">emplace_back</span>(strings-&gt;data[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待获取结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 子节点列表</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">zoo_get_children_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch)</span> </span>{</span><br><span class="line">    <span class="comment">// 子节点列表</span></span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetChildrenContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aget_children</span>(zh, path, watch, zoo_get_children_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待获取结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取子节点列表成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == ctx.rc) {</span><br><span class="line">        <span class="comment">// 直接转移 children 所有权给 result</span></span><br><span class="line">        result = std::<span class="built_in">move</span>(ctx.children);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取子节点列表失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"failed to get children of node %s"</span>, path);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回子节点列表</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的 Watcher 监听器，接收 ZkServer 给 ZkClient 发送的通知</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_watcher</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">int</span> type, <span class="keyword">int</span> state, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">void</span> *watcherCtx)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断接收到的事件类型是不是会话事件类型</span></span><br><span class="line">    <span class="keyword">if</span> (type == ZOO_SESSION_EVENT) {</span><br><span class="line">        <span class="comment">// ZK 客户端连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (state == ZOO_CONNECTED_STATE) {</span><br><span class="line">            <span class="comment">// 从 ZK 客户端的上下文中获取预设置的信号量</span></span><br><span class="line">            <span class="keyword">sem_t</span> *init_sem = (<span class="keyword">sem_t</span> *)<span class="built_in">zoo_get_context</span>(zh);</span><br><span class="line">            <span class="comment">// 唤醒正在等待 ZK 客户端初始化完成的线程</span></span><br><span class="line">            <span class="built_in">sem_post</span>(init_sem);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ZK 客户端身份认证失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == ZOO_AUTH_FAILED_STATE) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper auth failed"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ZK 客户端会话过期</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == ZOO_EXPIRED_SESSION_STATE) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper session expired"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////// ZK 客户端实现代码 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ZkClient::<span class="built_in">ZkClient</span>() : <span class="built_in">m_zhandle</span>(<span class="literal">nullptr</span>) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ZkClient::~<span class="built_in">ZkClient</span>() {</span><br><span class="line">    <span class="keyword">if</span> (m_zhandle != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="comment">// 关闭 ZK 的客户端句柄（释放资源）</span></span><br><span class="line">        <span class="built_in">zookeeper_close</span>(m_zhandle);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 ZK 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ZkClient::Start</span><span class="params">(<span class="keyword">const</span> std::string &amp;host, <span class="keyword">const</span> <span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">    <span class="comment">// 拼接 ZK 服务端的连接信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string conn_str = host + <span class="string">":"</span> + std::<span class="built_in">to_string</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 ZK 的客户端句柄，连接 ZK 服务端（特别注意：这里是异步初始化）</span></span><br><span class="line"><span class="comment">     * ZooKeeper C API 的多线程版本有三个线程，包括：</span></span><br><span class="line"><span class="comment">     * (1) API 调用线程（当前调用 ZK API 的线程）</span></span><br><span class="line"><span class="comment">     * (2) 网络 I/O 线程，基于 pthread_create() + poll 实现</span></span><br><span class="line"><span class="comment">     * (3) Watcher 回调线程，基于 pthread_create() 实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    m_zhandle = <span class="built_in">zookeeper_init</span>(conn_str.<span class="built_in">c_str</span>(), global_watcher, <span class="number">30000</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_zhandle) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper client init failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> init_sem;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;init_sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将信号量存放到 ZK 客户端的上下文中</span></span><br><span class="line">    <span class="built_in">zoo_set_context</span>(m_zhandle, &amp;init_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置等待 ZK 客户端连接的超时时间（10 秒）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;ts);</span><br><span class="line">    ts.tv_sec += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待 ZK 客户端初始化完成</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sem_timedwait</span>(&amp;init_sem, &amp;ts) != <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;init_sem);</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper client connect timeout"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;init_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"zookeeper client init success"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上根据指定的 Path 创建 ZNode 节点</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">int</span> mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZNode 节点已存在</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">"znode %s create failed, because it existed"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ZNode 节点不存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ZNONODE == flag) {</span><br><span class="line">        <span class="comment">// 实际创建的节点路径</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> path_buf_len = <span class="number">512</span>;</span><br><span class="line">        <span class="keyword">char</span> path_buf[path_buf_len] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步创建 ZNode 节点</span></span><br><span class="line">        flag = <span class="built_in">zoo_create_sync</span>(m_zhandle, path, data, datalen, &amp;ZOO_OPEN_ACL_UNSAFE, mode, path_buf, path_buf_len);</span><br><span class="line">        <span class="comment">// 节点创建成功</span></span><br><span class="line">        <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"znode %s create success"</span>, path_buf);</span><br><span class="line">            <span class="comment">// 返回实际创建的节点路径</span></span><br><span class="line">            <span class="keyword">return</span> path_buf;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 节点创建失败</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">            <span class="comment">// 返回空字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发生错误，比如会话过期、身份认证失败等</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 递归创建 ZNode 节点</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::CreateRecursive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">int</span> mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::string current_path;</span><br><span class="line">    std::string result_path;</span><br><span class="line">    <span class="keyword">size_t</span> current_pos = <span class="number">1</span>;       <span class="comment">// 跳过第一个 '/'</span></span><br><span class="line">    <span class="function">std::string <span class="title">full_path</span><span class="params">(path)</span></span>;  <span class="comment">// 拷贝节点路径，避免修改原始字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_pos &lt;= full_path.<span class="built_in">size</span>()) {</span><br><span class="line">        <span class="keyword">size_t</span> next_pos = full_path.<span class="built_in">find</span>(<span class="string">'/'</span>, current_pos);</span><br><span class="line">        <span class="keyword">if</span> (next_pos == std::string::npos) {</span><br><span class="line">            <span class="comment">// 最后一级路径（完整路径）</span></span><br><span class="line">            current_path = full_path;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            current_path = full_path.<span class="built_in">substr</span>(<span class="number">0</span>, next_pos);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> is_last_path = (next_pos == std::string::npos);   <span class="comment">// 是否为最后一级路径</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *path_data = is_last_path ? data : <span class="string">""</span>;      <span class="comment">// 父路径不写入数据</span></span><br><span class="line">        <span class="keyword">int</span> path_data_len = is_last_path ? datalen : <span class="number">0</span>;        <span class="comment">// 父路径的数据长度为零</span></span><br><span class="line">        <span class="keyword">int</span> path_mode = is_last_path ? mode : ZOO_PERSISTENT;  <span class="comment">// 父路径为持久节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        std::string created_path = <span class="built_in">Create</span>(current_path.<span class="built_in">c_str</span>(), path_data, path_data_len, path_mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果节点创建失败</span></span><br><span class="line">        <span class="keyword">if</span> (created_path.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="comment">// 判断节点是否存在</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, current_path.<span class="built_in">c_str</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 如果节点存在，使用（兼容）已存在的节点</span></span><br><span class="line">            <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">                created_path = current_path;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果节点不存在或者发生错误，则直接返回空字符串</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 打印日志信息</span></span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">                <span class="comment">// 返回空字符串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是最后一级路径，则跳出 While 循环</span></span><br><span class="line">        <span class="keyword">if</span> (is_last_path) {</span><br><span class="line">            result_path = created_path;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        current_pos = next_pos + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_path;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取子节点列表</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">ZkClient::GetChildren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空列表</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取子节点列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">zoo_get_children_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的数据</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::GetData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> data_buf_len = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">char</span> data_buf[data_buf_len] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取 ZNode 节点的数据</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_get_sync</span>(m_zhandle, path, <span class="number">0</span>, data_buf, data_buf_len, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 获取节点数据成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 返回节点数据</span></span><br><span class="line">        <span class="keyword">return</span> data_buf;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取节点数据失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"get znode data failed, path: %s"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的状态</span></span><br><span class="line"><span class="function">Stat <span class="title">ZkClient::GetStat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空数据</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">stat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取 ZNode 节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_get_sync</span>(m_zhandle, path, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;stat);</span><br><span class="line">    <span class="comment">// 获取节点状态成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 返回节点状态</span></span><br><span class="line">        <span class="keyword">return</span> stat;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取节点状态失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"get znode stat failed, path: %s"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空数据</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 判断 ZNode 节点是否存在</span></span><br><span class="line"><span class="function">ZNodeStatus <span class="title">ZkClient::Exist</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZNode 节点已存在</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="keyword">return</span> EXIST;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ZNode 节点不存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ZNONODE == flag) {</span><br><span class="line">        <span class="keyword">return</span> NOTEXIST;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发生错误，比如会话过期、身份认证失败等</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查节点路径是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ZkClient::checkPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">nullptr</span> || path[<span class="number">0</span>] != <span class="string">'/'</span>) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"invalid node path: %s"</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="RPC-框架测试代码"><a href="#RPC-框架测试代码" class="headerlink" title="RPC 框架测试代码"></a>RPC 框架测试代码</h3><p>这里的项目测试代码位于 <code>example</code> 目录下，实质是 RPC 框架的使用案例代码，用于给 RPC 框架的第三方使用者演示如何发布和调用 RPC 服务。</p><h4 id="Protobuf-协议文件-1"><a href="#Protobuf-协议文件-1" class="headerlink" title="Protobuf 协议文件"></a>Protobuf 协议文件</h4><ul><li><code>user.proto</code> 协议文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package user;</span><br><span class="line"></span><br><span class="line">// 允许生成通用的 C++ 服务接口（可选项）</span><br><span class="line">option cc_generic_services = true;</span><br><span class="line"></span><br><span class="line">// 请求结果</span><br><span class="line">message ResultCode {</span><br><span class="line">    uint32 errcode = 1; </span><br><span class="line">    bytes errmsg = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 登录请求</span><br><span class="line">message LoginRequest {</span><br><span class="line">    bytes name = 1;</span><br><span class="line">    bytes password = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 登录响应</span><br><span class="line">message LoginResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    bool success = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 注册请求</span><br><span class="line">message RegisterRequest {</span><br><span class="line">    bytes name = 1;</span><br><span class="line">    bytes password = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 注册响应</span><br><span class="line">message RegisterResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    bool success = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义RPC服务接口类和服务函数</span><br><span class="line">service UserServiceRpc {</span><br><span class="line">    rpc Register(RegisterRequest) returns (RegisterResponse);</span><br><span class="line"></span><br><span class="line">    rpc Login(LoginRequest) returns (LoginResponse);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>friend.proto</code> 协议文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package friends;</span><br><span class="line"></span><br><span class="line">// 允许生成通用的 C++ 服务接口（可选项）</span><br><span class="line">option cc_generic_services = true;</span><br><span class="line"></span><br><span class="line">// 请求结果</span><br><span class="line">message ResultCode {</span><br><span class="line">    uint32 errcode = 1; </span><br><span class="line">    bytes errmsg = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 好友信息</span><br><span class="line">message Friend {</span><br><span class="line">    uint32 userid = 1;</span><br><span class="line">    bytes username = 2;</span><br><span class="line"></span><br><span class="line">    // 枚举类型</span><br><span class="line">    enum SEX {</span><br><span class="line">        MAN = 0;</span><br><span class="line">        WOMAN = 1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SEX sex = 3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取好友列表的请求</span><br><span class="line">message GetFriendListRequest {</span><br><span class="line">    uint32 userid = 1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取好友列表的响应</span><br><span class="line">message GetFriendListResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    // 好友列表</span><br><span class="line">    repeated Friend friends = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义RPC服务接口类和服务函数</span><br><span class="line">service FriendServiceRpc {</span><br><span class="line">    rpc GetFriendList(GetFriendListRequest) returns (GetFriendListResponse);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-RPC-框架提供服务"><a href="#使用-RPC-框架提供服务" class="headerlink" title="使用 RPC 框架提供服务"></a>使用 RPC 框架提供服务</h4><ul><li><code>rpcprovider.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcprovider.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 服务，继承基类 UserServiceRpc（由 Protobuf 自动生成）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> :</span> <span class="keyword">public</span> user::UserServiceRpc {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 本地的登录函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Login</span><span class="params">(std::string name, std::string password)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local Login function, name: %s, password: %s"</span>, name.<span class="built_in">c_str</span>(), password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地的注册函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Register</span><span class="params">(std::string name, std::string password)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local Register function, name: %s, password: %s"</span>, name.<span class="built_in">c_str</span>(), password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 UserServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Login</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::user::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">               ::user::LoginResponse* response, ::google::protobuf::Closure* done)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string password = request-&gt;<span class="built_in">password</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        <span class="keyword">bool</span> success = <span class="built_in">Login</span>(name, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        user::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(success);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给 RPC 服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 UserServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::user::RegisterRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ::user::RegisterResponse* response, ::google::protobuf::Closure* done)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string password = request-&gt;<span class="built_in">password</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        <span class="keyword">bool</span> success = <span class="built_in">Register</span>(name, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        user::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(success);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给RPC服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 服务，继承基类 FriendServiceRpc（由 Protobuf 自动生成）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendServcie</span> :</span> <span class="keyword">public</span> friends::FriendServiceRpc {</span><br><span class="line">    <span class="comment">// 本地获取好友列表的函数</span></span><br><span class="line">    <span class="function">std::vector&lt;friends::Friend&gt; <span class="title">GetFriendList</span><span class="params">(<span class="keyword">uint32_t</span> userid)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local GetFriendList function, userid: %u"</span>, userid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        std::vector&lt;friends::Friend&gt; result;</span><br><span class="line"></span><br><span class="line">        friends::Friend f1;</span><br><span class="line">        f1.<span class="built_in">set_userid</span>(<span class="number">1</span>);</span><br><span class="line">        f1.<span class="built_in">set_username</span>(<span class="string">"Jim"</span>);</span><br><span class="line">        f1.<span class="built_in">set_sex</span>(friends::Friend::MAN);</span><br><span class="line">        result.<span class="built_in">push_back</span>(f1);</span><br><span class="line"></span><br><span class="line">        friends::Friend f2;</span><br><span class="line">        f2.<span class="built_in">set_userid</span>(<span class="number">2</span>);</span><br><span class="line">        f2.<span class="built_in">set_username</span>(<span class="string">"Tom"</span>);</span><br><span class="line">        f2.<span class="built_in">set_sex</span>(friends::Friend::MAN);</span><br><span class="line">        result.<span class="built_in">push_back</span>(f2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 FriendServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetFriendList</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::friends::GetFriendListRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::friends::GetFriendListResponse* response, ::google::protobuf::Closure* done)</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        <span class="keyword">uint32_t</span> userid = request-&gt;<span class="built_in">userid</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        std::vector&lt;friends::Friend&gt; friends = <span class="built_in">GetFriendList</span>(userid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        friends::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应的数据</span></span><br><span class="line">        <span class="keyword">for</span> (friends::Friend&amp; item : friends) {</span><br><span class="line">            friends::Friend* f = response-&gt;<span class="built_in">add_friends</span>();</span><br><span class="line">            f-&gt;<span class="built_in">set_sex</span>(item.<span class="built_in">sex</span>());</span><br><span class="line">            f-&gt;<span class="built_in">set_userid</span>(item.<span class="built_in">userid</span>());</span><br><span class="line">            f-&gt;<span class="built_in">set_username</span>(item.<span class="built_in">username</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给RPC服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 RPC 服务的发布</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    Logger::<span class="built_in">GetInstance</span>().<span class="built_in">SetLogLevel</span>(INFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 框架的初始化操作（比如加载 RPC 配置文件）</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"init rpc framework..."</span>);</span><br><span class="line">    MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用来发布 RPC 服务的网络对象类</span></span><br><span class="line">    RpcProvider provider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    provider.<span class="built_in">PublishService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    provider.<span class="built_in">PublishService</span>(<span class="keyword">new</span> <span class="built_in">FriendServcie</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-RPC-框架调用服务"><a href="#使用-RPC-框架调用服务" class="headerlink" title="使用 RPC 框架调用服务"></a>使用 RPC 框架调用服务</h4><ul><li><code>rpcconsumer.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 注册方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">user::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    user::RegisterRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">"jim"</span>);</span><br><span class="line">    request.<span class="built_in">set_password</span>(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    user::RegisterResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">Register</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function Register invoke success"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function Register invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 登录方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Login</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">user::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    user::LoginRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">"jim"</span>);</span><br><span class="line">    request.<span class="built_in">set_password</span>(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    user::LoginResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">Login</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function Login invoke success"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function Login invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 获取好友列表方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetFriendList</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">friends::FriendServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    friends::GetFriendListRequest request;</span><br><span class="line">    request.<span class="built_in">set_userid</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    friends::GetFriendListResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">GetFriendList</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function GetFriendList invoke success"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取返回的数据</span></span><br><span class="line">        <span class="keyword">auto</span> friends = response.<span class="built_in">friends</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : friends) {</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"userid: %u, username: %s, sex: %d"</span>, item.<span class="built_in">userid</span>(), item.<span class="built_in">username</span>().<span class="built_in">c_str</span>(), item.<span class="built_in">sex</span>());</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function GetFriendList invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 RPC 服务的调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    Logger::<span class="built_in">GetInstance</span>().<span class="built_in">SetLogLevel</span>(INFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 框架的初始化操作（比如加载 RPC 配置文件）</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"init rpc framework..."</span>);</span><br><span class="line">    MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 注册方法</span></span><br><span class="line">    <span class="built_in">Register</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 登录方法</span></span><br><span class="line">    <span class="built_in">Login</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 获取好友列表方法</span></span><br><span class="line">    <span class="built_in">GetFriendList</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待一段时间，在程序结束之前，尽量让日志信息都被写入日志文件</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="项目代码下载"><a href="#项目代码下载" class="headerlink" title="项目代码下载"></a>项目代码下载</h3><p>完整的 RPC 框架项目代码可以在 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-mprpc">这里</a> 下载得到。</p><h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><ul><li>(1) 更改 <code>conf</code> 目录下的 <code>rpc.conf</code> 配置文件，指定 ZooKeeper 服务器的 IP 和端口号等信息 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ZooKeeper的IP地址（必填）</span><br><span class="line">zk_server_host=127.0.0.1</span><br><span class="line"># ZooKeeper的端口号（必填）</span><br><span class="line">zk_server_port=2181</span><br><span class="line"># RPC服务提供者优先使用的网卡接口（可选）</span><br><span class="line">rpc_network_interface=eth1</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 通过 CMake 编译构建整个项目 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权脚本执行</span></span><br><span class="line">chmod +x autobuild.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一键编译构建脚本</span></span><br><span class="line">./autobuild.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 启动 ZooKeeper 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 ZooKeeper 服务器</span></span><br><span class="line">sudo systemctl start zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 服务器的运行状态</span></span><br><span class="line">sudo systemctl status zookeeper</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 启动 RPC 服务提供者的案例程序 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 RPC 服务提供者的案例程序（可使用相同的命令启动多个 RPC 服务提供者，不需要考虑端口冲突问题）</span></span><br><span class="line">./example_rpc_provider -i rpc.conf</span><br></pre></td></tr></tbody></table></figure><ul><li>(5) 启动 RPC 服务调用者的案例程序 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 RPC 服务调用者的案例程序（可使用相同的命令启动多个 RPC 服务调用者，不需要考虑端口冲突问题）</span></span><br><span class="line">./example_rpc_consumer -i rpc.conf</span><br></pre></td></tr></tbody></table></figure><ul><li>(6) 查看 RPC 框架运行输出的日志文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 RPC 框架运行输出的日志文件（请自行更改日志文件名）</span></span><br><span class="line">vim 2025-06-12-log.txt</span><br></pre></td></tr></tbody></table></figure><h2 id="项目调试"><a href="#项目调试" class="headerlink" title="项目调试"></a>项目调试</h2><ul><li>GDB 调试 C/C++ 代码，可用于定位线程死锁等问题的发生 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GDB 调试指定的可执行文件（应用程序）</span></span><br><span class="line">gdb example_rpc_provider</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 设置断点（格式：源文件名称＋行号）</span></span><br><span class="line">(gdb) <span class="built_in">break</span> mprpcconfig.cc:19</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 指定参数运行应用程序（运行后，会停留在断点处）</span></span><br><span class="line">(gdb) run -i rpc.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 断点调试 - 运行下一行代码</span></span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 断点调试 - 查看指定变量的值</span></span><br><span class="line">(gdb) p src_buf</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 退出调试</span></span><br><span class="line">(gdb) quit</span><br></pre></td></tr></tbody></table></figure><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><p>在上述的 RPC 框架代码中，每当 RPC 服务端处理完成一个 RPC 请求后，都会主动断开与 RPC 客户端的 TCP 连接；同样，RPC 客户端在获取到响应结果后，也会主动断开与 RPC 服务端的 TCP 连接。这种实现方式属于短连接模式，在生产环境中通常比较少见。原因如下：</p><ul><li><p>TCP 连接的创建和释放代价较高，每次请求都涉及：</p><ul><li>三次握手（建立连接）</li><li>四次挥手（关闭连接）</li></ul></li><li><p>在高并发场景下，频繁建立和关闭 TCP 连接会导致：</p><ul><li>系统资源消耗大（文件描述符、内核网络栈负载）</li><li>服务端的性能瓶颈，特别是处理大量短时请求时</li></ul></li></ul><p>以阿里巴巴开源的 RPC 框架 Dubbo 为例，Dubbo 默认采用 TCP 的单一长连接和 NIO 异步通信模型，其主要特点是：</p><ul><li>客户端与服务端之间建立持久化的长连接（通常是连接池或多路复用）</li><li>异步非阻塞通信（基于 Netty 实现）</li><li>复用连接发送多次请求，避免了重复的 TCP 握手和断开操作，显著降低了网络资源和 CPU 消耗</li></ul><p>因此在生产环境中，建议使用 TCP 的单一长连接和 NIO 异步通信模型（Muduo 网络库天生支持），以此保证 RPC 框架的高并发性能。值得一提的是，使用 TCP 长连接后，需要额外处理 TCP 分包的问题，也就是将 TCP 字节流里的数据识别为一个个消息（RPC 请求消息）。</p><table><thead><tr><th>模式</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td>短连接（请求 - 响应后立即断开）</td><td>简单实现，资源浪费大</td><td>一般用于简单的 HTTP/1.0 接口或调试环境</td></tr><tr><td>长连接（复用 TCP 连接）</td><td>性能优越，适合高并发</td><td> gRPC、Dubbo、Redis、数据库连接等</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/18340f27.html">ZooKeeper 入门系列教程</a></li><li><a href="/posts/46940ea4.html">C++ 快速上手使用 Protobuf</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 如何实现 RPC 分布式网络通信框架，使用了 Muduo、Protobuf、ZooKeeper 等技术。</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="RPC" scheme="https://www.techgrow.cn/tags/RPC/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 开发集群聊天服务器</title>
    <link href="https://www.techgrow.cn/posts/e635f0aa.html"/>
    <id>https://www.techgrow.cn/posts/e635f0aa.html</id>
    <published>2025-05-29T13:55:33.000Z</published>
    <updated>2025-06-04T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写高性能网络库（Muduo）</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 实现集群聊天服务器，使用了 Json 库和 Muduo 网络库，并引入了 Redis、MySQL、Nginx 中间件。</p><span id="more"></span><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><table><thead><tr><th>软件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>11</code></td><td></td></tr><tr><td>Boost</td><td><code>1.74.0.3</code></td><td>Muduo 库依赖 Boost 库</td></tr><tr><td> Muduo</td><td><code>2.0.3</code></td><td><a href="https://github.com/chenshuo/muduo">Muduo 库</a>，基于 C++ 开发，用于网络编程</td></tr><tr><td> hiredis</td><td><code>1.3.0</code></td><td><a href="https://github.com/redis/hiredis">Reids 库</a> ，基于 C 语言开发，用于操作 Redis</td></tr><tr><td>nlohmann/json</td><td><code>3.12.0</code></td><td><a href="https://github.com/nlohmann/json">Json 库</a>，基于 C++ 开发，用于 Json 序列化和反序列化</td></tr><tr><td> MySQL C API （Connector/C）</td><td><code>8.4.5</code></td><td>用于读写 MySQL 数据库，基于 C 语言开发</td></tr><tr><td> Redis</td><td><code>7.0.15</code></td><td>Redis 服务器</td></tr><tr><td> MySQL</td><td><code>8.4.5</code></td><td>MySQL 服务器</td></tr><tr><td> Nginx</td><td><code>1.28.0</code></td><td>Nginx 服务器</td></tr><tr><td> G++（GCC）</td><td><code>12.2.0</code></td><td>建议使用 <code>5.5</code>、<code>7.5</code> 版本的 G++（GCC） 编译器</td></tr><tr><td> CMake</td><td><code>3.25.1</code></td><td>C/C++ 项目构建工具</td></tr><tr><td> Linux</td><td><code>Debian 12</code></td><td>Muduo 库不支持 Windows 平台</td></tr><tr><td> Visual Studio Code</td><td><code>1.100.2</code></td><td>使用 VSCode 远程开发特性</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">平台兼容性说明</p><p>由于使用了 Muduo 库，且 Muduo 库仅支持 Linux 平台；因此本文提供的所有 C++ 集群聊天服务器代码支持在 Linux 平台运行，不支持 Windows 平台，默认是基于 Debian 12 进行远程开发。</p></div><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>使用 C++ 开发 Linux 应用时，常见的开发环境有以下几种：</p><ul><li>(1) <a href="https://blog.csdn.net/icacxygh001/article/details/120981354">Linux 环境下直接使用 VSCode、Clion 等 IDE 进行本地开发</a></li><li> (2) <a href="https://blog.csdn.net/xiaowangabc1/article/details/147927306">Windows + VSCode + MinGW 搭建本地 C/C++ 开发环境</a></li><li> (3) <a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89469717">Windows + Visual Studio 搭建远程 Linux 跨平台项目</a></li><li> (4) <a href="/posts/630b5e44.html">Windows + VSCode 搭建远程 Linux 开发环境</a></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>上面介绍的三种开发环境，任意选择一种自己熟悉的就可以；如果日常使用的是 Windows 系统，建议选择第四种开发环境（VSCode 远程开发）；如果习惯使用 Linux 系统，强烈建议选择第一种开发环境（Linux 本地开发）。</p></div><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><ul><li>安装常用的工具 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装开发工具</span></span><br><span class="line">sudo apt-get install -y vim git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装网络工具</span></span><br><span class="line">sudo apt-get install -y wget curl telnet netcat-openbsd socat tcpdump hping3</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-GCC"><a href="#安装-GCC" class="headerlink" title="安装 GCC"></a>安装 GCC</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC、G++、GDB</span></span><br><span class="line">sudo apt-get install -y build-essential gdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 GCC 版本</span></span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 G++ 版本</span></span><br><span class="line">g++ --version</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-CMake"><a href="#安装-CMake" class="headerlink" title="安装 CMake"></a>安装 CMake</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 CMake</span></span><br><span class="line">sudo apt-get -y install cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 CMake 版本</span></span><br><span class="line">cmake -version</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><ul><li>安装 Redis</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Redis</span></span><br><span class="line">sudo apt-get install -y redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 Redis</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Redis 的运行状态</span></span><br><span class="line">sudo systemctl status redis-server</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Redis 版本</span></span><br><span class="line">redis-server --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 客户端执行 Ping 操作</span></span><br><span class="line">redis-cli ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 Redis 服务器响应以下内容，则说明 Redis 服务器正常运行</span></span><br><span class="line">PONG</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">Redis 默认配置文件的路径</p><p>通过 APT 安装 Redis 服务器后，其主配置文件的路径为 <code>/etc/redis/redis.conf</code>。</p></div><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><ul><li>安装依赖包 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖软件（比如 pcre、zlib、ssl）</span></span><br><span class="line">sudo apt install -y build-essential libpcre3 libpcre3-dev zlib1g zlib1g-dev libssl-dev</span><br></pre></td></tr></tbody></table></figure><ul><li>编译安装 Nginx</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://nginx.org/download/nginx-1.28.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf nginx-1.28.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.28.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">./configure --with-stream --with-http_ssl_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure><ul><li>Nginx 安装说明</li></ul><table><thead><tr><th>安装说明</th><th>路径</th></tr></thead><tbody><tr><td> Nginx 默认安装路径</td><td><code>/usr/local/nginx</code></td></tr><tr><td>Nginx 主配置文件路径</td><td><code>/usr/local/nginx/conf/nginx.conf</code></td></tr><tr><td>Nginx 二进制可执行文件路径</td><td><code>/usr/local/nginx/sbin/nginx</code></td></tr></tbody></table><ul><li>Nginx 管理命令 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 Nginx</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优雅关闭 Nginx</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s quit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立刻关闭 Nginx</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 Nginx 配置文件</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载 Nginx 配置文件</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 Systemd 服务（实现 Nginx 服务自启动）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Systemd 服务配置文件，添加以下配置内容</span></span><br><span class="line">sudo vi /etc/systemd/system/nginx.service</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=The NGINX HTTP and reverse proxy server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s quit</span><br><span class="line">PIDFile=/usr/<span class="built_in">local</span>/nginx/logs/nginx.pid</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重载系统配置文件</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 Nginx 服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 Nginx 服务</span></span><br><span class="line">sudo systemctl start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Nginx 服务的运行状态</span></span><br><span class="line">sudo systemctl status nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优雅关闭 Nginx 服务</span></span><br><span class="line">sudo systemctl stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载 Nginx 服务的配置文件</span></span><br><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Nginx <code>1.9.0</code> 版本之前，Nginx 仅支持基于 HTTP 协议 的 Web 服务器负载均衡，无法处理 TCP 层的流量转发。自 Nginx <code>1.9.0</code> 版本开始，官方引入了名为 <code>stream</code> 的新模块，使 Nginx 能够支持基于 TCP 和 UDP 的四层负载均衡，从而扩展了其在数据库代理、邮件服务、消息中间件等非 HTTP 场景中的应用能力。值得一提的是，尽管 <code>stream</code> 模块在 <code>1.9.0</code> 版本中开始被引入，但在官方源码中该模块默认并未启用。因此，在编译 Nginx 源码时，如果希望使用 <code>stream</code> 模块的功能，则必须显式添加 <code>--with-stream</code> 编译参数，这样才能将其集成进最终构建的二进制可执行文件中。</p></div><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><ul><li>添加 MySQL 官方 APT 源 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 APT 配置包（访问 https://dev.mysql.com/downloads/repo/apt/ 可以获取最新版本）</span></span><br><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.8.34-1_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 APT 配置包</span></span><br><span class="line"><span class="comment"># 在安装过程中会弹出配置界面，通常默认选择的是 MySQL 8.4 版本，如果需要安装其他版本（如 8.0），可以按回车键进入子菜单选择其他版本</span></span><br><span class="line"><span class="comment"># 由于集群聊天服务器需要使用到 MySQL 客户端，因此还需要安装 MySQL Connectors（不需要改动选择，因为默认已经选择安装）</span></span><br><span class="line">sudo dpkg -i mysql-apt-config_0.8.34-1_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 APT 索引</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></tbody></table></figure><ul><li>安装 MySQL</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 MySQL（安装过程中会提示输入 MySQL 的 root 用户的密码）</span></span><br><span class="line">sudo apt-get install -y mysql-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 MySQL</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 MySQL 的运行状态</span></span><br><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">MySQL 默认配置文件的路径</p><p>通过 APT 安装 MySQL 服务器后，其主配置文件的路径为 <code>/etc/mysql/my.cnf</code>。</p></div><ul><li>安装 MySQL C API 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 MySQL 客户端开发包（包含了 MySQL C API 的头文件和动态库文件）</span></span><br><span class="line">sudo apt-get install -y libmysqlclient-dev</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 MySQL 安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录 MySQL</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 MySQL 版本</span></span><br><span class="line"><span class="keyword">select</span> version();</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 MySQL C API 库的安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /usr -iname libmysqlclient*</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.a</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.so.24</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.so.24.0.5</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">MySQL C API 库</p><p>本文使用 <code>libmysqlclient.so</code> 库来操作 MySQL 数据库，该库称为 MySQL C API（也叫 Connector/C），它是基于 C 语言实现的。C++ 项目也可以使用这个库，只要用 <code>extern "C"</code> 来链接（或者直接使用 MySQL 提供的头文件中已经加好的处理）。</p></div><h3 id="安装-Boost-库"><a href="#安装-Boost-库" class="headerlink" title="安装 Boost 库"></a>安装 Boost 库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Boost 的所有组件和头文件</span></span><br><span class="line">sudo apt-get install -y libboost-all-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Bootst 版本</span></span><br><span class="line">sudo dpkg -s libboost-all-dev | grep Version</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>由于 Muduo 使用了 Boost 库（如 <code>boost::any</code>），因此需要安装 Boost 库。</p></div><h3 id="安装-Muduo-库"><a href="#安装-Muduo-库" class="headerlink" title="安装 Muduo 库"></a>安装 Muduo 库</h3><ul><li>编译安装 Muduo 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chenshuo/muduo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入代码目录</span></span><br><span class="line"><span class="built_in">cd</span> muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Muduo 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Muduo 库的静态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep muduo</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Muduo 的编译依赖 CMake 和 Boost 库，默认编译生成的是静态库（<code>.a</code>），如果需要编译生成共享库（<code>.so</code>），可以自行修改 <code>CMakeLists.txt</code> 中的配置。</li><li>Muduo 支持 C++ 11，仅支持 Linux 平台，不支持 Windows 平台，建议使用 <code>7.x</code> 及以后版本的 <code>g++</code> 编译器。</li></ul></div><h3 id="安装-Hiredis-库"><a href="#安装-Hiredis-库" class="headerlink" title="安装 Hiredis 库"></a>安装 Hiredis 库</h3><ul><li>编译安装 Hiredis 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/redis/hiredis.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> hiredis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Hiredis 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/hiredis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Hiredis 库的静态库和动态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep hiredis</span><br></pre></td></tr></tbody></table></figure><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h3><ul><li>客户端新用户注册</li><li>客户端用户登录</li><li>添加好友和添加群组</li><li>好友聊天</li><li>群组聊天</li><li>离线消息</li><li> Nginx 配置 TCP 负载均衡</li><li>集群聊天系统支持客户端跨服务器通信</li></ul><h3 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h3><ul><li>掌握 Json 的编程应用</li><li>掌握 CMake 构建自动化编译环境</li><li>掌握 Muduo 网络库的编程以及实现原理</li><li>掌握 Nginx 配置部署 TCP 负载均衡器的应用以及原理</li><li>掌握服务器的网络 I/O 模块、业务模块、数据模块分层的设计思想</li><li>掌握 Redis 发布 - 订阅的编程实践以及应用原理</li></ul><h3 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h3><p>在集群聊天服务器项目中，使用 Nginx 作为 TCP 负载均衡器，同时使用 Redis 的发布 - 订阅特性来解决客户端跨服务器通信问题。整体工作流程如下图所示：</p><p><img data-src="../../../asset/2025/06/cluster-chat-loadbalance-1.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p>Nginx 单机作为负载均衡器时，经过合理的系统参数优化和配置（如 <code>ulimit</code>、内核参数调整等），通常可以稳定支撑 5 万～6 万个并发 TCP 连接。但是，由于 Nginx 本质上是属于应用层的四层代理，其性能仍受限于单机的 CPU、内存、网络带宽和文件描述符等资源限制。若需支持 超过 10 万甚至上百万的并发 TCP 连接，可采用 LVS + Keepalived + Nginx 的分层架构实现更高性能、更高可用性、更强伸缩性的负载均衡方案，该方案的部署拓扑结构 <a href="../../../asset/2025/06/cluster-chat-loadbalance-2.png">如图</a> 所示。</p></div><h3 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h3><ul><li>单例设计模式</li><li> Muduo 网络库</li><li> MySQL 数据库编程</li><li> CMake 构建编译环境</li><li> Json 序列化和反序列化</li><li> Nginx 的 TCP 负载均衡器使用</li><li> Redis 的发布 - 订阅编程实践</li></ul><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><h3 id="Nginx-负载均衡配置"><a href="#Nginx-负载均衡配置" class="headerlink" title="Nginx 负载均衡配置"></a>Nginx 负载均衡配置</h3><p>在集群聊天服务器项目中，由于使用了 Nginx 作为 TCP 负载均衡器，因此需要在 Nginx 的配置文件中（<code>nginx.conf</code>）添加 <code>stream</code> 模块的配置内容，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">events {</span><br><span class="line">  ........</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># nginx tcp loadbalance config</span><br><span class="line">stream {</span><br><span class="line">    # 集群聊天的服务器列表</span><br><span class="line">    upstream chat_server {</span><br><span class="line">        server 127.0.0.1:6000 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">        server 127.0.0.1:6002 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    # TCP 负载均衡器（负责转发流量）</span><br><span class="line">    server {</span><br><span class="line">        listen 8000;</span><br><span class="line">        proxy_pass chat_server;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">http {</span><br><span class="line">  ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Redis-发布-订阅使用"><a href="#Redis-发布-订阅使用" class="headerlink" title="Redis 发布 - 订阅使用"></a>Redis 发布 - 订阅使用</h3><p>在集群聊天服务器项目中，使用 Redis 的发布 - 订阅特性来解决客户端跨服务器通信问题。Reids 的发布 - 订阅功能，主要使用以下几个 Redis 命令来实现：</p><ul><li>订阅指定的 Channel</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe news</span><br></pre></td></tr></tbody></table></figure><ul><li>发布消息到指定的 Channel</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish news <span class="string">"hello"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>取消订阅指定的 Channel</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsubscribe news</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>在集群聊天服务器项目中，为了方便操作 Redis，会使用到 <a href="https://github.com/redis/hiredis">Hiredis</a> 库。</p></div><h3 id="MySQL-数据库初始化"><a href="#MySQL-数据库初始化" class="headerlink" title="MySQL 数据库初始化"></a>MySQL 数据库初始化</h3><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>C++ 集群聊天服务器项目的数据库表设计如下：</p><p><img data-src="../../../asset/2025/05/cxx-cluster-chat-server-1.png"></p><h4 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h4><ul><li>创建数据库 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `chat` <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></tbody></table></figure><ul><li>切换数据库 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE `chat`;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建用户表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `state` enum(<span class="string">'online'</span>,<span class="string">'offline'</span>) <span class="keyword">DEFAULT</span> <span class="string">'offline'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `name` (`name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">22</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建好友表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `friend` (</span><br><span class="line">  `userid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `friendid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `userid` (`userid`,`friendid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建用户组表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `allgroup` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `groupname` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `groupdesc` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `groupname` (`groupname`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建用户与用户组关联表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `groupuser` (</span><br><span class="line">  `groupid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `userid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `grouprole` enum(<span class="string">'creator'</span>,<span class="string">'normal'</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `groupid` (`groupid`,`userid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建离线消息表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `offlinemessage` (</span><br><span class="line">  `userid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `message` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `createtime` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><h3 id="集群聊天服务器开发"><a href="#集群聊天服务器开发" class="headerlink" title="集群聊天服务器开发"></a>集群聊天服务器开发</h3><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── sql</span><br><span class="line">│&nbsp;&nbsp; └── db.sql</span><br><span class="line">├── include</span><br><span class="line">│   ├── public</span><br><span class="line">│   │   ├── config.hpp</span><br><span class="line">│   │   ├── public.hpp</span><br><span class="line">│   │   └── times.hpp</span><br><span class="line">│   └── server</span><br><span class="line">│       ├── chatserver.hpp</span><br><span class="line">│       ├── chatservice.hpp</span><br><span class="line">│       ├── dao</span><br><span class="line">│       │   ├── friendmodel.hpp</span><br><span class="line">│       │   ├── groupmodel.hpp</span><br><span class="line">│       │   ├── groupusermodel.hpp</span><br><span class="line">│       │   ├── offlinemessagemodel.hpp</span><br><span class="line">│       │   └── usermodel.hpp</span><br><span class="line">│       ├── db</span><br><span class="line">│       │   └── db.hpp</span><br><span class="line">│       ├── domain</span><br><span class="line">│       │   ├── friend.hpp</span><br><span class="line">│       │   ├── group.hpp</span><br><span class="line">│       │   ├── groupuser.hpp</span><br><span class="line">│       │   ├── offlinemessage.hpp</span><br><span class="line">│       │   └── user.hpp</span><br><span class="line">│       └── redis</span><br><span class="line">│           └── redis.hpp</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── main.cpp</span><br><span class="line">│   └── server</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">│       ├── chatserver.cpp</span><br><span class="line">│       ├── chatservice.cpp</span><br><span class="line">│       ├── dao</span><br><span class="line">│       │   ├── friendmodel.cpp</span><br><span class="line">│       │   ├── groupmodel.cpp</span><br><span class="line">│       │   ├── groupusermodel.cpp</span><br><span class="line">│       │   ├── offlinemessagemodel.cpp</span><br><span class="line">│       │   └── usermodel.cpp</span><br><span class="line">│       ├── db</span><br><span class="line">│       │   └── db.cpp</span><br><span class="line">│       ├── main.cpp</span><br><span class="line">│       └── redis</span><br><span class="line">│           └── redis.cpp</span><br><span class="line">└── thirdparty</span><br><span class="line">    └── json.hpp</span><br></pre></td></tr></tbody></table></figure><h4 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h4><div class="admonition note"><p class="admonition-title">下载完整的项目代码</p><p>由于篇幅有限，下面只给出集群聊天服务端和客户端的部分核心代码，完整的项目代码可以在 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-cluster-chat-server">这里</a> 下载得到。</p></div><h5 id="公共核心代码"><a href="#公共核心代码" class="headerlink" title="公共核心代码"></a>公共核心代码</h5><ul><li><code>include/public/config.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局配置信息的头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 连接信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_IP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> DB_PORT = <span class="number">3306</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_USER = <span class="string">"root"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_PASSWORD = <span class="string">"Cxx_Chat_12345"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_NAME = <span class="string">"chat"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis 连接信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string REDIS_IP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> REDIS_PORT = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CONFIG_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>include/public/public.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUBLIC_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误编码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ErrorCode</span> {</span></span><br><span class="line">    SUCCESS = <span class="number">0</span>,           <span class="comment">// 请求处理成功</span></span><br><span class="line">    REGISTER_FAIL,         <span class="comment">// 注册失败</span></span><br><span class="line">    REPEAT_REGISTER,       <span class="comment">// 用户名已被注册</span></span><br><span class="line">    LOGIN_AUTH_FAIL,       <span class="comment">// 用户名或密码不正确</span></span><br><span class="line">    REPEAT_LOGIN,          <span class="comment">// 账号在其他设备已登录</span></span><br><span class="line">    ADD_FRIEND_FAIL,       <span class="comment">// 添加好友失败</span></span><br><span class="line">    JOIN_GROUP_FAIL,       <span class="comment">// 加入群组失败</span></span><br><span class="line">    SINGLE_CHAT_FAIL,      <span class="comment">// 一对一聊天失败</span></span><br><span class="line">    GROUP_CHAT_FAIL,       <span class="comment">// 群组聊天失败</span></span><br><span class="line">    INVALID_MESSAGE_TYPE,  <span class="comment">// 消息类型无效</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MsgType</span> {</span></span><br><span class="line">    LOGIN_MSG = <span class="number">1</span>,         <span class="comment">// 登录消息</span></span><br><span class="line">    LOGIN_MSG_ACK,         <span class="comment">// 登录响应消息</span></span><br><span class="line">    REGISTER_MSG,          <span class="comment">// 注册消息</span></span><br><span class="line">    REGISTER_MSG_ACK,      <span class="comment">// 注册响应消息</span></span><br><span class="line">    SINGLE_CHAT_MSG,       <span class="comment">// 一对一聊天消息</span></span><br><span class="line">    SINGLE_CHAT_MSG_ACK,   <span class="comment">// 一对一聊天响应消息</span></span><br><span class="line">    ADD_FRIEND_MSG,        <span class="comment">// 添加好友消息</span></span><br><span class="line">    ADD_FRIEND_MSG_ACK,    <span class="comment">// 添加好友响应消息</span></span><br><span class="line">    CREATE_GROUP_MSG,      <span class="comment">// 创建群组消息</span></span><br><span class="line">    CREATE_GROUP_MSG_ACK,  <span class="comment">// 创建群组响应消息</span></span><br><span class="line">    JOIN_GROUP_MSG,        <span class="comment">// 加入群组消息</span></span><br><span class="line">    JOIN_GROUP_MSG_ACK,    <span class="comment">// 加入群组响应消息</span></span><br><span class="line">    GROUP_CHAT_MSG,        <span class="comment">// 群聊天消息</span></span><br><span class="line">    GROUP_CHAT_MSG_ACK,    <span class="comment">// 群聊天响应消息</span></span><br><span class="line">    LOGIN_OUT_MSG,         <span class="comment">// 退出登录消息</span></span><br><span class="line">    LOGIN_OUT_MSG_ACK,     <span class="comment">// 退出登录响应消息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// PUBLIC_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>include/public/times.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIMES_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/c_local_time_adjustor.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/posix_time/posix_time.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间戳（单位：毫秒）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">getTimestampMs</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前系统的时间点</span></span><br><span class="line">    chrono::system_clock::time_point now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 转换为时间戳</span></span><br><span class="line">    <span class="keyword">return</span> chrono::duration_cast&lt;chrono::milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间戳（单位：毫秒）格式化为系统本地时间的字符串</span></span><br><span class="line"><span class="comment">// timestampMs: Unix 时间戳（自 1970-01-01 00:00:00 UTC 起的毫秒数）</span></span><br><span class="line"><span class="comment">// formatStr: 格式化字符串，例如 "%Y-%m-%d %H:%M:%S"</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">formatTimestampLocal</span><span class="params">(<span class="keyword">long</span> timestampMs, <span class="keyword">const</span> std::string&amp; formatStr)</span> </span>{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::posix_time;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::gregorian;</span><br><span class="line">    <span class="keyword">using</span> boost::date_time::c_local_adjustor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 UTC 时间：从 epoch 加上毫秒数</span></span><br><span class="line">    <span class="function">ptime <span class="title">epoch</span><span class="params">(date(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">    time_duration duration = <span class="built_in">milliseconds</span>(timestampMs);</span><br><span class="line">    ptime utc_time = epoch + duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为系统本地时间</span></span><br><span class="line">    <span class="keyword">typedef</span> c_local_adjustor&lt;ptime&gt; local_adj;</span><br><span class="line">    ptime local_time = local_adj::<span class="built_in">utc_to_local</span>(utc_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化输出</span></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    time_facet* facet = <span class="keyword">new</span> <span class="built_in">time_facet</span>(formatStr.<span class="built_in">c_str</span>());</span><br><span class="line">    oss.<span class="built_in">imbue</span>(std::<span class="built_in">locale</span>(std::locale::<span class="built_in">classic</span>(), facet));</span><br><span class="line">    oss &lt;&lt; local_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// TIMES_H</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="服务端核心代码"><a href="#服务端核心代码" class="headerlink" title="服务端核心代码"></a>服务端核心代码</h5><div class="admonition note"><p class="admonition-title">提示</p><p>在集群聊天服务端中，使用了 Json 库和 Muduo 网络库，并引入了 MySQL、Redis。</p></div><h6 id="Redis-操作代码"><a href="#Redis-操作代码" class="headerlink" title="Redis 操作代码"></a>Redis 操作代码</h6><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Redis 安装完成后，切记不要设置密码，否则下面的 C++ 代码将无法正常连接 Redis 服务器，这是因为下面的 C++ 代码并没有实现 Redis 的身份认证功能。</p></div><ul><li><code>include/server/redis/redis.hpp</code> 头文件 </li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> REDIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis 操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Redis</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Redis</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接redis服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向redis指定的通道subscribe消息</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">int</span> channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向redis指定的通道unsubscribe消息</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unsubscribe</span><span class="params">(<span class="keyword">int</span> channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在独立线程中异步接收订阅通道中的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">observer_channel_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向redis指定的通道publish消息</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">publish</span><span class="params">(<span class="keyword">int</span> channel, string message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化向业务层上报通道消息的回调对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init_notify_handler</span><span class="params">(function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, string)&gt; fn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// hiredis同步上下文对象（即redis客户端），负责publish消息</span></span><br><span class="line">    redisContext *_publish_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hiredis同步上下文对象（即redis客户端），负责subscribe消息</span></span><br><span class="line">    redisContext *_subcribe_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调操作，收到订阅的消息，给service层上报</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, string)&gt; _notify_message_handler;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/redis/redis.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Redis::<span class="built_in">Redis</span>() : _publish_context(<span class="literal">nullptr</span>), _subcribe_context(<span class="literal">nullptr</span>) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Redis::~<span class="built_in">Redis</span>() {</span><br><span class="line">    <span class="keyword">if</span> (_publish_context != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">redisFree</span>(_publish_context);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_subcribe_context != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">redisFree</span>(_subcribe_context);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接redis服务器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::connect</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 负责publish发布消息的上下文对象（即redis客户端）</span></span><br><span class="line">    _publish_context = <span class="built_in">redisConnect</span>(REDIS_IP.<span class="built_in">c_str</span>(), REDIS_PORT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == _publish_context || _publish_context-&gt;err) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"connect redis failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (_publish_context) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"connect redis error: "</span> &lt;&lt; _publish_context-&gt;errstr &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">redisFree</span>(_publish_context);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负责subscribe订阅消息的上下文对象（即redis客户端）</span></span><br><span class="line">    _subcribe_context = <span class="built_in">redisConnect</span>(REDIS_IP.<span class="built_in">c_str</span>(), REDIS_PORT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == _subcribe_context || _subcribe_context-&gt;err) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"connect redis failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (_subcribe_context) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"connect redis error: "</span> &lt;&lt; _subcribe_context-&gt;errstr &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">redisFree</span>(_subcribe_context);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在单独的线程中，监听通道上的事件，有消息就给业务层进行上报</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([&amp;]() { observer_channel_message(); })</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"connect redis success!"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向redis指定的通道subscribe消息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::subscribe</span><span class="params">(<span class="keyword">int</span> channel)</span> </span>{</span><br><span class="line">    <span class="comment">// SUBSCRIBE命令本身会造成线程阻塞等待通道里面发生消息，这里只做订阅通道，不接收通道消息</span></span><br><span class="line">    <span class="comment">// 通道消息的接收专门在observer_channel_message()函数中的独立线程中进行</span></span><br><span class="line">    <span class="comment">// 这里只负责发送订阅命令，不阻塞接收Redis服务器的响应消息，否则会和notifyMsg线程抢占响应资源</span></span><br><span class="line">    <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisAppendCommand</span>(<span class="keyword">this</span>-&gt;_subcribe_context, <span class="string">"SUBSCRIBE %d"</span>, channel)) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"subscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// redisBufferWrite()函数可以循环发送缓冲区中的数据，直到缓冲区数据发送完毕（done被置为1）</span></span><br><span class="line">    <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) {</span><br><span class="line">        <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisBufferWrite</span>(<span class="keyword">this</span>-&gt;_subcribe_context, &amp;done)) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"subscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向redis指定的通道unsubscribe消息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::unsubscribe</span><span class="params">(<span class="keyword">int</span> channel)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisAppendCommand</span>(<span class="keyword">this</span>-&gt;_subcribe_context, <span class="string">"UNSUBSCRIBE %d"</span>, channel)) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"unsubscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// redisBufferWrite()函数可以循环发送缓冲区中的数据，直到缓冲区数据发送完毕（done被置为1）</span></span><br><span class="line">    <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) {</span><br><span class="line">        <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisBufferWrite</span>(<span class="keyword">this</span>-&gt;_subcribe_context, &amp;done)) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"unsubscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在独立线程中异步接收订阅通道中的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Redis::observer_channel_message</span><span class="params">()</span> </span>{</span><br><span class="line">    redisReply *reply = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (REDIS_OK == <span class="built_in">redisGetReply</span>(<span class="keyword">this</span>-&gt;_subcribe_context, (<span class="keyword">void</span> **)&amp;reply)) {</span><br><span class="line">        <span class="comment">// 订阅收到的消息是一个带三个元素的数组</span></span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="literal">nullptr</span> &amp;&amp; reply-&gt;element[<span class="number">2</span>] != <span class="literal">nullptr</span> &amp;&amp; reply-&gt;element[<span class="number">2</span>]-&gt;str != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="comment">// 给业务层上报通道上发生的消息</span></span><br><span class="line">            _notify_message_handler(<span class="built_in">atoi</span>(reply-&gt;element[<span class="number">1</span>]-&gt;str), reply-&gt;element[<span class="number">2</span>]-&gt;str);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; observer_channel_message quit &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向redis指定的通道publish消息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::publish</span><span class="params">(<span class="keyword">int</span> channel, string message)</span> </span>{</span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">    redisReply *reply = (redisReply *)<span class="built_in">redisCommand</span>(_publish_context, <span class="string">"PUBLISH %d %s"</span>, channel, message.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == reply) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"publish command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化向业务层上报通道消息的回调对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Redis::init_notify_handler</span><span class="params">(function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, string)&gt; fn)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;_notify_message_handler = fn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="MySQL-操作代码"><a href="#MySQL-操作代码" class="headerlink" title="MySQL 操作代码"></a>MySQL 操作代码</h6><div class="admonition note"><p class="admonition-title">提示</p><p>这里使用 MySQL C API（Connector/C）库来读写 MySQL 数据库，该库基于 C 语言开发。</p></div><ul><li><code>include/server/db/db.hpp</code> 源文件 </li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DB_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化数据库连接</span></span><br><span class="line">    <span class="built_in">MySQL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放数据库连接</span></span><br><span class="line">    ~<span class="built_in">MySQL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新操作</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询操作</span></span><br><span class="line">    <span class="function">MYSQL_RES *<span class="title">query</span><span class="params">(string sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据库连接</span></span><br><span class="line">    <span class="function">MYSQL *<span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *_conn;  <span class="comment">// 数据库连接</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// DB_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/db/db.cpp</code> 源文件 </li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"db.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数据库连接</span></span><br><span class="line">MySQL::<span class="built_in">MySQL</span>() {</span><br><span class="line">    _conn = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放数据库连接</span></span><br><span class="line">MySQL::~<span class="built_in">MySQL</span>() {</span><br><span class="line">    <span class="keyword">if</span> (_conn != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">mysql_close</span>(_conn);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MySQL::connect</span><span class="params">()</span> </span>{</span><br><span class="line">    MYSQL *p = <span class="built_in">mysql_real_connect</span>(_conn, DB_IP.<span class="built_in">c_str</span>(), DB_USER.<span class="built_in">c_str</span>(), DB_PASSWORD.<span class="built_in">c_str</span>(), DB_NAME.<span class="built_in">c_str</span>(), DB_PORT,</span><br><span class="line">                                  <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="comment">// C和C++代码默认的编码字符是ASCII，如果不设置，从MySQL查询到的中文内容可能会显示？乱码</span></span><br><span class="line">        <span class="built_in">mysql_query</span>(_conn, <span class="string">"set names utf8mb4"</span>);</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"connect mysql success!"</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"connect mysql failed!"</span>;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="built_in">mysql_error</span>(_conn);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MySQL::update</span><span class="params">(string sql)</span> </span>{</span><br><span class="line">    LOG_DEBUG &lt;&lt; sql;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) {</span><br><span class="line">        LOG_ERROR &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">" "</span> &lt;&lt; sql &lt;&lt; <span class="string">" execute failed!"</span>;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="built_in">mysql_error</span>(_conn);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="function">MYSQL_RES *<span class="title">MySQL::query</span><span class="params">(string sql)</span> </span>{</span><br><span class="line">    LOG_DEBUG &lt;&lt; sql;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) {</span><br><span class="line">        LOG_ERROR &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">" "</span> &lt;&lt; sql &lt;&lt; <span class="string">" execute failed!"</span>;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="built_in">mysql_error</span>(_conn);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_store_result</span>(_conn);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据库连接</span></span><br><span class="line"><span class="function">MYSQL *<span class="title">MySQL::getConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> _conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="聊天服务端代码"><a href="#聊天服务端代码" class="headerlink" title="聊天服务端代码"></a>聊天服务端代码</h6><blockquote><p>聊天服务器的代码</p></blockquote><ul><li><code>include/server/chatserver.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CHATSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHATSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器的头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天服务器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ChatServer</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">const</span> string&amp; nameArg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ChatServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 处理用户的连接创建和断开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用户读写事件（比如接收客户端发送的数据）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    TcpServer _server;  <span class="comment">// TCP 服务器对象</span></span><br><span class="line">    EventLoop* _loop;   <span class="comment">// 指向事件回环的指针</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CHATSERVER_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/chatserver.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"chatserver.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"chatservice.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ChatServer::<span class="built_in">ChatServer</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">const</span> string&amp; nameArg)</span><br><span class="line">    : _server(loop, listenAddr, nameArg), _loop(loop) {</span><br><span class="line">    <span class="comment">// 设置服务端注册用户连接的创建和断开回调</span></span><br><span class="line">    _server.<span class="built_in">setConnectionCallback</span>(<span class="built_in">bind</span>(&amp;ChatServer::onConnection, <span class="keyword">this</span>, placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务端注册用户读写事件的回调</span></span><br><span class="line">    _server.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        <span class="built_in">bind</span>(&amp;ChatServer::onMessage, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置EventLoop的线程数量（比如：1个I/O线程，3个Worker线程）</span></span><br><span class="line">    _server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ChatServer::~<span class="built_in">ChatServer</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 开启事件循环处理</span></span><br><span class="line">    _server.<span class="built_in">start</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户的连接创建和断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;<span class="built_in">connected</span>()) {</span><br><span class="line">        <span class="comment">// 处理用户连接关闭的情况</span></span><br><span class="line">        ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">clientConnClose</span>(conn);</span><br><span class="line">        <span class="comment">// 断开连接（释放资源）</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户读写事件（比如接收客户端发送的数据）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取客户端发送的数据</span></span><br><span class="line">    string message = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"server received message : "</span> &lt;&lt; message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON 字符串反序列化</span></span><br><span class="line">    json jsonObj = json::<span class="built_in">parse</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非法消息直接忽略处理</span></span><br><span class="line">    <span class="keyword">if</span> (!jsonObj.<span class="built_in">contains</span>(<span class="string">"msgType"</span>)) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::INVALID_MESSAGE_TYPE;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"消息类型无效"</span>;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="keyword">int</span> msgType = jsonObj[<span class="string">"msgType"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息处理器</span></span><br><span class="line">    <span class="keyword">auto</span> msgHandler = ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">getMsgHandler</span>(msgType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用消息处理器，执行相应的业务处理</span></span><br><span class="line">    <span class="built_in">msgHandler</span>(conn, make_shared&lt;json&gt;(jsonObj), time);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>聊天核心业务的代码</p></blockquote><ul><li><code>include/server/chatservice.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CHATSERVICE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHATSERVICE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天核心业务的头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friendmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"groupmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"groupusermodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessagemodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usermodel.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理消息的回调类型（使用智能指针是为了兼容低版本的G++编译器）</span></span><br><span class="line"><span class="keyword">using</span> MsgHandler = function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天服务器的业务类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatService</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ChatService* <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理登录业务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理注册业务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reg</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理一对一聊天消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">singleChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理添加好友消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFriend</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理创建群组消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理加入群组消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">joinGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理群聊天消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">groupChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理退出登录消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loginOut</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息对应的处理器</span></span><br><span class="line">    <span class="function">MsgHandler <span class="title">getMsgHandler</span><span class="params">(<span class="keyword">int</span> msgType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理Redis订阅通道中发生的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRedisSubScribeMessage</span><span class="params">(<span class="keyword">int</span> userid, string msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用户连接关闭的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clientConnClose</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理服务器退出（Ctrl+C）后的业务重置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">ChatService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">ChatService</span>(<span class="keyword">const</span> ChatService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    ChatService&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ChatService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联消息ID和消息处理器（用于解耦业务代码）</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, MsgHandler&gt; _msgHandlerMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储在线用户的通信连接（操作时必须自行保证线程安全）</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, TcpConnectionPtr&gt; _userConnMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥锁，保证 _userConnMap 的线程安全</span></span><br><span class="line">    mutex _connMapmutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// User 表的数据操作对象</span></span><br><span class="line">    UserModel _userModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OfflineMessage 表的数据操作对象</span></span><br><span class="line">    OfflineMessageModel _offflineMessageModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Friend 表的数据操作对象</span></span><br><span class="line">    FriendModel _friendModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Group 表的数据操作对象</span></span><br><span class="line">    GroupModel _groupModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GroupUser 表的数据操作对象</span></span><br><span class="line">    GroupUserModel _groupUserModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis 操作对象</span></span><br><span class="line">    Redis _redis;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CHATSERVICE_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/chatservice.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器的业务实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"chatservice.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friendmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessagemodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"times.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usermodel.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ChatService::<span class="built_in">ChatService</span>() {</span><br><span class="line">    <span class="comment">// 连接Redis服务器</span></span><br><span class="line">    <span class="keyword">if</span> (_redis.<span class="built_in">connect</span>()) {</span><br><span class="line">        <span class="comment">// 设置Redis订阅通道的回调对象（负责处理Redis订阅消息）</span></span><br><span class="line">        _redis.<span class="built_in">init_notify_handler</span>(</span><br><span class="line">            <span class="built_in">bind</span>(&amp;ChatService::handleRedisSubScribeMessage, <span class="keyword">this</span>, placeholders::_1, placeholders::_2));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联登录业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(</span><br><span class="line">        {MsgType::LOGIN_MSG, <span class="built_in">bind</span>(&amp;ChatService::login, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联注册业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(</span><br><span class="line">        {MsgType::REGISTER_MSG, <span class="built_in">bind</span>(&amp;ChatService::reg, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联一对一聊天业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::SINGLE_CHAT_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::singleChat, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联添加好友业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::ADD_FRIEND_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::addFriend, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联添加群组业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::CREATE_GROUP_MSG, <span class="built_in">bind</span>(&amp;ChatService::createGroup, <span class="keyword">this</span>, placeholders::_1,</span><br><span class="line">                                                           placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联加入群组业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::JOIN_GROUP_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::joinGroup, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联群聊天业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::GROUP_CHAT_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::groupChat, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联退出登录业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::LOGIN_OUT_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::loginOut, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">ChatService* <span class="title">ChatService::instance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> ChatService instance;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取消息对应的处理器</span></span><br><span class="line"><span class="function">MsgHandler <span class="title">ChatService::getMsgHandler</span><span class="params">(<span class="keyword">int</span> msgType)</span> </span>{</span><br><span class="line">    <span class="comment">// 查找消息处理器</span></span><br><span class="line">    <span class="keyword">auto</span> it = _msgHandlerMap.<span class="built_in">find</span>(msgType);</span><br><span class="line">    <span class="comment">// 如果消息处理器不存在</span></span><br><span class="line">    <span class="keyword">if</span> (it == _msgHandlerMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 返回一个默认的消息处理器（空操作）</span></span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            LOG_ERROR &lt;&lt; <span class="string">"not found message handler by message type "</span> &lt;&lt; msgType;</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> _msgHandlerMap[msgType];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理Redis订阅通道中发生的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::handleRedisSubScribeMessage</span><span class="params">(<span class="keyword">int</span> userid, string msg)</span> </span>{</span><br><span class="line">    <span class="comment">// JSON 反序列化</span></span><br><span class="line">    json js = json::<span class="built_in">parse</span>(msg.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送的时间</span></span><br><span class="line">    <span class="keyword">long</span> timestamp = js[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息接收者的连接信息</span></span><br><span class="line">    <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(userid);</span><br><span class="line">    <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 消息接收者在线（指在当前聊天服务器中），直接转发消息</span></span><br><span class="line">        it-&gt;second-&gt;<span class="built_in">send</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 当接收到Redis订阅消息时，如果消息接收者刚好下线，则存储离线消息</span></span><br><span class="line">        OfflineMessage <span class="built_in">msg</span>(userid, js.<span class="built_in">dump</span>(), timestamp);</span><br><span class="line">        _offflineMessageModel.<span class="built_in">insert</span>(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理登录业务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::login</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    string name = (*data)[<span class="string">"name"</span>].get&lt;string&gt;();</span><br><span class="line">    string password = (*data)[<span class="string">"password"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户信息</span></span><br><span class="line">    User user = _userModel.<span class="built_in">selectByName</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">    <span class="keyword">if</span> (user.<span class="built_in">getId</span>() != <span class="number">-1</span> &amp;&amp; user.<span class="built_in">getPassword</span>() == password) {</span><br><span class="line">        <span class="comment">// 重复登录</span></span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">getState</span>() == <span class="string">"online"</span>) {</span><br><span class="line">            <span class="comment">// 返回数据给客户端</span></span><br><span class="line">            json response;</span><br><span class="line">            response[<span class="string">"errNum"</span>] = ErrorCode::REPEAT_LOGIN;</span><br><span class="line">            response[<span class="string">"errMsg"</span>] = <span class="string">"该账号在其他设备已登录"</span>;</span><br><span class="line">            response[<span class="string">"msgType"</span>] = MsgType::LOGIN_MSG_ACK;</span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 登录成功</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            unique_lock&lt;mutex&gt; <span class="built_in">lock</span>(_connMapmutex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储在线用户的通信连接</span></span><br><span class="line">            _userConnMap.<span class="built_in">insert</span>({user.<span class="built_in">getId</span>(), conn});</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放互斥锁</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向Redis订阅Channel</span></span><br><span class="line">            _redis.<span class="built_in">subscribe</span>(user.<span class="built_in">getId</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新用户登录状态</span></span><br><span class="line">            user.<span class="built_in">setState</span>(<span class="string">"online"</span>);</span><br><span class="line">            _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回给客户端的数据</span></span><br><span class="line">            json response;</span><br><span class="line">            response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">            response[<span class="string">"userId"</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">            response[<span class="string">"userName"</span>] = user.<span class="built_in">getName</span>();</span><br><span class="line">            response[<span class="string">"msgType"</span>] = MsgType::LOGIN_MSG_ACK;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询该用户是否有离线消息</span></span><br><span class="line">            vector&lt;OfflineMessage&gt; messages = _offflineMessageModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (!messages.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="comment">// 返回该用户的所有离线消息</span></span><br><span class="line">                response[<span class="string">"offlinemsg"</span>] = messages;</span><br><span class="line">                <span class="comment">// 读取该用户的离线消息后，将该用户的离线消息全部删除掉</span></span><br><span class="line">                _offflineMessageModel.<span class="built_in">remove</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询该用户的好友列表</span></span><br><span class="line">            vector&lt;User&gt; friends = _friendModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (!friends.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="comment">// 返回该用户的好友列表</span></span><br><span class="line">                response[<span class="string">"friends"</span>] = friends;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询该用户的群组列表</span></span><br><span class="line">            vector&lt;Group&gt; groups = _groupUserModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (!groups.<span class="built_in">empty</span>()) {</span><br><span class="line">                response[<span class="string">"groups"</span>] = groups;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回数据给客户端</span></span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 登录失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::LOGIN_AUTH_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"用户名或密码不正确"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::LOGIN_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理注册业务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::reg</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建用户对象</span></span><br><span class="line">    string name = (*data)[<span class="string">"name"</span>].get&lt;string&gt;();</span><br><span class="line">    string password = (*data)[<span class="string">"password"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户名是否已被注册</span></span><br><span class="line">    User oldUser = _userModel.<span class="built_in">selectByName</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (oldUser.<span class="built_in">getId</span>() != <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::REPEAT_REGISTER;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"用户名已被注册"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::REGISTER_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户记录</span></span><br><span class="line">    <span class="function">User <span class="title">newUser</span><span class="params">(name, password)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> result = _userModel.<span class="built_in">insert</span>(newUser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户记录成功</span></span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">        response[<span class="string">"userId"</span>] = newUser.<span class="built_in">getId</span>();</span><br><span class="line">        response[<span class="string">"userName"</span>] = newUser.<span class="built_in">getName</span>();</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::REGISTER_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 插入用户记录失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::REGISTER_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"用户注册失败"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::REGISTER_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理一对一聊天消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::singleChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 消息发送者的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> fromId = (*data)[<span class="string">"fromId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送者的用户名称</span></span><br><span class="line">    string fromName = (*data)[<span class="string">"fromName"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送者的消息内容</span></span><br><span class="line">    string fromMsg = (*data)[<span class="string">"fromMsg"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送的时间戳</span></span><br><span class="line">    <span class="keyword">long</span> fromTimestamp = (*data)[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息接收者的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> toId = (*data)[<span class="string">"toId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息接收者是否在当前聊天服务器中</span></span><br><span class="line">    <span class="keyword">bool</span> toExisted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否已经添加消息接收者为好友</span></span><br><span class="line">    Friend friendRel = _friendModel.<span class="built_in">select</span>(fromId, toId);</span><br><span class="line">    <span class="keyword">if</span> (friendRel.<span class="built_in">getUserId</span>() == <span class="number">-1</span> || friendRel.<span class="built_in">getFriendId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::SINGLE_CHAT_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"未添加对方好友, 无法进行一对一聊天"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::SINGLE_CHAT_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息接收者的连接信息</span></span><br><span class="line">    <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(toId);</span><br><span class="line">    <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 记录消息接收者在线（指在当前聊天服务器中）</span></span><br><span class="line">        toExisted = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 消息接收者在线（指在当前聊天服务器中），直接转发消息</span></span><br><span class="line">        it-&gt;second-&gt;<span class="built_in">send</span>((*data).<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息接收者不在当前聊天服务器中</span></span><br><span class="line">    <span class="keyword">if</span> (!toExisted) {</span><br><span class="line">        User toUser = _userModel.<span class="built_in">select</span>(toId);</span><br><span class="line">        <span class="comment">// 判断消息接收者是否在线（指在其他聊天服务器中）</span></span><br><span class="line">        <span class="keyword">if</span> (toUser.<span class="built_in">getState</span>() == <span class="string">"online"</span>) {</span><br><span class="line">            <span class="comment">// 消息接收者在线，通过Redis发布消息</span></span><br><span class="line">            _redis.<span class="built_in">publish</span>(toId, (*data).<span class="built_in">dump</span>());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 消息接收者不在线，存储离线消息</span></span><br><span class="line">            OfflineMessage <span class="built_in">msg</span>(toId, (*data).<span class="built_in">dump</span>(), fromTimestamp);</span><br><span class="line">            _offflineMessageModel.<span class="built_in">insert</span>(msg);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::SINGLE_CHAT_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理添加好友消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::addFriend</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好友的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> friendId = (*data)[<span class="string">"friendId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制不允许添加自己为好友</span></span><br><span class="line">    <span class="keyword">if</span> (userId == friendId) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::ADD_FRIEND_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"不允许添加自己为好友"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::ADD_FRIEND_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断好友是否真实存在</span></span><br><span class="line">    User friendUser = _userModel.<span class="built_in">select</span>(friendId);</span><br><span class="line">    <span class="keyword">if</span> (friendUser.<span class="built_in">getId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::ADD_FRIEND_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"好友ID不存在"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::ADD_FRIEND_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增好友关系</span></span><br><span class="line">    _friendModel.<span class="built_in">insert</span>(userId, friendId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::ADD_FRIEND_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理创建群组消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::createGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组名称</span></span><br><span class="line">    string groupName = (*data)[<span class="string">"groupName"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组描述</span></span><br><span class="line">    string groupDesc = (*data)[<span class="string">"groupDesc"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增群组</span></span><br><span class="line">    <span class="function">Group <span class="title">group</span><span class="params">(groupName, groupDesc)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> result = _groupModel.<span class="built_in">insert</span>(group);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加群组的创建人信息</span></span><br><span class="line">    <span class="keyword">if</span> (result &amp;&amp; group.<span class="built_in">getId</span>() != <span class="number">-1</span>) {</span><br><span class="line">        GroupUser groupUser;</span><br><span class="line">        groupUser.<span class="built_in">setGroupId</span>(group.<span class="built_in">getId</span>());</span><br><span class="line">        groupUser.<span class="built_in">setUserId</span>(userId);</span><br><span class="line">        groupUser.<span class="built_in">setGroupRole</span>(<span class="string">"creator"</span>);</span><br><span class="line">        <span class="comment">// 新增群组和用户的关联信息</span></span><br><span class="line">        _groupUserModel.<span class="built_in">insert</span>(groupUser);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"groupId"</span>] = group.<span class="built_in">getId</span>();</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::CREATE_GROUP_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理加入群组消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::joinGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组ID</span></span><br><span class="line">    <span class="keyword">int</span> groupId = (*data)[<span class="string">"groupId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断群组是否真实存在</span></span><br><span class="line">    Group group = _groupModel.<span class="built_in">select</span>(groupId);</span><br><span class="line">    <span class="keyword">if</span> (group.<span class="built_in">getId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::JOIN_GROUP_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"群组ID不存在"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::JOIN_GROUP_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增群组和用户的关联信息</span></span><br><span class="line">    <span class="function">GroupUser <span class="title">groupUser</span><span class="params">(groupId, userId, <span class="string">"normal"</span>)</span></span>;</span><br><span class="line">    _groupUserModel.<span class="built_in">insert</span>(groupUser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::JOIN_GROUP_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理群聊天消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::groupChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 消息发送者的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> fromId = (*data)[<span class="string">"fromId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送者的用户名称</span></span><br><span class="line">    string fromName = (*data)[<span class="string">"fromName"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送的时间戳</span></span><br><span class="line">    <span class="keyword">long</span> fromTimestamp = (*data)[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组的ID</span></span><br><span class="line">    <span class="keyword">int</span> groupId = (*data)[<span class="string">"groupId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组消息的内容</span></span><br><span class="line">    string groupMsg = (*data)[<span class="string">"groupMsg"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户是否已经加入群组</span></span><br><span class="line">    GroupUser groupUser = _groupUserModel.<span class="built_in">select</span>(groupId, fromId);</span><br><span class="line">    <span class="keyword">if</span> (groupUser.<span class="built_in">getGroupId</span>() == <span class="number">-1</span> || groupUser.<span class="built_in">getUserId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::JOIN_GROUP_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"未加入该群组, 无法进行群聊"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::JOIN_GROUP_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询群组内的用户（除了发送群组消息的用户）</span></span><br><span class="line">    vector&lt;User&gt; users = _groupUserModel.<span class="built_in">selectGroupUsers</span>(groupId, fromId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理群聊消息</span></span><br><span class="line">    <span class="keyword">if</span> (!users.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        unique_lock&lt;mutex&gt; lock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历群组内的用户</span></span><br><span class="line">        <span class="keyword">for</span> (User&amp; user : users) {</span><br><span class="line">            <span class="comment">// 获取用户的连接信息</span></span><br><span class="line">            <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">                <span class="comment">// 用户在线（指在当前聊天服务器中），直接转发群聊消息</span></span><br><span class="line">                it-&gt;second-&gt;<span class="built_in">send</span>((*data).<span class="built_in">dump</span>());</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                User toUser = _userModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">                <span class="comment">// 判断用户是否在线（指在其他聊天服务器中）</span></span><br><span class="line">                <span class="keyword">if</span> (toUser.<span class="built_in">getState</span>() == <span class="string">"online"</span>) {</span><br><span class="line">                    <span class="comment">// 用户在线，通过Redis发布群聊消息</span></span><br><span class="line">                    _redis.<span class="built_in">publish</span>(user.<span class="built_in">getId</span>(), (*data).<span class="built_in">dump</span>());</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 用户不在线，存储离线群聊消息</span></span><br><span class="line">                    OfflineMessage message;</span><br><span class="line">                    message.<span class="built_in">setUserId</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">                    message.<span class="built_in">setCreateTime</span>(fromTimestamp);</span><br><span class="line">                    message.<span class="built_in">setMessage</span>((*data).<span class="built_in">dump</span>());</span><br><span class="line">                    _offflineMessageModel.<span class="built_in">insert</span>(message);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::GROUP_CHAT_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理退出登录消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::loginOut</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除连接信息</span></span><br><span class="line">    <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(userId);</span><br><span class="line">    <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">        _userConnMap.<span class="built_in">erase</span>(it-&gt;first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往Redis取消订阅Channel</span></span><br><span class="line">    _redis.<span class="built_in">unsubscribe</span>(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新用户的登录状态</span></span><br><span class="line">    User user;</span><br><span class="line">    user.<span class="built_in">setId</span>(userId);</span><br><span class="line">    user.<span class="built_in">setState</span>(<span class="string">"offline"</span>);</span><br><span class="line">    _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::LOGIN_OUT_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户连接关闭的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::clientConnClose</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="comment">// 用户信息</span></span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Map表中删除用户对应的连接信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = _userConnMap.<span class="built_in">begin</span>(); it != _userConnMap.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second == conn) {</span><br><span class="line">            <span class="comment">// 记录用户ID</span></span><br><span class="line">            user.<span class="built_in">setId</span>(it-&gt;first);</span><br><span class="line">            <span class="comment">// 移除连接信息</span></span><br><span class="line">            _userConnMap.<span class="built_in">erase</span>(it-&gt;first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user.<span class="built_in">getId</span>() != <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 往Redis取消订阅Channel</span></span><br><span class="line">        _redis.<span class="built_in">unsubscribe</span>(user.<span class="built_in">getId</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新用户的登录状态</span></span><br><span class="line">        user.<span class="built_in">setState</span>(<span class="string">"offline"</span>);</span><br><span class="line">        _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理服务器退出（Ctrl+C）后的业务重置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::reset</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 重置所有用户的登录状态</span></span><br><span class="line">    _userModel.<span class="built_in">resetState</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>数据库业务操作的代码</p></blockquote><ul><li><code>include/server/dao/friendmodel.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FRIENDMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRIENDMODEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Friend 表的数据操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendModel</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加好友关系</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找好友列表</span></span><br><span class="line">    <span class="function">vector&lt;User&gt; <span class="title">select</span><span class="params">(<span class="keyword">int</span> userid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找好友关系</span></span><br><span class="line">    <span class="function">Friend <span class="title">select</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// FRIENDMODEL_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/dao/friendmodel.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;friendmodel.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"db.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加好友关系</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FriendModel::insert</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> sql[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 SQL 语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">"insert into friend(userid, friendid) values(%d, %d)"</span>, userid, friendid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 SQL 语句</span></span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>() &amp;&amp; mysql.<span class="built_in">update</span>(sql)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找好友列表</span></span><br><span class="line"><span class="function">vector&lt;User&gt; <span class="title">FriendModel::select</span><span class="params">(<span class="keyword">int</span> userid)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> sql[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询结果</span></span><br><span class="line">    vector&lt;User&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 SQL 语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql,</span><br><span class="line">            <span class="string">"select u.id, u.name, u.state from friend f inner join user u on f.friendid = u.id where f.userid = %d"</span>,</span><br><span class="line">            userid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 SQL 语句</span></span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>()) {</span><br><span class="line">        MYSQL_RES* res = mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">mysql_num_rows</span>(res) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 获取所有查询结果</span></span><br><span class="line">            MYSQL_ROW row;</span><br><span class="line">            <span class="keyword">while</span> ((row = <span class="built_in">mysql_fetch_row</span>(res)) != <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">int</span> id = <span class="built_in">atoi</span>(row[<span class="number">0</span>]);</span><br><span class="line">                string name = row[<span class="number">1</span>];</span><br><span class="line">                string state = row[<span class="number">2</span>];</span><br><span class="line">                result.<span class="built_in">emplace_back</span>(id, name, state);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回查询结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找好友关系</span></span><br><span class="line"><span class="function">Friend <span class="title">FriendModel::select</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> sql[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询结果</span></span><br><span class="line">    Friend result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 SQL 语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">"select userid, friendid from friend where userid = %d and friendid = %d"</span>, userid, friendid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 SQL 语句</span></span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>()) {</span><br><span class="line">        MYSQL_RES* res = mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">mysql_num_rows</span>(res) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 获取所有查询结果</span></span><br><span class="line">            MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res);</span><br><span class="line">            result.<span class="built_in">setUserId</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">            result.<span class="built_in">setFriendId</span>(<span class="built_in">atoi</span>(row[<span class="number">1</span>]));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回查询结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="客户端核心代码"><a href="#客户端核心代码" class="headerlink" title="客户端核心代码"></a>客户端核心代码</h5><h6 id="聊天客户端代码"><a href="#聊天客户端代码" class="headerlink" title="聊天客户端代码"></a>聊天客户端代码</h6><div class="admonition note"><p class="admonition-title">提示</p><p>在集群聊天客户端中，使用了 Linux 的 <code>socket</code> 和 <code>semaphore</code>，并没有引入 Muduo 网络库。</p></div><ul><li><code>src/client/main.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"group.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"groupmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessage.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessagemodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"times.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usermodel.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录当前登录用户的基本信息</span></span><br><span class="line">User g_currentUser;</span><br><span class="line"><span class="comment">// 记录当前登录用户的好友列表信息</span></span><br><span class="line">vector&lt;User&gt; g_currentUserFriendList;</span><br><span class="line"><span class="comment">// 记录当前登录用户的群组列表信息</span></span><br><span class="line">vector&lt;Group&gt; g_currentUserGroupList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于读/写线程之间的通信</span></span><br><span class="line"><span class="keyword">sem_t</span> rwsem;</span><br><span class="line"><span class="comment">// 控制主菜单程序运行</span></span><br><span class="line"><span class="keyword">bool</span> isMainMenuRunning = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 记录用户的登录状态</span></span><br><span class="line"><span class="keyword">atomic_bool</span> g_isLoginSuccess{<span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主菜单程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainMenu</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 子线程接收到消息后的处理逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readTaskHandler</span><span class="params">(<span class="keyword">int</span> clientfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示当前登录用户的基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showCurrentUserData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////首页功能/////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天客户端程序实现, 主线程用作消息发送线程, 子线程用作消息接收线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"command invalid, example: ./chat_client 127.0.0.1 8000"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析通过命令行参数传递的IP和端口号</span></span><br><span class="line">    <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建client端的socket</span></span><br><span class="line">    <span class="keyword">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clientfd) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"socket create failed"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填写client需要连接的服务器信息（IP和端口号）</span></span><br><span class="line">    sockaddr_in server;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sockaddr_in));</span><br><span class="line"></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client和server进行连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;server, <span class="built_in"><span class="keyword">sizeof</span></span>(sockaddr_in))) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"connect server failed"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化读写线程通信用的信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;rwsem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器成功, 启动一个接收消息的子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">readTask</span><span class="params">(readTaskHandler, clientfd)</span></span>;</span><br><span class="line">    readTask.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程用于接收用户输入, 负责发送数据</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 显示首页面菜单: 登录、注册、退出程序</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"========================"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"1. login"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"2. register"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"3. quit"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"========================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户输入验证循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"choice: "</span>;</span><br><span class="line">            cin &gt;&gt; choice;</span><br><span class="line">            <span class="comment">// 判断输入是否合法</span></span><br><span class="line">            <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) {</span><br><span class="line">                <span class="comment">// 输入不是整数，清除错误标志</span></span><br><span class="line">                cin.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">                cin.<span class="built_in">ignore</span>(<span class="number">10000</span>, <span class="string">'\n'</span>);</span><br><span class="line">                cerr &lt;&lt; <span class="string">"invalid choice!"</span> &lt;&lt; endl;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 清除残留的换行符</span></span><br><span class="line">                cin.<span class="built_in">ignore</span>(<span class="number">10000</span>, <span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据用户输入执行操作</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (choice) {</span><br><span class="line">            <span class="comment">// 登录业务</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: {</span><br><span class="line">                <span class="keyword">char</span> name[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                <span class="keyword">char</span> password[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                cout &lt;&lt; <span class="string">"user name: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(name, <span class="number">50</span>);</span><br><span class="line">                cout &lt;&lt; <span class="string">"user password: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(password, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">                json js;</span><br><span class="line">                js[<span class="string">"msgType"</span>] = LOGIN_MSG;</span><br><span class="line">                js[<span class="string">"name"</span>] = name;</span><br><span class="line">                js[<span class="string">"password"</span>] = password;</span><br><span class="line">                string request = js.<span class="built_in">dump</span>();</span><br><span class="line"></span><br><span class="line">                g_isLoginSuccess = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, request.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(request.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) {</span><br><span class="line">                    cerr &lt;&lt; <span class="string">"send login msg error: "</span> &lt;&lt; request &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待信号量, 由子线程处理完登录的响应消息后, 通知主线程继续执行</span></span><br><span class="line">                <span class="built_in">sem_wait</span>(&amp;rwsem);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 用户登录成功</span></span><br><span class="line">                <span class="keyword">if</span> (g_isLoginSuccess) {</span><br><span class="line">                    <span class="comment">// 进入聊天主菜单</span></span><br><span class="line">                    isMainMenuRunning = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">mainMenu</span>(clientfd);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 注册业务</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: {</span><br><span class="line">                <span class="keyword">char</span> name[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                <span class="keyword">char</span> pwd[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                cout &lt;&lt; <span class="string">"user name: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(name, <span class="number">50</span>);</span><br><span class="line">                cout &lt;&lt; <span class="string">"user password: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(pwd, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">                json js;</span><br><span class="line">                js[<span class="string">"msgType"</span>] = REGISTER_MSG;</span><br><span class="line">                js[<span class="string">"name"</span>] = name;</span><br><span class="line">                js[<span class="string">"password"</span>] = pwd;</span><br><span class="line">                string request = js.<span class="built_in">dump</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, request.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(request.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) {</span><br><span class="line">                    cerr &lt;&lt; <span class="string">"send reg msg error: "</span> &lt;&lt; request &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待信号量, 由子线程处理完注册的响应消息后, 通知主线程继续执行</span></span><br><span class="line">                <span class="built_in">sem_wait</span>(&amp;rwsem);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 退出程序业务</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">close</span>(clientfd);</span><br><span class="line">                <span class="built_in">sem_destroy</span>(&amp;rwsem);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cerr &lt;&lt; <span class="string">"invalid choice!"</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理注册的响应逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRegResponse</span><span class="params">(json &amp;responsejs)</span> </span>{</span><br><span class="line">    <span class="comment">// 注册失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != responsejs[<span class="string">"errNum"</span>].get&lt;<span class="keyword">int</span>&gt;()) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"注册失败: "</span> &lt;&lt; responsejs[<span class="string">"errMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 注册成功</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"注册成功, 用户ID: "</span> &lt;&lt; responsejs[<span class="string">"userId"</span>] &lt;&lt; <span class="string">" , 用户名称: "</span> &lt;&lt; responsejs[<span class="string">"userName"</span>].get&lt;string&gt;()</span><br><span class="line">             &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理登录的响应逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoginResponse</span><span class="params">(json &amp;responsejs)</span> </span>{</span><br><span class="line">    <span class="comment">// 登录失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != responsejs[<span class="string">"errNum"</span>].get&lt;<span class="keyword">int</span>&gt;()) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"登录失败: "</span> &lt;&lt; responsejs[<span class="string">"errMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">        g_isLoginSuccess = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 记录当前登录用户的基本信息</span></span><br><span class="line">        g_currentUser.<span class="built_in">setId</span>(responsejs[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        g_currentUser.<span class="built_in">setName</span>(responsejs[<span class="string">"userName"</span>].get&lt;string&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前用户的好友列表信息</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">"friends"</span>)) {</span><br><span class="line">            <span class="comment">// 初始化好友列表</span></span><br><span class="line">            g_currentUserFriendList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            vector&lt;User&gt; vec = responsejs[<span class="string">"friends"</span>];</span><br><span class="line">            <span class="keyword">for</span> (User &amp;user : vec) {</span><br><span class="line">                g_currentUserFriendList.<span class="built_in">push_back</span>(user);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前用户的群组列表信息</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">"groups"</span>)) {</span><br><span class="line">            <span class="comment">// 初始化群组列表</span></span><br><span class="line">            g_currentUserGroupList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            vector&lt;Group&gt; vec = responsejs[<span class="string">"groups"</span>];</span><br><span class="line">            <span class="keyword">for</span> (Group &amp;group : vec) {</span><br><span class="line">                g_currentUserGroupList.<span class="built_in">push_back</span>(group);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示登录用户的基本信息</span></span><br><span class="line">        <span class="built_in">showCurrentUserData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示当前用户的离线消息（个人聊天信息或者群组消息）</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">"offlinemsg"</span>)) {</span><br><span class="line">            vector&lt;OfflineMessage&gt; vec = responsejs[<span class="string">"offlinemsg"</span>];</span><br><span class="line">            <span class="keyword">for</span> (OfflineMessage &amp;message : vec) {</span><br><span class="line">                <span class="comment">// 离线消息的内容（JSON字符串）</span></span><br><span class="line">                json content = json::<span class="built_in">parse</span>(message.<span class="built_in">getMessage</span>());</span><br><span class="line">                <span class="comment">// 离线消息的发送时间</span></span><br><span class="line">                string datetime = formatTimestampLocal(message.<span class="built_in">getCreateTime</span>(), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">                <span class="comment">// 打印一对一聊天消息</span></span><br><span class="line">                <span class="keyword">if</span> (SINGLE_CHAT_MSG == content[<span class="string">"msgType"</span>].get&lt;<span class="keyword">int</span>&gt;()) {</span><br><span class="line">                    cout &lt;&lt; <span class="string">"好友消息["</span> &lt;&lt; content[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" "</span></span><br><span class="line">                         &lt;&lt; content[<span class="string">"fromName"</span>].get&lt;string&gt;() &lt;&lt; <span class="string">" said: "</span> &lt;&lt; content[<span class="string">"fromMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 打印群组聊天消息</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    cout &lt;&lt; <span class="string">"群聊消息["</span> &lt;&lt; content[<span class="string">"groupId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" ["</span> &lt;&lt; content[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span></span><br><span class="line">                         &lt;&lt; content[<span class="string">"fromName"</span>].get&lt;string&gt;() &lt;&lt; <span class="string">" said: "</span> &lt;&lt; content[<span class="string">"groupMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        g_isLoginSuccess = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程（接收消息的线程）执行的业务逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readTaskHandler</span><span class="params">(<span class="keyword">int</span> clientfd)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">recv</span>(clientfd, buffer, <span class="number">1024</span>, <span class="number">0</span>);  <span class="comment">// 阻塞等待消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == len || <span class="number">0</span> == len) {</span><br><span class="line">            <span class="built_in">close</span>(clientfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收ChatServer转发的数据, 反序列化生成JSON数据对象</span></span><br><span class="line">        json js = json::<span class="built_in">parse</span>(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息类型</span></span><br><span class="line">        <span class="keyword">int</span> msgType = js[<span class="string">"msgType"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 错误编码</span></span><br><span class="line">        <span class="keyword">int</span> errNum = js.<span class="built_in">contains</span>(<span class="string">"errNum"</span>) ? js[<span class="string">"errNum"</span>].get&lt;<span class="keyword">int</span>&gt;() : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理接收到的一对一聊天消息</span></span><br><span class="line">        <span class="keyword">if</span> (SINGLE_CHAT_MSG == msgType) {</span><br><span class="line">            string datetime = formatTimestampLocal(js[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;(), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">"好友消息["</span> &lt;&lt; js[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" "</span> &lt;&lt; js[<span class="string">"fromName"</span>].get&lt;string&gt;()</span><br><span class="line">                 &lt;&lt; <span class="string">" said: "</span> &lt;&lt; js[<span class="string">"fromMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理接收到的群组聊天消息</span></span><br><span class="line">        <span class="keyword">if</span> (GROUP_CHAT_MSG == msgType) {</span><br><span class="line">            string datetime = formatTimestampLocal(js[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;(), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">"群聊消息["</span> &lt;&lt; js[<span class="string">"groupId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" ["</span> &lt;&lt; js[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span></span><br><span class="line">                 &lt;&lt; js[<span class="string">"fromName"</span>].get&lt;string&gt;() &lt;&lt; <span class="string">" said: "</span> &lt;&lt; js[<span class="string">"groupMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理登录响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (LOGIN_MSG_ACK == msgType) {</span><br><span class="line">            <span class="built_in">doLoginResponse</span>(js);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;rwsem);  <span class="comment">// 通知主线程, 登录结果处理完成</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理注册响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (REGISTER_MSG_ACK == msgType) {</span><br><span class="line">            <span class="built_in">doRegResponse</span>(js);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;rwsem);  <span class="comment">// 通知主线程, 注册结果处理完成</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理成功创建群组响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (CREATE_GROUP_MSG_ACK == msgType &amp;&amp; SUCCESS == errNum) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"群组创建成功, 群组ID: "</span> &lt;&lt; js[<span class="string">"groupId"</span>].get&lt;<span class="keyword">int</span>&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理成功加入群组响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (JOIN_GROUP_MSG_ACK == msgType &amp;&amp; SUCCESS == errNum) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"加入群组成功"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理成功添加好友响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (ADD_FRIEND_MSG_ACK == msgType &amp;&amp; SUCCESS == errNum) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"好友添加成功"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理其他业务的错误响应</span></span><br><span class="line">        <span class="keyword">if</span> (SUCCESS != errNum &amp;&amp; js.<span class="built_in">contains</span>(<span class="string">"errMsg"</span>)) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"操作失败: "</span> &lt;&lt; js[<span class="string">"errMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示当前登录成功用户的基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showCurrentUserData</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"======================login user======================"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"current login user =&gt; id:"</span> &lt;&lt; g_currentUser.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" name:"</span> &lt;&lt; g_currentUser.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------friend list---------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!g_currentUserFriendList.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">for</span> (User &amp;user : g_currentUserFriendList) {</span><br><span class="line">            cout &lt;&lt; user.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getName</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getState</span>() &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------group list----------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!g_currentUserGroupList.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">for</span> (Group &amp;group : g_currentUserGroupList) {</span><br><span class="line">            cout &lt;&lt; group.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; group.<span class="built_in">getGroupName</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; group.<span class="built_in">getGroupDesc</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (User &amp;user : group.<span class="built_in">getUsers</span>()) {</span><br><span class="line">                cout &lt;&lt; user.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getName</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getState</span>() &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"======================================================"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////主菜单功能/////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "help" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span> fd = <span class="number">0</span>, string str = <span class="string">""</span>)</span></span>;</span><br><span class="line"><span class="comment">// "singlechat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">singlechat</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "addfriend" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfriend</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "creategroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creategroup</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "joingroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joingroup</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "groupchat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">groupchat</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "loginout" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loginout</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统支持的客户端命令列表</span></span><br><span class="line">unordered_map&lt;string, string&gt; commandMap = {{<span class="string">"help"</span>, <span class="string">"显示所有支持的命令, 格式 help"</span>},</span><br><span class="line">                                            {<span class="string">"singlechat"</span>, <span class="string">"一对一聊天, 格式 singlechat:friendid:message"</span>},</span><br><span class="line">                                            {<span class="string">"addfriend"</span>, <span class="string">"添加好友, 格式 addfriend:friendid"</span>},</span><br><span class="line">                                            {<span class="string">"creategroup"</span>, <span class="string">"创建群组, 格式 creategroup:groupname:groupdesc"</span>},</span><br><span class="line">                                            {<span class="string">"joingroup"</span>, <span class="string">"加入群组, 格式 joingroup:groupid"</span>},</span><br><span class="line">                                            {<span class="string">"groupchat"</span>, <span class="string">"群组聊天, 格式 groupchat:groupid:message"</span>},</span><br><span class="line">                                            {<span class="string">"loginout"</span>, <span class="string">"退出登录, 格式 loginout"</span>}};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册系统支持的客户端命令处理</span></span><br><span class="line">unordered_map&lt;string, function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, string)&gt;&gt; commandHandlerMap = {</span><br><span class="line">    {<span class="string">"help"</span>, help},           {<span class="string">"singlechat"</span>, singlechat}, {<span class="string">"addfriend"</span>, addfriend}, {<span class="string">"creategroup"</span>, creategroup},</span><br><span class="line">    {<span class="string">"joingroup"</span>, joingroup}, {<span class="string">"groupchat"</span>, groupchat},   {<span class="string">"loginout"</span>, loginout}};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主菜单程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainMenu</span><span class="params">(<span class="keyword">int</span> clientfd)</span> </span>{</span><br><span class="line">    <span class="built_in">help</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">while</span> (isMainMenuRunning) {</span><br><span class="line">        <span class="comment">// 存储用户选择执行的命令</span></span><br><span class="line">        string command;</span><br><span class="line">        cin.<span class="built_in">getline</span>(buffer, <span class="number">1024</span>);</span><br><span class="line">        <span class="function">string <span class="title">commandbuf</span><span class="params">(buffer)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> idx = commandbuf.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">            command = commandbuf;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            command = commandbuf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找相应命令的事件处理器</span></span><br><span class="line">        <span class="keyword">auto</span> it = commandHandlerMap.<span class="built_in">find</span>(command);</span><br><span class="line">        <span class="keyword">if</span> (it == commandHandlerMap.<span class="built_in">end</span>()) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"invalid input command!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用相应命令的事件处理回调函数</span></span><br><span class="line">        it-&gt;<span class="built_in">second</span>(clientfd, commandbuf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, commandbuf.<span class="built_in">size</span>() - idx));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "help" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>, string)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"&gt;&gt;&gt; show command list &gt;&gt;&gt; "</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : commandMap) {</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">" : "</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "addfriend" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfriend</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式: friendid</span></span><br><span class="line">    <span class="keyword">int</span> friendId = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (friendId &lt;= <span class="number">0</span>) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"add friend command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = ADD_FRIEND_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"friendId"</span>] = friendId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send add friend msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "singlechat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">singlechat</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式: friendid:message</span></span><br><span class="line">    <span class="keyword">int</span> idx = str.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"single chat command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> friendId = <span class="built_in">atoi</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>, idx).<span class="built_in">c_str</span>());</span><br><span class="line">    string message = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = SINGLE_CHAT_MSG;</span><br><span class="line">    request[<span class="string">"fromId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"fromName"</span>] = g_currentUser.<span class="built_in">getName</span>();</span><br><span class="line">    request[<span class="string">"fromMsg"</span>] = message;</span><br><span class="line">    request[<span class="string">"fromTimestamp"</span>] = <span class="built_in">getTimestampMs</span>();</span><br><span class="line">    request[<span class="string">"toId"</span>] = friendId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send single chat msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "creategroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creategroup</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式: groupname:groupdesc</span></span><br><span class="line">    <span class="keyword">int</span> idx = str.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"create group command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    string groupName = str.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">    string groupDesc = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = CREATE_GROUP_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"groupName"</span>] = groupName;</span><br><span class="line">    request[<span class="string">"groupDesc"</span>] = groupDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send create group msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "joingroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joingroup</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式：groupid</span></span><br><span class="line">    <span class="keyword">int</span> groupId = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (groupId &lt;= <span class="number">0</span>) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"join group command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = JOIN_GROUP_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"groupId"</span>] = groupId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send join group msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "groupchat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">groupchat</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式：groupid:message</span></span><br><span class="line">    <span class="keyword">int</span> idx = str.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"group chat command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> groupId = <span class="built_in">atoi</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>, idx).<span class="built_in">c_str</span>());</span><br><span class="line">    string groupMsg = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = GROUP_CHAT_MSG;</span><br><span class="line">    request[<span class="string">"fromId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"fromName"</span>] = g_currentUser.<span class="built_in">getName</span>();</span><br><span class="line">    request[<span class="string">"fromTimestamp"</span>] = <span class="built_in">getTimestampMs</span>();</span><br><span class="line">    request[<span class="string">"groupId"</span>] = groupId;</span><br><span class="line">    request[<span class="string">"groupMsg"</span>] = groupMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send group chat msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "loginout" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loginout</span><span class="params">(<span class="keyword">int</span> clientfd, string)</span> </span>{</span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = LOGIN_OUT_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send login out msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        isMainMenuRunning = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h4><ul><li><p>(1) 启动 Nginx、Redis、MySQL 服务，并配置 Nginx 的 TCP 负载均衡器</p></li><li><p>(2) 启动集群聊天服务端程序</p><ul><li>启动第一个聊天服务端程序：<code>./bin/chat_server 127.0.0.1 6000</code></li><li>启动第二个聊天服务端程序：<code>./bin/chat_server 127.0.0.1 6002</code></li></ul></li><li><p>(3) 启动集群聊天客户端程序</p><ul><li>启动第一个聊天客户端程序：<code>./bin/chat_client 127.0.0.1 8000</code>，连接的是 Nginx 的 TCP 负载均衡器</li><li>启动第二个聊天客户端程序：<code>./bin/chat_client 127.0.0.1 8000</code>，连接的是 Nginx 的 TCP 负载均衡器</li></ul></li></ul><h2 id="项目输出"><a href="#项目输出" class="headerlink" title="项目输出"></a>项目输出</h2><h3 id="输出求职简历"><a href="#输出求职简历" class="headerlink" title="输出求职简历"></a>输出求职简历</h3><ul><li><p>项目名称</p><ul><li>集群聊天服务器</li><li>基于 Muduo 网络库实现的集群聊天服务器</li></ul></li><li><p>开发工具</p><ul><li>VSCode 远程 Linux 开发</li><li> CMake 构建 C/C++ 项目</li><li> Linux Shell 编写项目自动编译脚本</li></ul></li><li><p>项目内容</p><ul><li>使用 Muduo 网络库实现项目的网络核心模块，提供高并发网络 I/O 服务，解耦网络和业务模块的代码</li><li>使用 Json 序列化和反序列化消息作为私有通信协议</li><li>配置 Nginx 基于 TCP 的负载均衡，实现聊天服务器的集群功能，提高后端服务的并发能力</li><li>基于 Redis 的发布 - 订阅功能，实现客户端跨服务器通信</li><li>使用 MySQL 关系型数据库作为项目数据的落地存储</li><li>使用数据库连接池提高数据库的访问性能</li></ul></li><li><p>项目收获</p><ul><li>熟悉了基于 Muduo 网络库进行服务端程序开发</li><li>掌握了 Nginx 的 TCP 负载均衡配置</li><li>掌握了 MySQL 和服务端中间件 Redis 的应用</li></ul></li><li><p>项目问题</p><ul><li>问题描述<ul><li>通过代码脚本或者专业的压测工具（比如 JMeter）测试聊天服务器的并发性能</li></ul></li><li>问题解决<ul><li>设置进程可使用文件描述符（<code>fd</code>）资源的上限数量，提高聊天服务器的并发性能</li></ul></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在面试流程中描述项目内容时，切忌详细罗列项目中的业务，重点是介绍项目用到什么技术，突出技术点 。</p></div><h3 id="常见的面试题"><a href="#常见的面试题" class="headerlink" title="常见的面试题"></a>常见的面试题</h3><h4 id="为什么要使用-Redis"><a href="#为什么要使用-Redis" class="headerlink" title="为什么要使用 Redis"></a>为什么要使用 Redis</h4><ul><li><p>问题描述</p><ul><li>为什么要使用 Redis 来实现客户端跨服务器通信？各个聊天服务器之间能不能直接进行通信呢？</li></ul></li><li><p>问题解答</p><ul><li><a href="../../../asset/2025/06/cxx-chatserver-qa-1.png">这里的设计</a>，会在各个 ChatServer 服务器互相之间直接建立 TCP 连接进行通信，相当于在服务器网络之间进行广播。这样的设计使得各个服务器之间耦合度太高，不利于系统扩展，并且会占用系统大量的 Socket 资源，各服务器之间的带宽压力很大，不能够节省资源给更多的客户端提供服务，因此绝对不是一个好的设计。</li><li>集群部署的服务器之间进行通信，最好的方式就是引入消息队列中间件，解耦各个服务器，使整个系统松耦合，提高服务器的响应能力，节省服务器的带宽资源，整体的设计应该 <a href="../../../asset/2025/06/cxx-chatserver-qa-2.png">如此</a>。</li><li>在集群环境中，经常使用的消息队列中间件有 ActiveMQ、RabbitMQ、Kafka、RocketMQ 等，它们都是应用场景广泛并且性能很好的消息队列，供集群服务器、分布式服务之间进行消息通信。限于集群聊天服务器项目的业务并不是非常复杂，并且对并发性能也没有太高的要求，因此消息队列选型的是 - Redis 发布 - 订阅。</li></ul></li></ul><h4 id="Redis-实现的功能不稳定"><a href="#Redis-实现的功能不稳定" class="headerlink" title="Redis 实现的功能不稳定"></a>Redis 实现的功能不稳定</h4><ul><li><p>问题描述</p><ul><li>当消息的生产速度大于消息的消费速度时，随着时间的推移，会造成 Redis 积压消息；如果消息积压的数量太大，会导致内存占用激增，Redis 最终可能会宕机。</li></ul></li><li><p>问题解答</p><ul><li>使用消息队列中间件替代 Redis 的发布 - 订阅功能，比如 Kafka、RabbitMQ、RocketMQ 等。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Redis 的主要功能有：缓存数据库（支持持久化）、分布式锁、发布 - 订阅，其中发布 - 订阅功能只适用于非核心业务、流量不是很大的业务。</p></div><h4 id="如何保证消息的可靠传输"><a href="#如何保证消息的可靠传输" class="headerlink" title="如何保证消息的可靠传输"></a>如何保证消息的可靠传输</h4><ul><li><p>问题描述</p><ul><li>如何保证客户端发送出去的消息，一定能够被服务端接收到，从而保证消息不丢失呢？</li></ul></li><li><p>问题解答</p><ul><li>在业务层中，可以通过消息序号 + ACK 应答机制实现消息的可靠传输，实现步骤如下：</li><li>(1) 客户端发送的每条消息都附加一个递增的 <code>seq</code> 序号（比如 1、2、3）。</li><li>(2) 客户端将未被确认的消息保存在本地的缓存队列中，用于后续重发和确认处理。</li><li>(3) 服务端收到消息后，返回 ACK 应答给客户端，标明确认的消息序号（比如 <code>seq:1</code>）。</li><li>(4) 客户端处理 ACK 响应：客户端接收到 ACK 响应后，从本地缓存队列中移除对应 <code>seq</code> 的消息，表示消息已被成功确认。</li><li>(5) 消息重发机制：客户端启动一个定时器线程，定时扫描缓存队列中未被确认的消息（比如每 3 秒扫描一次）。如果某条消息在一定时间内（比如 5 秒）未收到 ACK 确认，则自动重发该消息，直到收到服务端的 ACK 确认或者超过最大重试次数。</li></ul></li></ul><h4 id="如何保证数据传输的安全性"><a href="#如何保证数据传输的安全性" class="headerlink" title="如何保证数据传输的安全性"></a>如何保证数据传输的安全性</h4><ul><li><p>问题描述</p><ul><li>由于数据（比如聊天消息）是明文传输的，存在一定的数据安全问题，如何解决？</li></ul></li><li><p>问题解答</p><ul><li>使用对称加密算法（如 AES）和非对称加密算法（如 RSA）来保证数据传输的安全性，实现步骤如下：</li><li>(1) 客户端登录时，使用服务端的 RSA 公钥加密数据，其中的数据包含一个随机生成的 AES 密钥和登录信息，然后将加密后的数据发送给服务端。</li><li>(2) 服务端收到数据后，使用自己的 RSA 私钥解密数据，获得客户端的 AES 密钥和登录信息，并完成身份验证。</li><li>(3) 后续通信阶段，客户端与服务端使用同一个 AES 密钥对数据进行对称加密和解密，从而实现高效且安全的数据传输。</li><li>(4) AES 密钥应为一次性生成的会话密钥（Session Key）。RSA 加解密只用于密钥交换和登录信息保护，后续通信使用高性能的 AES 加解密。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">加密算法介绍</p><ul><li>在大型的 IM 软件（比如 QQ）中，会同时使用到对称加密算法和非对称加密算法，兼顾考虑数据安全性和加解密效率。</li><li><code>对称加密算法</code>：使用同一个密钥进行加密和解密，速度快，但需要考虑安全地共享密钥。常见的对称加密算法包括 DES、AES、3DES 等。</li><li><code>非对称加密算法</code>：使用一对公钥和私钥，公钥负责加密、私钥负责解密，安全性高，速度慢，适用于密钥交换与身份验证。常见的非对称加密算法包括 DSA、RSA、ECC 等。</li></ul></div><h4 id="客户端消息如何按顺序显示"><a href="#客户端消息如何按顺序显示" class="headerlink" title="客户端消息如何按顺序显示"></a>客户端消息如何按顺序显示</h4><ul><li><p>问题描述</p><ul><li>客户端接收到服务端发送的消息，如何按顺序显示？</li></ul></li><li><p>问题解答</p><ul><li>(1) 服务端消息加序号：服务端发送的每条消息都附加一个递增的 <code>seq</code> 序号，每个用户或会话维护独立的 <code>seq</code> 序号。</li><li>(2) 客户端缓存乱序消息：客户端接收到消息后，放入本地的有序缓存中，并使用 <code>expected_seq</code> 表示下一条应该显示的消息的序号。</li><li>(3) 按序显示 + 缓存清理：若客户端接收到消息序号等于 <code>expected_seq</code>，则立即显示，并从缓存中继续查找后续的连续消息，依次显示。</li><li>(4) 处理乱序和丢包：如果客户端接收到的是 <code>seq &gt; expected_seq</code>，则先缓存消息，暂时不显示。若某条消息长时间未到达，可发起消息重传请求或跳过处理。</li></ul></li></ul><h4 id="历史聊天消息应该如何存储"><a href="#历史聊天消息应该如何存储" class="headerlink" title="历史聊天消息应该如何存储"></a>历史聊天消息应该如何存储</h4><ul><li><p>问题描述</p><ul><li>历史聊天消息，有哪些存储方案？</li></ul></li><li><p>问题解答</p><ul><li>本地消息存储<ul><li>使用 SQLite 等嵌入式数据库：轻量、便于查询，适合单设备离线存储。</li><li>使用本地文件系统：以用户或群组为单位创建文件夹，按日期或大小分多个文件保存，适合大批量存储，读取简单但查询不方便。</li></ul></li><li>云端消息存储<ul><li>使用关系型数据库（如 MySQL）：结构化存储，支持高效查询和分页加载，适合结构清晰的聊天记录。</li><li>使用文件存储系统（如对象存储或分布式文件系统）：适合存储大批量的聊天原始记录或备份数据，读取顺序性强，但查询性能较弱。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">大规模系统中的历史聊天消息存储</p><ul><li>(1) 消息队列 + 消息落库架构，提升写入性能。</li><li>(2) Elasticsearch 作为全文索引系统，用于历史聊天记录搜索。</li><li>(3) 冷热数据分离：近期消息存储在数据库，历史消息转存在文件存储系统（如对象存储或分布式文件系统）。</li></ul></div><h4 id="如何感知客户端在线还是掉线"><a href="#如何感知客户端在线还是掉线" class="headerlink" title="如何感知客户端在线还是掉线"></a>如何感知客户端在线还是掉线</h4><ul><li><p>问题描述</p><ul><li>如果网络拥堵严重，ChatServer（聊天服务端）如何感知 ChatClient（聊天客户端）在线还是掉线呢？</li></ul></li><li><p>问题解答</p><ul><li>在 ChatServer（聊天服务端）和 ChatClient（聊天客户端）之间实现心跳保持机制，实现步骤如下：<ul><li>(1) 客户端定期发送心跳包（比如：每秒发一次 <code>MSG_TYPE: heartbeat</code>）</li><li>(2) 服务端为每个客户端维护一个心跳计数器，每秒自动加一</li><li> (3) 服务端每收到一次客户端发送的心跳包，就将该客户端的心跳计数器归零</li><li> (4) 若客户端的心跳计数器超过 5（即 5 秒内未收到心跳），则判断客户端已掉线</li><li> (5) 客户端掉线后，服务端开始清理该客户端的连接和资源</li></ul></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>TCP 传输层有 Keepalive 机制，可以通过 Linux 内核参数来调整（如下表所示）。但是，ChatServer 不能依赖该机制来实现心跳保持机制，因为 ChatServer 检测到 ChatClient 掉线后，需要主动清理相应的连接和资源。</li></ul></div><table><thead><tr><th>参数名</th><th>作用</th><th>默认值（一般情况）</th></tr></thead><tbody><tr><td><code>net.ipv4.tcp_keepalive_time</code></td><td>TCP 连接空闲多久后开始发送 Keepalive 探测包（单位：秒）</td><td>7200 秒（2 小时）</td></tr><tr><td><code>net.ipv4.tcp_keepalive_intvl</code></td><td>发送 Keepalive 探测包之间的时间间隔（单位：秒）</td><td>75 秒</td></tr><tr><td><code>net.ipv4.tcp_keepalive_probes</code></td><td>Keepalive 最大探测次数，超过则认定连接失效（断开）</td><td>9 次</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/m0_74795952/article/details/145707561">C++ 实现集群聊天服务器</a></li><li><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/97895611">C++ 使用 Redis 发布 - 订阅功能遇到的问题</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 开发集群聊天服务器，使用了 Muduo、Json、MySQL、Redis、Linux 等技术。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMake 快速入门指南</title>
    <link href="https://www.techgrow.cn/posts/effcb0d2.html"/>
    <id>https://www.techgrow.cn/posts/effcb0d2.html</id>
    <published>2025-05-27T14:25:49.000Z</published>
    <updated>2025-05-27T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<div class="row"><embed src="/pdf/CMake快速入门指南.pdf" width="100%" height="1024px" isolation="isolate" type="application/pdf"></div>]]></content>
    
    
    <summary type="html">本文主要介绍 CMake 的快速入门教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="在线电子书" scheme="https://www.techgrow.cn/tags/%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>大型电商网站商品详情页系统的架构设计</title>
    <link href="https://www.techgrow.cn/posts/f49eb46a.html"/>
    <id>https://www.techgrow.cn/posts/f49eb46a.html</id>
    <published>2025-05-27T13:43:32.000Z</published>
    <updated>2025-05-27T13:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="页面静态化方案"><a href="#页面静态化方案" class="headerlink" title="页面静态化方案"></a>页面静态化方案</h2><p>电商网站通常拥有上千万级商品，每个商品都有独立的详情页。为了提升页面响应速度，常采用页面静态化（生成静态 HTML 文件）技术。</p><h3 id="小型电商网站的页面静态化"><a href="#小型电商网站的页面静态化" class="headerlink" title="小型电商网站的页面静态化"></a>小型电商网站的页面静态化</h3><h4 id="页面静态化处理"><a href="#页面静态化处理" class="headerlink" title="页面静态化处理"></a>页面静态化处理</h4><ul><li><p>核心思路：</p><ul><li>开发一个页面静态化系统，将网站所有页面（如首页、商品详情页等）预先生成为静态 HTML 文件。</li><li>用户访问时，直接由 Nginx 返回对应的静态 HTML 文件的内容，无需查询数据库或执行后端代码。</li></ul></li><li><p>优点：</p><ul><li>高性能：无需每次请求都进行数据库交互或逻辑处理，响应速度快。</li><li>简单高效：适合页面数量有限的场景（几十到几万个页面）。</li></ul></li><li><p>缺点：</p><ul><li>不适合大规模网站，若页面数量达到亿级别，任何模板改动（如样式、文字等）都需要重新全量生成所有页面，耗时耗资源，不可行。</li></ul></li></ul><span id="more"></span><p><img data-src="../../../asset/2025/08/web-page-static-1.png"></p><h4 id="静态-HTML-文件更新"><a href="#静态-HTML-文件更新" class="headerlink" title="静态 HTML 文件更新"></a>静态 HTML 文件更新</h4><div class="admonition warning"><p class="admonition-title">思考</p><p>页面静态化系统预先生成所有静态 HTML 文件后，如果有多个 Nginx 对外提供服务，那如何动态更新多个 Nginx 服务器上的静态 HTML 文件呢？</p></div><p>结合版本控制与配置管理工具实现静态 HTML 文件的更新，这是最常用、最规范的方法，利用自动化工具完成分发和生效。</p><ul><li>流程：<ul><li>生成：页面静态化系统将网站所有页面预先生成为静态 HTML 文件。</li><li>存储：将新的静态 HTML 文件存放在一个版本控制系统（如 Git）中，这便于管理版本、回顾历史、协同工作。</li><li>触发：开发人员将修改后的静态 HTML 文件推送（<code>git push</code>）到 Git 仓库（如 GitLab/GitHub）。</li><li>自动分发：通过 CI/CD 工具（如 Jenkins， GitLab CI）监听 Git 仓库的变更。一旦有新的推送，CI/CD 工具自动触发部署脚本。</li><li>执行部署脚本：脚本通过配置管理工具（如 Ansible、SaltStack、Puppet）或简单的 <code>rsync</code> 命令，将新的静态 HTML 文件同步到所有 Nginx 服务器的指定目录下。</li></ul></li><li>优点：<ul><li>自动化、可追溯、规范性强，非常适合大规模集群。</li></ul></li><li>缺点：<ul><li>需要同时维护和理解一整套工具链（GitLab/GitHub、CI/CD、Ansible/SaltStack 等），对运维和开发团队的技术能力要求较高。</li></ul></li><li>适用场景：<ul><li>几十台到上万台服务器规模的管理，自动化优势能得到极大体现。</li></ul></li></ul><h3 id="大型电商网站的页面静态化"><a href="#大型电商网站的页面静态化" class="headerlink" title="大型电商网站的页面静态化"></a>大型电商网站的页面静态化</h3><h4 id="页面静态化处理-1"><a href="#页面静态化处理-1" class="headerlink" title="页面静态化处理"></a>页面静态化处理</h4><p>通过 “本地模板 + 多级缓存（本地缓存 + Redis 缓存） + 消息队列” 的方式，在不牺牲太多性能的前提下，完美解决了大型电商网站海量商品详情页数据动态更新和模板全局更新的难题，是一种兼具高性能、高时效性和高可扩展性的优秀方案。</p><ul><li><p>核心思路</p><ul><li>不再预生成所有静态 HTML 页面，而是采用 “本地模板 + 动态数据” 的方式，在收到请求时实时渲染页面。</li></ul></li><li><p>架构组成</p><ul><li><p>(1) 本地模板与缓存：</p><ul><li>Nginx 服务器本地存有 HTML 模板文件。</li><li>渲染所需的数据也在 Nginx 本地有一份缓存（如存储在内存中），有效期较短（例如 10 分钟）。</li></ul></li><li><p>(2) 请求处理流程：</p><ul><li>用户请求到达 Nginx。</li><li>Nginx 首先使用本地的 HTML 模板文件和本地的缓存数据快速渲染出一个页面返回。</li><li>因为所有操作都在本地完成，所以速度非常快，性能损耗仅在于渲染 HTML 本身。</li></ul></li><li><p>(3) 数据更新与同步机制（关键）：</p><ul><li>触发更新：当商品信息、店铺信息、广告信息等发生变更时，相关服务会向消息队列（如 RabbitMQ） 发送一个消息。</li><li>数据处理：有一个缓存构建服务会消费这个消息，调用各个服务接口（比如商品信息接口等）获取最新的数据，并整合成前端页面渲染所需的数据格式。</li><li>更新缓存：将整合好的最新数据更新到 Redis 分布式缓存中。</li><li>过期与拉取：Nginx 渲染页面时，若本地的缓存数据过期了，会主动去 Redis 分布式缓存中获取最新的数据来更新本地缓存。</li></ul></li></ul></li><li><p>架构优点</p><ul><li>解决了全量静态化的弊端：HTML 模板文件变更时，无需重新生成亿级页面，只需更新模板文件，下次请求所有用户都会自动使用新模板渲染。</li><li>保证了高性能：大部分请求直接使用本地缓存的数据和模板进行渲染，速度极快。</li><li>保证了数据时效性：通过 “消息队列 + Redis” 的机制，能在秒级或分钟级内将变更的数据同步到整个服务器集群，实现了数据更新与页面渲染的解耦。</li><li>具备高可扩展性：适合海量页面（如亿级）的场景。</li></ul></li></ul><p><img data-src="../../../asset/2025/08/web-page-static-2.png"></p><h4 id="模板文件动态更新"><a href="#模板文件动态更新" class="headerlink" title="模板文件动态更新"></a>模板文件动态更新</h4><div class="admonition warning"><p class="admonition-title">思考</p><p>如果有多个 Nginx 对外提供服务，那如何动态更新多个 Nginx 服务器上的 HTML 模版文件呢？</p></div><blockquote><p>方案一：结合版本控制与配置管理工具（推荐）</p></blockquote><p>这是最常用、最规范的方法，利用自动化工具完成分发和生效。</p><ul><li>流程：<ul><li>存储：将 HTML 模板文件存放在一个版本控制系统（如 Git）中，这便于管理版本、回顾历史、协同工作。</li><li>触发：开发人员将修改后的模板推送（<code>git push</code>）到 Git 仓库（如 GitLab/GitHub）。</li><li>自动分发：通过 CI/CD 工具（如 Jenkins， GitLab CI）监听 Git 仓库的变更。一旦有新的推送，CI/CD 工具自动触发部署脚本。</li><li>执行部署脚本：脚本通过配置管理工具（如 Ansible、SaltStack、Puppet）或简单的 <code>rsync</code> 命令，将新的模板文件同步到所有 Nginx 服务器的指定目录下。</li></ul></li><li>优点：<ul><li>自动化、可追溯、规范性强，非常适合大规模集群。</li></ul></li><li>缺点：<ul><li>需要同时维护和理解一整套工具链（GitLab/GitHub、CI/CD、Ansible/SaltStack 等），对运维和开发团队的技术能力要求较高。</li></ul></li><li>适用场景：<ul><li>几十台到上万台服务器规模的管理，自动化优势能得到极大体现。</li></ul></li></ul><blockquote><p>方案二：利用分布式文件系统</p></blockquote><p>让所有 Nginx 服务器不从本地磁盘，而是从同一个网络位置读取模板文件。</p><ul><li>流程：<ul><li>搭建一个分布式文件系统（如 NFS、GlusterFS）或使用对象存储（如 AWS S3， 阿里云 OSS，但通常需要配合缓存使用）。</li><li>将所有 Nginx 服务器的模板目录挂载到这个共享的网络存储上。</li><li>需要更新模板时，只需更新共享存储上的一份文件即可，所有 Nginx 服务器立即就能看到最新的文件。</li></ul></li><li>优点：<ul><li>管理简单，只需修改一个点。</li></ul></li><li>缺点：<ul><li>单点故障和性能瓶颈：如果网络存储出现故障或网络延迟高，所有网站都会受影响。</li><li>性能：每次请求都可能产生网络 I/O，延迟比本地读取高。</li><li>通常需要配合本地缓存使用，这又引入了缓存一致性问题。</li></ul></li><li>适用场景：<ul><li>中小规模集群或对实时性要求不极端的场景。</li></ul></li></ul><blockquote><p>方案三：使用反向代理层切换</p></blockquote><p>在更复杂的架构中，Nginx 本身可能也分为多级。可以在最前层的反向代理（或负载均衡器）上做文章。</p><ul><li>流程：<ul><li>假设有两组后端 Nginx 服务器：Group A（当前在线）和 Group B（待更新）。</li><li>先更新 Group B 的模板文件，并重启其服务。</li><li>通过前层的负载均衡器（如 LVS、F5，或另一个 Nginx）将流量从 Group A 平滑切换到 Group B。</li><li>确认 Group B 工作正常后，再更新 Group A 的模板，并将其作为新的备用组。</li></ul></li><li>优点：<ul><li>完全无缝更新，对用户无感知，是最高级的更新方式。</li></ul></li><li>缺点：<ul><li>架构复杂，需要额外的机器资源（至少多一整套备用服务器）。</li></ul></li><li>适用场景：<ul><li>超大规模、对可用性要求极高的网站（如淘宝、京东级别）。</li></ul></li></ul><blockquote><p>方案四：容器化部署（云原生方案）</p></blockquote><p>这是现代应用部署的趋势，与方案一紧密结合。</p><ul><li>流程：<ul><li>将 HTML 模板文件存放在一个版本控制系统（如 Git）中，这便于管理版本、回顾历史、协同工作。</li><li>通过 CI/CD 工具（如 Jenkins）监听 Git 仓库的变更。一旦模板文件更新，自动拉取代码，将 Nginx 和最新的模板文件一起构建成一个 Docker 镜像，并推送至镜像仓库。</li><li>CI/CD 工具（如 Jenkins）调用 Kubernetes API，触发 Deployment 的滚动更新（Rolling Update），使用新镜像逐步替换旧 Pod（容器）。</li><li>Kubernetes 的滚动更新（Rolling Update）策略会自动完成流量切换与新老实例更替，实现无缝、零宕机的全集群模板更新。</li></ul></li><li>优点：<ul><li>环境一致，部署流程标准化，是云原生时代的最佳实践。</li></ul></li><li>缺点：<ul><li>技术栈复杂，需要引入容器和编排平台。</li></ul></li><li>技术栈：<ul><li>版本控制系统（VCS）：如 Git，用于存储和管理模板文件、Dockerfile、部署脚本等。</li><li>CI/CD 工具：如 Jenkins、GitLab CI、GitHub Actions，用于自动化构建和部署流程。</li><li>容器镜像仓库：如 Docker Hub、Harbor、AWS ECR，用于存储构建好的 Docker 镜像。</li><li>容器编排平台：如 Kubernetes（K8s），用于最终的应用部署和滚动更新。</li><li>配置管理（融入了镜像）：Dockerfile 和 K8s 的 YAML 文件会替代 Ansible 等工具的角色（功能）。</li></ul></li></ul><hr><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong> CI/CD + 配置管理</strong></td><td>自动化、规范、可靠、无单点瓶颈</td><td>需要搭建和维护一套工具链</td><td><strong>绝大多数场景，最通用推荐</strong></td></tr><tr><td><strong>分布式文件系统</strong></td><td>管理简单，更新即时</td><td>存在单点故障和性能风险</td><td>中小集群，开发测试环境</td></tr><tr><td><strong>反向代理切换</strong></td><td>无缝更新，用户体验最佳</td><td>架构复杂，资源成本高</td><td>超大型网站，金融级应用</td></tr><tr><td><strong>容器化部署</strong></td><td>环境一致，现代化，易于扩展</td><td>技术复杂度最高</td><td>云原生技术栈团队</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">总结</p><p>方案一（CI/CD + Ansible 等工具）是最平衡、最常用的选择。它既能快速响应模板变更，又能可靠地管理成百上千台服务器，完美契合了 "模板变更了，不需要将所有页面全部重新静态化" 的设计初衷。</p></div>]]></content>
    
    
    <summary type="html">本文主要介绍大型电商网站商品详情页系统的架构设计。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="架构设计" scheme="https://www.techgrow.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于 Linux 下 VSCode 搭建 C/C++ 开发环境</title>
    <link href="https://www.techgrow.cn/posts/83b1bb3b.html"/>
    <id>https://www.techgrow.cn/posts/83b1bb3b.html</id>
    <published>2025-05-25T14:25:49.000Z</published>
    <updated>2025-05-25T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将在 Linux 系统中，搭建 VSCode 开发 C/C++ 程序的环境（本地开发），适用于绝大多数的 Linux 发行版，比如 CentOS、Ubuntu、Debian 等。</p><span id="more"></span><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ul><li>(1) 在 Linux 系统中安装 VSCode<ul><li><a href="/posts/d8f0998b.html">Linux 安装 VSCode 的详细教程</a></li></ul></li><li> (2) 在 VSCode 中安装 C/C++ 相关插件，比如：<ul><li><code>C/C++</code>：C/C++ 核心插件，提供 C/C++ 智能感知、调试、导航、语法提示等核心功能。</li><li><code>C/C++ Extension Pack</code>：C/C++ 插件组合包，用于一键安装多个与 C/C++ 开发相关的扩展，方便快速配置。</li><li><code>Code Runner</code>：代码快速运行插件（可选安装），仅支持运行单个源文件，支持多种语言，包括 C/C++、Java、JS、PHP、Python、、Go、Lua 等。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/630b5e44.html">VSCode 搭建远程 Linux 开发环境</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍基于 Linux 下 VSCode 如何搭建 C/C++ 开发环境。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
