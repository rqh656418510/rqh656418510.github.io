<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术空间</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2024-03-19T14:34:42.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 多线程编程之四 CAS、锁、ABA 问题</title>
    <link href="https://www.techgrow.cn/posts/3b82844a.html"/>
    <id>https://www.techgrow.cn/posts/3b82844a.html</id>
    <published>2024-03-19T14:34:42.000Z</published>
    <updated>2024-03-19T14:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="/posts/5bbede3c.html">Java 多线程编程之一 Java 内存模型浅析</a></li><li><a href="/posts/f7ed7888.html">Java 多线程编程之二 synchronize 锁对象竞争</a></li><li><a href="/posts/ed2e098d.html">Java 多线程编程之三 volatile 与 JMM 内存模型</a></li><li><a href="/posts/3b82844a.html">Java 多线程编程之四 CAS、锁、ABA 问题</a></li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="CAS-的介绍"><a href="#CAS-的介绍" class="headerlink" title="CAS 的介绍"></a>CAS 的介绍</h3><p><strong>CAS 的全称是 Compare-And-Swap（比较并交换），它是 CPU 并发原语，用于比较当前内存中的值与预期值是否相等，如果相等则进行更新操作，整个操作是原子性的，可用于解决多线程并发访问共享变量时的数据一致性问题。</strong>CAS 并发原语体现在 Java 语言中就是 <code>sun.misc.Unsafe</code> 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会帮开发者实现出 CAS 汇编指令，这是一种完全依赖于硬件平台的功能，通过它可以实现原子操作。再次强调，由于 CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成的，用于完成某项功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断（打断、加塞）。简而言之，CAS 是一系列 CPU 的原子指令，不会造成所谓的数据不一致问题，也就是说 CAS 是线程安全的。</p><div class="admonition note"><p class="admonition-title">Java 中的 CAS 实现</p><ul><li>在 Java 中，CAS 是一种无锁的同步方式，常用于实现原子操作和乐观锁，适用于并发竞争不激烈的业务场景，可以提高并发性能。</li><li>在 Java 中，CAS 是使用 <code>java.util.concurrent.atomic</code> 包中提供的原子类实现的，常用的类包括 AtomicInteger、AtomicLong、AtomicReference 等。</li></ul></div><span id="more"></span><h3 id="CAS-的原理"><a href="#CAS-的原理" class="headerlink" title="CAS 的原理"></a>CAS 的原理</h3><blockquote><p>AtomicInteger 类</p></blockquote><p>首先看看 <code>AtomicInteger.getAndIncrement()</code> 方法的源码，可以发现底层调用了一个 Unsafe 类的 <code>getAndAddInt()</code> 方法。</p><p><img data-src="../../../asset/2024/03/cas-2.png"></p><p><img data-src="../../../asset/2024/03/cas-1.png"></p><blockquote><p>Unsafe 类</p></blockquote><p>在 Java 中，CAS 操作的执行都依赖于 Unsafe 类的方法。Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层操作系统，需要通过本地（Native）方法来访问。Unsafe 相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe 类存在 于 <code>sun.misc</code> 包中，其内部方法可以像 C 语言的指针一样直接操作内存。特别注意，Unsafe 类的所有方法都是 <code>native</code> 修饰的，也就是说 Unsafe 类中的方法都直接调用操作系统底层资源执行相应的任务。Atomic 修饰的包装类（如 AtomicInteger）之所以能够保证原子性，依靠的就是底层的 Unsafe 类。</p><blockquote><p>valueOffset 变量</p></blockquote><p><code>valueOffset</code> 表示变量 value 的内存地址偏移量，因为 Unsafe 类就是根据内存地址偏移量来获取数据的。从下面的源码能够看到，通过 <code>this</code> 指针和 <code>valueOffset</code> 得知变量 value 的完整内存地址后，就可以获取到变量 value 的值，然后执行加 1 的操作。</p><p><img data-src="../../../asset/2024/03/cas-1.png"></p><blockquote><p>保证多线程之间的内存可见性</p></blockquote><p><img data-src="../../../asset/2024/03/cas-1.png"></p><p><img data-src="../../../asset/2024/03/cas-3.png"></p><p>变量 v 是线程将变量 value 从主内存中拷贝到工作内存中的副本。也就是说，线程每次都要从主内存拿到最新的值，并拷贝一份副本到自己的工作内存，然后再执行 <code>weakCompareAndSetInt()</code> 方法跟主内存的值进行比较。线程不可以越过高速缓存直接操作主内存。在执行加 1 操作之前，需要比较工作内存和主内存中的变量值是否一致，假设执行 <code>weakCompareAndSetInt()</code> 方法返回 false，那么就会一直执行 do while 循环，直到期望的值（工作内存中的值）和当前值（主内存中的值）一致。这里没有用 synchronized，而是用 CAS，这样既可以提高并发性能，又可以够保证数据一致性。因为每个线程进来后，都会进入的 do while 循环，然后不断地获取主内存中的变量值，并判断工作内存中的变量值是否为最新值，然后再将更改后的变量值写回主内存。由于 AtomicInteger 中的 value 变量被 volatile 修饰，当某个线程将更改后的变量值写回主内存后，会立刻通知其他线程，这样其他线程就可以立刻感知到最新的变量值。<strong>值得一提的是，Unsafe 类 + CAS 思想 = 自旋（自我旋转）。</strong></p><ul><li>假设线程 A 和线程 B 同时执行 <code>getAndInt()</code> 方法（两者分别跑在不同的 CPU 上）<ul><li>AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicInteger 的 value 为 3，根据 JMM 模型，线程 A 和线程 B 各自持有一份值为 3 的副本，分别存储在各自的工作内存</li><li>线程 A 通过 <code>getIntVolatile()</code> 方法拿到的 value 值为 3，此时刚线程 A 被挂起（该线程失去 CPU 执行权）</li><li>线程 B 通过 <code>getIntVolatile()</code> 方法拿到的 value 值也是 3，此时刚好线程 B 没有被挂起，并执行了 <code>weakCompareAndSetInt()</code> 方法，比较时主内存的值也是 3，线程 B 成功修改主内存的值为 4</li><li> 线程 A 恢复运行，执行 <code>weakCompareAndSetInt()</code> 方法进行比较，发现自己工作内存中的值 3 和主内存中的值 4 不一致，说明该值已经被其它线程修改过了，那么线程 A 本次修改失败，只能够重新读取主内存中的值，也就是再执行一次 do while 循环</li><li>线程 A 重新获取 value 值，因为变量 value 被 volatile 修饰，所以其它线程对它的修改，线程 A 总能够立刻感知到，线程 A 继续执行 <code>weakCompareAndSetInt()</code> 方法进行比较和替换，直到成功执行写入操作为止</li></ul></li></ul><blockquote><p>底层汇编</p></blockquote><p>Unsafe 类中的 <code>weakCompareAndSetInt()</code> 是一个本地（Native）方法，该方法的实现位于 <code>unsafe.cpp</code> 中，其核心逻辑如下：</p><ul><li>首先拿到变量 value 在内存中的地址</li><li>通过 <code>Atomic::cmpxchg</code> 实现比较和替换，其中参数 x 是即将更新的值，参数 e 是原内存的值</li></ul><h3 id="CAS-的优缺点"><a href="#CAS-的优缺点" class="headerlink" title="CAS 的优缺点"></a>CAS 的优缺点</h3><ul><li><p>优点</p><ul><li><code>无锁</code>：CAS 是一种基于硬件原子操作的无锁算法，避免了传统锁机制带来的性能损耗。</li><li><code>高效</code>：由于 CAS 是在硬件层面实现的原子操作，比使用锁的方式执行速度更快。</li><li><code>避免死锁</code>：CAS 操作不会导致线程死锁，因为它不需要获取锁来完成操作，而是基于原子性来完成操作。</li><li><code>可实现乐观并发控制</code>：CAS 实现了乐观锁，当多个线程尝试更新同一内存位置时，只有一个线程能够成功，其他线程可以根据失败重试或者执行其他操作。</li></ul></li><li><p>缺点</p><ul><li><code>自旋重试</code>：CAS 操作在并发量大的情况下可能会导致自旋重试的次数增加，消耗 CPU 资源。</li><li><code>ABA 问题</code>：CAS 操作会出现 ABA 问题，即在进行比较时，内存位置值已经被改变两次，导致原子操作无法正确判断值是否被修改。</li><li><code>不能多个操作的保证原子性</code>：CAS 只能保证单个操作的原子性，不能保证多个 CAS 操作的原子性，这在复杂的业务场景下可能会带来一些问题。</li></ul></li></ul><p>总的来说，CAS 是一种高效的无锁机制，适合在并发度不高、竞争不激烈的业务场景下使用，但需要小心处理 CAS 可能带来的 ABA 问题和自旋重试次数过多的情况。</p><div class="admonition warning"><p class="admonition-title">注意事项</p><ul><li>当对一个共享变量执行写操作时，可以通过循环 CAS 的方式来保证操作的原子性。对于多个共享变量的写操作，循环 CAS 就无法保证操作的原子性，这个时候只能用锁来保证原子性。</li><li>CAS 有可能需要多次比较，导致循环时间长，CPU 资源开销大。因为执行的是 do while 循环，如果比较不成功会一直在循环。最极端的情况，就是某个线程一直取到的值和预期值不一样，这样就会无限循环。</li></ul></div><h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><h3 id="ABA-问题产生"><a href="#ABA-问题产生" class="headerlink" title="ABA 问题产生"></a>ABA 问题产生</h3><p>普通原子类（如 AtomicInteger）或者原子引用类（如 AtomicReference）会产生 ABA 问题，示例代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生 ABA 问题的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;Integer&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 暂定两秒t2线程，保证上面的t1线程完成了一次ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">102</span>);</span><br><span class="line">            System.out.println(result + <span class="string">" "</span> + atomicReference.get());</span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true 102</span><br></pre></td></tr></tbody></table></figure><h3 id="ABA-问题解决"><a href="#ABA-问题解决" class="headerlink" title="ABA 问题解决"></a>ABA 问题解决</h3><p>可以使用 JDK 中的 AtomicStampedReference 版本号原子引用类解决 ABA 问题，示例代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决 ABA 问题的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"初始版本号: "</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 暂定一秒t1线程，保证下面的t2线程拿到的初始版本号与t1的初始版本号一致</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"第一次修改后的版本号: "</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"第二次修改后的版本号: "</span> + atomicStampedReference.getStamp());</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"初始版本号: "</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 暂定两秒t2线程，保证上面的t1线程完成了一次ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">102</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"是否修改成功："</span> + result + <span class="string">"，当前实际最新的版本号为： "</span> + atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(<span class="string">"当前实际最新值为："</span> + atomicStampedReference.getReference());</span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1初始版本号: 1</span><br><span class="line">t2初始版本号: 1</span><br><span class="line">t1第一次修改后的版本号: 2</span><br><span class="line">t1第二次修改后的版本号: 3</span><br><span class="line">t2是否修改成功：false，当前实际最新的版本号为： 3</span><br><span class="line">当前实际最新值为：100</span><br></pre></td></tr></tbody></table></figure><h3 id="ABA-问题总结"><a href="#ABA-问题总结" class="headerlink" title="ABA 问题总结"></a>ABA 问题总结</h3><p>利用原子引用 + 版本号（类似时间戳）机制可以解决 ABA 问题，比如可以直接使用 JDK 提供的版本号原子引用类 <code>AtomicStampedReference</code>。</p><h2 id="Java-常用锁"><a href="#Java-常用锁" class="headerlink" title="Java 常用锁"></a>Java 常用锁</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h4 id="自旋锁的介绍"><a href="#自旋锁的介绍" class="headerlink" title="自旋锁的介绍"></a>自旋锁的介绍</h4><p>自旋锁（SpinLock）是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的优点是减少线程上下切换的消耗，缺点是循环获取锁的操作会消耗 CPU 资源。在 CAS 中 Unsafe 类使用自旋锁的代码如下图：</p><p><img data-src="../../../asset/2021/03/juc-spinlock-1.png" alt="juc-spinlock-1"></p><h4 id="自旋锁的验证代码"><a href="#自旋锁的验证代码" class="headerlink" title="自旋锁的验证代码"></a>自旋锁的验证代码</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁验证代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">  Thread thread = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 自旋锁实现</span></span><br><span class="line">  <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) {</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t lock"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t unlock"</span>);</span><br><span class="line">  Thread thread = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 释放自旋锁</span></span><br><span class="line">  atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> mills)</span> </span>{</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">  Thread.sleep(mills);</span><br><span class="line">  } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">  LockTest4 test = <span class="keyword">new</span> LockTest4();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">  test.lock();</span><br><span class="line">  sleep(<span class="number">5000</span>);</span><br><span class="line">  test.unlock();</span><br><span class="line">  }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">  test.lock();</span><br><span class="line">  test.unlock();</span><br><span class="line">  }, <span class="string">"t2"</span>).start();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1 come in</span><br><span class="line">t1 lock</span><br><span class="line">t2 come in</span><br><span class="line">t1 unlock</span><br><span class="line">t2 lock</span><br><span class="line">t2 unlock</span><br></pre></td></tr></tbody></table></figure><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><h4 id="可重入锁的介绍"><a href="#可重入锁的介绍" class="headerlink" title="可重入锁的介绍"></a>可重入锁的介绍</h4><p>可重入锁又叫递归锁，指的是同一个线程在外层函数获得锁之后，在内层递归函数仍然能获取到该锁，也就是在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取到锁（代码如下）。<strong>简而言之，可重入锁保证了线程可以进入任何一个它已经拥有锁的所有同步代码块。<code>ReentrantLock</code>、<code>Synchronized</code> 都是典型的可重入锁。可重入锁最大的作用是可以避免死锁。</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>{</span><br><span class="line">  method2();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ReentrantLock-的验证代码"><a href="#ReentrantLock-的验证代码" class="headerlink" title="ReentrantLock 的验证代码"></a>ReentrantLock 的验证代码</h4><p>验证 ReentrantLock 是可重入锁的代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock 验证代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t invoked get()"</span>);</span><br><span class="line">            set();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t invoked set()"</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            get();</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            get();</span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked get()</span><br><span class="line">t1 invoked set()</span><br><span class="line">t2 invoked get()</span><br><span class="line">t2 invoked set()</span><br></pre></td></tr></tbody></table></figure><h3 id="写锁和读锁"><a href="#写锁和读锁" class="headerlink" title="写锁和读锁"></a>写锁和读锁</h3><h4 id="写锁和读锁的介绍"><a href="#写锁和读锁的介绍" class="headerlink" title="写锁和读锁的介绍"></a>写锁和读锁的介绍</h4><ul><li><code>写锁（独占锁）</code>：指该锁一次只能被一个线程所持有，<strong>对于 <code>ReentrantLock</code> 和 <code>Synchronized</code> 而言都是写锁（独占锁）。</strong></li><li><code>读锁（共享锁）</code>：指该锁可被多个线程所持有，对于 <code>ReentrantReadWriteLock</code> 来讲，其读锁是共享锁，其写锁是独占锁。读锁（共享锁）可保证并发读是非常高效的，其中读写、写读、写写的过程是互斥的，而读读是可以共存的。</li></ul><h4 id="写锁和读锁的验证代码"><a href="#写锁和读锁的验证代码" class="headerlink" title="写锁和读锁的验证代码"></a>写锁和读锁的验证代码</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 验证读写锁，简单模拟 MyBatis 的缓存实现</span></span><br><span class="line"><span class="comment">* 多个线程同时读同一个资源没有问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是写共享资源只能有一个线程</span></span><br><span class="line"><span class="comment">* 写操作：原子 + 独占，整个过程必须是一个完整的统一体，中间不许被分割和被打断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>{</span><br><span class="line">        reentrantReadWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写入："</span> + key);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写入完成"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            reentrantReadWriteLock.writeLock().unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>{</span><br><span class="line">        reentrantReadWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读取："</span> + key);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            Object result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读取完成"</span> + result);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            reentrantReadWriteLock.readLock().unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                myCache.put(tempInt + <span class="string">""</span>, tempInt + <span class="string">""</span>);</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                myCache.get(tempInt + <span class="string">""</span>);</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">2 正在写入：2</span><br><span class="line">2 写入完成</span><br><span class="line">1 正在写入：1</span><br><span class="line">1 写入完成</span><br><span class="line">5 正在写入：5</span><br><span class="line">5 写入完成</span><br><span class="line">1 正在读取：1</span><br><span class="line">4 正在读取：4</span><br><span class="line">1 读取完成1</span><br><span class="line">4 读取完成null</span><br><span class="line">4 正在写入：4</span><br><span class="line">4 写入完成</span><br><span class="line">3 正在写入：3</span><br><span class="line">3 写入完成</span><br><span class="line">3 正在读取：3</span><br><span class="line">5 正在读取：5</span><br><span class="line">2 正在读取：2</span><br><span class="line">3 读取完成3</span><br><span class="line">5 读取完成5</span><br><span class="line">2 读取完成2</span><br></pre></td></tr></tbody></table></figure><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><h4 id="公平锁和非公平锁的介绍"><a href="#公平锁和非公平锁的介绍" class="headerlink" title="公平锁和非公平锁的介绍"></a>公平锁和非公平锁的介绍</h4><ul><li>JUC 包中的公平锁和非公平锁用的都是 <code>ReentrantLock</code></li><li><code>公平锁</code>：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先到先得</li><li><code>非公平锁</code>：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。在高并发的情况下，有可能会造成优先级反转或者饥饿现象</li></ul><h4 id="公平锁和非公平锁的区别"><a href="#公平锁和非公平锁的区别" class="headerlink" title="公平锁和非公平锁的区别"></a>公平锁和非公平锁的区别</h4><ul><li><code>公平锁</code>：公平锁就是很公平，在并发情况下，每个线程在获取锁时会查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照 FIFO 的规则从队列中取到自己</li><li><code>非公平锁</code>：非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采取类似公平锁那种方式（等待队列）处理</li><li> JUC 包中 <code>ReentrantLock</code> 的创建可以指定构造函数的 <code>boolean</code> 类型来得到公平锁或非公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<strong>对于 <code>synchronized</code> 而言，也是一种非公平锁。</strong></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Java 中的 CAS、ABA 问题、自旋锁、可重入锁、写锁与读锁、公平锁与非公平锁等内容。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Java" scheme="https://www.techgrow.cn/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C 语言和 C++ 精品电子书资源推荐</title>
    <link href="https://www.techgrow.cn/posts/1461029e.html"/>
    <id>https://www.techgrow.cn/posts/1461029e.html</id>
    <published>2024-03-12T15:12:41.000Z</published>
    <updated>2024-03-12T15:12:41.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><ul><li><a href="https://sn9.us/file/632278-376032112">C 专家编程</a></li><li><a href="https://sn9.us/file/632278-375759118">C 和指针</a></li><li><a href="https://sn9.us/file/632278-376032122">C 和指针课后题答案</a></li><li><a href="https://sn9.us/file/632278-413723421">C 标准库中文版</a></li><li><a href="https://sn9.us/file/632278-413723439">C 程序设计 (第四版) 谭浩强。扫描版</a></li><li><a href="https://sn9.us/file/632278-413723433">C 编程惯用法：高级程序员常用方法和技巧。王昕。扫描版</a></li><li><a href="https://sn9.us/file/632278-413723430">C 语言参考手册第五版</a></li><li><a href="https://sn9.us/file/632278-376035626">C 语言接口与实现</a></li><li><a href="https://sn9.us/file/632278-376034345">你必须知道的 495 个 C 语言问题</a></li><li><a href="https://sn9.us/file/632278-376033973">C 语言程序设计现代方法第 2 版</a></li><li><a href="https://sn9.us/file/632278-376033493">C 语言核心技术</a></li><li><a href="https://sn9.us/file/632278-376033508">C 语言深度解剖 - 带书签版</a></li><li><a href="https://sn9.us/file/632278-376032403">C 陷阱与缺陷中文版</a></li><li><a href="https://sn9.us/file/632278-413723448">The C Programming Language 中文版</a></li><li><a href="https://sn9.us/file/632278-413723457">The C Programming Language 英文版</a></li><li><a href="https://sn9.us/file/632278-376032115">C 和 C++ 代码精粹</a></li><li><a href="https://sn9.us/file/632278-376035095">高质量程序设计指南.C/C++ 语言 (第三版). 林锐。扫描版</a></li><li><a href="https://sn9.us/file/632278-383494044">程序员的自我修养 — 链接、装载与库–书签目录</a></li></ul><span id="more"></span><h2 id="C-开发"><a href="#C-开发" class="headerlink" title="C++ 开发"></a>C++ 开发</h2><ul><li><a href="https://sn9.us/file/632278-382829324">C++ Primer Plus（第 6 版）中文版</a></li><li><a href="https://sn9.us/file/632278-376126118">C++ Primer 第 5 版 中文版</a></li><li><a href="https://sn9.us/file/632278-375722464">C++ Primer 第 5 版 英文版</a></li><li><a href="https://sn9.us/file/632278-376192138">Accelerated C++</a></li><li><a href="https://sn9.us/file/632278-376163164">ACE 程序员指南 - 网络与系统编程的实用设计模式</a></li><li><a href="https://sn9.us/file/632278-375790397">API Design for C++</a></li><li><a href="https://sn9.us/file/632278-375760951">C++ API 设计</a></li><li><a href="https://sn9.us/file/632278-376144337">Boost_C++_Application_Development_Cookbook</a></li><li><a href="https://sn9.us/file/632278-376145819">Boost 程序库探秘</a></li><li><a href="https://sn9.us/file/632278-376148152">Boost 程序库完全开发指南</a></li><li><a href="https://sn9.us/file/632278-376166515">C++ Concurrency in Action</a></li><li><a href="https://sn9.us/file/632278-375759973">C++ 并发编程实战 (中文版)</a></li><li><a href="https://sn9.us/file/632278-375712822">C++ Templates (简体中文版)</a></li><li><a href="https://sn9.us/file/632278-376163878">C++STL 程序员开发指南</a></li><li><a href="https://sn9.us/file/632278-375794339">C++ 必知必会</a></li><li><a href="https://sn9.us/file/632278-375712907">C++ 编程规范 101 条规则、准则最佳实践</a></li><li><a href="https://sn9.us/file/632278-375713020">C++ 编程思想_中文版_第 2 版_第 1 卷</a></li><li><a href="https://sn9.us/file/632278-375713065">C++ 编程思想_中文版_第 2 版_第 2 卷</a></li><li><a href="https://sn9.us/file/632278-376163158">C++ 编程新思维</a></li><li><a href="https://sn9.us/file/632278-375793834">C++ 标准程序库 (侯捷译)</a></li><li><a href="https://sn9.us/file/632278-375736387">C++ 标准程序库英文版 (第二版)</a></li><li><a href="https://sn9.us/file/632278-375760243">C++ 沉思录</a></li><li><a href="https://sn9.us/file/632278-375711926">C++ 代码设计与重用</a></li><li><a href="https://sn9.us/file/632278-375712103">C++ 多线程编程实战</a></li><li><a href="https://sn9.us/file/632278-375712244">C++ 黑客编程揭秘与防范</a></li><li><a href="https://sn9.us/file/632278-375713290">C++ 跨平台开发技术指南</a></li><li><a href="https://sn9.us/file/632278-376162906">C++ 设计新思维泛型编程与设计模式之应用</a></li><li><a href="https://sn9.us/file/632278-375726523">Effective C++ 中文第三版</a></li><li><a href="https://sn9.us/file/632278-375728854">More Effective C++ (中文版)</a></li><li><a href="https://sn9.us/file/632278-375751015">STL 源码剖析简体中文完整版 (清晰扫描带目录)</a></li><li><a href="https://sn9.us/file/632278-375793871">Effective STL 中文版</a></li><li><a href="https://sn9.us/file/632278-375713354">Essential C++ 中文版</a></li><li><a href="https://sn9.us/file/632278-375713470">Exceptional C++ Style 中文版</a></li><li><a href="https://sn9.us/file/632278-375713501">More Exceptional C++ 中文版</a></li><li><a href="https://sn9.us/file/632278-375713486">Google C++ Style Guide (中文版)</a></li><li><a href="https://sn9.us/file/632278-375713554">The C++ Programming Language 3rd Edition</a></li><li><a href="https://sn9.us/file/632278-375712756">C++ 反汇编与逆向分析技术揭秘</a></li><li><a href="https://sn9.us/file/632278-376163167">代码的力量：C／C++ 中国象棋程序入门与提高</a></li><li><a href="https://sn9.us/file/632278-375712784">提高 C++ 性能的编程技术</a></li><li><a href="https://sn9.us/file/632278-376148651">Linux 多线程服务端编程：使用 muduo C++ 网络库</a></li><li><a href="https://sn9.us/file/632278-375760487">深度探索 C++ 对象模型</a></li><li><a href="https://sn9.us/file/632278-375759499">深入理解 C++11：C++11 新特性解析与应用</a></li><li><a href="https://sn9.us/file/632278-375712564">深入实践 C++ 模板编程</a></li><li><a href="https://sn9.us/file/632278-375713740">实用 C++ 调试指南</a></li><li><a href="https://sn9.us/file/632278-376163161">网络编程 卷 1 运用 ACE 和模式消除复杂性</a></li><li><a href="https://sn9.us/file/632278-376253828">网络编程 卷 2 基于 ACE 和框架的系统化复用</a></li></ul><h2 id="QT-开发"><a href="#QT-开发" class="headerlink" title="QT 开发"></a>QT 开发</h2><ul><li><a href="https://sn9.us/file/632278-383242788">精通 QT4 编程（第二版）</a></li><li><a href="https://sn9.us/file/632278-383242886">Qt 学习之路</a></li><li><a href="https://sn9.us/file/632278-383242506">Qt5 类继承关系图</a></li><li><a href="https://sn9.us/file/632278-376189688">C++ GUI Qt4 编程 (第二版)</a></li><li><a href="https://sn9.us/file/632278-383243774">Qt Quick 核心编程</a></li><li><a href="https://sn9.us/file/632278-376188875">Qt 及 QtQuick 开发实战精解</a></li><li><a href="https://sn9.us/file/632278-376188515">Qt 及 QtQuick 开发实战精解源代码</a></li><li><a href="https://sn9.us/file/632278-376188832">《Qt Creator 快速入门》第 2 版源码</a></li><li><a href="https://sn9.us/file/632278-376188643">qt 高级编程</a></li><li><a href="https://sn9.us/file/632278-376188400">Linux 窗口程序设计 —Qt4 精彩实例分析</a></li><li><a href="https://sn9.us/file/632278-376188194">Linux 窗口程序设计 —Qt4 精彩实例分析源代码</a></li><li><a href="https://sn9.us/file/632278-376188209">Qt 中的 C++ 技术</a></li><li><a href="https://sn9.us/file/632278-376188175">Qt Creator 快速入门.</a></li><li><a href="https://sn9.us/file/632278-376188172">qml 杂记 Qt_Quick 中文手册</a></li><li><a href="https://sn9.us/file/632278-376188145">C++ Qt 设计模式 第 2 版 (中文版)</a></li></ul><h2 id="Linux-系统编程"><a href="#Linux-系统编程" class="headerlink" title="Linux 系统编程"></a>Linux 系统编程</h2><ul><li><a href="https://sn9.us/file/632278-383494041">Linux 程序设计 中文第 4 版</a></li><li><a href="https://sn9.us/file/632278-383494038">POSIX 多线程程序设计</a></li><li><a href="https://sn9.us/file/632278-376015739">POSIX 多线程程序设计中文版源代码</a></li><li><a href="https://sn9.us/file/632278-383494035">Linux 高级程序设计</a></li><li><a href="https://sn9.us/file/632278-383494032">Linux 程序设计第 4 版</a></li><li><a href="https://sn9.us/file/632278-376015243">Linux 程序设计 中文第 4 版源代码</a></li><li><a href="https://sn9.us/file/632278-376010578">Linux 系统编程</a></li><li><a href="https://sn9.us/file/632278-376019933">UNIX 网络编程卷 1：套接字联网 API 第 3 版</a></li><li><a href="https://sn9.us/file/632278-376016831">UNIX 网络编程 卷 2：进程间通信 第 2 版 源代码</a></li><li><a href="https://sn9.us/file/632278-376010578">Linux 系统编程</a></li><li><a href="https://sn9.us/file/632278-376017254">Unix 环境高级编程</a></li><li><a href="https://sn9.us/file/632278-376015885">Unix 环境高级编程 课后习题详细解答</a></li><li><a href="https://sn9.us/file/632278-376016822">UNIX 程序员手册</a></li><li><a href="https://sn9.us/file/632278-376020241">Linux C 编程从初学到精通</a></li></ul><h2 id="Windows-系统编程"><a href="#Windows-系统编程" class="headerlink" title="Windows 系统编程"></a>Windows 系统编程</h2><ul><li><a href="https://sn9.us/file/632278-382930409">WINDOWS 核心编程第五版</a></li><li><a href="https://sn9.us/file/632278-376164229">精通 Windows API - 函数、接口、编程实例</a></li><li><a href="https://sn9.us/file/632278-376163153">Windows 高级调试</a></li><li><a href="https://sn9.us/file/632278-376162901">Visual c++ 2012 入门经典</a></li><li><a href="https://sn9.us/file/632278-376160660">深入解析 Windows 操作系统 中文第四版</a></li><li><a href="https://sn9.us/file/632278-376158223">Visual Studio 程序员箴言</a></li><li><a href="https://sn9.us/file/632278-376156024">Visual_C++2010 入门经典 第 5 版</a></li><li><a href="https://sn9.us/file/632278-376156021">精通 Windows.Sockets 网络开发 - 基于 Visual.C. 实现</a></li><li><a href="https://sn9.us/file/632278-376152109">Visual Studio 2010 高级编程</a></li><li><a href="https://sn9.us/file/632278-376152101">Microsoft Windows 网络编程 (第 2 版)</a></li><li><a href="https://sn9.us/file/632278-376150600">Essntial COM by Meji</a></li><li><a href="https://sn9.us/file/632278-376150597">Com 技术内幕</a></li><li><a href="https://sn9.us/file/632278-376150591">Windows 编程 (第 6 版)</a></li><li><a href="https://sn9.us/file/632278-376150588">Windows 程序设计 (第 5 版，珍藏版)</a></li></ul>]]></content>
    
    
    <summary type="html">C 语言和 C++ 精品电子书资源推荐，涵盖 C 语言、C++ 开发、QT 开发、Linux 系统编程、Windows 系统编程等书籍。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="生活随笔" scheme="https://www.techgrow.cn/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="在线电子书" scheme="https://www.techgrow.cn/tags/%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>微信公众平台之服务号、订阅号、企业号的区别</title>
    <link href="https://www.techgrow.cn/posts/aaa405b6.html"/>
    <id>https://www.techgrow.cn/posts/aaa405b6.html</id>
    <published>2024-03-07T15:29:32.000Z</published>
    <updated>2024-03-07T15:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微信公众平台目前一共推出了三种公众账号：服务号、订阅号与企业号，那么这三种账号之间有什么区别和联系呢？微信官方的解释比较概括，只讲了这三种公众账号的功能，并没有细讲它们之间的区别，那么接下来笔者根据自己的经验详细展开介绍一下。</p><h2 id="三种账号的区别"><a href="#三种账号的区别" class="headerlink" title="三种账号的区别"></a>三种账号的区别</h2><p>在整个微信账号体系中，订阅号是发布信息的平‌台，服务号是为用户提供服务的平‌台，而企业号则是企业进行 “内部管理” 的平‌台，通过加载第三方应用，可以实现员工的沟通、协作和管理。现在很多公司已基于微信企业号做了应用开发，例如企微云平台等。</p><span id="more"></span><h3 id="侧重功能不同"><a href="#侧重功能不同" class="headerlink" title="侧重功能不同"></a>侧重功能不同</h3><ul><li><code>订阅号</code>：侧重于信息传播</li><li><code>服务号</code>：侧重于对用户进行服务</li><li><code>企业号</code>：侧重于生产运营管理</li></ul><h3 id="适用范围不同"><a href="#适用范围不同" class="headerlink" title="适用范围不同"></a>适用范围不同</h3><ul><li><code>订阅号</code>：主要适用于个人、媒体、企业、政府或其他有需求的组织</li><li><code>服务号</code>：主要适用于媒体、企业、政府或其他有需求的组织</li><li><code>企业号</code>：主要适用于企业、政府、事业单位或其他有需求的组织</li></ul><h3 id="推送消息显示的位置不同"><a href="#推送消息显示的位置不同" class="headerlink" title="推送消息显示的位置不同"></a>推送消息显示的位置不同</h3><ul><li><code>订阅号</code>：推送的消息，显示在微信对话列表中的 “订阅号” 文件夹里</li><li><code>服务号</code>：推送的消息，直接显示在微信对话列表中</li><li><code>企业号</code>：推送的消息，直接显示在微信对话列表中</li></ul><h3 id="推送消息的限制次数不同"><a href="#推送消息的限制次数不同" class="headerlink" title="推送消息的限制次数不同"></a>推送消息的限制次数不同</h3><ul><li><code>订阅号</code>：每天可群发 1 条消息</li><li><code>服务号</code>：每月可群发 4 条消息</li><li><code>企业号</code>：每分钟可群发 200 次</li></ul><h3 id="消息的保密性不同"><a href="#消息的保密性不同" class="headerlink" title="消息的保密性不同"></a>消息的保密性不同</h3><ul><li><code>订阅号</code>：消息可以转发和分享</li><li><code>服务号</code>：消息可以转发和分享</li><li><code>企业号</code>：消息可以转发和分享，但加密的消息禁止转发和分享</li></ul><h3 id="关注者的验证方式不同"><a href="#关注者的验证方式不同" class="headerlink" title="关注者的验证方式不同"></a>关注者的验证方式不同</h3><ul><li><code>订阅号</code>：可以被任何微信用户扫码关注</li><li><code>服务号</code>：可以被任何微信用户扫码关注</li><li><code>企业号</code>：只有企业通讯录里的成员可关注</li></ul><h3 id="自定义菜单权限不同"><a href="#自定义菜单权限不同" class="headerlink" title="自定义菜单权限不同"></a>自定义菜单权限不同</h3><ul><li><code>订阅号</code>：通过认证之后可使用自定义菜单功能（目前无需认证也支持自定义菜单）</li><li><code>服务号</code>：无需认证即可使用自定义菜单功能</li><li><code>企业号</code>：无需认证即可使用自定义菜单功能</li></ul><h3 id="高级接口权限不同"><a href="#高级接口权限不同" class="headerlink" title="高级接口权限不同"></a>高级接口权限不同</h3><ul><li><code>订阅号</code>：不支持高级接口权限</li><li><code>服务号</code>：通过认证之后，支持高级接口权限</li><li><code>企业号</code>：通过认证之后，支持高级接口权限</li></ul><h3 id="微信支付功能权限不同"><a href="#微信支付功能权限不同" class="headerlink" title="微信支付功能权限不同"></a>微信支付功能权限不同</h3><ul><li><code>订阅号</code>：不支持微信支付功能</li><li><code>服务号</code>：通过认证之后，支持微信支付功能</li><li><code>企业号</code>：通过认证之后，支持微信支付功能</li></ul><h3 id="定制应用权限不同"><a href="#定制应用权限不同" class="headerlink" title="定制应用权限不同"></a>定制应用权限不同</h3><ul><li><code>订阅号</code>：不支持定制应用</li><li><code>服务号</code>：不支持定制应用</li><li><code>企业号</code>：支持定制应用</li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍在微信公众号平台开发中，服务号、订阅号、企业号的区别。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发随笔" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程编程之三 volatile 与 JMM 内存模型</title>
    <link href="https://www.techgrow.cn/posts/ed2e098d.html"/>
    <id>https://www.techgrow.cn/posts/ed2e098d.html</id>
    <published>2024-02-23T14:34:42.000Z</published>
    <updated>2024-02-23T14:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/5bbede3c.html">Java 多线程编程之一 Java 内存模型浅析</a></li><li><a href="/posts/f7ed7888.html">Java 多线程编程之二 synchronize 锁对象竞争</a></li><li><a href="/posts/ed2e098d.html">Java 多线程编程之三 volatile 与 JMM 内存模型</a></li><li><a href="/posts/3b82844a.html">Java 多线程编程之四 CAS、锁、ABA 问题</a></li></ul><h2 id="JMM-内存模型介绍"><a href="#JMM-内存模型介绍" class="headerlink" title="JMM 内存模型介绍"></a>JMM 内存模型介绍</h2><h3 id="JMM-概述"><a href="#JMM-概述" class="headerlink" title="JMM 概述"></a>JMM 概述</h3><p>JMM 是 Java 内存模型 (Java Memory Model)，本身是一种抽象的概念，实际上并不存在。它描述的是一组规则或规范，通过这组规范定义了程序中各个变量 (包括实例字段，静态字段和构成数组对象的元素) 的访问方式。</p><ul><li>JMM 中关于同步的规定<ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值，并存储在自己的工作内存</li><li>加锁和解锁必须是同一把锁</li></ul></li></ul><p>由于 JVM 运行程序的实体是线程，而每个线程在创建时 JVM 都会为其创建一个工作内存 (有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而 Java 内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作 (读取、赋值等) 必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信 (传值) 必须通过主内存来完成。线程、工作内存、主内存工作交互图 (基于 JMM 规范)，如下：</p><span id="more"></span><p><img data-src="../../../asset/2024/03/jmm-1.png"></p><p>JMM 内存模型与 JVM 内存模型是两个完全不同的概念。JVM 内存模型是处于 Java 的 JVM 虚拟机层面的，实际上对于操作系统来说，本质上 JVM 还是存在于主内存中；而 JMM 是 Java 语言与 OS 和硬件架构层面的，主要作用是规定硬件架构与 Java 语言的内存模型，而本质上不存在 JMM 这个东西，JMM 只是一种规范，并不能说是某些技术的实现。进一步的讲，JMM 与 JVM 内存模型是不同的概念层次，在理解 JMM 的时候不要带着 JVM 内存模型去理解，更恰当说 JMM 描述的是一组规则，通过这组规则控制 Java 程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM 是围绕原子性、有序性、可见性拓展延伸的。JMM 与 JVM 内存模型唯一相似点，都存在共享数据区域和私有数据区域，在 JMM 中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。或许在某些地方，可能会看见主内存被描述为堆内存，工作内存被称为栈空间，实际上它们表达的都是同一个含义。</p><div class="admonition note"><p class="admonition-title">JMM 内存模型的可见性</p><p>JMM 内存模型的可见性指的是当主内存区域中的变量值被某个线程写入更改后，其它线程会马上知晓更改后的变量值，并重新得到更改后的变量值。</p></div><h3 id="主内存概述"><a href="#主内存概述" class="headerlink" title="主内存概述"></a>主内存概述</h3><p>主内存主要存储的是 Java 实例对象，所有线程创建的实例对象都存放在主内存中 (除了开启了逃逸分析和标量替换的栈上分配和 TLAB 分配)，不管该实例对象是成员变量还是方法中的本地变量  (也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多个线程对同一个变量进行非原子性操作时，可能会存在线程安全问题。</p><h3 id="工作内存概述"><a href="#工作内存概述" class="headerlink" title="工作内存概述"></a>工作内存概述</h3><p>工作内存主要存储当前方法的所有本地变量信息 (工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关 Native 方法的信息。注意，由于工作内存是每个线程的私有数据，线程间无法相互访问彼此的工作内存，线程之间的通讯还是需要依赖于主内存，因此存储在工作内存的数据不存在线程安全问题。</p><h3 id="工作内存与主内存交互"><a href="#工作内存与主内存交互" class="headerlink" title="工作内存与主内存交互"></a>工作内存与主内存交互</h3><p>这里简单介绍一下主内存与工作内存的数据存储类型以及操作方式。根据虚拟机规范，对于一个实例对象中的成员方法而言，如果方法中包含本地变量 (也称局部变量) 是基本数据类型 (boolean，byte，char，short，int，long，float，double)，将直接存储在工作内存的帧栈结构中的局部变量表，但倘若本地变量是引用类型，那么该对象的在内存中的具体引用地址将会被存储在工作内存的帧栈结构中的局部变量表，而对象实例将存储在主内存 (共享数据区域，堆) 中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型 (Integer、Double 等) 还是引用类型，都会被存储到堆区 (栈上分配与 TLAB 分配除外)。至于 static 变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个类的同一个方法，那么两个线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新回主内存，简单示意图如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer num = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>{</span><br><span class="line">    num++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2024/03/jmm-2.png"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>{</span><br><span class="line">    Integer num = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">    num++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2024/03/jmm-3.png"></p><h2 id="JMM-与硬件内存架构"><a href="#JMM-与硬件内存架构" class="headerlink" title="JMM 与硬件内存架构"></a>JMM 与硬件内存架构</h2><h3 id="计算机硬件内存架构"><a href="#计算机硬件内存架构" class="headerlink" title="计算机硬件内存架构"></a>计算机硬件内存架构</h3><p><img data-src="../../../asset/2024/03/jmm-4.png"></p><p>上图是经过简化 CPU 与内存操作的简易图，实际上没有这么简单，这里为了方便理解，省去了南北桥。就目前计算机而言，一般拥有多个 CPU 并且每个 CPU 都可能存在多个核心，多核是指在一枚处理器 (CPU) 中集成两个或多个完整的计算引擎 (内核)， 这样就可以支持多任务并行执行，从多线程的调度来说，每个线程都会映射到各个 CPU 核心中并行运行。在 CPU 内部有一组 CPU 寄存器，寄存器存储的是 CPU 可以直接访问和处理的数据，是一个临时放数据的空间。一般 CPU 都会从内存取数据到寄存器，然后进行处理，但由于内存的处理速度远远低于 CPU，导致 CPU 在处理指令时往往花费很多时间在等待内存做准备工作，于是在寄存器和主内存间添加了 CPU 缓存，CPU 缓存比较小，但访问速度比主内存快得多。如果 CPU 总是操作主内存中的同一地址的数据，很容易影响 CPU 执行速度，此时 CPU 缓存就可以把从内存读取到的数据暂时保存起来，如果寄存器要取内存中同一位置的数据，就可以直接从 CPU 缓存中提取，无需从主内存取。需要注意的是，寄存器并不是每次都可以从缓存中取得数据，万一不是同一个内存地址中的数据，那寄存器还必须直接绕过缓存从内存中取数据。所以并不是每次都可以从缓存取数据，这种现象有个专业的名称叫做 “缓存命中率”，可以从缓存中取就命中，不可以从缓存中取而从内存中取，就没命中，可见缓存命中率的高低也会影响 CPU 执行性能，这就是 CPU、缓存以及主内存间的简要交互过程。总而言之，当一个 CPU 需要访问主内存时，会先读取一部分主内存数据到 CPU 缓存 (当然，如果 CPU 缓存中存在需要的数据就会直接从缓存获取)，进而再读取 CPU 缓存的数据到寄存器，当 CPU 需要写数据到主内存时，同样会先刷新寄存器中的数据到 CPU 缓存，然后再将数据刷新到主内存中。</p><div class="admonition note"><p class="admonition-title">提示</p><p>上面介绍的 CPU 寄存器 --&gt; CPU 缓存 --&gt; 主内存的关系，实则就类似于 Appcalition (Java) --&gt; Cache (Redis) --&gt; DB (MySQL) 的关系，Java 程序的性能由于 DB 需要走磁盘受到了影响，导致 Java 程序在处理请求时需要等到 DB 的处理结果，而此时负责处理该请求的线程一直处于阻塞等待状态，只有当 DB 处理结果返回了才能继续工作，那么实际上整个模型中的问题是：DB 的速度跟不上 Java 程序的性能，导致整个请求处理起来变的很慢，但是实际上在 DB 处理的过程 Java 的线程是处于阻塞不工作的状态的，那么实际上是没有必要的，因为这样最终会导致整体系统的吞吐量下降，此时可以加入 Cache (Redis) 来提升程序响应效率，从而整体提升系统吞吐和性能。实际上做性能优化的目的就是让系统的每个层面处理的速度加快，而架构实际上就是设计一套能够吞吐更大量的请求的系统。</p></div><h3 id="Java-线程与-OS-映射关系"><a href="#Java-线程与-OS-映射关系" class="headerlink" title="Java 线程与 OS 映射关系"></a>Java 线程与 OS 映射关系</h3><p>在以上的阐述中，大致介绍了 Java 内存模型和硬件的内存架构之后，接着介绍 Java 中线程的实现原理，理解线程的实现原理，有助于了解 Java 内存模型与硬件内存架构的关系。在 Windows OS 和 Linux OS 上，Java 线程的实现是基于一对一的线程模型，所谓的一对一模型，实际上就是通过语言级别层面的程序去间接调用系统内核的线程模型，即在使用 Java 线程时，比如 <code>new Thread(Runnable)</code>，JVM 内部是转而调用当前操作系统的内核线程来完成当前 Runnable 任务。这里需要了解一个术语，内核线程 (Kernel-Level Thread，KLT)，它是由操作系统内核 (Kernel) 支持的线程，这种线程是由操作系统内核来完成线程切换，内核通过操作调度器进而对线程执行调度，并将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这也就是操作系统可以同时处理多任务的原因。由于编写的多线程程序属于语言层面的，程序一般不会直接去调用内核线程，取而代之的是一种轻量级的进程 (Light Weight Process)，也是通常意义上的线程，由于每个轻量级进程都会映射到一个内核线程，因此可以通过轻量级进程调用内核线程，进而由操作系统内核将任务映射到各个处理器，这种轻量级进程与内核线程间 1 对 1 的关系就称为 Java 程序中的线程与 OS 的一对一模型。如下图所示：</p><p><img data-src="../../../asset/2024/03/jmm-5.png"></p><blockquote><p>Java 程序中的每个线程都会经过 OS 被映射到 CPU 中进行处理，当然，如果 CPU 存在多核，那么一个 CPU 可同时并行调度执行多个线程。</p></blockquote><h3 id="JMM-与硬件内存架构的关系"><a href="#JMM-与硬件内存架构的关系" class="headerlink" title="JMM 与硬件内存架构的关系"></a>JMM 与硬件内存架构的关系</h3><p>通过对前面的 Java 内存模型、硬件内存架构以及 Java 多线程的实现原理，可以发现多线程的执行最终都会映射到硬件处理器上进行执行，但 Java 内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存 (线程私有数据区域) 和主内存 (堆内存) 之分，也就是说 Java 内存模型对内存的划分对硬件内存并没有任何影响，因为 JMM 只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到 CPU 缓存或者寄存器中。因此总体上来说，Java 内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。</p><p><img data-src="../../../asset/2024/03/jmm-6.png"></p><h2 id="指令重排序介绍"><a href="#指令重排序介绍" class="headerlink" title="指令重排序介绍"></a>指令重排序介绍</h2><h3 id="指令重排序的概述"><a href="#指令重排序的概述" class="headerlink" title="指令重排序的概述"></a>指令重排序的概述</h3><p>Java 语言规范规定 JVM 线程内部维持顺序化语义，即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫做 “指令重排序”。指令重排序的意义是什么？JVM 能根据处理器特性（CPU 多级缓存、多核处理器等）适当地对机器指令进行重排序，使机器指令更符合 CPU 的执行特性，最大限度的发挥机器性能。下图为从源码到最终执行的指令序列示意图：</p><p><img data-src="../../../asset/2024/03/jmm-9.png"></p><div class="admonition warning"><p class="admonition-title">重点内容</p><ul><li>处理器在进行指令重排序时，必须考虑指令之间的数据依赖性。</li><li>多线程环境中线程交替执行，由于编译器优化重排序的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</li></ul></div><h3 id="指令重排序的类型"><a href="#指令重排序的类型" class="headerlink" title="指令重排序的类型"></a>指令重排序的类型</h3><p>计算机在执行程序时，为了提高性能，编译器和处理器 (CPU) 往往会对指令做重排序，一般分以下 3 种：</p><ul><li><p><strong>编译器优化重排序</strong></p><ul><li>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li></ul></li><li><p><strong>指令级并行重排序</strong></p><ul><li>现代处理器 (CPU) 采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性 (即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</li></ul></li><li><p><strong>内存系统重排序</strong></p><ul><li>由于处理器使用缓存和读写缓存冲区，这使得加载 (load) 和存储 (store) 操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</li><li>其中编译器优化的重排属于编译期重排，指令并行的重排和内存系统的重排属于处理器重排，在多线程环境中，这两种重排优化可能会导致程序出现内存可见性问题。</li></ul></li></ul><h3 id="as-if-serial-的语义"><a href="#as-if-serial-的语义" class="headerlink" title="as-if-serial 的语义"></a>as-if-serial 的语义</h3><p><code>as-if-serial</code> 语义的意思是不管怎么重排序（编译器和处理器为了提高并行度），程序（单线程）的执行结果不能被改变。编译器、Runtime 和处理器都必须遵守 <code>as-if-serial</code> 语义。为了遵守 <code>as-if-serial</code> 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><h3 id="指令重排序的案例"><a href="#指令重排序的案例" class="headerlink" title="指令重排序的案例"></a>指令重排序的案例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 当两个线程同时执行 method01() 与 method02() 方法时，以下两条语句可能会被重排序</span></span><br><span class="line">        <span class="comment">// 从而导致 method02() 方法被某个线程调用后，输出的结果无法预测（不确定的）</span></span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (flag) {</span><br><span class="line">            a = a + <span class="number">5</span>;</span><br><span class="line">            System.out.println(<span class="string">"reValue:"</span> + a);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="JMM-存在的必要性"><a href="#JMM-存在的必要性" class="headerlink" title="JMM 存在的必要性"></a>JMM 存在的必要性</h2><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>由于 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，线程如果想要操作主内存中的某个变量，那么必须通过工作内存间接完成，主要过程是将变量从主内存拷贝到每个线程各自的工作内存，然后在工作内存中对变量进行操作，操作完成后再将变量写回主内存。<strong>如果存在两个线程同时对一个主内存中的实例对象的变量进行操作，这就有可能诱发线程安全问题</strong>。</p><p><img data-src="../../../asset/2024/03/jmm-7.png"></p><p>第一种情况，在上图中假设主内存中存在一个共享变量 <code>int i = 0</code>。现在有 A 和 B 两个线程分别对变量 i 进行操作，A、B 线程各自都先将主内存中的变量 i 拷贝到自己的工作内存中，也就是将其存储为共享变量副本 i，然后再对工作内存中的 i 进行自增操作。那么假设此时 A、B 线程同时将主内存中 <code>i = 0</code> 拷贝到自己的工作内存中进行操作，那么 A 在自己工作内存中对 i 进行自增的操作对 B 的工作内存的副本 i 是不可见的。当 A 执行完自增操作之后会将结果 1 刷写回主内存，此时 B 也执行完了 i++ 操作，那么实际上 B 刷写回主内存的值也是基于之前从主内存中拷贝到自己工作内存的值 <code>i = 0</code>，那么实际上 B 刷写回主内存的值也是 1。理论上两个线程都对主内存中 i 进行了自增操作，正确的结果应该是 <code>i = 2</code>，但是此时的情况结果却是 <code>i = 1</code>，这就产生了线程安全问题。</p><p><img data-src="../../../asset/2024/03/jmm-8.png"></p><p>第二种情况，在上图中假设现在 A 线程想要修改 i 的值为 2，而 B 线程却想要读取 i 的值，那么 B 线程读取到的值是 A 线程更新后的值 2 还是更新前的值 1 呢？答案是不确定，即 B 线程有可能读取到 A 线程更新前的值 1，也有可能读取到 A 线程更新后的值 2。这是因为工作内存是每个线程私有的数据区域，而线程 A 修改变量 i 时，首先是将变量从主内存拷贝到 A 线程的工作内存中，然后对变量进行操作，操作完成后再将变量 i 写回主内存，而对于 B 线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如 A 线程修改完后正在将数据写回主内存，而 B 线程此时正在读取主内存，即将 <code>i = 1</code> 拷贝到自己的工作内存中，这样 B 线程读取到的值就是 <code>i = 1</code>；但如果 A 线程将 <code>i = 2</code> 写回主内存后，B 线程才开始读取主内存的话，那么此时 B 线程读取到的就是 <code>i = 2</code>，但到底是哪种情况先发生呢？这是不确定的。</p><h2 id="并发编程的三大特性"><a href="#并发编程的三大特性" class="headerlink" title="并发编程的三大特性"></a>并发编程的三大特性</h2><p>为了解决类似如上阐述的线程安全问题，JVM 定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见，这组规则也称为 Java 内存模型（JMM）。JMM 整体就是围绕着程序执行的原子性、可见性、有序性展开的。</p><h3 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性 (Atomicity)"></a>原子性 (Atomicity)</h3><p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。比如对于一个静态变量 <code>int i = 0</code>，两个线程同时对它赋值，线程 A 的赋值操作为 <code>i = 1</code>，而线程 B 的赋值操作为 <code>i = 2</code>，不管线程如何运行，最终 i 的值要么是 1，要么是 2，线程 A 和线程 B 之前的操作是互不干扰的，这就是原子性操作，不可被中断的特点。特别注意的是，对于 32 位系统的来说，double 类型数据和 long 类型数据 (对于基本数据类型，byte，short，int，float，boolean，char 的读写是原子操作) 的读写并非原子性的，也就是说如果存在两个线程同时对 double 类型或者 long 类型的数据进行读写是存在相互干扰的。因为对于 32 位虚拟机来说，每次原子读写是 32 位的，而 double 和 long 则是 64 位的存储单元，这样会导致一个线程在写时，操作完前 32 位的原子操作后，轮到 B 线程读取时，恰好只读取到了后 32 位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是 “半个变量” 的数值，即 64 位数据被两个线程分成了两次读取。但也不必太担心，因为读取到 “半个变量” 的情况比较少见，至少在目前的商用虚拟机中，几乎都把 64 位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道有这么回事即可。 那么其实本质上原子性操作指的就是一组大操作要么就全部执行成功，要么就全部失败，举个例子：下单：{增加订单，减库存} 那么对于用户来说下单是一个操作，那么系统就必须保证下单操作的原子性，要么就增加订单和减库存全部成功，不存在增加订单成功，减库存失败，那么这个例子从宏观上来就就是一个原子性操作，非原子性操作反之，线程安全问题产生的根本原因也是由于多线程对一个共享资源进行非原子性操作导致的。</p><h3 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性 (Visibility)"></a>可见性 (Visibility)</h3><p>可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行（单线程）程序来说，可见性是不存在的，因为在任何一个操作中修改了某个变量的值，后续的操作中都能读取到这个变量值，并且是修改过的新值。但在多线程环境中就不一定了，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程 A 修改了共享变量 i 的值，还未写回主内存时，另外一个线程 B 又对主内存中同一个共享变量 i 进行操作，但此时 A 线程工作内存中的共享变量 i 对线程 B 来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题。另外，无论是编译器优化还是处理器优化的重排现象，在多线程环境下，都可能会导致程序乱序执行的问题，从而也可能会导致可见性问题。</p><h3 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性 (Ordering)"></a>有序性 (Ordering)</h3><p>有序性是指对于单线程的执行代码，通常认为代码的执行是按顺序依次执行的，这样的理解如果是放在单线程环境下没有问题，毕竟对于单线程而言确实如此，代码由编码的顺序从上往下执行，就算发生指令重排序，由于所有硬件优化的前提都是必须遵守 <code>as-if-serial</code> 语义，所以不管怎么排序，都不会且不能影响单线程程序的执行结果，将这称之为 “有序执行”。反之，对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排序后的指令与原指令的顺序未必一致。要明白的是，在 Java 程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。</p><h2 id="JMM-如果解决三大特性问题"><a href="#JMM-如果解决三大特性问题" class="headerlink" title="JMM 如果解决三大特性问题"></a>JMM 如果解决三大特性问题</h2><ul><li>原子性问题解决<ul><li>除了 JVM 自身提供的对基本数据类型读写操作的原子性外，对于方法级别或者代码块级别的原子性操作，可以通过 synchronized 和 Lock 加锁实现原子性。</li><li>因为 synchronized 和 Lock 加锁可以保证每个时刻只有一个线程执行同步代码。<strong>synchronized 可以保证原子性、可见性和有序性，但不能禁止指令重排。</strong></li></ul></li><li>可见性问题解决<ul><li>对于指令重排和主内存与工作内存同步延迟现象导致的可见性问题，可以使用 volatile 关键字解决。<strong>volatile 可以保证可见性和禁止指令重排，但不能保证原子性。</strong></li><li>另外，synchronized 和 Lock 加锁也可以保证可见性，因为它们可以保证任一时刻只有一个线程能访问共享资源，并在其释放锁之前将修改的变量刷新到主内存中。</li><li>当一个共享变量被 volatile 关键字修饰时，它可以保证修改的值立即被其他的线程看到，即修改的值立即更新到主内存中；当其他线程需要读取变量时，它会去主内存中读取新值。</li></ul></li><li>有序性问题解决<ul><li>对于指令重排导致的有序性问题，可以通过 volatile 关键字解决，因为 volatile 的其中一个作用就是禁止指令重排。</li><li>另外，synchronized 和 Lock 加锁也可以保证有序性，因为 synchronized 和 Lock 加锁后可以保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码，这样自然就保证了有序性。</li></ul></li></ul><h3 id="数据同步八大原子操作"><a href="#数据同步八大原子操作" class="headerlink" title="数据同步八大原子操作"></a>数据同步八大原子操作</h3><p>Java 程序在执行的过程中本质上就是操作系统在调度 JVM 的 “线程” 执行，而在执行的过程中是与内存的交互操作，而内存交互操作有 8 种。特别注意，虚拟机实现必须保证每一个操作都是原子的，不可拆分的，但对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许非原子性。一个共享变量如何从主内存拷贝到工作内存，又如何从工作内存同步到主内存之间的实现细节，由 Java 内存模型定义的八种操作来完成。</p><ul><li><code>lock（锁定）</code>：作用于主内存的变量，把一个变量标记为一个线程独占状态；</li><li><code>unlock（解锁）</code>：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</li><li><code>read（读取）</code>：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 工作使用；</li><li><code>load（载入）</code>：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量；</li><li><code>use（使用）</code>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎；</li><li><code>assign（赋值）</code>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量；</li><li><code>store（存储）</code>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作；</li><li><code>wirte（写入）</code>：作用于工作内存的变量，它把 store 操作从工作内存中的一个变量值传送到主内存的变量中。</li></ul><div class="admonition note"><p class="admonition-title">总结</p><ul><li>如果要把一个变量从主内存中拷贝到工作内存中，就需要按顺序地执行 read 和 load 操作。</li><li>如果把变量从工作内存中同步到主内存中，就需要按顺序地执行 store 和 write 操作。</li><li>Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li></ul></div><h3 id="数据同步使用规则说明"><a href="#数据同步使用规则说明" class="headerlink" title="数据同步使用规则说明"></a>数据同步使用规则说明</h3><p>JMM 对上述八大原子操作制定了如下的使用规则：</p><ul><li>(1) 不允许 read 和 load、store 和 write 操作之一单独出现，即使用了 read 则必须 load，使用了 store 则必须 write；</li><li>(2) 不允许线程丢弃它最近的 assign 操作，即工作变量的数据改变了之后，必须告知主内存；</li><li>(3) 不允许一个线程将没有 assign 的数据从工作内存同步回主内存；</li><li>(4) 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量，也就是对变量执行 use、store 操作之前，必须经过 assign 和 load 操作；</li><li>(5) 一个变量同一时间只有一个线程能对其进行 lock，多次 lock 后，必须执行相同次数的 unlock 才能解锁；</li><li>(6) 如果对一个变量进行 lock 操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新执行 load 或 assign 操作来初始化变量的值；</li><li>(7) 如果一个变量没有被 lock，就不能对其进行 unlock 操作，也不能 unlock 一个被其他线程锁住的变量；</li><li>(8) 对一个变量进行 unlock 操作之前，必须将此变量同步回主内存（执行 store 和 write 操作）。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>JMM 通过这八种操作规则和对 volatile 的一些特殊规则就能确定哪些操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析，所以一般也不会通过上述规则进行分析。更多的时候，会使用 JMM 中的 happens-before 规则来进行分析。</p></div><h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h3><p>假如在多线程开发过程中，都需要通过 sychronized、volatile 来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，而且加锁其实本质上是让多线程的并行执行变为了串行执行，这样会大大影响程序的性能。幸运的是，从 JDK 5 开始，Java 使用新的 JSR-133 内存模型，提供了 happens-before 原则（也叫先行发生原则）来辅助保证程序执行的原子性、可见性和有序性，它是判断数据是否存在竞争、线程是否安全的依据。</p><h4 id="happens-before-原则的概述"><a href="#happens-before-原则的概述" class="headerlink" title="happens-before 原则的概述"></a>happens-before 原则的概述</h4><p>happens-before (先行发生原则) 是 Java 内存模型中定义的两个操作之间的偏序关系。比如说操作 A 先行发生于操作 B，那么在 B 操作发生之前，A 操作产生的 “影响” 都会被操作 B 感知到。这里的影响是指修改了内存中的共享变量、发送了消息、调用了方法等。</p><h4 id="happens-before-原则的内容"><a href="#happens-before-原则的内容" class="headerlink" title="happens-before 原则的内容"></a>happens-before 原则的内容</h4><ul><li><code>程序顺序原则</code>：即在单个线程内必须保证语义串行，也就是说按照代码顺序执行。</li><li><code>锁规则</code>：解锁（unlock）操作必须发生在后续的同一个锁的加锁（lock）之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后（同一个锁）。</li><li><code>volatile 规则</code>：volatile 变量的写，先发生于读，这保证了 volatile 变量的可见性。简单理解就是，volatile 变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li><li><code>线程启动规则</code>：线程的 <code>start()</code> 方法先于它的每一个动作，即如果线程 A 在执行线程 B 的 <code>start()</code> 方法之前修改了共享变量的值，那么当线程 B 执行 <code>start()</code> 方法时，线程 A 对共享变量的修改对线程 B 可见。</li><li><code>线程终止原则</code>：线程的所有操作先于线程的终结，<code>Thread.join()</code> 方法的作用是等待当前执行的线程终止。假设在线程 B 终止之前，修改了共享变量，线程 A 从线程 B 的 <code>join()</code> 方法成功返回，线程 B 对共享变量的修改将对线程 A 可见。</li><li><code>线程中断规则</code>：对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检查到中断事件的发生，可以通过 <code>Thread.interrupted()</code> 方法检测线程是否中断。</li><li><code>对象终结规则</code>：对象的构造函数执行，结束先于 <code>finalize()</code> 方法。</li><li><code>传递性规则</code>：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</li></ul><div class="admonition note"><p class="admonition-title">finalize () 方法说明</p><p><code>finalize()</code> 是 Object 中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它 <code>finalize()</code> 方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运），比如释放资源或者关闭连接等。</p></div><h4 id="happens-before-原则的使用"><a href="#happens-before-原则的使用" class="headerlink" title="happens-before 原则的使用"></a>happens-before 原则的使用</h4><p>在下述的代码中，如果有两个线程 A 和 B，线程 A 先调用 <code>setValue()</code> 方法，然后线程 B 调用 <code>getValue()</code> 方法，那么线程 B 执行方法返回的结果是什么？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对照先行发生原则一个一个来对比。首先是程序次序规则，这里是多线程，不在一个线程中，不适用；然后是锁规则，这里没有 synchronized，自然不会发生 lock 和 unlock，不适用；后面对于线程启动规则、线程终止规则、线程中断规则也不适用；这里与对象终结规则、传递性规则也没有关系。线程 A 和线程 B 的启动时间虽然有先后，但上述代码没有符合 8 条原则中的任意一条，也没有使用任何同步手段，因此线程 B 执行结果是不确定的，即上述的操作不是线程安全的。如何修改呢，一个是对 get、set 方法加入 synchronized 关键字，即可以使用锁规则；要么对 value 加 volatile 修饰，可以使用 volatile 变量规则。</p><hr><p>通过上面的例子可知，一个操作时间上先发生并不代表这个操作先行发生，那么一个操作先行发生是不是代表这个操作在时间上先发生？也不是，如下面的例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>在同一个线程内，对 i 的赋值先行发生于对 j 赋值的操作，但是代码重排序优化，也有可能是 j 的赋值先发生，我们无法感知到这一变化。综上所述，时间先后顺序与先行发生原则之间基本没有太大关系。我们衡量并发安全的问题的时候不要受到时间先后顺序的干扰，一切以先行发生原则为准。</p><h2 id="Volatile-关键字介绍"><a href="#Volatile-关键字介绍" class="headerlink" title="Volatile 关键字介绍"></a>Volatile 关键字介绍</h2><h3 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h3><p>volatile 是 Java 虚拟机提供的轻量级的同步机制，它有如下两个作用：</p><ul><li>保证可见性</li><li>禁止指令重排</li></ul><h3 id="volatile-的三大特性"><a href="#volatile-的三大特性" class="headerlink" title="volatile 的三大特性"></a>volatile 的三大特性</h3><p>volatile 有三大特性：</p><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>volatile 保证可见性和禁止指令重排的两大特性，其内存语义都是通过内存屏障实现的。</p></div><h3 id="volatile-可以保证可见性"><a href="#volatile-可以保证可见性" class="headerlink" title="volatile 可以保证可见性"></a>volatile 可以保证可见性</h3><p>关于 volatile 的可见性作用，必须意识到被 volatile 修饰的共享变量对所有线程总是立即可见的，即对于 volatile 共享变量的所有写操作总是能立刻反应到其他线程中。JMM 是如何实现让 volatile 共享变量对其他线程立即可见的呢？实际上，当某个线程对一个 volatile 共享变量执行写操作时，JMM 会把该线程对应的工作内存中的共享变量副本刷新到主内存中，并通知其他线程将自己工作内存中的共享变量副本设置为无效；当某个线程对自己工作内存中的共享变量副本进行读写操作时，该线程会从主内存中重新读取共享变量的值到工作内存中。volatile 共享变量正是通过这种写 - 读方式实现对其他线程可见，但其内存语义则是通过内存屏障实现的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initFlag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"refresh data......."</span>);</span><br><span class="line">        initFlag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"refresh data success......."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 线程A</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">while</span> (!initFlag) {</span><br><span class="line">                counter++;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() + <span class="string">": 当前线程嗅探到 initFlag 的状态的改变"</span>);</span><br><span class="line">        }, <span class="string">"threadA"</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中间休眠500hs</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程B</span></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            refresh();</span><br><span class="line">        }, <span class="string">"threadB"</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refresh data.......</span><br><span class="line">refresh data success.......</span><br><span class="line">线程 threadA: 当前线程嗅探到 initFlag 的状态的改变</span><br></pre></td></tr></tbody></table></figure><blockquote><p>结合前面介绍的数据同步八大原子操作来分析上述的代码：</p></blockquote><p><img data-src="../../../asset/2024/03/jmm-10.png"></p><ul><li>线程 A 启动后，执行流程如上图所示<ul><li>第一步：执行 read 操作，作用于主内存，将变量 initFlag 从主内存拷贝一份，这时候还没有放到工作内存中，而是放在了总线里；</li><li>第二步：执行 load 操作，作用于工作内存，将上一步拷贝的变量，放入工作内存中；</li><li>第三步：执行 use 操作，作用于工作内存，把工作内存中的变量传递给执行引擎，对于线程 A 来说，执行引擎会判断 <code>initFlag = true</code> 吗？不等于，此时循环会一直执行。</li></ul></li></ul><p><img data-src="../../../asset/2024/03/jmm-11.png"></p><ul><li>线程 B 启动后，执行流程如上图所示<ul><li>第一步：执行 read 操作，作用于主内存，从主内存拷贝 initFlag 变量，这时候拷贝的变量还没有放到工作内存中，这一步是为了 load 做准备；</li><li>第二步：执行 load 操作，作用于工作内存，将拷贝的变量放入到工作内存中；</li><li>第三步：执行 use 操作，作用于工作内存，将工作内存的变量传递给执行引擎，执行引擎判断 <code>while(!initFlag)</code>，然后执行循环体；</li><li>第四步：执行 assign 操作，作用于工作内存，把从执行引擎接收的值赋值给工作内存的变量，即设置 <code>inifFlag = true</code>；</li><li>第五步：执行 store 操作，作用于工作内存，将工作内存中的变量 <code>initFlag = true</code> 传递给主内存；</li><li>第六步：执行 write 操作，作用于工作内存，将变量写入到主内存中。</li></ul></li></ul><h4 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h4><p>为什么某个线程将共享变量的值更改后，其它线程可以马上知晓呢？其实这里是使用 “总线嗅探技术” 来保证可见性的。</p><blockquote><p>缓存一致性</p></blockquote><p>在介绍总线嗅探技术之前，首先谈谈缓存一致性的问题，就是当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一致。为了解决缓存一致性的问题，需要各个处理器在访问缓存时都遵循一些协议，在读写时要根据协议进行操作，这类协议主要有 MSI、MESI 等等。</p><blockquote><p>MESI 协议</p></blockquote><p>当 CPU 写入数据时，如果发现操作的变量是共享变量，即在其它 CPU 中也存在该变量的副本，就会发出信号通知其它 CPU 将该共享变量的缓存（副本）设置为无效。因此当其它 CPU 读取这个变量的缓存时，发现自己缓存的该变量是无效的，那么它就会从内存中重新读取。</p><blockquote><p>总线嗅探</p></blockquote><p>那么 CPU 是如何发现缓存数据是否失效呢？这里用到了 “总线嗅探技术”，就是每个处理器通过嗅探在总线上传播的数据来检查自己的缓存数据是否失效了。当处理器发现自己的缓存数据对应的内存地址被修改，就会将当前处理器的缓存数据设置为无效状态；当处理器对这个缓存数据进行修改的时候，会重新从内存中把数据读取到处理器缓存中，然后再执行修改操作。</p><blockquote><p>总线风暴</p></blockquote><p>总线嗅探技术有哪些缺点？由于 volatile 的 MESI 缓存一致性协议，需要不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值。因此不要大量使用 volatile 关键字，至于什么时候使用 volatile、什么时候用锁以及 syschonized 都是需要根据实际场景衡量的。</p><h3 id="volatile-无法保证原子性"><a href="#volatile-无法保证原子性" class="headerlink" title="volatile 无法保证原子性"></a>volatile 无法保证原子性</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>{</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在并发场景下，上述代码中变量 i 的任何改变都会立刻反应到其他线程中，但是如果存在多个线程同时调用 <code>increase ()</code> 方法的话，就会出现线程安全问题。<strong>因为 i++ 并不是原子性操作，i++ 实际上是由三个操作组成，包括从主内存读取值、在工作内存中执行加 1 操作、将操作结果刷写回主内存，它们三步中其中一个线程在执行任何一步的时候都有可能被打断，所以会出现线程安全问题。</strong>如果第二个线程在第一个线程读取旧值和写回新值期间读取了 i&nbsp;的值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加 1 操作，这也就造成了线程安全问题，因此需要使用 synchronized、Lock 或者原子类来保证原子性，以确保线程安全。特别注意，一旦使用 synchronized 修饰方法后，由于 sunchronized 本身也具备与 volatile 一样的可见性，因此在这样的情况下就完全可以不使用 volatile 关键字来修饰变量。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileAtomic</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) {</span><br><span class="line">                    <span class="comment">// 自加运算不是原子操作</span></span><br><span class="line">                    counter++;</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            thread.start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9615</span><br></pre></td></tr></tbody></table></figure><p>可以发现上述程序实际输出的结果不到 10000，原因是因为存在并发操作，并且 volatile 不能保证原子性。每个线程只执行 <code>counter++</code> 操作，那为什么不能保证原子性呢？这是因为 <code>counter++</code> 操作不是一步完成的（非原子性），它分为三个步骤完成，包括从主内存读取值、在工作内存中执行加 1 操作、将操作结果刷写回主内存。假设现在有三个线程同时执行自加运算操作，三个线程都读取到主内存中的 counter 共享变量，然后三个线程在各自的工作内存中对共享变量的副本进行加 1 操作，但它们并发执行加 1 之后，因为同一时刻只能有一个线程刷写回主内存，所以其它线程的写操作会被挂起。假设线程 A 先执行写操作，在写操作执行完之后，由于 volatile 的可见性，JMM 会主动通知其它两个线程主内存中共享变量的值已经被修改了；但是由于 CPU 的调度速度实在太快了，其它两个线程还没来得及接收到通知，就陆续将加 1 的结果写入主内存，这就造成其他线程覆盖了线程 A 写入的值，从而导致出现写丢失的现象，这样也就让最终的计算结果少于 10000。</p><h3 id="volatile-禁止指令重排优化"><a href="#volatile-禁止指令重排优化" class="headerlink" title="volatile 禁止指令重排优化"></a>volatile 禁止指令重排优化</h3><p><strong>volatile 关键字的其中一个作用是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。</strong>关于指令重排优化前面已经介绍过，这里主要重点介绍 volatile 是如何使用内存屏障实现禁止指令重排优化的。</p><h4 id="内存屏障概述"><a href="#内存屏障概述" class="headerlink" title="内存屏障概述"></a>内存屏障概述</h4><p>内存屏障（Memory Barrier），又称内存栅栏，是一个 CPU 指令，其作用有两个：</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ul><h5 id="硬件层的内存屏障"><a href="#硬件层的内存屏障" class="headerlink" title="硬件层的内存屏障"></a>硬件层的内存屏障</h5><p>Intel 硬件提供了一系列的内存屏障，主要有以下几种类型：</p><ul><li><code>lfence</code>：是一种 Load Barrier 读屏障；</li><li><code>sfence</code>：是一种 Store Barrier 写屏障；</li><li><code>mfence</code>：是一种全能型的屏障，具备 lfence 和 sfence 的能力；</li><li><code>Lock 前缀</code>：Lock 不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock 会对 CPU 总线和高速缓存加锁，可以理解为 CPU 指令级的一种锁。它后面可以跟 ADD、ADC、AND、BTC、BTR、BTS、CMPXCHG、CMPXCH8B、DEC、INC、NEG、NOT、OR、SBB、SUB、XOR、XADD、and XCHG 等指令。</li></ul><h5 id="JVM-中的内存屏障"><a href="#JVM-中的内存屏障" class="headerlink" title="JVM 中的内存屏障"></a>JVM 中的内存屏障</h5><p>不同硬件实现内存屏障的方式不同，Java 内存模型屏蔽了这些底层硬件平台的差异，由 JVM 来为不同平台生成相应的机器码。JVM 中提供了四类内存屏障指令：</p><p><img data-src="../../../asset/2024/03/jmm-12.png"></p><p><strong>由于编译器和处理器 (CPU) 都能执行指令重排优化，如果在指令间插入一条内存屏障，则会告诉编译器和处理器，不管什么指令都不能和这条内存屏障指令重排序，也就是说可以通过插入内存屏障来禁止在内存屏障前后的指令执行重排序优化。内存屏障的另外一个作用是强制刷出各种处理器的缓存数据，因此任何处理器上的线程都能读取到这些数据的最新版本。总之，volatile 变量正是通过内存屏障实现其内存中的语义，即可见性和禁止指令重排优化。</strong></p><h5 id="单例模式-volatile-分析"><a href="#单例模式-volatile-分析" class="headerlink" title="单例模式 volatile 分析"></a>单例模式 volatile 分析</h5><p>这里将介绍一个非常典型的禁止指令重排优化的例子：单例模式（DCL - 双端检锁）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>&nbsp;<span class="class"><span class="keyword">class</span>&nbsp;<span class="title">DoubleCheckLock</span>&nbsp;</span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>&nbsp;DoubleCheckLock&nbsp;instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>&nbsp;<span class="title">DoubleCheckLock</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;DoubleCheckLock&nbsp;<span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 第一次检测</span></span><br><span class="line">        <span class="keyword">if</span>&nbsp;(instance == <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span>&nbsp;(DoubleCheckLock.class){</span><br><span class="line">                <span class="comment">// 第二次检测</span></span><br><span class="line">                <span class="keyword">if</span>&nbsp;(instance&nbsp;==&nbsp;<span class="keyword">null</span>){</span><br><span class="line">                    <span class="comment">// 在多线程环境下，这行代码可能会出现问题</span></span><br><span class="line">                    instance&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp; DoubleCheckLock();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>&nbsp;instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>上述代码在单线程环境下并没什么问题，但如果在多线程环境下就可能会出现线程安全的问题。因为当某一线程执行到第一次检测，读取到 instance 不为 null 时，instance 实例可能还没有完成初始化。</p></div><p>因为 <code>instance = new DoubleCheckLock ()；</code> 可以分为以下 3 个步骤完成（伪代码）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();    <span class="comment">// 1. 分配对象内存空间</span></span><br><span class="line">instance(memory);       <span class="comment">// 2. 初始化对象</span></span><br><span class="line">instance = memory;      <span class="comment">// 3. 设置 instance 指向刚分配的内存地址，此时 instance != null</span></span><br></pre></td></tr></tbody></table></figure><p>步骤 1 和步骤 2 之间可能会重排序，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();    <span class="comment">// 1. 分配对象内存空间</span></span><br><span class="line">instance = memory;      <span class="comment">// 3. 设置 instance 指向刚分配的内存地址，此时 instance != null，但是对象还没有初始化完成</span></span><br><span class="line">instance(memory);       <span class="comment">// 2. 初始化对象</span></span><br></pre></td></tr></tbody></table></figure><p>由于步骤 2 和步骤 3 不存在数据依赖关系，而且无论重排序前还是重排序后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义执行的一致性（单线程），但并不会关心多线程间的语义一致性。所以当一个线程访问 instance 实例不为 null 时，由于 instance 实例未必已经初始化完成，这就会造成线程安全问题。也就是，当没有使用 volatile 关键字时，在某些情况下会出现多次初始化实例的情况（存疑），这是由于指令重排序导致的。那么该如何解决呢，很简单，使用 volatile 禁止 instance 变量被执行指令重排优化即可。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止指令重排优化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br></pre></td></tr></tbody></table></figure><h3 id="volatile-内存语义的实现"><a href="#volatile-内存语义的实现" class="headerlink" title="volatile 内存语义的实现"></a>volatile 内存语义的实现</h3><h4 id="内存语义的实现"><a href="#内存语义的实现" class="headerlink" title="内存语义的实现"></a>内存语义的实现</h4><p>前面提到过重排序分为编译器重排序和处理器重排序。为了实现 volatile 内存语义，JMM 会分别限制这两种类型的重排序类型。下面是 JMM 针对编译器制定的 volatile 重排序规则表。</p><p><img data-src="../../../asset/2024/03/jmm-13.png"></p><ul><li>从上图可以看出<ul><li>当第二个操作是 volatile 写时，不管第一个操作是什么，都不能重排序。这个规则确保了 volatile 写之前的操作不会被编译器重排序到 volatile 写之后。</li><li>当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。这个规则确保了 volatile 读之后的操作不会被编译器重排序到 volatie 读之前。</li><li>当第一个操作是 volatile 写，第二个操作是 volatile 读或写时，不能重排序。</li></ul></li></ul><p><strong>为了实现内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</strong>对于编译器来说，发现一个最优配置来最小化插入屏障的总数几乎不可能。为此，JMM 采取保守策略。下面是 JMM 基于保守策略的内存屏障插入策略：</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障</li></ul><blockquote><p>上述内存屏障插入策略非常保守，但它可以保证在任一处理器平台，任意的程序中都能得到正确的 volatile 内存语义。</p></blockquote><p><img data-src="../../../asset/2024/03/jmm-14.png"></p><p>上图是在保守策略下，volatile 写操作插入内存屏障后生成的指令序列示意图。StoreStore 屏障可以保证在 volatile 写操作之前，其前面的所有普通写操作已经对任意处理器可见。这是因为 StoreStore 屏障将保障前面所有的普通写在 volatile 写之前刷新到主内存。这里比较有意思的是，volatile 写后面的 StoreLoad 屏障。此屏障的作用是避免 volatile 写与后面可能有的 volatile 读 / 写操作重排序。因为编译器常常无法准确判断在一个 volatile 写的后面是否需要插入一个 StoreLoad 屏障（比如，一个 volatile 写之后方法立即 return）。为了保证能正确实现 volatile 的内存语义，JMM 在采取了保守策略：在每个 volatile 写的后面，或者在每个 volatile 读的前面插入一个 StoreLoad 屏障。从整体执行效率的角度考虑，JMM 最终选择了在每个 volatile 写的后面插入一个 StoreLoad 屏障，因为 volatile 写 - 读内存语义的常见使用模式是：一个写线程写 volatile 变量，多个线程读同一个 volatile 变量。当读线程的数量大大超过写线程时，选择在 volatile 写之后插入 StoreLoad 屏障将带来可观的执行效率的提升。从这里可以看到 JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p><p><img data-src="../../../asset/2024/03/jmm-15.png"></p><p>上图是在保守策略下，volatile 读操作插入内存屏障后生成的指令序列示意图。LoadLoad 屏障用来禁止处理器把前面的 volatile 读与后面的普通读重排序。LoadStore 屏障用来禁止处理器把前面的 volatile 读与后面的普通写重排序。</p><h4 id="代码案例分析"><a href="#代码案例分析" class="headerlink" title="代码案例分析"></a>代码案例分析</h4><p>上述介绍的 volatile 写 和 volatile 读的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile 写 - 读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面通过具体的示例代码进行说明。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>&nbsp;<span class="title">VolatileBarrierExample</span>&nbsp;</span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>&nbsp;a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span>&nbsp;<span class="keyword">int</span>&nbsp;v1&nbsp;=&nbsp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span>&nbsp;<span class="keyword">int</span>&nbsp;v2&nbsp;=&nbsp;<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="function"><span class="keyword">void</span>&nbsp;<span class="title">readAndWrite</span><span class="params">()</span>&nbsp;</span>{</span><br><span class="line">        <span class="keyword">int</span>&nbsp;i&nbsp;=&nbsp;v1;　　&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;第一个volatile读</span></span><br><span class="line">        <span class="keyword">int</span>&nbsp;j&nbsp;=&nbsp;v2;&nbsp;&nbsp;&nbsp;&nbsp;　&nbsp;&nbsp;<span class="comment">//&nbsp;第二个volatile读</span></span><br><span class="line">        a&nbsp;=&nbsp;i&nbsp;+&nbsp;j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="comment">//&nbsp;普通写</span></span><br><span class="line">        v1&nbsp;=&nbsp;i&nbsp;+&nbsp;<span class="number">1</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　&nbsp;<span class="comment">//&nbsp;第一个volatile写</span></span><br><span class="line">        v2&nbsp;=&nbsp;j&nbsp;*&nbsp;<span class="number">2</span>;&nbsp;&nbsp;&nbsp;&nbsp;　&nbsp;&nbsp;<span class="comment">//&nbsp;第二个volatile写</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>针对 <code>readAndWrite()</code> 方法，编译器在生成字节码时可以做如下的优化：</p><p><img data-src="../../../asset/2024/03/jmm-16.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在上图中，最后的 StoreLoad 屏障不能省略。因为第二个 volatile 写之后，方法立即 return，此时编译器可能无法准确判断后面是否会有 volatile 读或写，为了安全起见，编译器通常会在这里插入一个 StoreLoad 屏障。</p></div><p>上面的优化针对任意处理器平台，由于不同的处理器有不同 “松紧度” 的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以 X86 处理器为例，上图中除最后的 StoreLoad 屏障外，其他的屏障都会被省略。前面保守策略下的 volatile 读和写操作，在 X86 处理器平台可以继续被优化，如下图所示。X86 处理器仅会对读 - 写操作做重排序。X86 不会对读 - 读、读 - 写 和 写 - 写 做重排序，因此在 X86 处理器中会省略掉这 3 种操作类型对应的内存屏障。在 X86 中，JMM 仅需在 volatile 写操作后面插入一个 StoreLoad 屏障即可正确实现 volatile 写 - 读的内存语义，这意味着在 X86 处理器中，volatile 写的开销比 volatile 读的开销会大很多，因为执行 StoreLoad 的屏障开销会比较大。</p><p><img data-src="../../../asset/2024/03/jmm-17.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://baijiahao.baidu.com/s?id=1709086005694976168">Java 内存模型（JMM）与 Volatile 关键字底层原理</a></li><li><a href="https://juejin.cn/post/6893430262084927496">一文读懂 Java 内存模型 (JMM) 及 volatile 关键字</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Java 中的 volatile 与 JMM 内存模型，包括内存可见性、禁止指令重排、内存屏障等内容。</summary>
    
    
    
    
    <category term="Java" scheme="https://www.techgrow.cn/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>近期学习计划</title>
    <link href="https://www.techgrow.cn/posts/860c6c02.html"/>
    <id>https://www.techgrow.cn/posts/860c6c02.html</id>
    <published>2024-01-02T14:38:21.000Z</published>
    <updated>2024-02-05T14:38:21.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误, 请重新输入." data-whm="文章校验失败, 但不影响阅读解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b2030e8d0c19e253a9151525e83bcb5644ad9e7ef9c51b8a61ead17ab881b9ab">4cfab7e4fdfd9afdbf1592f9652b8a199f3cb3b67d053a3a2b7db0e886465ca164af0df16bf14e0fab728c9ff50fc391cebc6b0cccdb129e6ba846f64fd1707908115181dd12f8623e78de3879033c9f76dccdb2aca93fa5b64ea70af83fda03ff378127688246fd68b19d16f2edb96c0c5e42cc28860181f561cd5311a41d1a7d4a84a65a6216916a002ddb385ffb0c2663792bec981c87fe04d8f258708cd72bb89577ca1e2c51ba4d795877b0c14f3b2ae25df3babbb633f1792d5c0477d2fa4edf15c0a2fb827b95bd9a7066e242a274dea01f92d0858df04ad5c8cc077e147b67a169368c10e980846cd92d3fe1d5ce2712d2a5c5573a0fe5eded499e725acc4013fa791a66f552814d7859a5153ae45895f6259b0a165c200e3c753f2863b20f624eebb792c27548fdaac67c70584d4621cee294823f674039694aeb76a0d6cd9af764723f5250268ef3f6a0249c236e9876faf8ffe1b402c9a8887a989f9570bbcd3e99488396d8d529d2da716ff13a5546a074c62281ea698ddc6f7c3b346985643db1ab7ce7ba84f72981ac775b6673642e7b3edf9d6423c6ed77cfa2650729eee7eef8acde5bb59b6d47b64d799ba32f7439b38f56cb19720b2b4d787eeba7c7dd39b78c5e1b79c068902d759e16cf44733eb979ed6c10753a46daa77f19ba0ba83aa9ce6ae1195dbd0e1146649fb3da9b4af693c8653ecb02f440353dbd6cefdb283bd8ae14e73f2b84c4d5a035446a0f4d78b78de074e43b48bdaf598490975e0c00c3841e8d7ec390708b3a0b955ae1a2b353038c515b81f9b5c22160b0036b1bfdd482a365edc5b770b9409f69f3a291d1dee92ee8bb6f0fff5436e479db838e015d281c5dbf43f12c86324637a6acd30b8fb69e1477244dbfd35dd1f8797d954a7db666c734b6db51ad1f71e902081eeca58bbfc338c1f34d19ba63fc470477bf3a4fab27312fffcd8a5e089558278930c1d66e3189fec93848428107048c6f2c85f277f743c247ee1f2f79f18e21e4c94dbc5e2e4c9ed0fdfbd0b3cc8dd29382bf1d880a3f077735c5127a0eadb673951c9b6127c9b537142aaa70ebda5d5407f48bb9ae4ff33fb150a3d5a5ad9d8bb719729abcc8ce9379b666c14b6470b60751c77fbef62eaf5ea3e57f6b5d840d445cb207c34acd0488cbdd427f833d5325d4b904e60ba34e459c76cc52a431d71180e0404843dcef31ead39312aa84d54c6c2031c2da2299c640d61149a81871e0f520ccc44d914c116bb2c6d1ffdfe7a68ef3846015ba36fa2437fe2f4e7390befe4589fb1195eaa4638784c145329fb340850dd195aec1075ddcc3fc171e34c8ea9d60a89da367fad1b201f4dca28965c5e6cb68d7592ceb36ff711a835e0b5d6876cde762379c0b51f6f5479cc6ed8d899e5c11880eb2532104e062d27b2f8096482e103fb30d6bbdbc18e6a1d678547cf21697153ef5d42540a841c9ab54bca8a76004e811602d6e55436ee182a7a14ed46c8ca2166bc9242e0149e7532940ed708603adc2bf78fdfa0482a714eff347d475ef75391c0618edfabda95b236c1dea8f76ca4aafcb8f378d1cd56911d41c514dee9c52b669e0439f69bafc4d54191fb6e36e412edcc88a9d8decf9b24698532bee15eda4cf2199c1f2f4623878db28cadd770799915f9f9e17d7f80a051ef899b2efac01267bff73c85b5c1b342ecef76f71343e037040442e4dbe15bd6b0706c34cca06328923ddc2436d953b3afdc7bc86e7ac4b2ac6f46323c868a32f7e38c2e297505a5405aaaad4aacbdaddbcc65965d8487ae1ba7670cea5ba705084c5b8b45c1d1123a149e1b5817761b0f23c3e5e80e2fa1783a08d90370530113f3d84737ed1d111a5225c5347e3f7a0a6077947b35ec93c2b8387b5582df218cc325db2898388e9ddd078edb80aeb1794e298ae3d4cdb00ec2fadd79947bdd16bda0a445d46c444e8d2316f134d8d0e130c2b032d14cdbd23fb44cf5c726a65052c5ed9dbe6fb6a0dcc2272ccbabf11027a62a2d4c5250a08ffe5817d80372075cdc41f9d92db00cffc5a3330860d4b264a5f750becc1df9567d34daace514cc2585c724bfcee8f2aed137494dbf650c647d9e4e9359cb1a01ca4fb1dd873478c0d15eae4fec24b173b80ec6519804b56b295640c76a4f7998683a7828b48ff7657307c86f7d0e2883d8bf64a9c9cce6642bd73d0d5ca33706828019ba93dc88dcd9719be38bc79eabcea156f44974057ba616f8ea1dbb2208d9d10b32687ab86d4e3c49c3899df49e84a1abf46585364c5aa80b8b93b1411af3ed0ee9f5d162094c457c5f8aa103ec03dbd176efb9e30768ffbd419cb9ad15c56e3316fd558581fed62f91ff12c01aeebbc8a21cdef83930bc88ac0cfbcfe35fd5891bfe80136dea6280e909949d0a18e40f34d418da33dd525e2d7ecf59f2be0a5003656e4664661237553fa9f316ec8c6961a3c5007975508b1954e35463036dcb3ae12984b4c0aeb41faa5518eb09b28d8d46d62c1b50870006238f4a8a9dab4eb5b70df8a79e465985ee5e7caaae303521858fe69ec9e784670b01c7d2e6abb3193e90dc3ca3e89624ba6db2a818df3db7bc874fc103daa778f1db0eabac541e90327d4811255b0ed52a20ce74bf9dcd6c3a6a9287ac22f9852c890ed35f17c500d4c0eb2676a65167ffdfc17cc57fa700ab20c67877da172421707b3e399f4941fff662a97a96d70fb7bb4ea0585ef31efaffb4847952b13b526334cf1697cc087c5a14733365f70ba87319528668e378a569664bf65c91701f79792b99f85743a060483f2e347331dd0c4d58eff400f5de31f3bc83f3f5a054664ec39a5eea65a3fc6510091bd9eac230fd93db289d41a0253441da5aa25bafef8ef1c91446dfec784a7f05d94a021428b9069a260a13252882322d222a20b7c5e2a7c73a513c3ad184d43f2dd950e09ed71a348e06b36a67e5aa2b7233b3636110a1b2cce3e9bdf3223c0139ab3462bf28115853a138a5a59ff5d3bc8c0fad0e3d07285ff9a32cd985a04e269613e2ea388bcd9a2534204e7843eeb98ee596094003332a2fced56a0b61aa4b9db03fd9f609f4f2bd18e62435f90c8c17eba67a1a86dc9c31505d5be09cb67fd938cd5ae6e493ab3714e0c213ba52a2f146c6dc8c043484affa3bf7fd10467e3836052afa11cbc57c1cdd2180086d1bc096bb039443e6dd949b3f3300a1e3dc71e6a8642c1a419044d69fc7971de4b25150846f6f272bf9fc90c6182e65ab3d6b0d9470ce717ad0dbca8b64ed83298b2283d8ffc515cd80e2c1abdc08cc9fc7e15d73269074018fc4c260dc022237156378bf299ab0f96612640fdc9350fa4899ee7765eafb3a83709a24a5c070e92025577ded6ed56fe2dee37ea16b66b9a560aa42a5ab11fb8dd9c25def94cf6ee2674535e20ed1b0ca374965ba1cc23a4d1fac0c812e32223de0b0e254369553ae3a00be69cb0fb860abf4df8f764faeabad4def490db9cdd479a3701a8a5ac3215c1733916b9f16752f16d8b6bb16c6a9f123ebabe357d8b6b4bc715052793157cfcb20d574d25b236b82d283edf6b22f3d8c4c36b907479d69776d4567bb89d272eefad2f490eb9898b7656b26975b0c6420b74faf45a4d3197b6772463ef6f93ef5eb0671b315bff5124a8e923eae5e4450af8622c33e55298e5b792bb491101d4447dcd223bae5958f188ef683bc4488cd9de851330033ce9051db9666fd8e8c23ccc8e42effbe25999df78c79e0febbccf7e3a6694eea9803eefb7084f6531aecf7e56c7e578f00f249dddb461d7b615bcaff6722291dd8c8fb9e6735fad292de8763501a4085c6dc1c101401c504608e4a34bce86b41f6a6e74cde3615bbdd3b66793491225d7365f9bca2ab1d88c04ed65af4ada2a819690e7de5a462171cbc08f797ef90029ddce717af4eee315d9cb7f2fea113053f93878906aa12809c83c86bdf7ebe355a06049e71510b580166025485e97d6864401a489e74f1e4da62d350f6d81e6844e598a04ce2c84cf8142d8b975227b8381c8ca676fac901116f92731d99888113d5baf4547955bbc85d5e7555d3749a4718bcf4ba5fa823263dc55905e2f43e1da42806a2aa96951a4ec66bfa2bcb55fa30446508a781c5b45fc1ab03c850d8d440e250d485dffa1931031a123adb78ae128251f5981ace31748d2bddb1bf48c94abbae0839e2e472e122dd54806a893e83f236f3542a601e81a22bff7d2e623f4894a970e103d2be4a60fadd3e24647060a32bac1d5bdefbfb8cceea3281a63020d9a6bd0e41aba7661c1e44289131516887747f74b56de5b998206437c3755b3e1b1dc5f0541510c0e2c1ef2fc3bc17e44f69a4f21c437c5aaaa712bc8eb8d3f49967eada483f929c3790c94b9d1b19f8842043ca97adb608dc38ad86a0b2bd705da579f14ce1c8619019c89c67f6af733162f1c99088b3c937e4b2935ca422c7478888feef3c78b7c376f317bd103b189c32b803533c5e850b41ad9546f506653b84482896f2530047c14a93d0f5d9ad8de23af32b0b625c2872b1e1106caeb5376635f6ed75b501a209b4911fd630644fc737abf0e04f50ca2df00e756a5ff9ee0eb2d89a2268f4b4b68c06c866fb730e22951973625ed5c6f51bdf7b760f41edcd2838828589bef7e6fb779092e36c6f83f3618366b118c87661566cf0a1dc2c537a71cb4781f76a2e3d6bb3f2a5e45be4af37c61bf07d3da72e6eaf8a702abc8a2c23aa4ab3d5cd37b748d4c95ca97bf6d6bf30674b9614f7b1bf2da9baed6889158b1fdb8e021969098fbdb0f8beb571a8b73fe0b126a9534991acad9cfe725ece1c69aa99369f3c33e12c7c21fdbff8bb8ceb8070232026b4fcdda88e1a4928d359d82f84f9a4126c5238664ec689658104886b90d9d705b1a835f21ba51440a10ea00db58e3cce4b737b7c7c258bf746994540c37b9218db6ccf6ab883d0b32db01baea97e43bf4dd6cfd3bdf552dc242c62f636a52f788598ce8efa0b36ba1f14683fde308f99f23ee0e57c4d71c6cfa7f342bcca44817476d85b14c86443439e4a8293c14a9f618162fea14ff6606830f7b19a021ae13d928514916ec862f8058230ea49be8282081a09563443c17344dd5abc42a98e9013e435f680f524a1112b039a624352e6321e4392d6f0d182c2164ac0e65341faeeab636c1981d6f1b93928afa611ba3c0c09862145e33d1ab2b83bc37c41856182e680dba8ecc7064964c982b8ad6025da6e32bde07d4e5855ad6625a3768436581a5836b71caf59e2d2fe03a078ec3ae474e3c74549433e8cfb577d3bb7b5fef6e585d318915904dcd266df6844f62a4ba42e6904d626cc316433e5512e5d9fad72a17f2204538007b76d50c6b35e293f2e492fff78c3714bac696edac74a595642f054f0f3499063457f8a1250c8d160e71b3f377e45209bab2e99c24bc9daf020010d9f33b7d13b6d1eebcf9bd152a8d20121c17d72a7ab8fad6bcb3325ba77c4bde9f975e0c9fb961030c1fdde4f787a916cbde1276e307db7162788271d961d62b23f1b90bde59a7699dc810c3075e52017f03343bb873537662d853919f99be63326b8c793a56c4d50c68347c873a721213f6c9b3d3177866eb032603848a901b8840535457c378a7d2a3415eb401668d4177e6311ccd86718b09c873d91c4f6e1b7c2c7f00bbf6949ec8719227daa981796a4092a7b7d4d6d774526743c1eb950d398a9b95d5d47d298a25cf1bea1c3208191e3fb65444b618154f9744abd709a3def5d6708c77adcbdb2e3679640a0e11f29622787eeb59ef2b038e0c516bcc69829dd0203640feeb7e0b15ea6524b54c2ec3872f1489ce5eb811f9718c1f08cd90e3cb923d4cdbd991933136cbacb9b3826f271a0a4f71e27364cbaa428608d3ffad770361115aa342c19ea4e5ada4abf79bca8be7317c217d0fde7fe2e3821385a87892cc661bbef0318254b805ea662a75c0d34683e9f88909edbf9f703223f8fc221fa27b025966601f5d37273b50ac7fc1197e9efc1df9c8027d444a5ac4941987c901938371a549e21065430f39ad49dbf74a955fff43865c0cd063461a4551cf426cf8089396734563d14e22f973fb0024d55afea71cad47d97e4aaa7da64d9bc28d00f9f44c7fc8a7ee5273f81f3ec71ae9c6cda006f6edcfad2f929d89feae9620655db9dbaa90e5381c19ff2baa7198fe52c871229e231294422f9444f3ce88cb0a203fcf7155a2e5500b0b6ce55069025ad732c902093542a68b56364817fb9f8d1825f83904e2d7cfffac16de3292bd5652484fe634835ffaeeb26350c42ed084ab80852a6ba626e1da2e0377993194d0e994c4906c632294077841bb3281f54e232262783d6efdc1fdc4e59dd8c2cb408dca53a38788221e853468f665ee41a9364f305a44f210f0dc0713044591f32c6d97809beaeec0a3c4a63584e28e8022c995221d3223de94885c9258f33b0f0f62623a6e1a1ba1e2b5cb8d3e85486f063590d6f1ec5e946334e52673af60ce6cd0a98506a59afad8721542f81869b11378b87e4c8dad522764272e4b4c1a7a2693496b6ee3d6600c38439a60a9bc2869ad57e1645a551cc2207ac2a559df57cd69990ce7b628c7f49959dd9d0bcd545d900e641811f0c04f95971281e101b84e7202909e6a88836a42c267890708097d4fb78f72e1e54d86c7b7b05e07b9360fa0a57dc63cfac7863c982d59c89d12103b41ac24fe8e8eb905b488ce58b684ff3f95cf4d0d36740b8a8d454029744b9417e326acef50c4fb13e21b0e548fb5146400250122bdadeb1ddb00b11e8bf9bdff64ae1ad5637d3691512dcd126cfe68e8a9cb994001637dde99d57127a65fd5e465fcc8cc7a458a7eb17be302421aa8ef90a6fdbef7df21fb1badc3d01e5ebd736c14ac865810c0ffa2662e849a9151527731b06420c1772a78d89e1f8dded4cd601509fdb39ca9cd0a497d0390cfdedd45c6f812c6beca004aa0096d14194359f06d24980f3ede665d25292bbd40b04a576b34901e2792fbef6357659a31d421d29dfbf57ec4b38086ea3cc5b1b3f9ab483e92fd789b7f1a495e5aa3b9036898056c19f6147922819888e93fe4246e502c4434648a4008e92ccabdcafc4287b14233eb74bc7a2b311896e302a0f82e99a984b0846378125b4b3c79038c02d7226acaaca4c250c2c3c7a59872491292fb6acb68cff782d60a2cc1c2a7b9a1ee4f1320cde88290996f1db0b2f1f7bee8a5d1a3c93eae61a2d1ab00f1d0efa46a39e90a602ec9f5cf40b61b197ea8ce2d6dbd26eed10203ffd25a90faa0e9e63524ecabbd89ccbf7c09248dd9d817117c6f2d0568936b1ff43cd491cdfc0af56cbc63bd6c390f2d11a852408242c29b92add64b4d440f480bc264fa3ba46f7d47aa2932d0404671f4d9f75b209f2731aa6c45887bec9cd085a716c2705e9243b80190aa988c142f752f2108530ddd610e754af3b7a11db8481467b0c96dd2497af896a9c8abcaab5d7ab897ed1e27c18e043ee733a74bbc7ee2becc8ca8c2e47c46cdf0c47d39dc921ea86da7986fc2203e8240583c7ad615e87658f493c6a8816f22f5eda7e7376b4fd3ec7a0b35f143997a14223644ccfa0cafe6fff1570c105befde3f539321f32011adfa9706c34f1338671409f25a799f4541a672b2e7d2a4a1478fa4cec808a385eeb93a4ac82f76c8186e8685fcfa368462daefac4b51678dc526e5f95d9a5c6a5dba8d356f031b5a1d8f7fc8706485c07f98a4be75613041c54a020657e8062cd264407cf72d27ade5afe7efbfda0a71235387657f3d3a9e03e00eff0b9cab643b89609b172d1de3a693cbb3956bb4dbf3033b519c520b09d5c4d36082b26ff9c0a5afcf1879a0ca0d8448a487bd997480cbb6b952caa8aebaf94db13dc943ed15bf835d80785a45a7b0745308cace7e6e013278fe6175b0d15394d1fc85861f078b2dbf0e367df8a8efba5630cfe88912bf46fe94c2f24cbe420017e3812c6a2dec3cc5f9b777ec967452924cd298b26ca5b061abdb8cbe48b3a32d84dd59556bc02408bc23bd4c81f66269a3d3c2ebff71977d1d971c3eba9f85e2388e0e42c1355fcbf3afcb94e9cd1dcb1d984d0c36b61446b19a3caaf2962108d24ef888056515f3837fae07165c6924b7551e7a4a7602a308cde9223178bd1083988e6c605425148babc144d201f66672fe66e8755773f72b8fb8f7c278694329481e4c479ed10883396c97734c4d790fdb73dc77270962493bdd02ac77fdf4e30e06faf1a1fc27988f50f2d2c5c135656772f98f31c15a8ec276dcdc91d09bdf458e973c623073a75f346cf984a897a6af92668d13def647ba9e8c6ef8eae9c3900fb02d4e5f5497d3666c97bb8cf00a113696930bc36e376fedab295af337b88f64f606d21bf5c3aae27e7a4f4bc47bb9a88e61750f77df7a3b5156d71b5391f3f89c416930b42b059e16adf880e1385dcb1ac58311a13814c7e23de911834acbbff8a69d079aa5c378c8ac154e00ba29f52ee073ec2ee4dcc9ab5f02e2a72f850b081aa80cc1a4b2508123d44ab1b8a1d9f7cbc89dad0d7709f0fd195bce6fa44a11508b59effde5f4db4f40aef663219c4dcc62571728785a9bb769a2d32c001debf3f40a87b973344d7140ad8f15e84efb5e8016fe6e6c91b1c4e4cdde2aba7599df8cd8b875238115fa147188083e433cbc1a6eed8ae2b08fc73f56fb0a041dc8be46a388d037a59c059aabc6ef3b00fe32bbede166017e4e032c5fd9aaee00070b84ae46a8c6068ff356fc21d303e279e2dc3e6af88a50f2d14d16520610eaada529d8216d681fcdd623de40a40f0c00fecaed676209d8cc628df12428e98619d50d54b9f2c944d72122c61eccc5614b94aca78075090378aed120f005bdf2bc12ddf3a6e89d72ffa6e04b720221ea137c8e79969de1a9997422cafc155febf7e5350723317a43dbfa83e575fbafc0c0072c8c3d10245e5e876254a0fee8a8c3620fdb46af4753f705359146c6b28c4026aa42075f42d660b7f396fceb4916eab9f15fb7701d2547561b7b654a97914baac49fa1c9b85644ec474ae337dec9d5f4f273c053e885a0a4befd9f270568fb8790d35480c606a86e73e706efb11c6c6883b63339664cf5a209185d7990fed0909611c64fcbaed94f84ece25becb636fb297cdbe1a1e7337b787188a7b4ba891c969c8a525fc06f29022eceebe3f8f2f5a1a0992cbc4cbebb160c4ea205c81fe7be59ce119a4f174a37dad21f85d1bffc47f31d048cbbc85cbf2c23539fe828d62045d0968a405a041ab5607ad270e02625bde3afbbf3f25674533e4b35be5260a6a3d5959444113eea72936e30c437979996d6893088260d899d7d0bd5e111c6ab2e60d182af7b3170e42b8d0a32e7898a2b62396d698dcaebf24a9eb276f20ff62cf74a81bada095add9c4ca7cc6aca83f7e496503a533586cbfd89af21d6ab90e7e1766851027b2109e129e8376725ce643b5bdd2a5c6f5dcee14df5a3ca598563b609a733a05b79728972928e8fb74f653156041a15731351c0ec42e416a868d80c81290962db60178b434f336cc10e9c3dbfb51aab6ebeb97ea3bac4497fa5f88500017ff7255454165ec5ef75bc31133e8283413f0e69574a0135636701a7e1495e2e3d30f9d153984be33aff6b622b415d371d915d9cf99c47928e4412b5c18294443d033a586defcdcc4bd8ba4dbf284adf928a7b1b77855beedcd0034c2992691df6f5bcbbec7af238f56706456849ace01ab653e5ba15fc17516b20f391b3b5cfd1670cd0ef97be8d11f2de8d27fefbcc8e4845e3dae83f2ef8ce39e9a3f7814fa68a2b316508f81a6937ccc66f4efb5bb0d753ae9a24d8084bc4d176d8100c434bb08a66d3a924a542dc2c308a735cef29a708ab6f97d7be65c6756e07f7ac82ca26d000547c233c6d351a011050920482af3042013822c2760cd88078257826ef059ec75efd8117ca56c7716254b1cbbb8359d86c8cdf9c376cfb82dac3736328b20c1ff00598b5423205e8fb8dc0d042e3dec9add1e73d610c559d2c855c5fe531fb95763e57f4748b04c949734c773c5cbda1578d7ceb17e877a566ed8f22fd95b7a964e4bcd3a8dabc280b8e27159e0ac4f85877fae2ff805b2cb37282b2a9a25932902a4e725f91da959c3f25f047cc5c6a333d80b281ed2f2cf400d79974feaa553e6181689900cbd6ba730883d8898444973556d0ae4e58e950e0e42aa5ac21f9c4c3f0c29f00f3ab147e1120fce80fb7e09ca1fc1148cafa0893aeea6beddd1ed8b80f9d16de3d246ac263e3343f4ac3b46d3302e90ffecbcb3760f2379e220b123923e1a7c8a614566ac2e1d04fd1eb296df98c081f2d77548522be19785c3b2e19f447024cdabaf04674e7497db57a838f1eb11d32257d36e53fea896aced59cb90c8d3e1dae702f660b6a4f3fb6b3d48b04f44da147c3453beb5e12fd26121e94ada0ab487c57bba64096c850427d3fa0b58b13b656f388f5948df59c34385f6e2eec8f15d8aaf5fbd8a890cabe93b69f9469ca1e7fa92c7dacae6827e3c6f030c5c17cd3ec60d96cf5c254db6a741599278c8d4947ed6a9a7bb7f4cf7d688f867c510d9421e0cca1de714f4d8262afd9abbf1d9175692d6f9f92a399d2512c8fc4580cc5e2d98c32bb88d3673198b2519caabe2a9a6e2c6248346dc1b006293c2e6fa9aa48b915b137aae83a686b3c4a83163320f9164a2b57f95edf5cdab1130e604338783d46731dad62df81f59ad287d3b00957339b62f1eb42a22c5c29f29291dd0cca5a902c9b09d18b734f5daef5685fcef79cad883d607744a837241ee1f0b0109ea0c469f30c1652b33f95a15849e6ed1a9c5b550e8fe02e42457659e3f1659cf90adb59387e783f63baf339602b95cadcab7f0d8e353528ac5d1600892ea3066cc7d094f73380ba305de5d72209035c67045c66dda153cc1ae7d1e4c25c6bda008fda092d42b4eff9904a871bcf6d6202e726de94260eb642e2a170094ca42d4578a6ca05809876d975d6cb06f920bd86f29ce0b2b80a8c2adf0e4fcd2ab6c83fd1f2dd7dcc6d5689127e7c3c9390dde8f82548b5b3bcd62e15b1defc38001448b0c59f430b4082cde21994d4408ffee7dd2d6b6577f4486646c86ee128f6d4c27b62a397cebec8bfbcabbe6b9a8de829d7c6f48e84b6ba9e578876b17a4691110ba7b5a17d6ae409cc4d57357c2843d0c81057f996eb738993b7ecace4d05c47e3f1f81d6e61a0fc1c20d6bd8e38443b08784e33ab256fe7ff2d32fbabd1b12ad2630afd4567653f587f1018c757d0bc7beff70a0de0a09e694ff0b06148ed54e40e88c68b949e9d023eb68ebfde2c13cb5bd07615c309cc03026caf320605a91570f5e2cdd52e7d25055b463b92194ec606097e57cbc9d1963e44203355c906b6bf9c8f41620baa1e0aefbc1e12a90f6e57090203c1d3a0e96f099856d5cd46a702b542076a46f549a91ec63b41a6a4f550ea5b2541341cc09619c2a84ba9752d1fe13caa8b05be75566f829415a8db6e8dbd977b575c3f8b119acf5ffc93655161e586518017a96e1cf3e31ffc568345169a7ee7816ef3c2cec5deb2e9c84f4f15b790ea2f4e07b05b067ecc2f938a5c3e9a0e7d220f231007673038177eb7e137848e2ab1f7f29daf5bd96bc7f10e71e7fda161e3f3535164dc2625663e1ec0306ca39ff88e4f98318300f36a5f46778b77cbbb6143b72732937096aa86049711ba52d90221f0f2fa79a7abefd70af5f9077c8bc680b3aba92df5a124f6f3e008793ae62513551d59fe8292eca03d76dc42db36ccf64a9e65ed2d9bf0b4f7e00a09979b80533dfd697eacc56a84614be953901d60e2e3be9382221dc66ea9ccd63edb67a8a6873bf58de6f9e0cb3815dc510a5ed4bfd689ec73013cf2e189874687905d2ec563cbaaa68ff680ca1939532453c0baf610120e4f98b075b3957b432da13b7d0088c4ca735012bd22dd2adf14367f79ddf6c061f5f7caadbdb8889c82b6d9f7c8b15acdee6cb5b89eafee355b1d51db1efd5520dfcad72cc6b6d4a7c94509b161b33fdbd04aad8968013d673837891567848629cdbf5f1a9760eb730c3b38767b6ca0798cdb8e6fce09e426f1bb87e9dd30bf893abba8fa2873d18f7b1c487a7ad9eb83ab83b68a65ad9a03598e5e4a46de1d92eca0b227fcd8af5f2afc8c01097881052b1c14bd853a07870bcfb3ef4cf3389f6dc1b6958c194672d9e3d99e0f5c55a8d0bc22382d797cb731b9f4c16665d1dff324d5f2c735ebddbe4c6223ddb28594f21597ccc5ba06e6ecb3cd1886cffbca2a16f60bf7fea8c195d11202c057e65437bb84532f475805bb2a193da89e67fbeab6f5a7401a6b4f650691ec16ca062c14b9dd63ce27df2e7456e9c9463aee868159b030eff4ce3306d661704b82ae7c73253ff3a3b9e0b598e317fa2d35e618ce552f61d46f0d53055a462ab3c1a58ccf5c486c9bd67aeb0f0bec5e28b9a1839d73f7930f05c376c14bf0d8c1e96fa4a3e397e02c0a033ab71b0e3d02e9d2a9d58fd3f663ae46ef339874944dc1226b9d52bd63674f5bd1c68d6d2feb7e3790cc8186894586cf0e6950390ba053c724004bec081f23bd85b7f045c58d1299c21b4c0558370daa762d0d2e0a7c1dd32dc03420d276a2279658444d461c8462a3a97206f4b90cb3db6c918348cf6c59569bf2956bcf3d927c003a2c4107a20975549a5b80e60e5b3817298fff0e6a9ff3ac3a61b3efd094c734dcfb286b6592eefe892f29c070470a5eae3d4ea111768b4f025d78e1826b0562d1f53852848025d45ab0e5da6eafb60f23d7c705b7bef3a1a02bc772823bc1d5151830eb9e5fcc0db514a9376c05c840ce5b23df1efcad6ce9056f462904572d174476cae76049b05d39c39a16f05de2d5a61bc875dfa183235e79944962c218b0994dafbd49940e0eb23645a52e319a231fb8ae528dbd6fbc67272d5c5f67bfa1a34ba49526914fa6c945daf457e935a526eba095860b5a1190fab9dda9d343e499eea3f362c085b82b66d30bb37838efb3a9a27b5474dc1ab7d751afba31f582c727c5c7a28ad4231567bb1e7859a5c6d11fcc86811c7b2018a33fee6b44d7ab867296517cd2bc18df67bee4f0bab718563c21439d1714eca4b978d2a2b9ea12457761ee29c92e183fa9b219d0248bf90553aebaf71b2bd8799997a593a2114bf6f1d8ef5e031267e4be81c1e4d1a0b5a3616c5dd81e5ef0ffe8f554dc9c3b26324218f91f57edad3920707d55866e945cd342e0b01446397b63b2aa5fd1e04a95ba7db4bb2aa30046def252c7dcb71fe5dd2aa81c2a3ca96013953c1da07ed317b005cde745183c9d9fdaede91b69fc543c3eebdb1dbf5df993f22309d5fd6ee736602313d7fb7c345d48961b626b5d1ff7100be011a5387c5c51bb90304b715f61ab894f83935502f3c5817bea20befc545908d3d20fe845b1485e770ae06cd9b86eef0b2d36cb4463ac33a668cecd09b3fac3e562fc019e9105720b7c561e84dbf028ae41344155c8f8b8e41eaae45a44375cb01405a92d8188aa64ac6bbcba64d1809e039d7630acd783cf26bf0dca2a66297ffe8223cc68cb153908424672436c61932900c47691fe91fcaa47343cfbe6afc5c638863f88c8f4833c86c2a973ec7a686f2183f4b954682de072aa39cdea76ec66ee365ab463f6483e4e6ba171af28e0725a92013a43623207d9cf0eff379adbec8b0d90233b7278227f8761a15955b72d0e2b3ffac857cac64f949271f87b7c30f2fc91a51cada4cb2f94ab8a8a62c34b097b62368a87d808444ecd638ffc162bcf46c52edeb02c76c9730dba2971aa0578f724177aa5e7705e61b1c56c6db121ad00cd3a5dd68585d7b8d3b671bb60045c46cc78c50342de6515d769d579850ebfb889cbd9d4bbfeeace6efaeffe02831d2c764ba593077f1874da00f97d9389cfb7311fe9a36b1b2cf7374764892e7bb0a04869ba51e75b2a95670bf9cbc02acd0ef08be4b9878f8e9e37967bd5f53b313ae2a57a8b4e3ac5de74c95c4732921a4f1fee360400616a81363cfa00dcf4e70900a0dfd3ac445855735ea76e581777ba1bb29e87cef13126dc839dbee82626b4fd05d91c66279f627f9d608c7ea857408cb33da29967d8d25b4e1c22df53f0424ecbc29a654c565b1e60b9701bb14bfe68b290b2e789ee5603555c594067bbc2112087347fd1eca2007e9d92e9d98e442759941ed096d74487687f206b80dc68db2a723ddc0634d7410a27221ab6d1694c6a6b3af496254e225fc93f7ba9e757c2b6bcd21cc268b4e3e9969795a2a212f69d61cdef90f0fc8d95b0b21002da456f3c1897979f1a7a3b415508b14d60d044ea271423d1fe1aebefdb243ec0a28e3b03d047411d587d4c806152a55d8bf5f6b7613a96663f0363e59039fc36711bf03355af98293d7f3551c52d08c4a847f61bb2374853d32008d765fa33db72fbb0d7a7e1c216e30bf385be43f21fa82d761c3b4a95fec8dc89d478c8d8472511da379507367d3c21bd3e59498a47f5829a095f304e491eefb992bd0fcbe3424716b89b8c0dda5cd3a58f0b29db411b41afe952c4c3fbf20d288832d5387e1d7072f8d4267d646e13f7f7a83b6d904b9e64a5f454da9e3a400a5f14d931ea624c6c722564baa89527a9766d267415a97da4db449ec2da3c7a9433ef27df872e5d0079741daa19ee0da40895fd670c63a45940d33bd84bbca8db417d50027d7f722b0db32966e5181f222cfcab8f70958defb6134b2d07a53b4cf3068683241dc0bb6be7f75b3fcc2ffda7e69049dcea259459326f754b749edfe8f3b47ab88662d536a042ef0b2a851035d93aa934e7bc96057ac179f8623ad74127d5db6030c3c5423ca58300ff6ac1baa4f2fff530700b55886026b9a2ca2adb4e0940a404c4a7c3cdd80895381f2d906ff8d469b4babe285dfb7fd35c426e4d752363b50178ba5e31783c62fac458c76ff41a3c2fea80a62dcb989d705eda80d92892a4d7ad4d226e9a8c37decbbf6d0bc36ca3b7f468c9dc346c14e9ceacabaac9e208d8f3c834d415f2eb5deced8299403c31c5a00eb457aba363a83e679a93f664d4dfa814170bbe3f5f9685e7ec5601f2f2dcfcec7afa71f26f26fd4e4d50df9292941e42c9e1536385392a6ca968617f2d44001bf556b0cbecd9e7c716f9f5a34c682b4e36608c85f4584634d13eae752d190a98279b1dce90e9bb8d66ca8a46f8147f20190732de96ae68cdf4c60668b7e84b4d1a691c9df438472d564d286befb801ec3bee1ecf2cdb6fbc23bac6a0a94f5d7383c083dd6751ae022b2c95835ace9177be3980fb6ffc808dbdd38a6fcab66e2057aed18ede592303fde8c6e20d508cca2987fa8cdeb9d73bf4d15cd8bac4fbe63b23d47b228eab480c6fdfaee0c9beb7005db41fc0fadf69e789bbc356145abcba6c14f309890d1a4e80d57cea97daaa994855daa8eba4245f76e5a614042d13d09279cab32c7552f0e30ec1b958ee29f1b4d18ec3c793c56c33b0915c540a93806338c4339a3e1f032874205e6f05efe98002fdec7d4a080c833444dd5ff3087c9464d1a6d6f4c4a124354ae9a17954b2e6cfc63ea7fb2d0b6676e496de4f692749fd9ee047353fc6b3d92befd0b99f60c0daf0bf66651bcf7b689d68bc8dbe50af7e45e233bb7e60627a99100bb9d71ca7388fc124f03e90c00db42c7d852a376bcd9693644c1594a5d589886c65a3869a8fdd6b5003443c3f425a9075abbfeea562bf7ff7bad3b88a0c87995d98244d26715a74e3e06328f01f6c673ae8dd150c51e6629f765d4f8aa77bde6e7285363c7d126bcd2a3eb03bcfb47157e4dbf0ab4ed258fd597b90bc98ec1f6868d8eda405d28d8412622e98053c7f8bf3b66dcdf2a1c9385db23291b075985e2edbb35e4ac16bd672cba3ee697e15040562bc0bac4f909002d04ee8ed13764ca58f074ec49c2349dc53d76acdc34325d76226cb13801cc2335ea996ccaf41e9739c239b1ed0e4fa785a8ae85027aa9324fed7d7cf7fb1750ad11e7a7720d12d0db9c09f310cd887266dc62f103c15a6e2e16f1f3085c2d49bd570520393fb9a2ec4e54100268edce9f2bf011d3b8a7b3bd49031a1672399a5dbc9aa72027f6247941fd9ff6f83ae2ba9687c704dbbf0d834db1b213488fce0cab10f621272b4f2c3dfb69b57f953b7193df3b41b2df00c197bf3824263653110c32dad20cac3c23c3c67b52fd01006ce6b788301405bcb10c1a203cb048e87b7c831fd9d28381c37a9616b6d0cbd952a057d0252c3953382f0a6971500c9348dba45a2e8c2027721259bb434d81b6002f992bac1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="请 输 入 阅 读 密 码.">请 输 入 阅 读 密 码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">本文主要记录近期开发相关的学习计划。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="加密博客" scheme="https://www.techgrow.cn/tags/%E5%8A%A0%E5%AF%86%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>近期开发计划</title>
    <link href="https://www.techgrow.cn/posts/29d74d90.html"/>
    <id>https://www.techgrow.cn/posts/29d74d90.html</id>
    <published>2024-01-02T14:38:21.000Z</published>
    <updated>2024-02-05T14:38:21.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误, 请重新输入." data-whm="文章校验失败, 但不影响阅读解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7aa038b85c2e84e72ab1db689533070f5573ed05f84a9c955d7977b52ef5538e">4cfab7e4fdfd9afdbf1592f9652b8a199f3cb3b67d053a3a2b7db0e886465ca1ea14179f28e40c4d184809b24d2f909058d2606747febc969140bf1db3dbbb1a7542b98eb3d7de26ec2c86ec81828b35913853b3ca6e01e7cdd106a9462dcbff705b54ac505b28447538b61c3ec4400b8cb84079a99816fe59006d71ef364f10dfb4d6a52fa3c40030b50b35a957f58eeaf772e9c44236a3270411d3be05e2b07d30b9bac2b2c9e4a597c4d551dde647547269d613d69e329a68cd1dcba6a2bae36bd33e5e11d2a5d518899e43e6fbe0524ed9b9c309564739dcbd3851cc07f0cf45fdf977054a7183a76498682d3bcbe26762ba095458de76d41fd18e8353e46f9e6a744945ca97a1e13148bb3f9423d01ee13a6b4834facb1fd3008b9bc0b23815838f409203118497fae9e3c50332fdcc1f781ba863ad73325b42ab0feec4ff52515efcaae7b170dbd491c656284a85ddf836e73fcccf8e7ca5401292a93019511a0678c1a62a4f9d524748fa16eb444d4ba9b9709af6db0fd8358faffb7d0c03a8d01f503646851d8ec0c9f69f5e075714dcc796357f1870f6f0dca899a9bf358860381dd91e102a52d8499852d404fc84364601414cf25f113952a4e8453feca610d559c44f8a12d16bfedd77987b81e1710f415778084a5bb8f4a5c6c2aab5f7ed9a2212789eea24995e31f21d19c0f60d3d46829a35a209ad5a64ba59a81bdcf152f450d14cd1a48d46a1387566700476d2ecdb9d8353d4cbf63e855586f66ae706f65dc4955184b9a65a836128c63f24689bd56daa7a178ce5757d9d01dc84779600b82e6a988dab8b740a61c2ff52336f31143d91d739de64ac0009731caf857040616087028acc4ed0f44ce7db4b06867cc89fbeb38e768587f29842144388051bf5a9d0e6d50c34f302fd7baa802f9f9c168ffda3ebac1d2050694c4497144e66768873510e3bd1c5331c36ce81277ca2b8b28a332997ea2d4a0c033d8734e7f53a93fd0f7d93befa1e2ca440424342540b5fb5dafb58bae19439fc52008da933c4ab1c09c9397180751c729410b4e33e4b42e2ca464123092a013681dc189d3c6c9b568c9ef209dd27aa322816b62fdb4d438cbb725b076f448c90ab1226f482c58e4a439618e5544ad0b035ece5da84f39b6e91cc187ad85bba9ad3d1df678e401029e9de1b70b3eb57536d7dd879dfcf8c3e624a38256e95a99af821624daa673e38bd8747b26b94d5348d0d27779b447f343f87368acb8e537276216e2e5e6561d9ccaa46b82bd680bce7c4f4cc56d82439b2024cb26c26c284a9d8f5ce24f35b52d335f8b62fc257b04b8ebac321d9785d90e835961fd2c723e3eaf1e9e9f98ee5db63e0521cac3e574a777bb5f1b4b5dbb8ba3d93a4168cc2dfcc0b9a0ae2442d97a01fa711ef780b41f63d893f1f9f6e88ed61953c66ef74636546b60e5f3b74dedf7826adb9aafc045a4d081cc0c6c46f7d99ecc3ac20e73e1b55a401ba5aa22f530c892de0f7961c766fc616288952010e6da9b886d01b932b09af54700ca58efd3d810c1b6e44c3d4f523cd5bf484023309b809e90de2882acb79c237a7a53594e54cd663039a5c74d97b93a5552c24ef2db394e2bca465056620ea92087125ac05f012fe376adaad2684a73e829406a0537e0c721990efafb49abc2d2573fef95878899b9b3bc40aebb4dacfc78dedfe5f8c510f95fc8cb0c645e44a85a438a33e3abfae5b91404b5baaa760e533120ae51b8a1b45d03db0bb7de2afeb3c68cd14915e3aa2cf82d4006b4925c5c061e4e67f779c38b0398feb23efe1b4af81aa7c13957cee35779cb2baf9aaef4eb0074ba9856601131144f3f32b06b8576ebaeaea8467d965e248dec371e7458f974280e534d7df0ed9d0bd01e8d8c8699fab51b573418372ce4c097c62b155d034eab1fb62d37e66d1931e99c8c49eff493573b2f81085af4de971a5b6c8798d3aae32abc0058307e4eacb6d4c20a714d8025ef4a7aabca790b41248b65894b64b5844136de8c10b9a51a96137dfdae9fbe2f8aa1bec41ec1b99bd9e00772946d236131f0e967f002172ee52b95cd5294ee434c95d941684c440616e2d692c46ce12482b1b975fea4822b6c403a9044b94723fb0f8c340d69c4280cdc99c7ad5bfd27a961d195ab077396fb346fbf60a83f70fd162efc7dea1b6b0aab01b08a18fd862d646ecee92cc5b4aac63b70a87e5374a6b2ad3732c63be3b7fec49225659ec8661145100469d3368056e1c5059b25129d28f297492af8aa0d955560b368ccaf6da9b4b74726223aa8713bc5d07c0683dec0ecdd18c1eb5758f6c9fb7f2b378bb0f0e9158c5b1f4e9965ea2dd715b871e0a4b17b315e9212509bb190ba53daefac614109d530a6c6a72a403193252f64cde247028c19e65b05e2aa5a628efed935c6ac9c288ea9b946bebbcfea053b7abf03b3fa9a8bbf594f4a364281fdddbb6404a71011f4bf85ad4eb9042d591b74b9b827ef705ea7fb47c6503cba8dd79b7d1a33e8e3a15bb2d8e2ca8a36eb685c94b2d78215b71c98b2c0b3ee37e035bafbbafef30c0983a823efe8e7117435dd296db8e79ee3f3a744a2538dfde388f61d0a6d130734c4e44be686c870afdb7a1caa863bdabc994fce857ebf7972073d4426ebf9405f5926b4a25db7461119b55bd9ec4bd07931eb8c7d447e022e17a2df094a1dc00dcacd1fc064f1054276eed105893619605c48d576be245c5b87c97301e98a03f4e7214bb91ccb684917f6d96f2fd3488a7eca5ee845751e15fa94e41092d5e55efeab282dcdd9e11323b8a3946b92b5a59100d1e1491e329296363557a9af9262b745f52b40442e617efb7736c99a740dca8af13ebddcd673eb4a534f72e933973592758b63bbd367081a651b5caa7693a2a0ebda3c9f381a2ba519351c4c1d716001a1848bdd3202c31f564397ceb9eb3e4e70041673ccfaa66bd757cea040a014a4391e18d126faec37a2ee964edd824d8c5d2de2c3ead3f410961b608cad747e2bc14687da33756d6de87cc5f8dff3547d7e63964d64eafa0cb410cf2690800747f38b1a7921cfb554ea6bfff93e4207b42461762ef62c1bdc669e1899d1bb55eacf78d9996258735b9a96d7632068e0736297bda947ac28572609247d9f0e1c88c57b891ae7e97a36b4332161e91c23a37f07780aeb2ec85d85e9dea91110a395c7b162dcc3995b684d10eb28d8c55aa78a45b50171f6b23658357003d77d76c00f69027d812e5a3278649dd7f510af0d5eb652abdc305daab3743709e2dad44b171ddc5be2200541a923d4fb3b83785916e92604a89b9f17fc4b838abb234a80e9e037601fc00ef31188b3464ae33435dfb10ab5c973090ac8f01badd332ec2e904e605cc4a3385be2648132d8718fa5f8fb37c035144517ab367a704133c9644c5d1dbcccd2cb46bf88d63527a0116c8282a3f90f9c7a142d29ee89e95e272aa7063df9143ab4ddba067e8d9fb8e84e1ed83e648e0d238ee55f89ac10c0d62477d0f7c123e9c3d88d6e94e2fdc0b162ac345a16e8a23a0c02f82b4e358a37eca0f550842074acdf047d912df3390745af62d280f49d6292bf2f2c09c0a824f6b8636cdb1638a362e2652aea98475ad25b689189ed0940d539736cadb54cb971531dd44ccb04dc1ae651569af62e117d836931dca4e0895fd6eeb4bca0d59f7c421dbe4e44b4cb69b59b67356219451c11b8d7dd5bf20e013a1ffe68d983d1f722c28bc1d7919d49391c48bf1f7ad94a8950d4cc574db236fdd0bae29273aff2931b6b0b981d3e8b6031c1e6f29a5bc4bbd788723eb8b77b8d311fbf17f848d7709988df6130a9050950aa3dea53fee05c55ce0129f5d50dc4bb80243fd3dcfd8ea416b51808c78d2b2a48f9295cb0c48d850f4d9ea9754f770976bcf621dd13892580768a72d15472a8cdc8025628dfbd380c5be7a4f9d36dc72cc0a5a5281119618c23394885a86b6e0fcf909f2fe8964b41f729a21ea6fe351b1057ae08b3e1afc0d3ef3e0a8e6ea83f57ffcf9269dcd4e5a25369630477074a1243e17561171b83664124025196b8581d3daacf8bf6630fe9bc0026fd074b6661e53781f90a757827dff0df9294f141d088c3209794d875c4fac17e0d476f8a760608d272c6e44cb59ba224e27b2df0bf92d167b9c88d7654110876536879bd3fff1db399662dbbe65bb8451b63dfefba2c0cc6511f4d0bd7135cd679d571b0f8278fb6d16883a843ac8feef8a31fe0484d3a70ae7e9e264437e831c618323b273e75b07cc94a4942b7abee0e629f1d1afefdff8bb8d1e92b9d256a9b8270f7ed297bae1cecd45422e80e518f7911d1a0fd78b969d016e08d330fa115d88ce949c137b9cd4f094428fdb499bf6d554a1bf5a89e15cff3a2ca75b42c4e45593dec554558a68993f38206a93ed9f0108dda3554077915127d450d5517f8b63e2274614f61f8df13b408a990f9946d710005fe09a1ee277c47cf38c4358e2d3263791a611a975c8d10ab60b427b5cb5a8551f564bbf59daab665729f836398fdf8dead68c8a2f6c540a3b70fbac21f8730386c18d0e24212731760555c6f60b23e4bc8054b59868ff124046064aedb65b38d9c17f7cffe6efe3c9dbc79f95771675913101fecb789a17a362750f9d1d3f23d0293554e9a5364a3f57a57f33924e50a836a1e448f0074c7c1d99a42bfb695109fdd3462da7fe1c0f953a6028ba576dc5f0bd3b8b69782888a326b4c23d48d9ef531ff8a74cc96f7ae17b926bb76e45598d4f4d186485d107985561cbc8f7eb5361ea6ea16dabfa2506c0bf67b316d547735432ae0c1d549c359d932b3866f0d366c9be1ded3c3073af4943144b8f8f5a81a51e9ed6a812b6bfe57c9288a01360741989c98f4a5f814da3bf74171fa964c630020d35fe88e46467f9dd37c0bcdd9c54ad21b5630df463bcffdc9b5086439fbd90cd5feebd21fbf19858a0bff3f959cf4c8aa546625becce865924cbca2047d82cb3451a2054d8896936256978eab4d6708896210809c05f87d4a1f6412ea838e6a22ae451e61c7a0cc0d15dca8897b8c04e8a8f9555ab8c26f8bea71412c44ee056cb8b1be5878d616b5127f581ea01974ac9e8765f48a3d2291685f878cfe2c710c1224aea84f4544b60fe75e20747ea69d919e5438ee2c46f09a3a829a33f8d344cdba5a0d4f8a6be912ee9dc2073e64ca73bb6cf8a18df311c05c8e1cadff10de8bf4284b4195c05729b5daa7d27077042fc43e20b4aa2271d673cfab972be594036dd6add32bfdd752066ba423c74fc701ef431b52eef8908df6526566f8f3e9662dc00f198ee669d37676b2a538b5ca4299f8e982cae65320161f6e43f38a25115091bed6696b1f2d7b2cc5e0199ffb5dbee9b63f219e1ba13da38735677e30cf4336cd8656efac6dc6afade3773ba1104d218d8f3b2020835336c8d7ac1e15e5ce10dc5811c6f52efb493fc5e4dc69304e44b4f753d9e3beebe013acea970a32144a91e53f2049b786e68389162b6337a4bb41e367c15389458e1af8ac7da2d943bd7ca97c8a3b17ce7538b095f15a86b6159e68709b65e196b5d4b44cf844bc6176a4b8ef844464f3987a211a93e24dfa199f8f34b19166e626cce8c8e9dbc116b0fcb62c4cd88b4aeeb0119b76eb38f624cd9b8a1cbfd5f43214f8f45034aeed30c89435f44bdfcd2adf832089f9716f02808677410dad61df3da105822adec82a11bf601a2b14289cbf8fce26b01ae6802dfcd8d0592027b83135734e4147bb453814b708231a72d6d12a58022dc7c8e546fc90f95b6102c5d650925e9613efa2b7a520ffb62bc526cd6602b6d30178ca55c18efc7b058c64d9c3f199390f507c18429710b5d52cf5a3fc655e2eb7688c11df912756dd978dd262293f702824caf505fcd6e551ceef8282d230e2768a63457ecadd3a7f8597dbf914ac64e1235003b652037d5045dddec13e1e31192cbd3072744e593e4f2bb49b136ada88e09ba5576ce8d38e8335f8f4f3290dd837de1c8a51e3acb0877936f072366c1151dc70033c28816f6e9a6efc83ad3425f88f78d62ce100cb5a7723f24374567f5653c46cb8323c69571aa468834974110f5dc82a30875bab673be32e95062212ff48ee5e856672f35710fcefcf29362ea983f223d5ca3d01789ff6450a19f93a521acdb652884c351c56f222a03e9c49e45319c9942d717c30101654f3c51031bb677fbcd5a7a4355c62ccb933b7ce3c3611dfb12234b152bcc270d5d3a57f6ce3bfa9a910f4ff1e2799dcfea466e5ac7f9365acc05ac0c2e9edfa3d0b8f084b5f402dbc4f9941cdbcb8ccf46e1776333e5a2bb6df995be4e3b87f10ec5bb4f04c538d087fc9f5dbc9eb683f1971e53016afc07fa5ecaf402068e19b7b2029215d7b8b2defef4a172968a7ab3dee2cb19cef50825e0e915ebd73dbec0cce52d1944e6aad535af0957f425d5ffe17d51638f241ff13bebb8f1358333bd5f1c9e9d9a560611cfd917e14b53e2a5d653980f581504b29f6ead070e64230ab9dae5410176b8744855e1c165235bffa9b3460dc763afca48d7c41aa892fcf38cf6b3d20ba7a20dad3f604894d404d83e74dcae2f9144843c1a81d6767f55ad82c55b3556d81301baf67529a1de8b33b18822c2a7338059682b196ec7eba1a3baf268ec6869f127437ee6d6ef4a5c518b40523e0674e0ffbf1917dc5ca27deeef6d41a6600b1193e0f0ebe6bd93d6b1bea9943617596c4726e9d9f3aa7cbab91c5a9fc9049c84b4bb9ea41d0c6f1cdfe3f72b1a03ce13344e61e9f8b1f19311d9a7d907243ed69be76f6331fa81f69b09b7533748d7b2a05c9f1474e014c06436d960c68263dd2b6901762151d628e06526bf38fda01d348277169cca7394c10737bce7df1a1336c517683f6a905f0e2bf5e0f9bdea98c4ac933345fc74560d88c4ecd2f4776ffec9b599d5b4366a2dcbf9e8ba78fd2f258141e900ad8f3de5c491595fedb26fd1a4fd4bc88de3735c0390ab8bfd211cde9f6575fdfe227bd67e9cff80241f75cd27bf2d549bb4c03d5887becd8345bee94b40770f09678175698a3d67bf8afaeecdcd2ac2a7e1a9db5fdc81b837cf76b964fdca7c35e527a41f3c32be359c4ad173df3085b78986b28100865a760d7ff0fb80d93eb470a57e9a1667d64c576da0898479cc8f54b74b2c895289fc321081df00400a686d75a116754ea4cb29ce5b6e5917cd7db174df72c4f7cc5ceca1e0b53cdce9779ad6bd511c31e7d5bb73b8f0cb2452b0f4f7d1bf73740aa1806ab113df1c82901d59db26690a388a3d17be3bc88c880cb92501e2dfdd76d1681c7e30a34e4469f06b67670cf626da64b3bdc160c82d4f4427217e1bb3baac2f6004ffe4f8da116e1336eb2c217957defd6c15af86195715fc5ac9132d339e754d00b308fd090316c37439e743277ab213484e5a68f4fcb2c65be736e26fda553648ba748f1a17b21001bfd5f02d54d395b50dc4ed81302c5cedd11bd5d9b75ba57cfe4a358a0ad3ca5e1952d402c72a7647322c931a2d913bb537d331ac1858694a7611d07e5154783d6d1c18efe984d82294203c3278d59f5d6a524e295ecc6120714350b9989be5c49fce14982491cd3ad781bedbd82e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="请 输 入 阅 读 密 码.">请 输 入 阅 读 密 码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">本文主要记录近期的近期开发计划。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="加密博客" scheme="https://www.techgrow.cn/tags/%E5%8A%A0%E5%AF%86%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Docker 搭建 Kafka 集群</title>
    <link href="https://www.techgrow.cn/posts/d2c9b56d.html"/>
    <id>https://www.techgrow.cn/posts/d2c9b56d.html</id>
    <published>2023-12-19T14:13:45.000Z</published>
    <updated>2023-12-19T14:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->]]></content>
    
    
    <summary type="html">本文主要介绍如何使用 Docker 搭建 Kafka 集群。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Qt 各版本官方下载地址</title>
    <link href="https://www.techgrow.cn/posts/5bd27ea.html"/>
    <id>https://www.techgrow.cn/posts/5bd27ea.html</id>
    <published>2023-12-04T13:55:33.000Z</published>
    <updated>2023-12-04T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 Qt <code>5.15</code> 开始，Qt 的开源版本只支持在线安装，不再提供离线安装包。使用在线安装器可以安装 Qt <code>5.9</code> 之后 Qt <code>5</code> 和 Qt <code>6</code> 的各个子版本。</p><div class="admonition note"><p class="admonition-title">Qt 的长期技术支持版本</p><ul><li>Qt 6 发布后，Qt 5 仍然在更新，Qt 5 系列的最后一个长期技术支持版本是 <code>5.15</code>。</li><li>Qt 6 系列的第一个长期技术支持版本是 <code>6.2</code>，包含了 Qt 框架中的所有模块。</li></ul></div><h2 id="官方下载地址"><a href="#官方下载地址" class="headerlink" title="官方下载地址"></a>官方下载地址</h2><ul><li><a href="http://download.qt.io/">Qt 相关下载大全</a></li><li><a href="https://download.qt.io/archive/online_installers/">在线安装器的下载地址</a></li><li><a href="http://download.qt.io/archive/qtcreator/">Qt Creator 各个版本的下载地址</a></li><li><a href="http://download.qt.io/archive/vsaddin/">Qt VS 开发插件各个版本的下载地址</a></li></ul><span id="more"></span><h2 id="Qt-官方资源下载（较慢）"><a href="#Qt-官方资源下载（较慢）" class="headerlink" title="Qt 官方资源下载（较慢）"></a>Qt 官方资源下载（较慢）</h2><blockquote><p>Qt 官方有一个专门的资源下载网站，所有的开发环境和相关工具都可以从这里下载，具体地址是：<code>http://download.qt.io/</code></p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-1.png"></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td> archive</td><td> 各种 Qt 开发工具安装包，新旧都有（可以下载 Qt 开发环境和源代码）。</td></tr><tr><td>community_releases</td><td> 社区定制的 Qt 库，Tizen 版 Qt 以及 Qt 附加源码包。</td></tr><tr><td>development_releases</td><td> 开发版，有新的和旧的不稳定版本，在 Qt 开发过程中的非正式版本。</td></tr><tr><td>learning</td><td> 有学习 Qt 的文档教程和示范视频。</td></tr><tr><td>ministro</td><td> 迷你版，目前是针对 Android 的版本。</td></tr><tr><td>official_releases</td><td> 正式发布版，即最新稳定版的 Qt 库和开发工具（可以下载 Qt 开发环境和源代码）。</td></tr><tr><td>online</td><td>Qt 在线资源。</td></tr><tr><td>snapshots</td><td> 预览版，最新的开发测试中的 Qt 库和开发工具。</td></tr></tbody></table><blockquote><p><code>archive</code> 和 <code>official_releases</code> 两个目录都有最新的 Qt 开发环境安装包，这里以 <code>archive</code> 目录里的内容为例来说明。点击进入 <code>archive</code> 目录，会看到多个子目录：</p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-2.png"></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td> vsaddin</td><td>Qt 针对 Visual Studio 集成的插件。</td></tr><tr><td>qtcreator</td><td>Qt 官方的集成开发工具。</td></tr><tr><td>qt</td><td>Qt 开发环境的下载目录。</td></tr><tr><td>online_installers</td><td> 在线安装器，国内用户的下载速度较慢。</td></tr><tr><td>additional_libraries</td><td>QT 框架的一些附加模块。</td></tr></tbody></table><blockquote><p>再进入 <code>qt</code> 子目录 ，会看到所有的 Qt 版本，从 <code>1.0</code> 到目前的 <code>6.6</code></p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-3.png"></p><blockquote><p>进入 <code>6.6</code> 目录，会看到各种子版本</p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-4.png"></p><blockquote><p>进入 <code>6.6.1</code> 子版本，会看到多个目录</p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-5.png"></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td> submodules</td><td>Qt 各个子模块的源码包</td></tr><tr><td> single</td><td>Qt 完整的源码包</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">Qt 版本号的命名规则</p><p>这里解释一下 Qt 的版本号，比如 <code>6.5.3</code> 是完整的 Qt 版本号，第一个数字 6 是大版本号（major），第二个数字 5 是小版本号（minor），第三个数字 3 是补丁号（patch）。只要前面两个数字相同，Qt 的特性就是一致的，最后的数字是对该版本的补丁更新。</p></div><h2 id="Qt-国内镜像资源下载（较快）"><a href="#Qt-国内镜像资源下载（较快）" class="headerlink" title="Qt 国内镜像资源下载（较快）"></a>Qt 国内镜像资源下载（较快）</h2><p>在国内，Qt 的官方下载速度较慢，建议使用国内镜像网站下载。这里推荐几个国内著名的 Qt 镜像网站，主要是各个高校的：</p><table><thead><tr><th>镜像网站名称</th><th>下载地址</th></tr></thead><tbody><tr><td>中国科学技术大学 </td><td><a href="http://mirrors.ustc.edu.cn/qtproject/">http://mirrors.ustc.edu.cn/qtproject/</a></td></tr><tr><td> 清华大学 </td><td><a href="https://mirrors.tuna.tsinghua.edu.cn/qt/">https://mirrors.tuna.tsinghua.edu.cn/qt/</a></td></tr><tr><td> 北京理工大学 </td><td><a href="http://mirror.bit.edu.cn/qtproject/">http://mirror.bit.edu.cn/qtproject/</a></td></tr><tr><td> 中国互联网络信息中心 </td><td><a href="https://mirrors.cnnic.cn/qt/">https://mirrors.cnnic.cn/qt/</a></td></tr></tbody></table><blockquote><p>值得一提的是，国内镜像网站的资源目录结构和 Qt 官网是类似的，这里不再赘述。</p></blockquote><h2 id="Qt-在线安装案例"><a href="#Qt-在线安装案例" class="headerlink" title="Qt 在线安装案例"></a>Qt 在线安装案例</h2><blockquote><p>在 <a href="https://download.qt.io/archive/online_installers/">Qt 官网</a> 下载在线安装器，如 <code>qt-unified-windows-x86-4.2.0-online.exe</code></p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-6.png"></p><blockquote><p>双击在线安装器的 <code>EXE</code> 文件，开始安装 Qt，然后根据自己实际需求安装所需的组件</p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-7.png"></p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Qt 的安装一般需要 20G 以上的磁盘空间，请确保磁盘有足够的空间。</li><li>由于笔者在本地安装了 Visual Studio 2019，因此在上述图中选择了 <code>MSVC 2019 64-bit</code> 开发套件，若不需要，可以选择不安装该组件。</li><li>笔者选择安装 Qt 的长期技术支持版本，分别是 Qt <code>5.15</code> 与 Qt <code>6.2</code>，若不需要使用 Qt 5，可以选择不安装上述图中 Qt <code>5.15.2</code> 相关的组件，只安装 Qt 6 相关的组件。</li></ul></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://c.biancheng.net/view/3851.html">Qt 下载（多种下载通道 + 所有版本）</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Qt 各版本的官方下载地址，包括 Qt 的安装教程、镜像网站下载加速等内容。</summary>
    
    
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>分库分表可能真的要退出历史舞台</title>
    <link href="https://www.techgrow.cn/posts/8c661fac.html"/>
    <id>https://www.techgrow.cn/posts/8c661fac.html</id>
    <published>2023-11-26T14:45:21.000Z</published>
    <updated>2023-11-26T14:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一开始，开箱即用的 MySQL，一定是企业的首选。不仅仅因为用的人多，更重要的是生态成熟。随着业务的飞速发展（虽然现在这种机会比较少了），对于 MySQL 来说，很快就会遇到各种性能问题。这个时候，就需要由单机 MySQL 向分布式发展了。</p><h2 id="传统数据库的瓶颈"><a href="#传统数据库的瓶颈" class="headerlink" title="传统数据库的瓶颈"></a>传统数据库的瓶颈</h2><p>单机 MySQL 面临很多问题：</p><ul><li>单表太大，比如超过 500w，查询就非常吃力</li><li>单库太大，各种资源告急</li><li>读请求太高，严重影响写请求</li></ul><span id="more"></span><h2 id="传统数据库解决方案"><a href="#传统数据库解决方案" class="headerlink" title="传统数据库解决方案"></a>传统数据库解决方案</h2><p>很长时间以来，国内互联网的做法普遍是采用加入一个中间件的方式来解决，但随着分布式数据库的技术越来越成熟，这些魔法逐渐下沉到它本应该解决的层面 – 数据库实现层。留给分库分表技术的时间已经不多，它的存量市场越来越少了。分库分表技术，退出历史舞台，也是迟早的事情了。解决上面三个单机 MySQL 问题，有很多种切入层面，常见的有框架层、驱动层、代理层。</p><h3 id="第一种（框架层）"><a href="#第一种（框架层）" class="headerlink" title="第一种（框架层）"></a>第一种（框架层）</h3><p>简单地在 MyBatis 或者 JPA 之上使用 AOP 或者拦截器封装一层，也可以实现，这也是最傻的方式。</p><h3 id="第二种（驱动层）"><a href="#第二种（驱动层）" class="headerlink" title="第二种（驱动层）"></a>第二种（驱动层）</h3><p>再进一步，就可以在 JDBC 之上的驱动层来实现，把分库分表的路由维护在内存里，通过重写的 DataSource、Connection、Statment、ResultSet 等，对业务进行无侵入的改进。但可惜的是，这类方案还必须要维护与逻辑表相对应的物理表，而且功能也是阉割的，不确定性依然不小。更要命的是，JDBC 只支持 Java，对于某些公司来说，就非常的不适用。</p><h3 id="第三种（代理层）"><a href="#第三种（代理层）" class="headerlink" title="第三种（代理层）"></a>第三种（代理层）</h3><p>再就是采用中间件的传统模式，引入 Proxy 中间件，即把自己伪装成一个 MySQL Server，接受 Client 的请求。至于它后面怎么去操作真实的数据库，开发者都不需要知道。但 Proxy 本身也是一套服务，需要保证高可用，且有运维成本在里面，同时功能依然是阉割的。</p><h2 id="新型数据库解决方案"><a href="#新型数据库解决方案" class="headerlink" title="新型数据库解决方案"></a>新型数据库解决方案</h2><p>框架层、驱动层、代理层，在过去很长一段时间里，有无数的互联网公司前赴后继的试水，从 TDDL、Cobar，到 MyCat、ShardingSphere，各种层面的中间件也是层出不穷。但最近几年，这种争相斗艳的场面逐渐不再，到最后剩下来的，也就 ShardingSphere 这一枝独秀了。是问题不存在了么？不，正好相反，问题越来越严重。并不是问题消失了，而是它被转化成其他解决方式了。</p><h3 id="分布式数据库的前景"><a href="#分布式数据库的前景" class="headerlink" title="分布式数据库的前景"></a>分布式数据库的前景</h3><p>抛开关系型数据库不说，很久之前，类似于 ElasticSearch、Cassandra 这样的 NoSQL 存储，分片和副本的概念，就已经非常成熟了，而且它们是内置的，并不需要 DBA 去人工维护它们的物理位置。对于关系型数据库来说，走向分布式也终将成为必然。随着 Raft 等协议应用越来越广泛，分布式数据库的可靠性也逐渐得到了保证。如果以前因为事务问题而拒绝采用某些 NoSQL 产品，那么如今完全兼容 MySQL 的分布式数据库，没有理由再拒绝。</p><h3 id="分布式数据库的选择"><a href="#分布式数据库的选择" class="headerlink" title="分布式数据库的选择"></a>分布式数据库的选择</h3><p>云厂商，直接提供了像 Aurora、PolarDB 之类的 MySQL 增强，更有类似 TiDB、OceanBase 这样纯粹的分布式数据库，越来越多的业务走向了这个终途。当团队加班加点验证着分库分表中间件的时候，却发现其实换个兼容的存储就能玩得转，你会怎么选，简直不用再多说。当然，一旦选用了分布式数据库，以前的 DBA 经验可能就不管用了，比如说索引及其二级索引。开发团队不得不学习新的知识，来应对分布式环境。但这些都是阵痛，<strong>长远看来，分布式数据库是趋势，而分库分表中间件只能吃存量业务。</strong></p><h2 id="如何选择解决方案"><a href="#如何选择解决方案" class="headerlink" title="如何选择解决方案"></a>如何选择解决方案</h2><ul><li>如果业务拥有常年累积的大量复杂数据，建议采用复杂的分库分表组件。</li><li>如果业务比较新，在可预见的未来会有大量数据，那选择分布式数据库是最合适的。</li></ul><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p><strong>分库分表中间件并不是消失了。它摇身一变，变成了分布式数据库的一部分。</strong>你可能会听到很多切到分布式数据库，又从分布式数据库切回到 MySQL 的案例，这属于想吃螃蟹但并没有吃到。目前来看，分布式数据库越来越稳定，生态建设也越来越好。而分库分表，则适用于存量业务，终将会退出历史的舞台。</p>]]></content>
    
    
    <summary type="html">分库分表可能真的要退出历史舞台。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Cisdem PDF Converter OCR 转换器破解安装</title>
    <link href="https://www.techgrow.cn/posts/3ac58081.html"/>
    <id>https://www.techgrow.cn/posts/3ac58081.html</id>
    <published>2023-11-22T13:18:36.000Z</published>
    <updated>2023-11-22T13:18:36.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PDF 可以在任何屏幕上完美地显示内容，并且可以轻松阅读、存档或分发文件，而 Office 格式是文档创建和编辑的必备格式，因此 PDF 转换对于进一步编辑或重复使用变得很常见。<strong>Cisdem PDF Converter OCR 支持快速无缝地将 PDF 转换为多种文档格式，同时支持将扫描版的 PDF 文档转换成可编辑的 PDF 文档。</strong></p><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>支持 Windows 7、Windows 8、Windows 10、Windows 11 的 64 位操作系统。</p><h2 id="软件简介"><a href="#软件简介" class="headerlink" title="软件简介"></a>软件简介</h2><p>Cisdem PDF Converter OCR 是一款 PDF 格式转换软件，可以轻松地将正常和可扫描的 PDF 文档转换为可编辑文本格式的文件，比如转换为可编辑和可搜索的 PDF、Word、Excel、PPT、ePub、HTML、TXT、Rtfd、图片 (JPEG，BMP，PNG，GIF，TIFF) 等格式，支持 OCR 技术，同时保持原始布局和文件质量。</p><h2 id="软件特点"><a href="#软件特点" class="headerlink" title="软件特点"></a>软件特点</h2><p>Cisdem PDF Converter OCR 将尽力保留文本、图像、表格元素，并尽可能准确地保持原始格式、布局。例如，它可以在 Word 文档中保留复杂 PDF 文件的原始外观和感觉，将表格数据放入 Excel 电子表格中的正确单元格中，并在 PowerPoint 中保留布局，您无需花费数小时调整输出文件。OCR (光学字符识别) 用于根据形状和外观识别文本字符，它可以帮助从扫描的 PDF 或图像文件中提取文本内容，是归档和重新扫描 PDF 的必备功能。Cisdem PDF Converter OCR 不仅可以通过启用 OCR 功能快速批量处理扫描的 PDF 和图像文件，还可以通过手动标记文本、图像和表格来微调 OCR 应用区域，以实现更准确的识别。Cisdem PDF Converter OCR 可以识别 200 多种语言，包括英语、中文、西班牙语、阿拉伯语、法语、俄语、葡萄牙语、德语、日语、韩语等。</p><span id="more"></span><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><ul><li>百度网盘链接: <code>https://pan.baidu.com/s/1jls5BTI_kinz5e70wbbQHg</code></li><li>百度网盘提取码: <code>7exm</code></li></ul><h3 id="破解安装"><a href="#破解安装" class="headerlink" title="破解安装"></a>破解安装</h3><ol><li>在软件下载并解压后，将获得 <code>Setup.exe</code> 和 <code>Crack</code> 等文件，双击 <code>Setup.exe</code> 文件开始安装</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-1.png"></p><ol start="2"><li>默认选择创建桌面快捷方式，然后点击 <code>next</code> 按钮</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-2.png"></p><ol start="3"><li>点击 <code>install</code> 按钮开始安装软件</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-3.png"></p><ol start="4"><li>去掉勾选，先不要运行软件，等待安装破解补丁</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-4.png"></p><ol start="5"><li>在安装破解补丁前，首先打开软件的安装目录。如果忘记软件的安装目录，请返回到系统桌面，找到软件的桌面快捷图标，并右键点击图标，出现弹窗后选择 <code>打开文件位置</code> 即可获得软件的安装目录</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-5.png"></p><ol start="6"><li>打开解压后的 <code>Crack</code> 文件夹，将里面的破解补丁文件复制到软件安装目录中替换</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-6.png"></p><ol start="7"><li>选择替换目标中的文件</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-7.png"></p><ol start="8"><li>双击桌面的快捷方式运行软件，点击顶部菜单栏里的 <code>About</code> 选项，查看是否激活成功</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-8.png"></p><h2 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h2><ol><li>将需要转换的 PDF 文件拖拽到软件的主界面中，此时会提示在线下载并安装 OCR 模块，点击 <code>OK</code> 按钮开始下载。如果下载失败，可以关闭并重启软件，拖拽 PDF 文件到主界面，然后重新安装 OCR 模块</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-9.png"></p><ol start="2"><li>等待 OCR 模块下载完成</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-10.png"></p><ol start="3"><li> OCR 模块下载完成后，根据提示进行安装</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-11.png"></p><ol start="4"><li>若需要将扫描版的 PDF 文件转换为可编辑的 PDF 文件，可以选择 <code>OCR PDF</code>，并点击 <code>齿轮</code> 图标，选择语言为 <code>Chinese（Simplified）</code> 和 <code>English</code>，然后点击 <code>OK</code> 按钮</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-12.png"></p><ol start="5"><li>最后选择 PDF 文件转换后的输出目录，然后点击 <code>Convert</code> 按钮开始转换 PDF 文件</li></ol><p><img data-src="../../../asset/2023/10/pdf-convert-13.png"></p>]]></content>
    
    
    <summary type="html">本文主要记录 Cisdem PDF Converter OCR 转换器的破解安装教程，包括如何将 PDF 转换为其他格式的文件。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 云原生解决方案介绍</title>
    <link href="https://www.techgrow.cn/posts/16a97c36.html"/>
    <id>https://www.techgrow.cn/posts/16a97c36.html</id>
    <published>2023-11-15T14:13:45.000Z</published>
    <updated>2023-11-15T14:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍 Kafka 在生产实践中存在的问题，如运维操作、负载均衡、故障恢复等各方面，并简单介绍字节跳动、小红书是如何使用消息队列的云原生化来解决这些问题的。</p><h2 id="Kafka-实践遇到的问题"><a href="#Kafka-实践遇到的问题" class="headerlink" title="Kafka 实践遇到的问题"></a>Kafka 实践遇到的问题</h2><p>随着业务快速增长，经典消息队列 Kafka 的劣势开始逐渐暴露，在弹性、规模、成本及运维方面都无法满足业务需求。在本中，将介绍 Kafka 在生产实践中存在的问题，如运维操作、负载均衡、故障恢复等各方面。</p><span id="more"></span><h3 id="运维操作"><a href="#运维操作" class="headerlink" title="运维操作"></a>运维操作</h3><p>Kafka 的重启、扩缩容、分区迁移，这些运维操作都比较复杂。</p><p><img data-src="../../../asset/2023/10/kafka-note-1.png"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><img data-src="../../../asset/2023/10/kafka-note-2.png"></p><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>Kafka 自身支持处理单机故障，但对多机故障却无能为力。</p><p><img data-src="../../../asset/2023/10/kafka-note-3.png"></p><h3 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h3><p><img data-src="../../../asset/2023/10/kafka-note-4.png"></p><h3 id="存算一体架构"><a href="#存算一体架构" class="headerlink" title="存算一体架构"></a>存算一体架构</h3><p><img data-src="../../../asset/2023/10/kafka-note-5.png"></p><h2 id="字节跳动云原生消息队列方案"><a href="#字节跳动云原生消息队列方案" class="headerlink" title="字节跳动云原生消息队列方案"></a>字节跳动云原生消息队列方案</h2><p>BMQ 是字节跳动自研的一款消息队列，基于 C++ 开发，兼容 Kafka 协议，采用 HDFS 分布式存储来存放消息数据。</p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img data-src="../../../asset/2023/10/kafka-note-6.png"></p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p><img data-src="../../../asset/2023/10/kafka-note-7.png"></p><h3 id="Broker-运行机制"><a href="#Broker-运行机制" class="headerlink" title="Broker 运行机制"></a>Broker 运行机制</h3><p><img data-src="../../../asset/2023/10/kafka-note-8.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-9.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-10.png"></p><h3 id="Proxy-运行机制"><a href="#Proxy-运行机制" class="headerlink" title="Proxy 运行机制"></a>Proxy 运行机制</h3><p><img data-src="../../../asset/2023/10/kafka-note-11.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-12.png"></p><h3 id="容灾容错-HDFS"><a href="#容灾容错-HDFS" class="headerlink" title="容灾容错 HDFS"></a>容灾容错 HDFS</h3><p><img data-src="../../../asset/2023/10/kafka-note-13.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-14.png"></p><h3 id="线上业务使用场景"><a href="#线上业务使用场景" class="headerlink" title="线上业务使用场景"></a>线上业务使用场景</h3><p><img data-src="../../../asset/2023/10/kafka-note-15.png"></p><h2 id="小红书-Kafka-云原生最佳实践"><a href="#小红书-Kafka-云原生最佳实践" class="headerlink" title="小红书 Kafka 云原生最佳实践"></a>小红书 Kafka 云原生最佳实践</h2><p>小红书在 Kafka 原有的基础上，引入了分层存储、弹性扩容、消费隔离等特性。</p><h3 id="核心手段"><a href="#核心手段" class="headerlink" title="核心手段"></a>核心手段</h3><p><img data-src="../../../asset/2023/10/kafka-note-16.png"></p><h3 id="系统架构-1"><a href="#系统架构-1" class="headerlink" title="系统架构"></a>系统架构</h3><p><img data-src="../../../asset/2023/10/kafka-note-17.png"></p><h3 id="架构优势"><a href="#架构优势" class="headerlink" title="架构优势"></a>架构优势</h3><p><img data-src="../../../asset/2023/10/kafka-note-18.png"></p><h3 id="成本优化"><a href="#成本优化" class="headerlink" title="成本优化"></a>成本优化</h3><p><img data-src="../../../asset/2023/10/kafka-note-19.png"></p><h3 id="消费隔离"><a href="#消费隔离" class="headerlink" title="消费隔离"></a>消费隔离</h3><p><img data-src="../../../asset/2023/10/kafka-note-20.png"></p><h3 id="智能缓存"><a href="#智能缓存" class="headerlink" title="智能缓存"></a>智能缓存</h3><p><img data-src="../../../asset/2023/10/kafka-note-21.png"></p><h3 id="弹性扩容"><a href="#弹性扩容" class="headerlink" title="弹性扩容"></a>弹性扩容</h3><p><img data-src="../../../asset/2023/10/kafka-note-22.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-23.png"></p><h3 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h3><p><img data-src="../../../asset/2023/10/kafka-note-24.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-25.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-26.png"></p><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><h4 id="升级现有架构"><a href="#升级现有架构" class="headerlink" title="升级现有架构"></a>升级现有架构</h4><p><img data-src="../../../asset/2023/10/kafka-note-27.png"></p><h4 id="引入存算分离架构"><a href="#引入存算分离架构" class="headerlink" title="引入存算分离架构"></a>引入存算分离架构</h4><p><img data-src="../../../asset/2023/10/kafka-note-28.png"></p><h2 id="AutoMQ-云原生消息队列方案"><a href="#AutoMQ-云原生消息队列方案" class="headerlink" title="AutoMQ 云原生消息队列方案"></a>AutoMQ 云原生消息队列方案</h2><h3 id="AutoMQ-for-Kafka"><a href="#AutoMQ-for-Kafka" class="headerlink" title="AutoMQ for Kafka"></a>AutoMQ for Kafka</h3><p>由 <a href="https://www.automq.com/">AutoMQ</a> 开源的新一代消息流存储平台，面向开发者提供低成本、无状态、 100% 兼容 Apache Kafka 的消息服务。目前有两种版本，分别是商业版与开源版本。</p><ul><li><a href="https://docs.automq.com/zh/docs/automq-s3kafka/YUzOwI7AgiNIgDk1GJAcu6Uanog">官方中文文档</a></li><li><a href="https://github.com/AutoMQ/automq-for-kafka">GitHub 开源项目</a></li></ul><h3 id="AutoMQ-for-RocketMQ"><a href="#AutoMQ-for-RocketMQ" class="headerlink" title="AutoMQ for RocketMQ"></a>AutoMQ for RocketMQ</h3><p>由 <a href="https://www.automq.com/">AutoMQ</a> 基于 Apache RocketMQ 5.0 的云原生开源实现。目前有两种版本，分别是商业版与开源版本。</p><ul><li><a href="https://github.com/AutoMQ/automq-for-rocketmq">GitHub 开源项目</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/post/7199550396213542973">消息队列 | 青训营笔记</a></li><li><a href="https://www.bilibili.com/video/BV1Cc411R7kt">字节跳动云原生消息队列实践 - 视频</a></li><li><a href="https://www.bilibili.com/video/BV1dw411s7g8">小红书 Kafka 云原生化最佳实践 - 视频</a></li><li><a href="https://www.bilibili.com/video/BV1hM411S7PP">如何实现 Apache Kafka 十倍的降本增效 - 视频</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Kafka 云原生解决方案。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="消息队列" scheme="https://www.techgrow.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux 的 Xinetd 服务介绍</title>
    <link href="https://www.techgrow.cn/posts/7f134f1e.html"/>
    <id>https://www.techgrow.cn/posts/7f134f1e.html</id>
    <published>2023-11-14T13:48:23.000Z</published>
    <updated>2023-11-14T13:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Xinetd-简介"><a href="#Xinetd-简介" class="headerlink" title="Xinetd 简介"></a>Xinetd 简介</h2><p>Xinetd 是新一代的网络守护进程服务程序，又叫超级 Internet 服务器，经常用来管理保护多种轻量级 Internet 服务。它在 Linux 的安全中有着举足轻重的地位，它管理的服务都是一些不是很常用，但是系统中偶尔也会用到的小服务或者该服务没什么好的安全机制，比如：Ftp、Rsync、Telnet、SSH 等。它并不是一真正意义上的服务，Xinetd 相当于 Rync、SSH 等服务的代理人，比如代理了 <code>sshd</code>，那就可以关闭 SSH 服务，22 端口就由 Xinetd 服务代理了。它的作用大致可以分为以下几个：访问控制、防止 DOS 攻击、服务转发、用户交互式体验等。</p><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ul><li><code>超级守护进程</code>：多个服务统一由一个进程管理，该进程可以管理多个服务。</li><li><code>独立启动的守护进程</code>：每个特定服务都有单独的守护进程（stand-alone），这个保证单一服务始终存活的进程就是独立启动的守护进程。</li></ul><span id="more"></span><h3 id="优点介绍"><a href="#优点介绍" class="headerlink" title="优点介绍"></a>优点介绍</h3><ul><li><p>强大的存取控制功能</p><ul><li>设置特定的连接时间；</li><li>内置对恶意用户和善意用户的差别待遇设定；</li><li>使用 <code>libwrap</code> 支持，其效能更甚于 <code>tcpd</code>；</li><li>可以限制连接的等级，基于主机的连接数和基于服务的连接数；</li><li>将某个服务设置到特定的主机以提供服务。</li></ul></li><li><p>有效防止 DoS 攻击</p><ul><li>可以限制连接的等级；</li><li>可以限制一个主机的最大连接数，从而防止某个主机独占某个服务；</li><li>可以限制日志文件的大小，防止磁盘空间被填满。</li></ul></li><li><p>强大的日志功能</p><ul><li>可以为每一个服务 <code>syslog</code> 设定日志等级；</li><li>如果不使用 <code>syslog</code>，也可以为每个服务建立日志文件；</li><li>可以记录请求的起止时间以决定对方的访问时间；</li><li>可以记录试图非法访问的请求。</li></ul></li><li><p>转向功能</p><ul><li>可以将客户端的请求转发到另一台主机去处理。</li></ul></li><li><p>支持 IPv6</p><ul><li>Xinetd 从 <code>2.1.8.8 pre*</code> 版本开始就支持 IPv6，另外 IPv4 仍然被支持。</li></ul></li><li><p>与客户端的交互功能</p><ul><li>无论客户端请求是否成功，Xinetd 都会有提示告知连接状态。</li></ul></li></ul><h3 id="缺点介绍"><a href="#缺点介绍" class="headerlink" title="缺点介绍"></a>缺点介绍</h3><p>Xinetd 当前最大的缺点是对 RPC 支持的不稳定，但是可以启用 <code>protmap</code>，使它与 Xinetd 共存来解决这个问题。</p><h2 id="Xinetd-使用"><a href="#Xinetd-使用" class="headerlink" title="Xinetd 使用"></a>Xinetd 使用</h2><p>原则上任何系统服务都可以使用 Xinetd，然而最适合的应该是那些常见的网络服务，并且这些服务的请求数目和频繁程度不会太高。像 DNS 和 Apache 就不适合采用 Xinetd 进行管理，而像 FTP、Telnet、SSH 等就适合使用 Xinetd 进行管理。</p><ul><li>系统默认使用 Xinetd 的服务可以分为如下几类<ul><li>① 标准 Internet 服务：telnet、ftp。</li><li>② 信息服务：finger、netstat、systat。</li><li>③ 邮件服务：imap、imaps、pop2、pop3、pops。</li><li>④ RPC 服务：rquotad、rstatd、rusersd、sprayd、walld。</li><li>⑤ BSD 服务：comsat、exec、login、ntalk、shell、talk。</li><li>⑥ 内部服务：chargen、daytime、echo、servers、services、time。</li><li>⑦ 安全服务：irc。</li><li>⑧ 其他服务：name、tftp、uucp。</li></ul></li></ul><p>具体可以使用 Xinetd 进行管理的服务都在 <code>/etc/services</code> 配置文件中定义，该配置文件记录了网络服务名和它们对应使用的端口号及协议。文件中的每一行对应一种服务，它由 4 个字段组成，中间用 Tab 键或空格键分隔，分别表示 <code>服务名称</code>、<code>使用端口</code>、<code>协议名称</code> 及 <code>别名</code>。在一般情况下，不要修改该配置文件的内容，因为这些设置都是 Internet 标准的设置。一旦修改，可能会造成系统冲突，使用户无法正常访问资源。Linux 系统的端口号范围为 0 ~ 65535，不同范围的端口号有不同的意义：</p><ul><li><code>0</code>：不使用。</li><li><code>1 ~ 1023</code>：系统保留，只能由 <code>root</code> 用户使用。</li><li><code>1024 ~ 4999</code>：由客户端程序自由分配。</li><li><code>5000 ~ 65535</code>：由服务器程序自由分配。</li></ul><h2 id="Xinetd-配置"><a href="#Xinetd-配置" class="headerlink" title="Xinetd 配置"></a>Xinetd 配置</h2><p> Xinetd 的配置文件是 <code>/etc/xinetd.conf</code>，但是它只包括默认值，并包含 <code>/etc/xinetd.d</code> 目录中的配置文件。如果要启用或禁用某项 Xinetd 服务，可以编辑位于 <code>/etc/xinetd.d</code> 目录中的配置文件。例如，<code>disable</code> 属性被设为 <code>yes</code>，表示该项服务已禁用；<code>disable</code> 属性被设为 <code>no</code>，表示该项服务已启用。参数和值之间的操作符可以是 <code>=</code>、<code>+=</code> 或 <code>-=</code>。所有属性可以使用 <code>=</code>，其作用是分配一个或多个值。某些属性可以使用 <code>+=</code> 或 <code>-=</code>，其作用分别是将其值增加到某个现存的值表中，或将其值从现存值表中删除。详细的配置参数说明如下：</p><table><thead><tr><th>配置参数</th><th>说明</th></tr></thead><tbody><tr><td> enabled</td><td> 是否启用该服务或服务列表</td></tr><tr><td> disabled</td><td> 是否停用该服务或服务列表</td></tr><tr><td> server</td><td> 启动脚本的位置</td></tr><tr><td> server_args</td><td></td></tr><tr><td>socket_type</td><td> 服务的数据包类型</td></tr><tr><td> log_type</td><td> 包括：日志类型、路径、报警最大容量、停止服务的最大容量</td></tr><tr><td> log_on_success</td><td> 成功后要将哪些值记录到日志中</td></tr><tr><td> log_on_failure</td><td> 失败后要将哪些值记录到日志中</td></tr><tr><td> only_from</td><td> 只有指定 IP 可以访问</td></tr><tr><td> no_access</td><td> 指定 IP 不可以访问</td></tr><tr><td> access_times</td><td> 允许连接的时间</td></tr><tr><td> user</td><td> 运行此服务进程的用户</td></tr><tr><td> wait</td><td> 服务将以多线程的方式运行</td></tr><tr><td> max_load</td><td> 系统最大负载系数</td></tr><tr><td> cps m n</td><td> 限制每秒 m 个入站连接，如果超过 m，则等待 n 秒，主要用于对付服务攻击</td></tr><tr><td> port</td><td> 连接的端口</td></tr><tr><td> nice</td><td></td></tr><tr><td>protocol</td><td> 连接使用的协议</td></tr><tr><td> instances</td><td> 最大连接进程数</td></tr><tr><td> per_source</td><td> 限制每个主机的最大连接数</td></tr><tr><td> bind</td><td></td></tr><tr><td>mdns</td><td></td></tr><tr><td>v6only</td><td></td></tr><tr><td>passenv</td><td></td></tr><tr><td>groups</td><td></td></tr><tr><td>umask</td><td></td></tr><tr><td>banner</td><td></td></tr><tr><td>banner_fail</td><td></td></tr><tr><td>banner_success</td><td></td></tr><tr><td>rlimit_as</td><td> 最多可用内存</td></tr><tr><td> rlimit_cpu</td><td>CPU 每秒最多处理的进程数</td></tr></tbody></table><h2 id="Xinetd-安装"><a href="#Xinetd-安装" class="headerlink" title="Xinetd 安装"></a>Xinetd 安装</h2><ul><li>CentOS 安装 Xinetd</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo yum -y install xinetd</span><br></pre></td></tr></tbody></table></figure><ul><li>Xinetd 服务管理 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">sudo service xinetd start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">sudo service xinetd stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">sudo service xinetd restart</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/weixin_43869703/article/details/133879164">Xinetd 服务介绍</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Xinetd 服务的使用。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Debian 12 设置时区与同步时间</title>
    <link href="https://www.techgrow.cn/posts/6a0cde5a.html"/>
    <id>https://www.techgrow.cn/posts/6a0cde5a.html</id>
    <published>2023-11-11T12:13:32.000Z</published>
    <updated>2023-11-11T12:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍如何在 Debian 系统上设置时区与同步时间，适用于 Debian 11 Bullseye、Debian 12 Bookworm 发行版。</p><h2 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h2><p>一般全自动安装好的 Debian 是 UTC 时间，与北京时间差 8 小时，所以最好将时区设置为常用的时区，这样方便使用与阅读。<code>timedatectl</code> 是一个新工具，它作为 <code>systemd</code> 系统和服务管理器的一部分，代替旧的传统的用在基于 Linux 分布式系统的 <code>sysvinit</code> 守护进程的 <code>date</code> 命令。<code>timedatectl</code> 命令可以查询和更改系统时钟和设置，可以使用此命令来设置或更改当前的日期、时间和时区，或实现与远程 NTP 服务器的自动系统时钟同步。</p><ul><li>查看所有可用的时区 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl list-timezones</span><br></pre></td></tr></tbody></table></figure><ul><li>设置当前系统的时区为上海 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo timedatectl set-timezone <span class="string">"Asia/Shanghai"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>查看当前系统的时区 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl status</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h2><p>一般重新设置系统时区后，现实时间会与系统时间之间会有误差，这时候建议使用 <code>systemd-timesyncd</code> 相关工具来解决时间差异的问题。<strong>特别注意：<code>timedatectl</code> 并不兼容 <code>ntpd</code> 等组件，请不要安装 <code>ntpd</code> 等组件，以免时间同步失效。</strong></p><ul><li>安装 <code>systemd-timesyncd</code> 服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install systemd-timesyncd</span><br></pre></td></tr></tbody></table></figure><ul><li>更改配置文件，添加 NTP 服务器（添加一行 NTP 服务器地址）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/timesyncd.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Time]</span><br><span class="line">NTP=pool.ntp.org 0.asia.pool.ntp.org 1.asia.pool.ntp.org 2.asia.pool.ntp.org</span><br><span class="line">#RootDistanceMaxSec=5</span><br><span class="line">#PollIntervalMinSec=32</span><br><span class="line">#PollIntervalMaxSec=2048</span><br></pre></td></tr></tbody></table></figure><ul><li>重启 <code>systemd-timesyncd</code> 服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart systemd-timesyncd</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 <code>systemd-timesyncd</code> 服务的运行状态 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status systemd-timesyncd</span><br></pre></td></tr></tbody></table></figure><ul><li>启用时间自动同步 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo timedatectl set-ntp <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><ul><li>查看时间同步状态 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timedatectl status</span><br><span class="line"></span><br><span class="line">timedatectl timesync-status</span><br><span class="line"></span><br><span class="line">timedatectl show-timesync --all</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍如何在 Debian 12 设置时区与同步时间。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>Debian 12 编译安装 Erlang 23.2</title>
    <link href="https://www.techgrow.cn/posts/a6c59612.html"/>
    <id>https://www.techgrow.cn/posts/a6c59612.html</id>
    <published>2023-11-03T12:13:32.000Z</published>
    <updated>2023-11-03T12:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><table><thead><tr><th>软件</th><th>版本</th></tr></thead><tbody><tr><td> Debian</td><td><code>12</code></td></tr><tr><td>autoconf</td><td><code>2.6.9</code></td></tr><tr><td>OpenSSL</td><td><code>1.1.1</code></td></tr><tr><td>Erlang</td><td><code>23.2</code></td></tr></tbody></table><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y build-essential perl unzip flex bison fop xsltproc unixodbc libssl-dev unixodbc-dev libncurses5-dev libgl1-mesa-dev libglu1-mesa-dev libxml2-utils</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-autoconf"><a href="#安装-autoconf" class="headerlink" title="安装 autoconf"></a>安装 autoconf</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里必须安装 <code>2.69</code> 版本的 <code>autoconf</code>，否则 Erlang <code>23.2</code> 在编译前的配置操作会执行失败。</p></div><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载已安装的版本</span></span><br><span class="line">sudo apt-get remove --purge autoconf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">curl -O http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar zxvf autoconf-2.69.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cd</span> autoconf-2.69</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">autoconf -V</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h3 id="安装-OpenSSL"><a href="#安装-OpenSSL" class="headerlink" title="安装 OpenSSL"></a>安装 OpenSSL</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里必须安装 <code>1.1.1</code> 版本的 OpenSSL，否则 Erlang <code>23.2</code> 会编译失败。</p></div><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/openssl/openssl/archive/refs/heads/OpenSSL_1_1_1-stable.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">unzip OpenSSL_1_1_1-stable.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cd</span> openssl-OpenSSL_1_1_1-stable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">./config --prefix=/usr/<span class="built_in">local</span>/openssl-1.1.1 --openssldir=/usr/<span class="built_in">local</span>/openssl-1.1.1 shared</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-Erlang"><a href="#安装-Erlang" class="headerlink" title="安装 Erlang"></a>安装 Erlang</h3><div class="admonition note"><p class="admonition-title">提示</p><ul><li>若在 Erlang 的安装过程中，出现 <code>wxWidgets</code> 没有安装的警告信息，可以忽略该警告。</li><li>由于暂时不需要使用到 <code>wxWidegts</code> 组件（GUI），因此下面使用了 <code>--without-wx</code> 命令行参数进行配置。</li><li>若需要使用到 <code>wxWidegts</code> 组件（GUI），则需要安装 <code>libwxgtk3.0-gtk3-dev</code>、<code>libwxgtk-webview3.0-gtk3-dev</code> 软件包，目前 Debian 12 的软件仓库里并没有这两个软件包，可能需要使用源码进行编译安装。</li></ul></div><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建安装目录</span></span><br><span class="line">sudo mkdir -p /usr/<span class="built_in">local</span>/erlang-23.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://erlang.org/download/otp_src_23.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -xvf otp_src_23.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cd</span> otp_src_23.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">./otp_build autoconf</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/erlang-23.2 -with-ssl=/usr/<span class="built_in">local</span>/openssl-1.1.1 --without-javac --without-wx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="built_in">export</span> ERLANG_HOME=/usr/<span class="built_in">local</span>/erlang-23.2</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$ERLANG_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使环境变量生效</span></span><br><span class="line">sudo <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></tbody></table></figure><h3 id="卸载-OpenJDK"><a href="#卸载-OpenJDK" class="headerlink" title="卸载 OpenJDK"></a>卸载 OpenJDK</h3><p>Erlang 在安装过程中使用 <code>fop</code> 来生成 PDF 文档，而 <code>fop</code> 依赖了 OpenJDK，因此在上面安装依赖的步骤里，默认已经安装了最新版本的 OpenJDK。若希望在 Erlang 编译安装成功后卸载 OpenDJK，可以使用以下命令：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看已安装的OpenJDK版本</span></span><br><span class="line">sudo apt list --installed | grep openjdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载OpenJDK（请自行更改版本号）</span></span><br><span class="line">sudo apt-get autoremove openjdk-17-jre-headless</span><br></pre></td></tr></tbody></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/asdf-vm/asdf-erlang/issues/257">Ubuntu 22 erlang 23 build error</a></li><li><a href="https://github.com/asdf-vm/asdf-erlang/issues/195">Cannot find required auxiliary files: install-sh config.guess config.sub</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何在 Debian 12 安装 Erlang 23.2。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>Debian 11 生产环境部署 PXC 8.0 集群</title>
    <link href="https://www.techgrow.cn/posts/ff0f2d6.html"/>
    <id>https://www.techgrow.cn/posts/ff0f2d6.html</id>
    <published>2023-10-30T12:13:32.000Z</published>
    <updated>2023-11-12T12:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍 Deian 11 如何安装 Percona XtraDB Cluster 8.0 集群（三个物理节点），并基于 Haproxy + Keepalived （两个物理节点）实现双机热备方案。</p><h3 id="系列教程"><a href="#系列教程" class="headerlink" title="系列教程"></a>系列教程</h3><ul><li><a href="/posts/aba17375.html">Docker 部署 PXC 5.7 单机集群</a></li><li><a href="/posts/8dc5e7ed.html">Docker 部署 PXC 8.0 单机集群</a></li><li><a href="/posts/ff0f2d6.html">Debian 11 生产环境部署 PXC 8.0 集群</a></li></ul><span id="more"></span><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ul><li><a href="https://docs.percona.com/percona-xtradb-cluster/8.0/apt.html">Percona XtraDB Cluster 8.0 官方文档</a></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h3><p><img data-src="../../../asset/2023/10/mysql-pxc8-6.png"></p><h3 id="部署规划"><a href="#部署规划" class="headerlink" title="部署规划"></a>部署规划</h3><ul><li>软件版本说明</li></ul><table><thead><tr><th>软件</th><th>版本</th><th>描述</th></tr></thead><tbody><tr><td> Haproxy</td><td>1.5.18</td><td></td></tr><tr><td>Keepalived</td><td>1.3.5</td><td></td></tr><tr><td>Percona XtraDB Cluster (PXC)</td><td>8.0</td><td></td></tr></tbody></table><ul><li> 节点部署规划</li></ul><table><thead><tr><th>节点名称</th><th>主机名</th><th> IP</th><th> 系统</th><th>说明</th></tr></thead><tbody><tr><td> PXC 节点一</td><td> pxc-node-1</td><td>192.168.1.188</td><td>Debian 11 (Bullseye)</td><td>Percona XtraDB Cluster (PXC)</td></tr><tr><td>PXC 节点二</td><td> pxc-node-2</td><td>192.168.1.193</td><td>Debian 11 (Bullseye)</td><td>Percona XtraDB Cluster (PXC)</td></tr><tr><td>PXC 节点三</td><td> pxc-node-3</td><td>192.168.1.223</td><td>Debian 11 (Bullseye)</td><td>Percona XtraDB Cluster (PXC)</td></tr><tr><td>Haproxy 节点一</td><td> haproxy-node-1</td><td>192.168.1.235</td><td>Debian 11 (Bullseye)</td><td>Haproxy + Keepalived</td></tr><tr><td>Haproxy 节点二</td><td> haproxy-node-2</td><td>192.168.1.239</td><td>Debian 11 (Bullseye)</td><td>Haproxy + Keepalived</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Percona XtraDB Cluster 要求最小的集群大小是 3 个节点。</li><li>建议尽可能地控制 PXC 集群的规模，节点越多，数据同步速度越慢。</li><li>PXC 存在硬件配置短板限制，即整个集群的写吞吐量受最弱节点的限制。因此所有 PXC 节点的硬件配置要一致，否则如果一个节点变慢，整个集群会跟着变慢。</li></ul></div><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><h3 id="配置-Host"><a href="#配置-Host" class="headerlink" title="配置 Host"></a>配置 Host</h3><p>在每个节点服务器上编辑 <code>/etc/hosts</code> 文件，加入以下内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.188    pxc-node-1</span><br><span class="line">192.168.1.193    pxc-node-2</span><br><span class="line">192.168.1.223    pxc-node-3</span><br><span class="line">192.168.1.235    haproxy-node-1</span><br><span class="line">192.168.1.239    haproxy-node-2</span><br></pre></td></tr></tbody></table></figure><h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><p>在每个节点服务器上设置主机名。若由于其他限制导致不允许更改主机名，则可以跳过以下步骤。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看主机名</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久更改主机名</span></span><br><span class="line">$ sudo hostnamectl set-hostname xx-xxxx</span><br></pre></td></tr></tbody></table></figure><h3 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h3><p>在配置系统防火墙之前，在每个服务器上分别安装 UFW 防火墙工具。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装ufw</span></span><br><span class="line">sudo apt install ufw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放SSH端口</span></span><br><span class="line">sudo ufw allow OpenSSH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用ufw</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ufw的运行状态</span></span><br><span class="line">sudo ufw status</span><br></pre></td></tr></tbody></table></figure><h4 id="PXC-集群的防火墙"><a href="#PXC-集群的防火墙" class="headerlink" title="PXC 集群的防火墙"></a>PXC 集群的防火墙</h4><p>在本节中，将在每个 PXC 集群节点服务器上使用 UFW 配置防火墙，使 PXC 集群节点之间可以互相通信。</p><ul><li><p>PXC 集群默认会使用到以下端口</p><ul><li><code>3306</code></li><li><code>4444</code></li><li><code>4567</code></li><li><code>4568</code></li></ul></li><li><p>基于 UFW 配置防火墙</p></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 PXC 端口，192.168.1.0/24 是所有 PXC 集群节点的子网地址</span></span><br><span class="line">sudo ufw allow from 192.168.1.0/24 proto tcp to any port 3306</span><br><span class="line">sudo ufw allow from 192.168.1.0/24 proto tcp to any port 4444</span><br><span class="line">sudo ufw allow from 192.168.1.0/24 proto tcp to any port 4567</span><br><span class="line">sudo ufw allow from 192.168.1.0/24 proto tcp to any port 4568</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 UFW 的运行状态 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看ufw的运行状态</span></span><br><span class="line">sudo ufw status</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">OpenSSH                    ALLOW       Anywhere                  </span><br><span class="line">3306/tcp                   ALLOW       192.168.1.0/24            </span><br><span class="line">4444/tcp                   ALLOW       192.168.1.0/24            </span><br><span class="line">4567/tcp                   ALLOW       192.168.1.0/24            </span><br><span class="line">4568/tcp                   ALLOW       192.168.1.0/24            </span><br><span class="line">OpenSSH (v6)               ALLOW       Anywhere (v6)     </span><br></pre></td></tr></tbody></table></figure><h4 id="Haproxy-的防火墙"><a href="#Haproxy-的防火墙" class="headerlink" title="Haproxy 的防火墙"></a>Haproxy 的防火墙</h4><p>在本节中，将在每个 Haproxy 节点服务器上使用 UFW 配置防火墙，使外部可以正常访问 Haproxy。</p><ul><li><p>Haproxy 默认会使用到以下端口</p><ul><li><code>3306</code>：Haproxy 代理 MySQL 的端口</li><li><code>8888</code>：Haproxy 监控页面的 Web 端口</li></ul></li><li><p>基于 UFW 配置防火墙</p></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 Haproxy 端口，192.168.1.0/24 是所有 Haproxy 节点的子网地址</span></span><br><span class="line">sudo ufw allow from 192.168.1.0/24 proto tcp to any port 3306</span><br><span class="line">sudo ufw allow from 192.168.1.0/24 proto tcp to any port 8888</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 UFW 的运行状态 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看ufw的运行状态</span></span><br><span class="line">sudo ufw status</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">OpenSSH                    ALLOW       Anywhere                  </span><br><span class="line">3306/tcp                   ALLOW       192.168.1.0/24            </span><br><span class="line">8888/tcp                   ALLOW       192.168.1.0/24            </span><br><span class="line">OpenSSH (v6)               ALLOW       Anywhere (v6)   </span><br></pre></td></tr></tbody></table></figure><h4 id="Keepalived-的防火墙"><a href="#Keepalived-的防火墙" class="headerlink" title="Keepalived 的防火墙"></a>Keepalived 的防火墙</h4><p>在本节中，将在每个 Keepalived 节点服务器上使用 UFW 配置防火墙，使 Keepalived 节点之间可以互相进行心跳通信。</p><ul><li><p>Keepalived 心跳通信</p><ul><li>Keepalived 使用 VRRP 协议进行通信（协议号码为 <code>112</code>）</li><li>Keepalived 用于心跳通信的默认 VRRP 广播地址是 <code>224.0.0.18</code></li><li>如果 Keepalived 节点之间不能正常进行心跳通信，就会发生脑裂现象，即多个 Keepalived 节点会同时抢占到虚拟 IP</li></ul></li><li><p> 基于 UFW 配置防火墙</p></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 VRRP 广播地址，enp0s3 是网卡接口，192.168.1.0/24 是所有 Keepalived 节点的子网地址</span></span><br><span class="line">ufw allow <span class="keyword">in</span> on enp0s3 from 192.168.1.0/24 to 224.0.0.18;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">OpenSSH                    ALLOW       Anywhere                  </span><br><span class="line">3306/tcp                   ALLOW       192.168.1.0/24            </span><br><span class="line">8888/tcp                   ALLOW       192.168.1.0/24            </span><br><span class="line">224.0.0.18 on enp0s3       ALLOW       192.168.1.0/24            </span><br><span class="line">OpenSSH (v6)               ALLOW       Anywhere (v6)   </span><br></pre></td></tr></tbody></table></figure><h3 id="关闭-SeLinux"><a href="#关闭-SeLinux" class="headerlink" title="关闭 SeLinux"></a>关闭 SeLinux</h3><p>在本节中，将在每个节点服务器上永久关闭 SeLinux，保证 PXC 集群节点可以互相通信。值得一提的是，如果系统没有安装 SeLinux，则可以跳过以下步骤。</p><ul><li>编辑 SeLinux 的配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">sudo vi /etc/selinux/config</span><br></pre></td></tr></tbody></table></figure><ul><li>将 <code>SELINUX</code> 的值设置为 <code>disabled</code></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This file controls the state of SELinux on the system.</span><br><span class="line"># SELINUX= can take one of these three values:</span><br><span class="line">#     enforcing - SELinux security policy is enforced.</span><br><span class="line">#     permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">#     disabled - No SELinux policy is loaded.</span><br><span class="line">SELINUX=disabled</span><br><span class="line"># SELINUXTYPE= can take one of three two values:</span><br><span class="line">#     targeted - Targeted processes are protected,</span><br><span class="line">#     minimum - Modification of targeted policy. Only selected processes are protected.</span><br><span class="line">#     mls - Multi Level Security protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></tbody></table></figure><h3 id="系统性能优化"><a href="#系统性能优化" class="headerlink" title="系统性能优化"></a>系统性能优化</h3><p>在本节中，将在每个节点服务器上更改系统的最大打开文件描述符数，且更改永久生效。</p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>关于更改最大打开文件描述符数的详细教程，可以看 <a href="/posts/88a10b.html">这里</a>。</li><li>PXC 集群无需配置 Percona Server 数据库的最大打开文件描述符数，因为在 Percona Server 服务的配置文件 <code>/lib/systemd/system/mysql.service</code> 和 <code>/lib/systemd/system/mysql@.service</code> 中，默认都已经配置了 <code>LimitNOFILE=16364</code>。</li></ul></div><ul><li>查看限制 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n</span><br></pre></td></tr></tbody></table></figure><ul><li>更改配置 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步</span></span><br><span class="line">sudo vim /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">* soft nofile 1048576</span><br><span class="line">* hard nofile 1048576</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步</span></span><br><span class="line">sudo vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">fs.file-max = 1048576</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步（重启系统）</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></tbody></table></figure><ul><li>验证生效 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n</span><br><span class="line"></span><br><span class="line">sudo sysctl fs.file-max</span><br></pre></td></tr></tbody></table></figure><h3 id="卸载已安装软件"><a href="#卸载已安装软件" class="headerlink" title="卸载已安装软件"></a>卸载已安装软件</h3><p>检查每个节点服务器上的 Debian 系统是否已经安装过 MySQL、MariaDB、Percona Server 数据库，如果安装过请先卸载掉，然后再安装 PXC 集群。</p><h3 id="检查交换分区的大小"><a href="#检查交换分区的大小" class="headerlink" title="检查交换分区的大小"></a>检查交换分区的大小</h3><p>检查每个节点服务器上的交换分区大小，如果 Debian 系统没有交换分区，则建议手动创建并挂载，详细教程请看 <a href="/posts/9301e8fd.html">这里</a>。</p><ul><li>交换分区大小配置规则<ul><li>如果 RAM 介于 2 GB 和 8 GB 之间，则 SWAP 为 RAM 大小的 2 倍。</li><li>如果 RAM 在 8 GB 到 32 GB 之间，则 SWAP 为 RAM 大小的 1.5 倍。</li><li>如果 RAM 大于 32 GB，则 SWAP 为 32 GB。</li></ul></li></ul><h2 id="PXC-集群安装"><a href="#PXC-集群安装" class="headerlink" title="PXC 集群安装"></a>PXC 集群安装</h2><p>在本节中，将在每个节点服务器上，基于 Debian 11 添加并设置 Percona XtraDB Cluster 存储库，然后安装 Percona XtraDB Cluster 软件包。此外，在安装过程中，系统会提示设置 MySQL 的 <code>root</code> 账号的密码，并为 Percona XtraDB Cluster 设置默认身份验证插件。最后，将通过配置的 <code>root</code> 用户和密码登录数据库，验证 Percona XtraDB Cluster 的安装。值得一提的，PXC 集群的部署规划如下表所示：</p><table><thead><tr><th>节点名称</th><th>主机名</th><th> IP</th><th> 系统</th><th>说明</th></tr></thead><tbody><tr><td> PXC 节点一</td><td> pxc-node-1</td><td>192.168.1.188</td><td>Debian 11 (Bullseye)</td><td>Percona XtraDB Cluster (PXC)</td></tr><tr><td>PXC 节点二</td><td> pxc-node-2</td><td>192.168.1.193</td><td>Debian 11 (Bullseye)</td><td>Percona XtraDB Cluster (PXC)</td></tr><tr><td>PXC 节点三</td><td> pxc-node-3</td><td>192.168.1.223</td><td>Debian 11 (Bullseye)</td><td>Percona XtraDB Cluster (PXC)</td></tr></tbody></table><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ul><li>安装基础依赖 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt install -y wget gnupg2 lsb-release curl</span><br></pre></td></tr></tbody></table></figure><ul><li>安装 Percona XtraDB Cluster 的存储库包 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载存储库包</span></span><br><span class="line">wget -q https://repo.percona.com/apt/percona-release_latest.generic_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装存储库包</span></span><br><span class="line">sudo dpkg -i percona-release_latest.generic_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包索引信息</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></tbody></table></figure><ul><li>启用 Percona XtraDB Cluster 8.0 （相当于 MySQL 8.0）的存储库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo percona-release setup pxc80</span><br></pre></td></tr></tbody></table></figure><ul><li>安装 Percona XtraDB Cluster 软件包 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装PXC软件包</span></span><br><span class="line">sudo apt install -y percona-xtradb-cluster</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用代理，如果网络很卡导致安装失败，建议使用代理进行安装</span></span><br><span class="line">sudo apt install -y -o Acquire::http::proxy=<span class="string">"socks5h://127.0.0.1:1080/"</span> percona-xtradb-cluster</span><br></pre></td></tr></tbody></table></figure><ul><li>选择默认的认证插件（建议选择强加密）</li></ul><p><img data-src="../../../asset/2023/10/mysql-pxc8-7.png"></p><ul><li>根据提示输入 <code>root</code> 账号的密码（强）</li></ul><p><img data-src="../../../asset/2023/10/mysql-pxc8-1.png"></p><ul><li>根据提示确认 <code>root</code> 账号的密码（强）</li></ul><p><img data-src="../../../asset/2023/10/mysql-pxc8-2.png"></p><ul><li>启动 MySQL 服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">sudo systemctl start mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></tbody></table></figure><h3 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h3><p>在每个节点服务器上执行以下命令，然后输入 <code>root</code> 账号的密码，若能成功登录 MySQL，则说明数据库正常运行。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">sudo mysql -h localhost -u root -p</span><br></pre></td></tr></tbody></table></figure><h2 id="PXC-集群配置"><a href="#PXC-集群配置" class="headerlink" title="PXC 集群配置"></a>PXC 集群配置</h2><p><strong>特别注意，在开始配置 Percona XtraDB Cluster 集群之前，必须确保所有节点上的 MySQL 服务器都已停止运行。</strong></p><ul><li>关闭第一个节点（负责集群初始化）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭服务</span></span><br><span class="line">sudo systemctl stop mysql@bootstrap.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">sudo systemctl status mysql@bootstrap.service</span><br></pre></td></tr></tbody></table></figure><ul><li>关闭其他节点 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭服务</span></span><br><span class="line">sudo systemctl stop mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></tbody></table></figure><h3 id="拷贝-SSL-TLS-证书"><a href="#拷贝-SSL-TLS-证书" class="headerlink" title="拷贝 SSL/TLS 证书"></a>拷贝 SSL/TLS 证书</h3><p>Percona XtraDB Cluster 有两种流量加密：客户端 / 服务器连接和复制流量。在最新的 Percona XtraDB Cluster 8.0 上，默认情况下会启用所有复制流量的加密以增强安全性。因此在创建和设置 Percona XtraDB Cluster 时，所有服务器都必须具有相同的 CA 和 Server 证书，即必须将默认的 CA 和 Server 证书从 <code>pxc-node-1</code> 节点拷贝到 <code>pxc-node-2</code> 节点和 <code>pxc-node-3</code> 节点。</p><ul><li>在 PXC 集群安装的过程中，SSL/TLS 证书已经在数据目录 <code>/var/lib/mysql</code> 下自动生成了，包括 Client、Server、CA 三种类型的证书 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看SSL/TLC证书列表</span></span><br><span class="line">ls /var/lib/mysql/*.pem</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/mysql/ca.pem</span><br><span class="line">/var/lib/mysql/ca-key.pem</span><br><span class="line">/var/lib/mysql/public_key.pem</span><br><span class="line">/var/lib/mysql/private_key.pem</span><br><span class="line">/var/lib/mysql/client-key.pem</span><br><span class="line">/var/lib/mysql/client-cert.pem</span><br><span class="line">/var/lib/mysql/server-key.pem</span><br><span class="line">/var/lib/mysql/server-cert.pem</span><br></pre></td></tr></tbody></table></figure><ul><li>在 <code>pxc-node-1</code> 节点上，拷贝 CA 和 Server 证书到 <code>pxc-node-2</code> 节点和 <code>pxc-node-3</code> 节点。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入证书目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝证书</span></span><br><span class="line">scp server-key.pem server-cert.pem ca.pem root@pxc-node-2:/var/lib/mysql</span><br><span class="line">scp server-key.pem server-cert.pem ca.pem root@pxc-node-3:/var/lib/mysql</span><br></pre></td></tr></tbody></table></figure><h3 id="在第一个节点上初始化集群"><a href="#在第一个节点上初始化集群" class="headerlink" title="在第一个节点上初始化集群"></a>在第一个节点上初始化集群</h3><p>在本节中，将在第一个节点服务器 <code>pxc-node-1</code> 上初始化 Percona XtraDB Cluster 集群（即引导 PXC 集群启动）。<strong>请确保以下步骤都是在节点一服务器上执行。</strong></p><ul><li>编辑节点一的 MySQL 配置文件，添加以下配置内容 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份配置文件</span></span><br><span class="line">sudo cp /etc/mysql/mysql.conf.d/mysqld.cnf /etc/mysql/mysql.conf.d/mysqld.cnf.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">server-id=1</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">log-error=/var/log/mysql/error.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">######## wsrep ###############</span><br><span class="line"></span><br><span class="line"># Path to Galera library</span><br><span class="line">wsrep_provider=/usr/lib/libgalera_smm.so</span><br><span class="line"></span><br><span class="line"># Cluster connection URL contains the IPs of pxc01, pxc02, and pxc03</span><br><span class="line">wsrep_cluster_address=gcomm://192.168.1.188,192.168.1.193,192.168.1.223</span><br><span class="line"></span><br><span class="line"># In order for Galera to work correctly binlog format should be ROW</span><br><span class="line">binlog_format=ROW</span><br><span class="line"></span><br><span class="line"># Slave thread to use</span><br><span class="line">wsrep_slave_threads=4</span><br><span class="line"></span><br><span class="line"># Using the MyISAM storage engine is not recommended.</span><br><span class="line">default_storage_engine=InnoDB</span><br><span class="line"></span><br><span class="line"># This InnoDB autoincrement locking mode is a requirement for Galera</span><br><span class="line">innodb_autoinc_lock_mode=2</span><br><span class="line"></span><br><span class="line"># Node 1 address</span><br><span class="line">wsrep_node_address=192.168.1.188</span><br><span class="line"></span><br><span class="line"># SST method</span><br><span class="line">wsrep_sst_method=xtrabackup-v2</span><br><span class="line"></span><br><span class="line"># Cluster name</span><br><span class="line">wsrep_cluster_name=pxc_cluster</span><br><span class="line"></span><br><span class="line"># If is not specified, then system hostname will be used</span><br><span class="line">wsrep_node_name=pxc-cluster-node-1</span><br><span class="line"></span><br><span class="line"># PXC Strict Mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER</span><br><span class="line">pxc_strict_mode=ENFORCING</span><br><span class="line"></span><br><span class="line">wsrep_provider_options="socket.ssl_key=server-key.pem;socket.ssl_cert=server-cert.pem;socket.ssl_ca=ca.pem"</span><br><span class="line"></span><br><span class="line">[sst]</span><br><span class="line">encrypt=4</span><br><span class="line">ssl-key=server-key.pem</span><br><span class="line">ssl-ca=ca.pem</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">核心参数说明：</span><br><span class="line">    - `wsrep_cluster_name`：集群的名称</span><br><span class="line">    - `server-id`：MySQL 实例的唯一标识符（每个节点都不一样）</span><br><span class="line">    - `wsrep_node_name`：当前节点服务器的名称（每个节点都不一样），如果不指定默认使用主机名</span><br><span class="line">    - `wsrep_node_address`：当前节点服务器的 IP 地址（每个节点都不一样）</span><br><span class="line">    - `wsrep_cluster_address`：所有节点服务器的 IP 地址</span><br><span class="line"></span><br><span class="line">其他参数说明：</span><br><span class="line">    - `default_storage_engine=InnoDB`：指定默认的存储引擎为 InnoDB</span><br><span class="line">    - `innodb_autoinc_lock_mode=2`：该模式下所有 INSERT SQL 都不会有表级 AUTO-INC 锁，即多个语句可以同时执行</span><br><span class="line">    - `pxc_strict_mode=ENFORCING`：严厉模式，`ENFORCING` 表示会阻止用户执行 Percona XtraDB Cluster 所不支持的功能</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化集群 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动节点一的MySQL服务（初始化集群）</span></span><br><span class="line">systemctl start mysql@bootstrap.service</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li><code>mysql@bootstrap</code> 是一个用于运行 Percona XtraDB Cluster 的 Systemd 服务，这与普通的 <code>mysql</code> 服务有本质的区别，主要用于 PXC 集群的初始化（即引导 PXC 集群启动）。</li><li>使用 Percona XtraDB Cluster 构建 MySQL 服务器时，第一个节点必须使用 <code>mysql@bootstrap</code> 服务进行管理，包括启动、关闭、重启、查看状态等操作（如下所示），而其他节点则可以直接使用普通的 <code>mysql</code> 服务进行管理。</li><li>启动第一个节点服务器：<code>systemctl start mysql@bootstrap.service</code>。</li><li>关闭第一个节点服务器：<code>systemctl stop mysql@bootstrap.service</code>。</li><li>重启第一个节点服务器：<code>systemctl restart mysql@bootstrap.service</code>。</li><li>查看第一个节点服务器的状态：<code>systemctl status mysql@bootstrap.service</code>。</li></ul></div><ul><li>验证集群的初始化是否成功 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">sudo mysql -h localhost -u root -p</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">show status like <span class="string">'wsrep%'</span>;</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>当 PXC 集群初始化成功后，应该可以看到下述的状态信息。<code>wsrep_cluster_size</code> 的值是 <code>1</code>，这意味着 Percona XtraDB Cluster 是用一台服务器初始化的。<code>wsrep_incoming_address</code> 的值是节点一服务器的 IP 地址。最后，节点处于 <code>Synced</code> 状态，这意味着它已完全连接并准备好进行写集复制。</p></div><p><img data-src="../../../asset/2023/10/mysql-pxc8-3.png"></p><h3 id="将第二个节点添加到集群中"><a href="#将第二个节点添加到集群中" class="headerlink" title="将第二个节点添加到集群中"></a>将第二个节点添加到集群中</h3><ul><li>编辑节点二的 MySQL 配置文件，添加以下内容 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份配置文件</span></span><br><span class="line">sudo cp /etc/mysql/mysql.conf.d/mysqld.cnf /etc/mysql/mysql.conf.d/mysqld.cnf.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">server-id=2</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">log-error=/var/log/mysql/error.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">######## wsrep ###############</span><br><span class="line"></span><br><span class="line"># Path to Galera library</span><br><span class="line">wsrep_provider=/usr/lib/libgalera_smm.so</span><br><span class="line"></span><br><span class="line"># Cluster connection URL contains the IPs of pxc01, pxc02, and pxc03</span><br><span class="line">wsrep_cluster_address=gcomm://192.168.1.188,192.168.1.193,192.168.1.223</span><br><span class="line"></span><br><span class="line"># In order for Galera to work correctly binlog format should be ROW</span><br><span class="line">binlog_format=ROW</span><br><span class="line"></span><br><span class="line"># Slave thread to use</span><br><span class="line">wsrep_slave_threads=4</span><br><span class="line"></span><br><span class="line"># Using the MyISAM storage engine is not recommended.</span><br><span class="line">default_storage_engine=InnoDB</span><br><span class="line"></span><br><span class="line"># This InnoDB autoincrement locking mode is a requirement for Galera</span><br><span class="line">innodb_autoinc_lock_mode=2</span><br><span class="line"></span><br><span class="line"># Node 2 address</span><br><span class="line">wsrep_node_address=192.168.1.193</span><br><span class="line"></span><br><span class="line"># SST method</span><br><span class="line">wsrep_sst_method=xtrabackup-v2</span><br><span class="line"></span><br><span class="line"># Cluster name</span><br><span class="line">wsrep_cluster_name=pxc_cluster</span><br><span class="line"></span><br><span class="line"># If is not specified, then system hostname will be used</span><br><span class="line">wsrep_node_name=pxc-cluster-node-2</span><br><span class="line"></span><br><span class="line"># PXC Strict Mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER</span><br><span class="line">pxc_strict_mode=ENFORCING</span><br><span class="line"></span><br><span class="line">wsrep_provider_options="socket.ssl_key=server-key.pem;socket.ssl_cert=server-cert.pem;socket.ssl_ca=ca.pem"</span><br><span class="line"></span><br><span class="line">[sst]</span><br><span class="line">encrypt=4</span><br><span class="line">ssl-key=server-key.pem</span><br><span class="line">ssl-ca=ca.pem</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p><code>server-id</code>、<code>wsrep_node_address</code>、<code>wsrep_node_name</code> 这三个参数必须跟其他节点一、节点三不一样。</p></div><ul><li>验证节点二是否成功添加到集群，在节点二服务器上执行以下命令 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动MySQL服务</span></span><br><span class="line">sudo systemctl start mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看MySQL服务的状态</span></span><br><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">sudo mysql -h localhost -u root -p</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">show status like <span class="string">'wsrep%'</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2023/10/mysql-pxc8-4.png"></p><h3 id="将第三个节点添加到集群中"><a href="#将第三个节点添加到集群中" class="headerlink" title="将第三个节点添加到集群中"></a>将第三个节点添加到集群中</h3><ul><li>编辑节点三的 MySQL 配置文件，添加以下内容 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份配置文件</span></span><br><span class="line">sudo cp /etc/mysql/mysql.conf.d/mysqld.cnf /etc/mysql/mysql.conf.d/mysqld.cnf.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">server-id=3</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">log-error=/var/log/mysql/error.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">######## wsrep ###############</span><br><span class="line"></span><br><span class="line"># Path to Galera library</span><br><span class="line">wsrep_provider=/usr/lib/libgalera_smm.so</span><br><span class="line"></span><br><span class="line"># Cluster connection URL contains the IPs of pxc01, pxc02, and pxc03</span><br><span class="line">wsrep_cluster_address=gcomm://192.168.1.188,192.168.1.193,192.168.1.223</span><br><span class="line"></span><br><span class="line"># In order for Galera to work correctly binlog format should be ROW</span><br><span class="line">binlog_format=ROW</span><br><span class="line"></span><br><span class="line"># Slave thread to use</span><br><span class="line">wsrep_slave_threads=4</span><br><span class="line"></span><br><span class="line"># Using the MyISAM storage engine is not recommended.</span><br><span class="line">default_storage_engine=InnoDB</span><br><span class="line"></span><br><span class="line"># This InnoDB autoincrement locking mode is a requirement for Galera</span><br><span class="line">innodb_autoinc_lock_mode=2</span><br><span class="line"></span><br><span class="line"># Node 3 address</span><br><span class="line">wsrep_node_address=192.168.1.223</span><br><span class="line"></span><br><span class="line"># SST method</span><br><span class="line">wsrep_sst_method=xtrabackup-v2</span><br><span class="line"></span><br><span class="line"># Cluster name</span><br><span class="line">wsrep_cluster_name=pxc_cluster</span><br><span class="line"></span><br><span class="line"># If is not specified, then system hostname will be used</span><br><span class="line">wsrep_node_name=pxc-cluster-node-3</span><br><span class="line"></span><br><span class="line"># PXC Strict Mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER</span><br><span class="line">pxc_strict_mode=ENFORCING</span><br><span class="line"></span><br><span class="line">wsrep_provider_options="socket.ssl_key=server-key.pem;socket.ssl_cert=server-cert.pem;socket.ssl_ca=ca.pem"</span><br><span class="line"></span><br><span class="line">[sst]</span><br><span class="line">encrypt=4</span><br><span class="line">ssl-key=server-key.pem</span><br><span class="line">ssl-ca=ca.pem</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p><code>server-id</code>、<code>wsrep_node_address</code>、<code>wsrep_node_name</code> 这三个参数必须跟其他节点一、节点二不一样。</p></div><ul><li>验证节点三是否成功添加到集群，在节点三服务器上执行以下命令 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动MySQL服务</span></span><br><span class="line">sudo systemctl start mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看MySQL服务的状态</span></span><br><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">sudo mysql -h localhost -u root -p</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">show status like <span class="string">'wsrep%'</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2023/10/mysql-pxc8-5.png"></p><h2 id="PXC-集群测试"><a href="#PXC-集群测试" class="headerlink" title="PXC 集群测试"></a>PXC 集群测试</h2><p>在本节中，将对 PXC 集群的复制进行测试，包括创建数据库和表、插入数据。</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul><li>登录节点二的 MySQL 服务器，创建 <code>percona</code> 数据库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line">CREATE DATABASE `percona` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br></pre></td></tr></tbody></table></figure><ul><li>登录节点一或者节点三的 MySQL 服务器，观察是否同步创建了相同的数据库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看数据库列表</span></span><br><span class="line">SHOW DATABASES;</span><br></pre></td></tr></tbody></table></figure><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><ul><li>登录节点三的 MySQL 服务器，创建 <code>example</code> 数据库表 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line">USE `percona`;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库表</span></span><br><span class="line">CREATE TABLE example (node_id INT PRIMARY KEY, node_name VARCHAR(30));</span><br></pre></td></tr></tbody></table></figure><ul><li>登录节点一的 MySQL 服务器，往 <code>example</code> 数据库表插入数据 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line">USE `percona`;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line">INSERT INTO percona.example VALUES (1, <span class="string">'pxc01'</span>);</span><br><span class="line">INSERT INTO percona.example VALUES (2, <span class="string">'pxc02'</span>);</span><br><span class="line">INSERT INTO percona.example VALUES (3, <span class="string">'pxc03'</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>登录节点二的 MySQL 服务器，查询 <code>example</code> 表的数据 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line">USE `percona`;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询数据</span></span><br><span class="line">SELECT * FROM percona.example;</span><br></pre></td></tr></tbody></table></figure><h2 id="PXC-集群管理"><a href="#PXC-集群管理" class="headerlink" title="PXC 集群管理"></a>PXC 集群管理</h2><h3 id="创建用户操作"><a href="#创建用户操作" class="headerlink" title="创建用户操作"></a>创建用户操作</h3><p>登录任意一个 PXC 集群节点的数据库，执行以下命令创建新用户，并授权用户可以远程访问指定的数据库。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">sudo mysql -h localhost -u root -p</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">CREATE USER <span class="string">'uatOption'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'Pxc_User_123@456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权远程访问指定的数据库</span></span><br><span class="line">GRANT ALL PRIVILEGES ON percona.* TO <span class="string">'uatOption'</span>@<span class="string">'%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限信息</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户列表</span></span><br><span class="line">SELECT host, user, plugin, authentication_string FROM mysql.user;</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>这里为了兼容 MySQL 5 的认证方式，建议在创建数据库用户时，指定加密规则为 <code>mysql_native_password</code>。值得一提的是，MySQL 8 默认使用的加密规则是 <code>caching_sha2_password</code>。</p></div><h3 id="集群各指标检查"><a href="#集群各指标检查" class="headerlink" title="集群各指标检查"></a>集群各指标检查</h3><p>在检测 PXC 集群各指标之前，先登录任意一个 PXC 集群节点的数据库，然后再执行其他操作。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">sudo mysql -h localhost -u root -p</span><br></pre></td></tr></tbody></table></figure><h4 id="集群完整性检查"><a href="#集群完整性检查" class="headerlink" title="集群完整性检查"></a>集群完整性检查</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status <span class="built_in">where</span> variable_name <span class="keyword">in</span> (<span class="string">'wsrep_cluster_state_uuid'</span>,<span class="string">'wsrep_cluster_conf_id'</span>,<span class="string">'wsrep_cluster_size'</span>,<span class="string">'wsrep_cluster_status'</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------+--------------------------------------+</span><br><span class="line">| Variable_name            | Value                                |</span><br><span class="line">+--------------------------+--------------------------------------+</span><br><span class="line">| wsrep_cluster_conf_id    | 7                                    |</span><br><span class="line">| wsrep_cluster_size       | 3                                    |</span><br><span class="line">| wsrep_cluster_state_uuid | e4bb8bf0-73d5-11ee-b279-3a5ebcc11ef7 |</span><br><span class="line">| wsrep_cluster_status     | Primary                              |</span><br><span class="line">+--------------------------+--------------------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure><p>特别注意，在正常情况下以下指标值，在所有节点应该都是一致的。</p><table><thead><tr><th>指标</th><th>说明</th></tr></thead><tbody><tr><td><code>wsrep_cluster_state_uuid</code></td><td>在集群所有节点中该值应该是相同的，若有不同值，说明该节点没有连入集群。</td></tr><tr><td><code>wsrep_cluster_conf_id</code></td><td>在集群所有节点中该值应该是相同的，若有不同值，说明该节点被临时 <code>分区</code> 了，当节点之间网络连接恢复后，该值应该恢复成一致。</td></tr><tr><td><code>wsrep_cluster_size</code></td><td>如果与集群中的节点数一致，说明所有节点已经连接。</td></tr><tr><td><code>wsrep_cluster_status</code></td><td>集群状态，若不为 <code>Primary</code>，说明出现 <code>分区</code> 或是 <code>split-brain</code> 状况。</td></tr></tbody></table><h4 id="集群节点状态检查"><a href="#集群节点状态检查" class="headerlink" title="集群节点状态检查"></a>集群节点状态检查</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status <span class="built_in">where</span> variable_name <span class="keyword">in</span> (<span class="string">'wsrep_ready'</span>,<span class="string">'wsrep_connected'</span>,<span class="string">'wsrep_local_state_comment'</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+--------+</span><br><span class="line">| Variable_name             | Value  |</span><br><span class="line">+---------------------------+--------+</span><br><span class="line">| wsrep_connected           | ON     |</span><br><span class="line">| wsrep_local_state_comment | Synced |</span><br><span class="line">| wsrep_ready               | ON     |</span><br><span class="line">+---------------------------+--------+</span><br></pre></td></tr></tbody></table></figure><p>特别注意，在正常情况下以下指标值，在所有节点应该都是一致的。</p><table><thead><tr><th>指标</th><th>说明</th></tr></thead><tbody><tr><td><code>wsrep_ready</code></td><td>该值为 <code>ON</code>，则说明可以接受 SQL 负载；如果为 <code>OFF</code>，则需要检查 <code>wsrep_connected</code>。</td></tr><tr><td><code>wsrep_connected</code></td><td>如果该值为 <code>OFF</code>，且 <code>wsrep_ready</code> 的值也为 <code>OFF</code>，则说明该节点没有连入集群，可能是 <code>wsrep_cluster_address</code> 或 <code>wsrep_cluster_name</code> 等配置错误造成的，具体需要排查 MySQL 的错误日志。</td></tr><tr><td><code>wsrep_local_state_comment</code></td><td>若 <code>wsrep_connected</code> 为 <code>ON</code>，但 <code>wsrep_ready</code> 为 <code>OFF</code>，则可以从该项查找错误原因。</td></tr></tbody></table><h4 id="集群健康信息检查"><a href="#集群健康信息检查" class="headerlink" title="集群健康信息检查"></a>集群健康信息检查</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status <span class="built_in">where</span> variable_name <span class="keyword">in</span> (<span class="string">'wsrep_flow_control_paused'</span>,<span class="string">'wsrep_cert_deps_distance'</span>,<span class="string">'wsrep_flow_control_sent'</span>,<span class="string">'wsrep_local_recv_queue_avg'</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| wsrep_cert_deps_distance   | 1     |</span><br><span class="line">| wsrep_flow_control_paused  | 0     |</span><br><span class="line">| wsrep_flow_control_sent    | 0     |</span><br><span class="line">| wsrep_local_recv_queue_avg | 0     |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>指标</th><th>说明</th></tr></thead><tbody><tr><td><code>wsrep_flow_control_paused</code></td><td>表示数据复制停止了多长时间（即因 Slave 延迟而慢的程度，取值范围为 0 ~ 1，越靠近 0 越好，值为 1 表示数据复制完全停止（停止广播），可优化 <code>wsrep_slave_threads</code> 的值来改善）。</td></tr><tr><td><code>wsrep_cert_deps_distance</code></td><td>表示有多少事务可以并行应用处理，<code>wsrep_slave_threads</code> 设置的值不应该高出该值太多。</td></tr><tr><td><code>wsrep_flow_control_sent</code></td><td>表示该节点已经停止复制了多少次。</td></tr><tr><td><code>wsrep_local_recv_queue_avg</code></td><td>表示 Slave 事务队列的平均长度，可作为 Slave 瓶颈的预兆。</td></tr></tbody></table><h2 id="Haproxy-Keepalived-双机热备"><a href="#Haproxy-Keepalived-双机热备" class="headerlink" title="Haproxy + Keepalived 双机热备"></a>Haproxy + Keepalived 双机热备</h2><p>在本节中，将使用 Haproxy + Keepalived 实现双机热备方案，其中 Haproxy 负责将请求转发给 PXC 集群各个节点。值得一提的，Haproxy 与 Keepalived 的部署规划如下表所示：</p><table><thead><tr><th>节点名称</th><th>主机名</th><th> IP</th><th> 系统</th><th>说明</th></tr></thead><tbody><tr><td> Haproxy 节点一</td><td> haproxy-node-1</td><td>192.168.1.235</td><td>Debian 11 (Bullseye)</td><td>Haproxy + Keepalived</td></tr><tr><td>Haproxy 节点二</td><td> haproxy-node-2</td><td>192.168.1.239</td><td>Debian 11 (Bullseye)</td><td>Haproxy + Keepalived</td></tr></tbody></table><h3 id="双机热备架构"><a href="#双机热备架构" class="headerlink" title="双机热备架构"></a>双机热备架构</h3><p><img data-src="../../../asset/2023/10/mysql-pxc8-6.png"></p><h3 id="创建数据库用户"><a href="#创建数据库用户" class="headerlink" title="创建数据库用户"></a>创建数据库用户</h3><p>在本节中，将创建 MySQL 用户，Haproxy 后续会使用这个用户对 PXC 集群节点进行心跳检测。</p><ul><li>登录任意一个 PXC 集群节点的数据库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">sudo mysql -h localhost -u root -p</span><br></pre></td></tr></tbody></table></figure><ul><li>创建数据库用户 <code>haproxy</code>，不指定密码和权限，只允许远程访问 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">CREATE USER <span class="string">'haproxy'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限信息</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户列表</span></span><br><span class="line">SELECT host, user, plugin, authentication_string FROM mysql.user;</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>MySQL 8.0 默认使用的加密规则是 <code>caching_sha2_password</code>，为了让 Haproxy 可以对 PXC 集群节点进行心跳检测，在创建数据库用户时，必须指定加密规则为 <code>mysql_native_password</code>，否则 Haproxy 无法正常检测 PXC 集群节点的运行状态。</p></div><h3 id="Haproxy-安装"><a href="#Haproxy-安装" class="headerlink" title="Haproxy 安装"></a>Haproxy 安装</h3><p>在本节中，将在两个单独的服务器节点上分别安装 Haproxy 服务（两个节点的安装步骤和配置内容基本一致），实现对 PXC 集群的负载均衡。</p><ul><li>安装 Haproxy</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt-get install -y haproxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> haproxy</span><br></pre></td></tr></tbody></table></figure><ul><li>配置 Haproxy</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份Haproxy的配置文件</span></span><br><span class="line">sudo cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Haproxy的配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    # 工作目录</span><br><span class="line">    # chroot /usr/local/etc/haproxy</span><br><span class="line">    # 日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info</span><br><span class="line">    log 127.0.0.1 local5 info</span><br><span class="line">    # 以守护进程运行</span><br><span class="line">    daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    log    global</span><br><span class="line">    mode    http</span><br><span class="line">    # 日志格式</span><br><span class="line">    option    httplog</span><br><span class="line">    # 日志中不记录负载均衡的心跳检测记录</span><br><span class="line">    option    dontlognull</span><br><span class="line">    # 连接超时（毫秒）</span><br><span class="line">    timeout connect 5000</span><br><span class="line">    # 客户端超时（毫秒）</span><br><span class="line">    timeout client  50000</span><br><span class="line">    # 服务器超时（毫秒）</span><br><span class="line">    timeout server  50000</span><br><span class="line"></span><br><span class="line"># 监控界面    </span><br><span class="line">listen  admin_stats</span><br><span class="line">    # 监控界面的访问的IP和端口</span><br><span class="line">    bind  0.0.0.0:8888</span><br><span class="line">    # 访问协议</span><br><span class="line">    mode        http</span><br><span class="line">    # URI相对地址</span><br><span class="line">    stats uri   /dbs</span><br><span class="line">    # 统计报告格式</span><br><span class="line">    stats realm     Global\ statistics</span><br><span class="line">    # 登陆账户信息</span><br><span class="line">    stats auth  admin:admin</span><br><span class="line"># 数据库负载均衡</span><br><span class="line">listen  proxy-pxc</span><br><span class="line">    # 访问的IP和端口</span><br><span class="line">    bind  0.0.0.0:3306</span><br><span class="line">    # 网络协议</span><br><span class="line">    mode  tcp</span><br><span class="line">    # 负载均衡算法（轮询算法）</span><br><span class="line">    # 轮询算法：roundrobin</span><br><span class="line">    # 权重算法：static-rr</span><br><span class="line">    # 最少连接算法：leastconn</span><br><span class="line">    # 请求源IP算法：source </span><br><span class="line">    balance  roundrobin</span><br><span class="line">    # 日志格式</span><br><span class="line">    option  tcplog</span><br><span class="line">    # Haproxy使用MySQL的haproxy账户对数据库进行心跳检测</span><br><span class="line">    option  mysql-check user haproxy</span><br><span class="line">    server  PXC_Node_1 192.168.1.188:3306 check weight 1 maxconn 2000  </span><br><span class="line">    server  PXC_Node_2 192.168.1.193:3306 check weight 1 maxconn 2000  </span><br><span class="line">    server  PXC_Node_3 192.168.1.223:3306 check weight 1 maxconn 2000 </span><br><span class="line">    # 使用Keepalived检测死链</span><br><span class="line">    option  tcpka</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">Haproxy 配置说明</p><ul><li><code>bind  0.0.0.0:8888</code>： <code>8888</code> 端口用于 Haproxy 提供监控界面的 Web 服务。</li><li><code>bind  0.0.0.0:3306</code>： <code>3306</code> 端口用于 Haproxy 转发请求给 PXC 集群节点。</li><li><code>option  mysql-check user haproxy</code>： 指定 Haproxy 使用 MySQL 的 <code>haproxy</code> 账户对 PXC 集群节点进行心跳检测。</li></ul></div><ul><li>重启 Haproxy</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启</span></span><br><span class="line">sudo systemctl restart haproxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">sudo systemctl status haproxy</span><br></pre></td></tr></tbody></table></figure><ul><li>测试 Haproxy</li></ul><p>使用浏览器访问不同节点的 Haproxy 监控页面（如下图所示），登录用户名是 <code>admin</code>，登录密码是 <code>admin</code>。如果可以正常访问 Haproxy 的监控界面，则说明 Haproxy 成功部署。</p><ul><li>Haproxy 节点一的监控页面： <code>http://192.168.1.235:8888/dbs</code></li><li>Haproxy 节点二的监控页面： <code>http://192.168.1.239:8888/dbs</code></li></ul><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-6.png"></p><h3 id="Keepalived-安装"><a href="#Keepalived-安装" class="headerlink" title="Keepalived 安装"></a>Keepalived 安装</h3><p>在本节中，将在两个单独的 Haproxy 服务器节点上分别安装 Keepalived 服务，实现 Haproxy + Keepalived 的双机热备方案。</p><div class="admonition note"><p class="admonition-title">提示</p><p>Keepalived 安装完成后，默认会将配置模板文件存放在 <code>/usr/share/doc/keepalived/samples/</code> 目录下。</p></div><h4 id="Haproxy-节点一安装-Keepalived"><a href="#Haproxy-节点一安装-Keepalived" class="headerlink" title="Haproxy 节点一安装 Keepalived"></a>Haproxy 节点一安装 Keepalived</h4><ul><li>安装 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt-get install -y keepalived</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> keepalived</span><br></pre></td></tr></tbody></table></figure><ul><li>配置 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或编辑Keepalived的配置文件，写入以下配置内容（请自行更改网卡设备参数）</span></span><br><span class="line">sudo vim /etc/keepalived/keepalived.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance  VI_1 {</span><br><span class="line">    state  MASTER           # 必填，Keepalived 的身份（MASTER 是主服务器，BACKUP 是备服务器）</span><br><span class="line">    interface  enp0s3       # 必填，系统的网卡设备，虚拟 IP 所在</span><br><span class="line">    virtual_router_id  51   # 必填，虚拟路由标识，取值在0-255之间，用来区分多个Instance的VRRP组播，同一网段内ID不能重复，主备机器的该值必须为一样</span><br><span class="line">    priority  100           # 必填，用来选举Master的，MASTER 权重要高于 BACKUP，数字越大优先级越高，该项取值范围是1-255（在此范围之外会被识别成默认值100）</span><br><span class="line">    advert_int  1           # 必填，MASTER 和 BACKUP 节点同步检查的时间间隔（单位为秒），主备之间必须一致，可以认为是健康检查的时间间隔</span><br><span class="line">    authentication {        # 必填，主备服务器的验证方式，主备之间必须使用相同的密码才能正常通信</span><br><span class="line">        auth_type  PASS     # 必填，主备服务器的认证方式，其中有两种方式PASS和HA（IPSEC），推荐使用PASS（密码只识别前8位），主备之间必须使用相同的密码才能正常通信</span><br><span class="line">        auth_pass  123456</span><br><span class="line">    }</span><br><span class="line">    virtual_ipaddress {     # 必填，虚拟 IP，可以设置多个虚拟 IP 地址，每行一个</span><br><span class="line">        192.168.1.173</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>启动 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">sudo systemctl start keepalived</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">sudo systemctl status keepalived</span><br></pre></td></tr></tbody></table></figure><h4 id="Haproxy-节点二安装-Keepalived"><a href="#Haproxy-节点二安装-Keepalived" class="headerlink" title="Haproxy 节点二安装 Keepalived"></a>Haproxy 节点二安装 Keepalived</h4><ul><li>安装 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt-get install -y keepalived</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> keepalived</span><br></pre></td></tr></tbody></table></figure><ul><li>配置 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或编辑Keepalived的配置文件，写入以下配置内容（请自行更改网卡设备参数）</span></span><br><span class="line">sudo vim /etc/keepalived/keepalived.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance  VI_1 {</span><br><span class="line">    state  BACKUP           # 必填，Keepalived 的身份（MASTER 是主服务器，BACKUP 是备服务器）</span><br><span class="line">    interface  enp0s3       # 必填，系统的网卡设备，虚拟 IP 所在</span><br><span class="line">    virtual_router_id  51   # 必填，虚拟路由标识，取值在0-255之间，用来区分多个Instance的VRRP组播，同一网段内ID不能重复，主备机器的该值必须为一样</span><br><span class="line">    priority  90            # 必填，用来选举Master的，MASTER 权重要高于 BACKUP，数字越大优先级越高，该项取值范围是1-255（在此范围之外会被识别成默认值100）</span><br><span class="line">    advert_int  1           # 必填，MASTER 和 BACKUP 节点同步检查的时间间隔（单位为秒），主备之间必须一致，可以认为是健康检查的时间间隔</span><br><span class="line">    authentication {        # 必填，主备服务器的验证方式，主备之间必须使用相同的密码才能正常通信</span><br><span class="line">        auth_type  PASS     # 必填，主备服务器的认证方式，其中有两种方式PASS和HA（IPSEC），推荐使用PASS（密码只识别前8位），主备之间必须使用相同的密码才能正常通信</span><br><span class="line">        auth_pass  123456</span><br><span class="line">    }</span><br><span class="line">    virtual_ipaddress {     # 必填，虚拟 IP，可以设置多个虚拟 IP 地址，每行一个</span><br><span class="line">        192.168.1.173</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>启动 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">sudo systemctl start keepalived</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">sudo systemctl status keepalived</span><br></pre></td></tr></tbody></table></figure><h3 id="双机热备方案测试"><a href="#双机热备方案测试" class="headerlink" title="双机热备方案测试"></a>双机热备方案测试</h3><ul><li>在其他电脑上，如果可以通过虚拟 IP <code>192.168.1.173</code> 正常访问 Haproxy 的 <code>8888</code> 与 <code>3306</code> 端口，则说明 PXC + Haproxy + Keepalived 的高可用集群搭建成功。</li></ul><table><thead><tr><th>测试内容</th><th>虚拟 IP</th><th> 端口</th><th>测试命令</th></tr></thead><tbody><tr><td> Haproxy 的监控页面</td><td> 192.168.1.173</td><td>8888</td><td><code>curl -basic -u admin:admin -I http://192.168.1.173:8888/dbs</code></td></tr><tr><td>Haproxy 的 MySQL 负载均衡</td><td> 192.168.1.173</td><td>3306</td><td><code>mysql -h 192.168.1.173 -u uatOption -P 3306 -p</code></td></tr></tbody></table><ul><li>通过 SSH 分别登录进两台 Haproxy 服务器，检查两个 Keepalived 节点之间是否可以正常进行心跳通信。如果不能进行心跳通信，则会发生脑裂现象（即两个 Keepalived 节点会同时抢占到虚拟 IP）。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看IP地址</span></span><br><span class="line">ip addr</span><br></pre></td></tr></tbody></table></figure><ul><li>关闭 Haproxy 节点一服务器上的 Keepalived 服务，然后在其他电脑上，打开浏览器访问 <code>http://192.168.1.173:8888/dbs</code>。如果可以正常访问 Haproxy 的监控页面，则说明 Haproxy + Keepalived 的双机热备方案生效了。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭Keepalived服务</span></span><br><span class="line">sudo systemctl stop keepalived</span><br></pre></td></tr></tbody></table></figure><ul><li>在 Haproxy 节点一服务器上的 Keepalived 服务关闭之后，通过 SSH 登录进 Haproxy 节点二服务器，使用 <code>ip addr</code> 命令查看 IP 地址，可以观察到 Haproxy 节点二服务器已经抢占到虚拟 IP。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看IP地址</span></span><br><span class="line">ip addr</span><br></pre></td></tr></tbody></table></figure><h3 id="双机热备方案完善"><a href="#双机热备方案完善" class="headerlink" title="双机热备方案完善"></a>双机热备方案完善</h3><p>第一个问题：上述两个 Haproxy 服务器内的 Keepalived 服务，彼此仅仅是基于心跳检测来实现双机热备（故障切换）。如果第一个 Haproxy 服务器内的 Keepalived 服务（Master）正常运行，而 Haproxy 自身运行异常，那么将会出现 Haproxy 负载均衡服务失效，无法切换到备用的 Haproxy 负载均衡器上，最终导致后端的 Web 服务无法收到响应。所以，<strong>应该是要基于 Shell 脚本每隔一段时间检测 Haproxy 服务是否正常运行，而不是仅仅依靠 Keepalived 主备节点之间的心跳检测。</strong>比如，当检测到 Haproxy 服务不是正常运行，首先尝试启动 Haproxy 服务；若 Haproxy 服务重启失败，就应该关闭掉该节点上的 Keepalived 服务，并发送报警邮件，这样才能自动切换到 Keepalived 服务的 Backup 节点上。详细的解决方案建议参考 <a href="/posts/503c34e4.html#Keepalived-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE">这里</a> 的教程。</p><hr><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/9370579.html">Haproxy 代理 MySQL 要考虑的问题</a></li></ul></div><p>第二个问题：Haproxy 代理 MySQL 的时候，事务持久性的问题必须解决。这个事务持久性不是 ACID 的 D（持久性，Durability），而是 Transaction Persistent，这里简单描述一下此处的事务持久性。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction</span><br><span class="line">update1...</span><br><span class="line">update2...</span><br><span class="line">insert3...</span><br><span class="line">commit</span><br></pre></td></tr></tbody></table></figure><p>当客户端显式开启一个事务，然后执行上述几个数据库操作，然后提交或回滚。如果使用代理软件（如 Haproxy）对 MySQL 进行代理，必须要保证这 5 个语句全都路由到同一个 MySQL 节点上，即使后端的 MySQL 采用的是多主模型（MGR、Galera 都提供多主模型），否则事务中各语句分散，轻则返回失败，重则数据不一致、提交混乱。这就是 Transaction Persistent 的概念，即让同一个事务路由到同一个后端节点。Haproxy 如何保证事务持久性呢？对于非 MySQL 协议感知的代理（LVS、Nginx、Haproxy 等），要保证事务持久性，只能通过间接的方法实现，比较通用的方法是在代理软件上监听不同的端口（实现读写分离）。具体的思路如下：</p><ul><li>1）在 Haproxy 上监听不同端口，例如 <code>3307</code> 端口的请求作为写端口，<code>3306</code> 端口的请求作为读端口。</li><li>2）从后端 MySQL 节点中选一个节点 (只能是一个) 作为逻辑写节点，Haproxy 将 <code>3307</code> 端口的请求全都路由给这个节点。</li><li>3）可以在 Haproxy 上配置多个备用写节点 (Backup)，但 <code>3307</code> 端口在某一时刻，路由到的必须只能有一个写节点。</li></ul><p>这样能保证事务的持久性，也能解决一些乐观锁问题。但是，如果后端是多主模型的 MGR（组复制）或 Galera，这样的代理方式将强制变为单主模型，虽然是逻辑上的强制。当然，这并非什么问题，至少到目前为止的开源技术，都建议采用单主模型。Haproxy 保证事务持久性的配置示例如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">listen  haproxy_3306_read_multi</span><br><span class="line">        bind *:3306</span><br><span class="line">        mode tcp</span><br><span class="line">        timeout client  10800s</span><br><span class="line">        timeout server  10800s</span><br><span class="line">        balance leastconn</span><br><span class="line">        option httpchk</span><br><span class="line">        option allbackups</span><br><span class="line">        default-server port 9200 inter 2s downinter 5s rise 3 fall 2 slowstart 60s maxconn 64 maxqueue 128 weight 100</span><br><span class="line">        server galera1 192.168.55.111:3306 check</span><br><span class="line">        server galera2 192.168.55.112:3306 check</span><br><span class="line">        server galera3 192.168.55.113:3306 check</span><br><span class="line"> </span><br><span class="line">listen  haproxy_3307_write_single</span><br><span class="line">        bind *:3307</span><br><span class="line">        mode tcp</span><br><span class="line">        timeout client  10800s</span><br><span class="line">        timeout server  10800s</span><br><span class="line">        balance leastconn</span><br><span class="line">        option httpchk</span><br><span class="line">        option allbackups</span><br><span class="line">        default-server port 9200 inter 2s downinter 5s rise 3 fall 2 slowstart 60s maxconn 64 maxqueue 128 weight 100</span><br><span class="line">        server galera1 192.168.55.111:3306 check</span><br><span class="line">        server galera2 192.168.55.112:3306 check backup</span><br><span class="line">        server galera3 192.168.55.113:3306 check backup</span><br></pre></td></tr></tbody></table></figure><p>上面的配置通过 <code>3306</code> 端口和 <code>3307</code> 端口进行读写分离，并且在负责写的 <code>3307</code> 端口中只有一个节点可写，其余两个节点作为 Backup 节点。对于 MySQL 的负载来说，更建议采用 MySQL 协议感知的程序来实现，例如 MySQL Router、ProxySql，MaxScale、MyCat 等数据库中间件。</p><h2 id="PXC-集群运维"><a href="#PXC-集群运维" class="headerlink" title="PXC 集群运维"></a>PXC 集群运维</h2><h3 id="查看错误日志"><a href="#查看错误日志" class="headerlink" title="查看错误日志"></a>查看错误日志</h3><p>PXC 集群使用的是 Percona Server 数据库，它是 MySQL 的衍生版本，因此 PXC 集群节点的很多操作跟 MySQL 一样，其错误日志信息存放在每个节点的 <code>/var/log/mysql/error.log</code> 文件里面。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看错误日志文件</span></span><br><span class="line">sudo vi /var/<span class="built_in">log</span>/mysql/error.log</span><br></pre></td></tr></tbody></table></figure><h3 id="正确关闭集群"><a href="#正确关闭集群" class="headerlink" title="正确关闭集群"></a>正确关闭集群</h3><p>如果第一个节点（负责集群初始化）不是最后一个离开集群的，那么它在一般情况下就不能再以第一个节点的形式启动了。这是因为从这个节点引导集群启动可能是不安全的，即这个节点可能不包含所有更新的数据。<strong>综上所述，PXC 集群节点的正确关闭顺序，应该与它们的启动顺序相反（类似栈结构 - 先进后出），即最先启动的节点应该最后关闭。</strong></p><ul><li>启动集群 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动第一个节点</span></span><br><span class="line">sudo systemctl start mysql@bootstrap.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动第二个节点（必须等待第一个节点启动完成再启动）</span></span><br><span class="line">sudo systemctl start mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动第三个节点（必须等待第一个节点启动完成再启动）</span></span><br><span class="line">sudo systemctl start mysql</span><br></pre></td></tr></tbody></table></figure><ul><li>关闭集群 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭第三个节点</span></span><br><span class="line">sudo systemctl stop mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭第二个节点</span></span><br><span class="line">sudo systemctl stop mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭第一个节点</span></span><br><span class="line">sudo systemctl stop mysql@bootstrap.service</span><br></pre></td></tr></tbody></table></figure><h3 id="节点动态下线"><a href="#节点动态下线" class="headerlink" title="节点动态下线"></a>节点动态下线</h3><p>PXC 集群允许动态下线节点，但需要注意的是节点的启动命令和关闭命令必须一致；比如使用 <code>mysql@bootstrap.service</code> 服务启动的第一个节点服务器（负责集群初始化），在它关闭时也必须使用 <code>mysql@bootstrap.service</code> 服务来操作（<strong>该结论有待验证</strong>）。</p><ul><li>第一个节点上下线 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个节点下线</span></span><br><span class="line">sudo systemctl stop mysql@bootstrap.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个节点上线</span></span><br><span class="line">sudo systemctl start mysql@bootstrap.service</span><br></pre></td></tr></tbody></table></figure><ul><li>其他节点上下线 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他节点下线</span></span><br><span class="line">sudo service stop mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他节点上线</span></span><br><span class="line">sudo service start mysql</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>由于 PXC 集群的所有节点都是对等的，所以下线第一个节点和下线其他节点在效果上都是相同的。</p></div><h3 id="单节点的操作系统重启"><a href="#单节点的操作系统重启" class="headerlink" title="单节点的操作系统重启"></a>单节点的操作系统重启</h3><p><strong>特别注意，当 PXC 集群中某个节点所在的 Debian 系统重启后，PXC 会自动将该节点的 MySQL 服务从集群中剔除（因为节点不可用了），以此保证高可用，但该节点的 MySQL 服务后续是不会自动启动的。</strong>也就是说，等 Debian 系统重启完成后，必须手动启动该节点上的 MySQL 服务。此时只要确保 PXC 集群中至少有一个节点存活着，那么就不需要再重新初始化 PXC 集群（引导 PXC 集群启动），因此无论等待重启的节点是第一个节点（负责集群初始化），还是其他节点，都可以直接使用 <code>mysql</code> 服务进行启动。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启意外关闭的节点</span></span><br><span class="line">sudo service start mysql</span><br></pre></td></tr></tbody></table></figure><h3 id="集群断电重启，第一个节点启动失败"><a href="#集群断电重启，第一个节点启动失败" class="headerlink" title="集群断电重启，第一个节点启动失败"></a>集群断电重启，第一个节点启动失败</h3><ul><li>PXC 集群的三台节点服务器都突然断电重启了（即所有集群节点几乎都在同一时刻意外关闭），等服务器上的 Debian 系统相继重新启动完成后，无法使用以下命令正常启动第一个节点服务器（负责集群初始化）上的 MySQL 服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动第一个节点</span></span><br><span class="line">sudo systemctl start mysql@bootstrap.service</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个节点启动的错误信息</span></span><br><span class="line">systemctl start mysql@bootstrap.service Job <span class="keyword">for</span> mysql@bootstrap.service failed because the control process exited with error code. See <span class="string">"systemctl status mysql@bootstrap.service"</span> and <span class="string">"journalctl -xe"</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></tbody></table></figure><ul><li>首先使用以下几种方式，查看 MySQL 的日志信息 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统日志信息</span></span><br><span class="line">journalctl -xe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看MySQL的错误日志文件</span></span><br><span class="line">sudo vi /var/<span class="built_in">log</span>/mysql/error.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看MySQL的运行状态信息</span></span><br><span class="line">sudo systemctl status mysql@bootstrap.service</span><br></pre></td></tr></tbody></table></figure><ul><li>进一步在 MySQL 的错误日志文件中，发现了以下错误内容（留意 ERROR 部分）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2023-10-26T22:13:35.822653Z 0 [Note] [MY-000000] [Galera] ####### Assign initial position for certification: e4bb8bf0-73d5-11ee-b279-3a5ebcc11ef7:29, protocol version: -1</span><br><span class="line">2023-10-26T22:13:35.822752Z 0 [Note] [MY-000000] [WSREP] Starting replication</span><br><span class="line">2023-10-26T22:13:35.822790Z 0 [Note] [MY-000000] [Galera] Connecting with bootstrap option: 1</span><br><span class="line">2023-10-26T22:13:35.822809Z 0 [Note] [MY-000000] [Galera] Setting GCS initial position to e4bb8bf0-73d5-11ee-b279-3a5ebcc11ef7:29</span><br><span class="line">2023-10-26T22:13:35.822823Z 0 [ERROR] [MY-000000] [Galera] It may not be safe to bootstrap the cluster from this node. It was not the last one to leave the cluster and may not contain all the updates. To force cluster bootstrap with this node, edit the grastate.dat file manually and set safe_to_bootstrap to 1 .</span><br><span class="line">2023-10-26T22:13:35.822844Z 0 [ERROR] [MY-000000] [WSREP] Provider/Node (gcomm://192.168.1.188,192.168.1.193,192.168.1.223) failed to establish connection with cluster (reason: 7)</span><br><span class="line">2023-10-26T22:13:35.822855Z 0 [ERROR] [MY-010119] [Server] Aborting</span><br><span class="line">2023-10-26T22:13:35.823148Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.33-25.1)  Percona XtraDB Cluster (GPL), Release rel25, Revision 0c56202, WSREP version 26.1.4.3.</span><br><span class="line">2023-10-26T22:13:35.824298Z 0 [ERROR] [MY-010065] [Server] Failed to shutdown components infrastructure.</span><br></pre></td></tr></tbody></table></figure><p>意思是从这个节点引导集群启动可能是不安全。由于该节点不是最后一个离开集群的节点（最后停掉的节点），可能不包含所有更新的数据。要强制使用该节点进行集群引导，请手动编辑该节点的 <code>grastate.dat</code> 文件，并将 <code>safe_to_bootstrap</code> 参数设置为 <code>1</code>。当然了，一般情况下不需要强制从该节点启动，可以逐一排查每个节点下的 <code>grastate.dat</code> 文件，找到 <code>safe_to_bootstrap=1</code> 的节点，然后在该节点上引导 PXC 集群启动即可。如果所有节点的 <code>safe_to_bootstrap</code> 都为 <code>0</code>，那么只能任意选择一个节点，更改该节点下的 <code>grastate.dat</code> 文件，将 <code>safe_to_bootstrap</code> 设置为 <code>1</code>，然后在该节点上引导 PXC 集群启动。<strong>特别注意，引导 PXC 集群启动（第一个节点）使用的是 <code>sudo systemctl start mysql@bootstrap.service</code> 命令，而启动其他节点使用的则是 <code>sudo systemctl start mysql</code> 命令。必须等待第一个节点启动成功，也就是 PXC 集群初始化完成之后，才能接着启动其他节点，最后再检查集群的数据是否可以正常同步。</strong></p><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>grastate.dat</code> 文件的完整路径是 <code>/var/lib/mysql/grastate.dat</code>。</li><li>在第一个节点服务器上引导 PXC 集群启动（即集群初始化）的命令是 <code>sudo systemctl start mysql@bootstrap.service</code>，其他节点的 MySQL 服务启动命令则是 <code>sudo systemctl start mysql</code>。</li></ul></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.jiangguo.net/c/mog/1w2.html">CentOS 搭建 PXC 5.7 集群</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/9370579.html">Haproxy 代理 MySQL 要考虑的问题</a></li><li><a href="https://docs.morpheusdata.com/en/5.5.1/getting_started/installation/distributed/full/perconaTls-ubuntu.html">Debian/Ubuntu Percona XtraDB Cluster with TLS</a></li><li><a href="https://www.howtoforge.com/how-to-install-percona-xtradb-cluster-on-debian-11/">How to Install Percona XtraDB Cluster on Debian 11</a></li><li><a href="http://blog.itpub.net/30310891/viewspace-2772587/">基于 Centos 7 部署 Percona Xtradb Cluster 5.7 高可用架构</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何在生产环境的 Debian 11 系统上部署 MySQL 的 PXC 8.0 集群，并基于 Haproxy + Keepalived 实现双机热备方案。</summary>
    
    
    
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>Docker 部署 PXC 8.0 单机集群</title>
    <link href="https://www.techgrow.cn/posts/8dc5e7ed.html"/>
    <id>https://www.techgrow.cn/posts/8dc5e7ed.html</id>
    <published>2023-10-26T12:13:32.000Z</published>
    <updated>2023-10-26T12:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍如何使用 Docker 部署 Percona XtraDB Cluster 8.0 集群（单机三个节点），并详细介绍集群可用性的验证。</p><h3 id="系列教程"><a href="#系列教程" class="headerlink" title="系列教程"></a>系列教程</h3><ul><li><a href="/posts/aba17375.html">Docker 部署 PXC 5.7 单机集群</a></li><li><a href="/posts/8dc5e7ed.html">Docker 部署 PXC 8.0 单机集群</a></li><li><a href="/posts/ff0f2d6.html">Debian 11 生产环境部署 PXC 8.0 集群</a></li></ul><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ul><li><a href="https://docs.percona.com/percona-xtradb-cluster/8.0/">Percona Xtradb Cluster 8.0 官方文档</a></li></ul><h2 id="PXC-集群介绍"><a href="#PXC-集群介绍" class="headerlink" title="PXC 集群介绍"></a>PXC 集群介绍</h2><div class="admonition note"><p class="admonition-title">提示</p><p>Percona Xtradb Cluster (PXC) 的详细介绍请看 <a href="/posts/cc846db2.html#Percona-XtraDB-Cluster">这里</a> 的教程。</p></div><span id="more"></span><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/wanglei957/p/11819547.html">Docker 部署 MySQL 集群</a></li><li><a href="https://cloud.tencent.com/developer/article/1929627">CentOS 7 部署 PXC 集群 【Docker + 单机多节点】</a></li><li><a href="https://www.cnblogs.com/ll409546297/p/17129532.html">MySQL 之 PXC 集群模式（Docker + MySQL + PXC 实现）</a></li><li><a href="https://www.cnblogs.com/nhdlb/p/14032657.html">Docker 部署 PXC 5.7 集群 - 搭建负载均衡实现双机热部署方案</a></li><li><a href="https://www.cnblogs.com/pengboke/p/15012571.html#node3">Docker 部署 PXC 集群 (Haproxy 负载均衡、Keepalived 高可用、XtraBackup 数据备份)</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 Docker 部署 MySQL 的 PXC 8.0 单机集群。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Docker 部署 PXC 5.7 单机集群</title>
    <link href="https://www.techgrow.cn/posts/aba17375.html"/>
    <id>https://www.techgrow.cn/posts/aba17375.html</id>
    <published>2023-10-24T12:13:32.000Z</published>
    <updated>2023-11-12T12:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍如何使用 Docker 部署 Percona XtraDB Cluster 5.7 集群（单机三个节点），并基于 Haproxy + Keepalived 实现双机热备方案。</p><h3 id="系列教程"><a href="#系列教程" class="headerlink" title="系列教程"></a>系列教程</h3><ul><li><a href="/posts/aba17375.html">Docker 部署 PXC 5.7 单机集群</a></li><li><a href="/posts/8dc5e7ed.html">Docker 部署 PXC 8.0 单机集群</a></li><li><a href="/posts/ff0f2d6.html">Debian 11 生产环境部署 PXC 8.0 集群</a></li></ul><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ul><li><a href="https://docs.percona.com/percona-xtradb-cluster/5.7/">Percona Xtradb Cluster 5.7 官方文档</a></li></ul><h2 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h2><h3 id="整体部署架构"><a href="#整体部署架构" class="headerlink" title="整体部署架构"></a>整体部署架构</h3><div class="admonition note"><p class="admonition-title">提示</p><p>PXC + Haproxy + Keepalived 双机热备架构的介绍可以阅读 <a href="/posts/aba17375.html#%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">这里</a> 的内容。</p></div><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-12.png"></p><h3 id="整体部署规划"><a href="#整体部署规划" class="headerlink" title="整体部署规划"></a>整体部署规划</h3><ul><li>软件版本说明</li></ul><table><thead><tr><th>软件</th><th>版本</th><th>描述</th></tr></thead><tbody><tr><td> PXC 镜像</td><td> 5.7.43</td><td></td></tr><tr><td>Haproxy 镜像</td><td> 2.8.3</td><td></td></tr><tr><td>Keepalived 服务</td><td> 1.3.5</td><td></td></tr></tbody></table><ul><li>Docker 部署 PXC 集群（三个节点）+ Haproxy（两个节点 - 主备）</li></ul><table><thead><tr><th>节点名称</th><th>容器名称</th><th>容器 IP</th><th> 容器数据卷</th><th>容器数据卷目录</th><th>操作系统</th></tr></thead><tbody><tr><td> PXC 节点一</td><td> pxc-node1</td><td>172.30.0.2</td><td>pxc-v1</td><td><code>/var/lib/docker/volumes/pxc-v1/_data/</code></td><td>Debian 11</td></tr><tr><td>PXC 节点二</td><td> pxc-node2</td><td>172.30.0.3</td><td>pxc-v2</td><td><code>/var/lib/docker/volumes/pxc-v2/_data/</code></td><td>Debian 11</td></tr><tr><td>PXC 节点三</td><td> pxc-node3</td><td>172.30.0.4</td><td>pxc-v3</td><td><code>/var/lib/docker/volumes/pxc-v3/_data/</code></td><td>Debian 11</td></tr><tr><td>Haproxy 节点一</td><td> haproxy-node1</td><td>172.30.0.5</td><td>haproxy-v1</td><td><code>/var/lib/docker/volumes/haproxy-v1/_data/</code></td><td>Debian 11</td></tr><tr><td>Haproxy 节点二</td><td> haproxy-node2</td><td>172.30.0.6</td><td>haproxy-v2</td><td><code>/var/lib/docker/volumes/haproxy-v2/_data/</code></td><td>Debian 11</td></tr></tbody></table><ul><li>Keepalived 服务器安装</li></ul><table><thead><tr><th>服务器名称</th><th>服务器角色</th><th>虚拟 IP</th><th> 说明</th><th>操作系统</th></tr></thead><tbody><tr><td> Keepalived 服务器一</td><td>主服务器（MASTER）</td><td>172.30.0.7</td><td> 安装在 Haproxy 节点一的容器内（<code>haproxy-node1</code>）</td><td>Debian 11</td></tr><tr><td>Keepalived 服务器二</td><td>备服务器（BACKUP）</td><td>172.30.0.7</td><td> 安装在 Haproxy 节点二的容器内（<code>haproxy-node2</code>）</td><td>Debian 11</td></tr><tr><td>Keepalived 服务器三</td><td></td><td> 192.168.1.160</td><td> 安装在宿主机内，为了实现外网可以正常访问 Docker 容器内的虚拟 IP</td><td>Centos 7</td></tr></tbody></table><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><h3 id="虚拟-IP-概念介绍"><a href="#虚拟-IP-概念介绍" class="headerlink" title="虚拟 IP 概念介绍"></a>虚拟 IP 概念介绍</h3><p>Linux 系统支持在一个网卡中定义多个 IP 地址，并将这些地址分配给多个应用程序，这些地址就是虚拟 IP，基于 Haproxy + Keepalived 的双机热备方案最关键的技术就是虚拟 IP。</p><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-10.png"></p><p>Keepalived 利用了上述 Linux 系统的特性，让多台服务器去获取同一个虚拟 IP，获取到的服务器将虚拟 IP 绑定到自身的网卡，然后接受外部流量；没有抢占到虚拟 IP 的则作为备用服务器，并进行心跳检测，一旦检测到主服务器宕机，则立刻抢占虚拟 IP。</p><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-11.png"></p><h3 id="负载均衡中间件选型"><a href="#负载均衡中间件选型" class="headerlink" title="负载均衡中间件选型"></a>负载均衡中间件选型</h3><p>PXC 集群有三个节点，如果每次都是第一个节点处理请求，那么就存在负载高、性能差、其他节点利用率不高等问题，所以更优的方案是对不同的节点都进行请求。这就需要有负载均衡中间件负责请求转发，主流的中间件有 Nginx、Haproxy 等，两者都支持 TCP/IP 协议，Nginx 额外支持插件，Haproxy 属于是老牌的中间件。在数据库集群的负载均衡领域，Haproxy 会使用的要多一些。不同中间件的对比如下图所示：</p><p><img data-src="../../../asset/2023/10/mysql-docker-pxc-proxy.png"></p><h3 id="Нaproxy-双机热备方案介绍"><a href="#Нaproxy-双机热备方案介绍" class="headerlink" title="Нaproxy 双机热备方案介绍"></a>Нaproxy 双机热备方案介绍</h3><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-12.png"></p><ul><li>Docker 创建两个 Haproxy 容器，每个容器中都单独安装 Keepalived 服务器</li><li>两个 Keepalived 服务器会争抢 Docker 容器内的虚拟 IP，一个抢到后，另一个没抢到就会等待，抢到的作为主服务器，没抢到的作为备用服务器</li><li>两个 Keepalived 服务器之间会进行心跳检测，如果备用服务器没有接收到主服务器的心跳响应，则说明主服务器发生故障，那么备用服务器就可以抢占虚拟 IP，继续工作</li><li>客户端向虚拟 IP 发送数据库请求，当其中一个 Haproxy 节点宕机后，还有另一个 Haproxy 节点可以接替工作</li><li>由于 Docker 容器内的虚拟 IP 不能被外网直接访问，所以需要借助宿主机里的 Keepalived 服务映射成外网可以访问的虚拟 IP</li></ul><span id="more"></span><h2 id="PXC-集群搭建"><a href="#PXC-集群搭建" class="headerlink" title="PXC 集群搭建"></a>PXC 集群搭建</h2><p>在本节中，将通过 Docker 部署 PXC 5.7 集群，其中包含三个集群节点。</p><div class="admonition note"><p class="admonition-title">提示</p><p>Percona Xtradb Cluster (PXC) 的详细介绍请看 <a href="/posts/cc846db2.html#Percona-XtraDB-Cluster">这里</a> 的教程。</p></div><h3 id="部署规划"><a href="#部署规划" class="headerlink" title="部署规划"></a>部署规划</h3><table><thead><tr><th>节点名称</th><th>容器名称</th><th>容器 IP</th><th> 容器数据卷</th><th>容器数据卷目录</th><th>操作系统</th></tr></thead><tbody><tr><td> PXC 节点一</td><td> pxc-node1</td><td>172.30.0.2</td><td>pxc-v1</td><td><code>/var/lib/docker/volumes/pxc-v1/_data/</code></td><td>Debian 11</td></tr><tr><td>PXC 节点二</td><td> pxc-node2</td><td>172.30.0.3</td><td>pxc-v2</td><td><code>/var/lib/docker/volumes/pxc-v2/_data/</code></td><td>Debian 11</td></tr><tr><td>PXC 节点三</td><td> pxc-node3</td><td>172.30.0.4</td><td>pxc-v3</td><td><code>/var/lib/docker/volumes/pxc-v3/_data/</code></td><td>Debian 11</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Percona XtraDB Cluster 要求最小的集群大小是 3 个节点。</li><li>建议尽可能地控制 PXC 集群的规模，节点越多，数据同步速度越慢。</li><li>PXC 存在硬件配置短板限制，即整个集群的写吞吐量受最弱节点的限制。因此所有 PXC 节点的硬件配置要一致，否则如果一个节点变慢，整个集群会跟着变慢。</li></ul></div><h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><ul><li>拉取镜像，官方文档详见 <a href="https://hub.docker.com/r/percona/percona-xtradb-cluster">Docker Hub</a>，镜像的各个版本号可以从 <a href="../../../asset/2023/10/docker-mysql-pxc-1.png">这里</a> 查看 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">sudo docker pull percona/percona-xtradb-cluster:5.7.43</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像打上标签</span></span><br><span class="line">sudo docker tag percona/percona-xtradb-cluster:5.7.43 pxc</span><br></pre></td></tr></tbody></table></figure><ul><li>创建数据卷，存储路径为 <code>/var/lib/docker/volumes/</code></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据卷</span></span><br><span class="line">sudo docker volume create --name pxc-v1</span><br><span class="line">sudo docker volume create --name pxc-v2</span><br><span class="line">sudo docker volume create --name pxc-v3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有数据卷</span></span><br><span class="line">sudo docker volume ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据卷的详细信息</span></span><br><span class="line">sudo docker volume inspect pxc-v1</span><br></pre></td></tr></tbody></table></figure><ul><li>创建网络（专用网段）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">sudo docker network create --subnet=172.30.0.0/24 pxc-network</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有网络</span></span><br><span class="line">sudo docker network ls</span><br></pre></td></tr></tbody></table></figure><ul><li>创建容器，<code>XTRABACKUP_PASSWORD</code> 是 XtraBackup 工具备份数据库数据的密码 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建第一个节点</span></span><br><span class="line">sudo docker create -p 13306:3306 -v pxc-v1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e XTRABACKUP_PASSWORD=123456 -e CLUSTER_NAME=pxc --name=pxc-node1 --net=pxc-network --ip 172.30.0.2 pxc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第二个节点（增加了CLUSTER_JOIN参数）</span></span><br><span class="line">sudo docker create -p 13307:3306 -v pxc-v2:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e XTRABACKUP_PASSWORD=123456 -e CLUSTER_NAME=pxc -e CLUSTER_JOIN=pxc-node1 --name=pxc-node2 --net=pxc-network --ip 172.30.0.3 pxc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第三个节点（增加了CLUSTER_JOIN参数）</span></span><br><span class="line">sudo docker create -p 13308:3306 -v pxc-v3:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e XTRABACKUP_PASSWORD=123456 -e CLUSTER_NAME=pxc -e CLUSTER_JOIN=pxc-node1 --name=pxc-node3 --net=pxc-network --ip 172.30.0.4 pxc</span><br></pre></td></tr></tbody></table></figure><ul><li>启动节点一的容器（必须先启动节点一，等待 PXC 集群初始化操作执行完成后，再启动节点二和节点三的容器）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动节点一</span></span><br><span class="line">sudo docker start pxc-node1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点一的日志信息</span></span><br><span class="line">sudo docker logs -f pxc-node1</span><br></pre></td></tr></tbody></table></figure><ul><li>启动节点二的容器（必须等待节点一启动成功后再启动）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动节点二</span></span><br><span class="line">sudo docker start pxc-node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点二的日志信息</span></span><br><span class="line">sudo docker logs -f pxc-node2</span><br></pre></td></tr></tbody></table></figure><ul><li>启动节点三的容器（必须等待节点一启动成功后再启动）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动节点三</span></span><br><span class="line">sudo docker start pxc-node3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点三的日志信息</span></span><br><span class="line">sudo docker logs -f pxc-node3</span><br></pre></td></tr></tbody></table></figure><h3 id="集群验证"><a href="#集群验证" class="headerlink" title="集群验证"></a>集群验证</h3><h4 id="登录-MySQL"><a href="#登录-MySQL" class="headerlink" title="登录 MySQL"></a>登录 MySQL</h4><ul><li>登录 MySQL 数据库，可以是 PXC 集群中的任意一个节点 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it pxc-node1 /usr/bin/mysql -uroot -p123456</span><br></pre></td></tr></tbody></table></figure><h4 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h4><ul><li>在 PXC 集群的任意一个节点上，执行以下 SQL 语句来查看集群状态 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">'wsrep_cluster%'</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-2.png"></p><h4 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h4><ul><li>在 PXC 集群的任意一个节点上，执行以下 SQL 语句，然后观察其他节点是否同步创建了数据库和表。</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `percona` <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line">USE `percona`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `acl_user` (</span><br><span class="line">  `id` <span class="type">char</span>(<span class="number">19</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'会员id'</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'微信openid'</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'密码'</span>,</span><br><span class="line">  `nick_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'昵称'</span>,</span><br><span class="line">  `salt` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'用户头像'</span>,</span><br><span class="line">  `token` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'用户签名'</span>,</span><br><span class="line">  `is_deleted` tinyint(<span class="number">1</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'逻辑删除 1（true）已删除， 0（false）未删除'</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'创建时间'</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'更新时间'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_username` (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">'用户表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入用户数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `acl_user` <span class="keyword">VALUES</span> (<span class="string">'1'</span>,<span class="string">'admin'</span>,<span class="string">'96e79218965eb72c92a549dd5a330112'</span>,<span class="string">'admin'</span>,<span class="string">''</span>,<span class="keyword">NULL</span>,<span class="number">0</span>,<span class="string">'2018-05-01 10:39:47'</span>,<span class="string">'2018-05-01 10:39:47'</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="Haproxy-负载均衡"><a href="#Haproxy-负载均衡" class="headerlink" title="Haproxy 负载均衡"></a>Haproxy 负载均衡</h2><p>在本节中，将介绍如何使用 Haproxy 作为负载均衡服务器，将请求转发给 PXC 集群中的各个节点。<strong>特别注意，在执行以下操作之前，请先启动 PXC 集群，并确保集群可以正常运行。</strong></p><h3 id="部署规划-1"><a href="#部署规划-1" class="headerlink" title="部署规划"></a>部署规划</h3><table><thead><tr><th>节点名称</th><th>容器名称</th><th>容器 IP</th><th> 容器数据卷</th><th>容器数据卷目录</th><th>操作系统</th></tr></thead><tbody><tr><td> Haproxy 节点一</td><td> haproxy-node1</td><td>172.30.0.5</td><td>haproxy-v1</td><td><code>/var/lib/docker/volumes/haproxy-v1/_data/</code></td><td>Debian 11</td></tr></tbody></table><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>当使用 PXC 集群的单个节点处理所有请求时，存在负载高、性能差、其他节点利用率不高等问题。</p><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-4.png"></p><p>使用 Haproxy 做负载均衡，将请求均匀地分配给 PXC 集群中的每一个节点，单节点负载低、性能高，且所有节点都能利用起来。</p><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-5.png"></p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>在本节中，将创建 MySQL 用户，Haproxy 后续会使用这个用户对 PXC 集群节点进行心跳检测。</p><ul><li>登录 MySQL 数据库，可以是 PXC 集群中的任意一个节点 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it pxc-node1 /usr/bin/mysql -uroot -p123456</span><br></pre></td></tr></tbody></table></figure><ul><li>创建数据库用户 <code>haproxy</code>，不指定密码和权限，只允许远程访问 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">CREATE USER <span class="string">'haproxy'</span>@<span class="string">'%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限信息</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户列表</span></span><br><span class="line">SELECT user, host FROM mysql.user;</span><br></pre></td></tr></tbody></table></figure><h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><ul><li>拉取镜像，官方文档详见 <a href="https://hub.docker.com/_/haproxy">Docker Hub</a></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">sudo docker pull haproxy:2.8.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像打上标签</span></span><br><span class="line">sudo docker tag haproxy:2.8.3 haproxy</span><br></pre></td></tr></tbody></table></figure><ul><li>创建数据卷，存储路径为 <code>/var/lib/docker/volumes/</code></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据卷</span></span><br><span class="line">sudo docker volume create --name haproxy-v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有数据卷</span></span><br><span class="line">sudo docker volume ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据卷的详细信息</span></span><br><span class="line">sudo docker volume inspect haproxy-v1</span><br></pre></td></tr></tbody></table></figure><ul><li>创建 Haproxy 的配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在数据卷目录下创建Haproxy的配置文件</span></span><br><span class="line">sudo touch /var/lib/docker/volumes/haproxy-v1/_data/haproxy.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Haproxy的配置文件，添加以下内容</span></span><br><span class="line">sudo vi /var/lib/docker/volumes/haproxy-v1/_data/haproxy.cfg</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    # 工作目录</span><br><span class="line">    # chroot /usr/local/etc/haproxy</span><br><span class="line">    # 日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info</span><br><span class="line">    log 127.0.0.1 local5 info</span><br><span class="line">    # 以守护进程运行</span><br><span class="line">    daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    log    global</span><br><span class="line">    mode    http</span><br><span class="line">    # 日志格式</span><br><span class="line">    option    httplog</span><br><span class="line">    # 日志中不记录负载均衡的心跳检测记录</span><br><span class="line">    option    dontlognull</span><br><span class="line">    # 连接超时（毫秒）</span><br><span class="line">    timeout connect 5000</span><br><span class="line">    # 客户端超时（毫秒）</span><br><span class="line">    timeout client  50000</span><br><span class="line">    # 服务器超时（毫秒）</span><br><span class="line">    timeout server  50000</span><br><span class="line"></span><br><span class="line"># 监控界面    </span><br><span class="line">listen  admin_stats</span><br><span class="line">    # 监控界面的访问的IP和端口</span><br><span class="line">    bind  0.0.0.0:8888</span><br><span class="line">    # 访问协议</span><br><span class="line">    mode        http</span><br><span class="line">    # URI相对地址</span><br><span class="line">    stats uri   /dbs</span><br><span class="line">    # 统计报告格式</span><br><span class="line">    stats realm     Global\ statistics</span><br><span class="line">    # 登陆账户信息</span><br><span class="line">    stats auth  admin:admin</span><br><span class="line"># 数据库负载均衡</span><br><span class="line">listen  proxy-pxc</span><br><span class="line">    # 访问的IP和端口</span><br><span class="line">    bind  0.0.0.0:3306  </span><br><span class="line">    # 网络协议</span><br><span class="line">    mode  tcp</span><br><span class="line">    # 负载均衡算法（轮询算法）</span><br><span class="line">    # 轮询算法：roundrobin</span><br><span class="line">    # 权重算法：static-rr</span><br><span class="line">    # 最少连接算法：leastconn</span><br><span class="line">    # 请求源IP算法：source </span><br><span class="line">    balance  roundrobin</span><br><span class="line">    # 日志格式</span><br><span class="line">    option  tcplog</span><br><span class="line">    # Haproxy使用MySQL的haproxy账户对数据库进行心跳检测</span><br><span class="line">    option  mysql-check user haproxy</span><br><span class="line">    server  PXC_Node_1 172.30.0.2:3306 check weight 1 maxconn 2000  </span><br><span class="line">    server  PXC_Node_2 172.30.0.3:3306 check weight 1 maxconn 2000  </span><br><span class="line">    server  PXC_Node_3 172.30.0.4:3306 check weight 1 maxconn 2000 </span><br><span class="line">    # 使用Keepalived检测死链</span><br><span class="line">    option  tcpka</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在上述 Haproxy 的配置文件中，不能启用 <code>chroot /usr/local/etc/haproxy</code>，否则 Haproxy 容器会启动失败（日志信息如下），暂时不清楚其原因。</p></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[NOTICE]   (1) : New worker (8) forked</span><br><span class="line">[NOTICE]   (1) : Loading success.</span><br><span class="line">[NOTICE]   (8) : haproxy version is 2.8.3-86e043a</span><br><span class="line">[NOTICE]   (8) : path to executable is /usr/local/sbin/haproxy</span><br><span class="line">[ALERT]    (8) : [haproxy.main()] Cannot chroot(/usr/local/etc/haproxy).</span><br><span class="line">[NOTICE]   (1) : haproxy version is 2.8.3-86e043a</span><br><span class="line">[NOTICE]   (1) : path to executable is /usr/local/sbin/haproxy</span><br><span class="line">[WARNING]  (1) : Current worker (8) exited with code 1 (Exit)</span><br><span class="line">[ALERT]    (1) : exit-on-failure: killing every processes with SIGTERM</span><br><span class="line">[WARNING]  (1) : All workers exited. Exiting... (1)</span><br></pre></td></tr></tbody></table></figure><ul><li>创建并运行 Haproxy 容器，其中的 <code>8888</code> 是 Haproxy 监听的 HTTP 端口（用于提供监控界面的 Web 服务），<code>3306</code> 是 Haproxy 监听的 MySQL 端口（用于转发请求给 PXC 集群节点）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并运行容器</span></span><br><span class="line">sudo docker run -it -p 4001:8888 -p 4002:3306 -v /var/lib/docker/volumes/haproxy-v1/_data/:/usr/<span class="built_in">local</span>/etc/haproxy --privileged --name=haproxy-node1 --net=pxc-network --ip 172.30.0.5 -d haproxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志信息</span></span><br><span class="line">sudo docker logs -f haproxy-node1</span><br></pre></td></tr></tbody></table></figure><h3 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a>部署验证</h3><h4 id="访问监控界面"><a href="#访问监控界面" class="headerlink" title="访问监控界面"></a>访问监控界面</h4><p>在宿主机内使用浏览器访问 <code>http://192.168.1.221:4001/dbs</code>，打开 Haproxy 的监控界面（如下图所示），登录用户名是 <code>admin</code>，登录密码是 <code>admin</code>。如果可以正常访问 Haproxy 的监控界面，则说明 Haproxy 成功部署。</p><div class="admonition note"><p class="admonition-title">提示</p><p>值得一提的是，上述的 <code>192.168.1.221</code> 是宿主机的 IP 地址，<code>4001</code> 是 Haproxy 容器映射的 HTTP 端口。</p></div><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-6.png"></p><h4 id="连接-PXC-集群"><a href="#连接-PXC-集群" class="headerlink" title="连接 PXC 集群"></a>连接 PXC 集群</h4><p>通过 Haproxy 容器映射的数据库代理端口 <code>4402</code> 登录 PXC 集群的 MySQL 节点。如果可以正常登录，则说明 Haproxy 成功将请求转发给 PXC 集群。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 192.168.1.221 -u root -P 4002 -p123456</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>值得一提的是，上述的 <code>192.168.1.221</code> 是宿主机的 IP 地址，<code>4002</code> 是 Haproxy 容器映射的 MySQL 端口。</p></div><h4 id="集群节点心跳检测"><a href="#集群节点心跳检测" class="headerlink" title="集群节点心跳检测"></a>集群节点心跳检测</h4><p>Haproxy 每隔一段时间会对 PXC 集群的节点进行心跳检测，当某个集群节点下线后，在 Haproxy 的监控界面可以观察到（如下图所示）。</p><div class="admonition note"><p class="admonition-title">提示</p><p>当 Haproxy 检测到有 PXC 集群节点处于不可用状态时，它会将该节点从负载均衡的服务器列表中剔除掉，直到该节点重新恢复到可用状态后。因此 Haproxy 可以做到一定程度的高可用，它的负载均衡跟 Nginx 有比较大的区别，后者默认不会剔除不用的服务器节点，而是会直接转发请求给故障节点。</p></div><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭节点二</span></span><br><span class="line">sudo docker stop pxc-node2</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-7.png"></p><h2 id="Haproxy-Keepalived-双机热备部署"><a href="#Haproxy-Keepalived-双机热备部署" class="headerlink" title="Haproxy + Keepalived 双机热备部署"></a>Haproxy + Keepalived 双机热备部署</h2><p>在本节中，将会创建多一个 Haproxy 容器（最终 Haproxy 会有两个容器），并在宿主机和每个 Haproxy 容器内单独安装 Keepalived 服务器，以此实现 Haproxy + Keepalived 双机热备方案。<strong>特别注意，在执行以下操作之前，请先启动 PXC 集群，并确保集群可以正常运行。</strong></p><h3 id="双机热备部署规划"><a href="#双机热备部署规划" class="headerlink" title="双机热备部署规划"></a>双机热备部署规划</h3><ul><li>Docker 部署 Haproxy（两个节点 - 主备）</li></ul><table><thead><tr><th>节点名称</th><th>容器名称</th><th>容器 IP</th><th> 容器数据卷</th><th>容器数据卷目录</th><th>操作系统</th></tr></thead><tbody><tr><td> Haproxy 节点一</td><td> haproxy-node1</td><td>172.30.0.5</td><td>haproxy-v1</td><td><code>/var/lib/docker/volumes/haproxy-v1/_data/</code></td><td>Debian 11</td></tr><tr><td>Haproxy 节点二</td><td> haproxy-node2</td><td>172.30.0.6</td><td>haproxy-v2</td><td><code>/var/lib/docker/volumes/haproxy-v2/_data/</code></td><td>Debian 11</td></tr></tbody></table><ul><li>Keepalived 服务器安装</li></ul><table><thead><tr><th>服务器名称</th><th>服务器角色</th><th>虚拟 IP</th><th> 说明</th><th>操作系统</th></tr></thead><tbody><tr><td> Keepalived 服务器一</td><td>主服务器（MASTER）</td><td>172.30.0.7</td><td> 安装在 Haproxy 节点一的容器内（<code>haproxy-node1</code>）</td><td>Debian 11</td></tr><tr><td>Keepalived 服务器二</td><td>备服务器（BACKUP）</td><td>172.30.0.7</td><td> 安装在 Haproxy 节点二的容器内（<code>haproxy-node2</code>）</td><td>Debian 11</td></tr><tr><td>Keepalived 服务器三</td><td></td><td> 192.168.1.160</td><td> 安装在宿主机内，为了实现外网可以正常访问 Docker 容器内的虚拟 IP</td><td>Centos 7</td></tr></tbody></table><h3 id="双机热备整体架构"><a href="#双机热备整体架构" class="headerlink" title="双机热备整体架构"></a>双机热备整体架构</h3><p>单节点的 Haproxy 不具备真正的高可用性，必须要有冗余设计，否则 Haproxy 宕机后，会造成整个集群不可用，如下图所示：</p><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-9.png"></p><p>对 Haproxy 进行集群部署（两个节点），并使用 Keepalived 实现双机热备架构，当其中一个 Haproxy 节点宕机后，另一个 Haproxy 节点可以顶上，保证整个集群的可用性，如下图所示：</p><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-12.png"></p><ul><li>Docker 创建两个 Haproxy 容器，每个容器中都单独安装 Keepalived 服务器</li><li>两个 Keepalived 服务器会争抢 Docker 容器内的虚拟 IP，一个抢到后，另一个没抢到就会等待，抢到的作为主服务器，没抢到的作为备用服务器</li><li>两个 Keepalived 服务器之间会进行心跳检测，如果备用服务器没有接收到主服务器的心跳响应，则说明主服务器发生故障，那么备用服务器就可以抢占虚拟 IP，继续工作</li><li>客户端向虚拟 IP 发送数据库请求，当其中一个 Haproxy 节点宕机后，还有另一个 Haproxy 节点可以接替工作</li><li>由于 Docker 容器内的虚拟 IP 不能被外网直接访问，所以需要借助宿主机里的 Keepalived 服务映射成外网可以访问的虚拟 IP</li></ul><h3 id="安装第一个-Keepalive-服务"><a href="#安装第一个-Keepalive-服务" class="headerlink" title="安装第一个 Keepalive 服务"></a>安装第一个 Keepalive 服务</h3><p>在本节中，将在上面创建第一个的 Haproxy 容器内，安装 Keepalived 服务器。</p><ul><li>使用 root 权限连接第一个 Haproxy 容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接Haproxy容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -u 0 -it haproxy-node1 /bin/bash</span><br></pre></td></tr></tbody></table></figure><ul><li>在第一个 Haproxy 容器内安装 Keepalived 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新包索引</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装软件</span></span><br><span class="line">apt-get install -y vim keepalived</span><br></pre></td></tr></tbody></table></figure><ul><li>在第一个 Haproxy 容器内配置 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Keepalived的配置文件</span></span><br><span class="line">touch /etc/keepalived/keepalived.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Keepalived的配置文件，写入以下配置内容（请自行更改网卡设备参数）</span></span><br><span class="line">vim /etc/keepalived/keepalived.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance  VI_1 {</span><br><span class="line">    state  MASTER           # 必填，Keepalived 的身份（MASTER 是主服务器，BACKUP 是备服务器）</span><br><span class="line">    interface  eth0         # 必填，Docker 的网卡设备，虚拟 IP 所在</span><br><span class="line">    virtual_router_id  51   # 必填，虚拟路由标识，取值在0-255之间，用来区分多个Instance的VRRP组播，同一网段内ID不能重复，主备机器的该值必须为一样</span><br><span class="line">    priority  100           # 必填，用来选举Master的，MASTER 权重要高于 BACKUP，数字越大优先级越高，该项取值范围是1-255（在此范围之外会被识别成默认值100）</span><br><span class="line">    advert_int  1           # 必填，MASTER 和 BACKUP 节点同步检查的时间间隔（单位为秒），主备之间必须一致，可以认为是健康检查的时间间隔</span><br><span class="line">    authentication {        # 必填，主备服务器的验证方式，主备之间必须使用相同的密码才能正常通信</span><br><span class="line">        auth_type  PASS     # 必填，主备服务器的认证方式，其中有两种方式PASS和HA（IPSEC），推荐使用PASS（密码只识别前8位），主备之间必须使用相同的密码才能正常通信</span><br><span class="line">        auth_pass  123456</span><br><span class="line">    }</span><br><span class="line">    virtual_ipaddress {     # 必填，虚拟 IP，可以设置多个虚拟 IP 地址，每行一个</span><br><span class="line">        172.30.0.7</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在第一个 Haproxy 容器内启动 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service keepalived start</span><br></pre></td></tr></tbody></table></figure><ul><li>在宿主机内查看第一个 Haproxy 容器内的进程列表，验证 Keepalived 服务是否正常运行 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top haproxy-node1</span><br></pre></td></tr></tbody></table></figure><ul><li>在宿主机内 Ping 虚拟 IP，验证虚拟 IP 是否可用 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 172.30.0.7</span><br></pre></td></tr></tbody></table></figure><h3 id="安装第二个-Keepalived-服务"><a href="#安装第二个-Keepalived-服务" class="headerlink" title="安装第二个 Keepalived 服务"></a>安装第二个 Keepalived 服务</h3><p>在本节中，将另外多部署一个 Haproxy 容器，并在容器内安装 Keepalived 服务器。</p><h4 id="部署第二个-Haproxy-容器"><a href="#部署第二个-Haproxy-容器" class="headerlink" title="部署第二个 Haproxy 容器"></a>部署第二个 Haproxy 容器</h4><ul><li>创建数据卷，存储路径为 <code>/var/lib/docker/volumes/</code></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据卷</span></span><br><span class="line">sudo docker volume create --name haproxy-v2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有数据卷</span></span><br><span class="line">sudo docker volume ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据卷的详细信息</span></span><br><span class="line">sudo docker volume inspect haproxy-v2</span><br></pre></td></tr></tbody></table></figure><ul><li>创建 Haproxy 的配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在数据卷目录下创建Haproxy的配置文件</span></span><br><span class="line">sudo touch /var/lib/docker/volumes/haproxy-v2/_data/haproxy.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Haproxy的配置文件，添加以下内容</span></span><br><span class="line">sudo vi /var/lib/docker/volumes/haproxy-v2/_data/haproxy.cfg</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    # 工作目录</span><br><span class="line">    # chroot /usr/local/etc/haproxy</span><br><span class="line">    # 日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info</span><br><span class="line">    log 127.0.0.1 local5 info</span><br><span class="line">    # 以守护进程运行</span><br><span class="line">    daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    log    global</span><br><span class="line">    mode    http</span><br><span class="line">    # 日志格式</span><br><span class="line">    option    httplog</span><br><span class="line">    # 日志中不记录负载均衡的心跳检测记录</span><br><span class="line">    option    dontlognull</span><br><span class="line">    # 连接超时（毫秒）</span><br><span class="line">    timeout connect 5000</span><br><span class="line">    # 客户端超时（毫秒）</span><br><span class="line">    timeout client  50000</span><br><span class="line">    # 服务器超时（毫秒）</span><br><span class="line">    timeout server  50000</span><br><span class="line"></span><br><span class="line"># 监控界面    </span><br><span class="line">listen  admin_stats</span><br><span class="line">    # 监控界面的访问的IP和端口</span><br><span class="line">    bind  0.0.0.0:8888</span><br><span class="line">    # 访问协议</span><br><span class="line">    mode        http</span><br><span class="line">    # URI相对地址</span><br><span class="line">    stats uri   /dbs</span><br><span class="line">    # 统计报告格式</span><br><span class="line">    stats realm     Global\ statistics</span><br><span class="line">    # 登陆账户信息</span><br><span class="line">    stats auth  admin:admin</span><br><span class="line"># 数据库负载均衡</span><br><span class="line">listen  proxy-pxc</span><br><span class="line">    # 访问的IP和端口</span><br><span class="line">    bind  0.0.0.0:3306  </span><br><span class="line">    # 网络协议</span><br><span class="line">    mode  tcp</span><br><span class="line">    # 负载均衡算法（轮询算法）</span><br><span class="line">    # 轮询算法：roundrobin</span><br><span class="line">    # 权重算法：static-rr</span><br><span class="line">    # 最少连接算法：leastconn</span><br><span class="line">    # 请求源IP算法：source </span><br><span class="line">    balance  roundrobin</span><br><span class="line">    # 日志格式</span><br><span class="line">    option  tcplog</span><br><span class="line">    # Haproxy使用MySQL的haproxy账户对数据库进行心跳检测</span><br><span class="line">    option  mysql-check user haproxy</span><br><span class="line">    server  PXC_Node_1 172.30.0.2:3306 check weight 1 maxconn 2000  </span><br><span class="line">    server  PXC_Node_2 172.30.0.3:3306 check weight 1 maxconn 2000  </span><br><span class="line">    server  PXC_Node_3 172.30.0.4:3306 check weight 1 maxconn 2000 </span><br><span class="line">    # 使用Keepalived检测死链</span><br><span class="line">    option  tcpka</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在上述 Haproxy 的配置文件中，不能启用 <code>chroot /usr/local/etc/haproxy</code>，否则 Haproxy 容器会启动失败（日志信息如下），暂时不清楚其原因。</p></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[NOTICE]   (1) : New worker (8) forked</span><br><span class="line">[NOTICE]   (1) : Loading success.</span><br><span class="line">[NOTICE]   (8) : haproxy version is 2.8.3-86e043a</span><br><span class="line">[NOTICE]   (8) : path to executable is /usr/local/sbin/haproxy</span><br><span class="line">[ALERT]    (8) : [haproxy.main()] Cannot chroot(/usr/local/etc/haproxy).</span><br><span class="line">[NOTICE]   (1) : haproxy version is 2.8.3-86e043a</span><br><span class="line">[NOTICE]   (1) : path to executable is /usr/local/sbin/haproxy</span><br><span class="line">[WARNING]  (1) : Current worker (8) exited with code 1 (Exit)</span><br><span class="line">[ALERT]    (1) : exit-on-failure: killing every processes with SIGTERM</span><br><span class="line">[WARNING]  (1) : All workers exited. Exiting... (1)</span><br></pre></td></tr></tbody></table></figure><ul><li>创建并运行 Haproxy 容器，其中的 <code>8888</code> 是 Haproxy 监听的 HTTP 端口（用于提供监控界面的 Web 服务），<code>3306</code> 是 Haproxy 监听的 MySQL 端口（用于转发请求给 PXC 集群节点）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并运行容器</span></span><br><span class="line">sudo docker run -it -p 4003:8888 -p 4004:3306 -v /var/lib/docker/volumes/haproxy-v2/_data/:/usr/<span class="built_in">local</span>/etc/haproxy --privileged --name=haproxy-node2 --net=pxc-network --ip 172.30.0.6 -d haproxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志信息</span></span><br><span class="line">sudo docker logs -f haproxy-node2</span><br></pre></td></tr></tbody></table></figure><ul><li>在宿主机内使用浏览器访问 <code>http://192.168.1.221:4003/dbs</code>，打开 Haproxy 的监控界面（如下图所示），登录用户名是 <code>admin</code>，登录密码是 <code>admin</code>。如果可以正常访问 Haproxy 的监控界面，则说明 Haproxy 成功部署。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>值得一提的是，上述的 <code>192.168.1.221</code> 是宿主机的 IP 地址，<code>4003</code> 是 Haproxy 容器映射的 HTTP 端口。</p></div><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-6.png"></p><h4 id="安装第二个-Keepalive-服务"><a href="#安装第二个-Keepalive-服务" class="headerlink" title="安装第二个 Keepalive 服务"></a>安装第二个 Keepalive 服务</h4><ul><li>使用 root 权限连接第二个 Haproxy 容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接Haproxy容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -u 0 -it haproxy-node2 /bin/bash</span><br></pre></td></tr></tbody></table></figure><ul><li>在第二个 Haproxy 容器内安装 Keepalived 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新包索引</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装软件</span></span><br><span class="line">apt-get install -y vim keepalived</span><br></pre></td></tr></tbody></table></figure><ul><li>在第二个 Haproxy 容器内配置 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Keepalived的配置文件</span></span><br><span class="line">touch /etc/keepalived/keepalived.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Keepalived的配置文件，写入以下配置内容（请自行更改网卡设备参数）</span></span><br><span class="line">vim /etc/keepalived/keepalived.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance  VI_1 {</span><br><span class="line">    state  BACKUP           # 必填，Keepalived 的身份（MASTER 是主服务器，BACKUP 是备服务器）</span><br><span class="line">    interface  eth0         # 必填，Docker 的网卡设备，虚拟 IP 所在</span><br><span class="line">    virtual_router_id  51   # 必填，虚拟路由标识，取值在0-255之间，用来区分多个Instance的VRRP组播，同一网段内ID不能重复，主备机器的该值必须为一样</span><br><span class="line">    priority  90            # 必填，用来选举Master的，MASTER 权重要高于 BACKUP，数字越大优先级越高，该项取值范围是1-255（在此范围之外会被识别成默认值100）</span><br><span class="line">    advert_int  1           # 必填，MASTER 和 BACKUP 节点同步检查的时间间隔（单位为秒），主备之间必须一致，可以认为是健康检查的时间间隔</span><br><span class="line">    authentication {        # 必填，主备服务器的验证方式，主备之间必须使用相同的密码才能正常通信</span><br><span class="line">        auth_type  PASS     # 必填，主备服务器的认证方式，其中有两种方式PASS和HA（IPSEC），推荐使用PASS（密码只识别前8位），主备之间必须使用相同的密码才能正常通信</span><br><span class="line">        auth_pass  123456</span><br><span class="line">    }</span><br><span class="line">    virtual_ipaddress {     # 必填，虚拟 IP，可以设置多个虚拟 IP 地址，每行一个</span><br><span class="line">        172.30.0.7</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在第二个 Haproxy 容器内启动 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service keepalived start</span><br></pre></td></tr></tbody></table></figure><ul><li>在宿主机内查看第二个 Haproxy 容器内的进程列表，验证 Keepalived 服务是否正常运行 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top haproxy-node2</span><br></pre></td></tr></tbody></table></figure><h3 id="安装第三个-Keepalive-服务"><a href="#安装第三个-Keepalive-服务" class="headerlink" title="安装第三个 Keepalive 服务"></a>安装第三个 Keepalive 服务</h3><p>在本节中，将在宿主机内安装第三个 Keepalive 服务器，目的是为了实现外网可以正常访问 Docker 内的虚拟 IP。<strong>特别注意，Docker 内的虚拟 IP 默认是不能被外网访问的，所以需要借助宿主机的 Keepalived 映射成外网可以正常访问的虚拟 IP。</strong></p><ul><li>配置宿主机的防火墙，对外开放 <code>8888</code> 和 <code>3306</code> 端口 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看防火墙运行状态</span></span><br><span class="line">sudo systemctl status firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用防火墙</span></span><br><span class="line">sudo systemctl start firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置防火墙永久开放8888和3306端口</span></span><br><span class="line">sudo firewall-cmd --zone=public --permanent --add-port=8888/tcp</span><br><span class="line">sudo firewall-cmd --zone=public --permanent --add-port=3306/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载防火墙配置</span></span><br><span class="line">sudo firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙已开放的端口</span></span><br><span class="line">sudo firewall-cmd --list-ports</span><br></pre></td></tr></tbody></table></figure><ul><li>在宿主机内查看当前局域网的 IP 分配情况 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装nmap</span></span><br><span class="line">sudo yum install -y nmap </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前网段所有分配的IP</span></span><br><span class="line">nmap -sP 192.168.1.0/24</span><br></pre></td></tr></tbody></table></figure><ul><li>在宿主机内安装 Keepalive</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Keepalive</span></span><br><span class="line">sudo yum install -y keepalived</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动Keepalived</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> keepalived</span><br></pre></td></tr></tbody></table></figure><ul><li>在宿主机内配置 Keepalive</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份Keepalived的配置文件</span></span><br><span class="line">sudo cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Keepalived的配置文件，覆盖写入以下配置内容（请自行更改网卡设备参数）</span></span><br><span class="line">sudo vim /etc/keepalived/keepalived.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 {</span><br><span class="line">    state MASTER</span><br><span class="line">    # 这里指定是宿主机的网卡，可以通过 "ip a" 命令查看当前系统上使用的网卡是哪个</span><br><span class="line">    interface enp0s3</span><br><span class="line">    virtual_router_id 100</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication {</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    }</span><br><span class="line">    virtual_ipaddress {</span><br><span class="line">           # 这里是指定宿主机上的一个虚拟IP，一定要和宿主机网卡在同一个网段，例如宿主机网卡的IP是192.168.1.221，那么指定的虚拟IP可以是192.168.1.160</span><br><span class="line">           192.168.1.160</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># 接收HTTP数据，用于访问Haproxy的Web监控页面</span><br><span class="line">virtual_server 192.168.1.160 8888 {</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr </span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line">    # 将宿主机接收到的数据，转发给Haproxy容器内的虚拟IP和HTTP端口</span><br><span class="line">    real_server 172.30.0.7 8888 {</span><br><span class="line">        weight 1</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># 接收数据库请求，用于访问Haproxy代理的MySQL端口</span><br><span class="line">virtual_server 192.168.1.160 3306 {</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr </span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line">    # 将宿主机接收到的数据，转发给Haproxy容器内的虚拟IP和MySQL端口</span><br><span class="line">    real_server 172.30.0.7 3306 {</span><br><span class="line">        weight 1</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在宿主机内启动 Keepalived</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">sudo systemctl start keepalived</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">sudo systemctl status keepalived</span><br></pre></td></tr></tbody></table></figure><h3 id="双机热备方案部署验证"><a href="#双机热备方案部署验证" class="headerlink" title="双机热备方案部署验证"></a>双机热备方案部署验证</h3><ul><li>在其他电脑上，如果可以通过宿主机的虚拟 IP <code>192.168.1.160</code> 正常访问宿主机 Haproxy 容器中的虚拟 IP <code>172.30.0.7</code> 及相应端口，则说明 PXC + Haproxy + Keepalived 的高可用集群搭建成功。</li></ul><table><thead><tr><th>验证内容</th><th>宿主机的虚拟 IP</th><th> 宿主机的端口</th><th>验证命令</th></tr></thead><tbody><tr><td> Haproxy 的监控页面</td><td> 192.168.1.160</td><td>8888</td><td><code>curl -basic -u admin:admin -I http://192.168.1.160:8888/dbs</code></td></tr><tr><td>Haproxy 的 MySQL 负载均衡</td><td> 192.168.1.160</td><td>3306</td><td><code>mysql -h 192.168.1.160 -u root -P 3306 -p123456</code></td></tr></tbody></table><ul><li>检查两个 Keepalived 节点之间是否可以正常进行心跳通信，如果不能进行心跳通信，则会发生脑裂现象（即两个 Keepalived 节点会同时抢占到虚拟 IP）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用root权限连接Haproxy容器一</span></span><br><span class="line">docker <span class="built_in">exec</span> -u 0 -it haproxy-node1 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看IP地址</span></span><br><span class="line">ip addr</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用root权限连接Haproxy容器二</span></span><br><span class="line">docker <span class="built_in">exec</span> -u 0 -it haproxy-node2 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看IP地址</span></span><br><span class="line">ip addr</span><br></pre></td></tr></tbody></table></figure><ul><li>在宿主机上面关闭 Haproxy 节点一的容器，然后在其他电脑上，打开浏览器访问 <code>http://192.168.1.160:8888/dbs</code>，如果可以正常访问 Haproxy 监控页面，则说明 Haproxy + Keepalived 的双机热备方案生效了。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭Haproxy节点一的容器</span></span><br><span class="line">sudo docker stop haproxy-node1</span><br></pre></td></tr></tbody></table></figure><ul><li>在宿主机上面关闭 Haproxy 节点一的容器之后，连接进 Haproxy 节点二的容器内部，使用 <code>ip addr</code> 命令查看 IP 地址，可以看见已经抢占到的虚拟 IP</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用root权限连接容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -u 0 -it haproxy-node2 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看IP地址</span></span><br><span class="line">ip addr</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2023/10/docker-mysql-pxc-13.png"></p><h2 id="Haproxy-Keepalived-双机热备完善"><a href="#Haproxy-Keepalived-双机热备完善" class="headerlink" title="Haproxy + Keepalived 双机热备完善"></a>Haproxy + Keepalived 双机热备完善</h2><p>在本节中，将介绍上述操作完成之后，Haproxy + Keepalived 双机热备方案仍需要改进的地方。</p><h3 id="Keepalived-服务自启动"><a href="#Keepalived-服务自启动" class="headerlink" title="Keepalived 服务自启动"></a>Keepalived 服务自启动</h3><p>目前集群里有两个 Keepalived 服务分别安装在不同的 Haproxy 容器内，但它们默认都没有配置自启动，也就是说 Keepalived 没有随 Haproxy 容器启动而启动。为了日后方便维护集群，建议将 Haproxy 容器内的 Keepalived 服务统一配置成自启动。可以尝试通过 Dockerfile 自主构建包含有 Haproxy + Keepalived 的 Docker 镜像。由于篇幅有限，这里不再累述。</p><h3 id="Haproxy-保证事务持久性"><a href="#Haproxy-保证事务持久性" class="headerlink" title="Haproxy 保证事务持久性"></a>Haproxy 保证事务持久性</h3><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/9370579.html">Haproxy 代理 MySQL 要考虑的问题</a></li></ul></div><p>Haproxy 代理 MySQL 的时候，事务持久性的问题必须解决。这个事务持久性不是 ACID 的 D（持久性，Durability），而是 Transaction Persistent，这里简单描述一下此处的事务持久性。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction</span><br><span class="line">update1...</span><br><span class="line">update2...</span><br><span class="line">insert3...</span><br><span class="line">commit</span><br></pre></td></tr></tbody></table></figure><p>当客户端显式开启一个事务，然后执行上述几个数据库操作，然后提交或回滚。如果使用代理软件（如 Haproxy）对 MySQL 进行代理，必须要保证这 5 个语句全都路由到同一个 MySQL 节点上，即使后端的 MySQL 采用的是多主模型（MGR、Galera 都提供多主模型），否则事务中各语句分散，轻则返回失败，重则数据不一致、提交混乱。这就是 Transaction Persistent 的概念，即让同一个事务路由到同一个后端节点。Haproxy 如何保证事务持久性呢？对于非 MySQL 协议感知的代理（LVS、Nginx、Haproxy 等），要保证事务持久性，只能通过间接的方法实现，比较通用的方法是在代理软件上监听不同的端口（实现读写分离）。具体的思路如下：</p><ul><li>1）在 Haproxy 上监听不同端口，例如 <code>3307</code> 端口的请求作为写端口，<code>3306</code> 端口的请求作为读端口。</li><li>2）从后端 MySQL 节点中选一个节点 (只能是一个) 作为逻辑写节点，Haproxy 将 <code>3307</code> 端口的请求全都路由给这个节点。</li><li>3）可以在 Haproxy 上配置多个备用写节点 (Backup)，但 <code>3307</code> 端口在某一时刻，路由到的必须只能有一个写节点。</li></ul><p>这样能保证事务的持久性，也能解决一些乐观锁问题。但是，如果后端是多主模型的 MGR（组复制）或 Galera，这样的代理方式将强制变为单主模型，虽然是逻辑上的强制。当然，这并非什么问题，至少到目前为止的开源技术，都建议采用单主模型。Haproxy 保证事务持久性的配置示例如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">listen  haproxy_3306_read_multi</span><br><span class="line">        bind *:3306</span><br><span class="line">        mode tcp</span><br><span class="line">        timeout client  10800s</span><br><span class="line">        timeout server  10800s</span><br><span class="line">        balance leastconn</span><br><span class="line">        option httpchk</span><br><span class="line">        option allbackups</span><br><span class="line">        default-server port 9200 inter 2s downinter 5s rise 3 fall 2 slowstart 60s maxconn 64 maxqueue 128 weight 100</span><br><span class="line">        server galera1 192.168.55.111:3306 check</span><br><span class="line">        server galera2 192.168.55.112:3306 check</span><br><span class="line">        server galera3 192.168.55.113:3306 check</span><br><span class="line"> </span><br><span class="line">listen  haproxy_3307_write_single</span><br><span class="line">        bind *:3307</span><br><span class="line">        mode tcp</span><br><span class="line">        timeout client  10800s</span><br><span class="line">        timeout server  10800s</span><br><span class="line">        balance leastconn</span><br><span class="line">        option httpchk</span><br><span class="line">        option allbackups</span><br><span class="line">        default-server port 9200 inter 2s downinter 5s rise 3 fall 2 slowstart 60s maxconn 64 maxqueue 128 weight 100</span><br><span class="line">        server galera1 192.168.55.111:3306 check</span><br><span class="line">        server galera2 192.168.55.112:3306 check backup</span><br><span class="line">        server galera3 192.168.55.113:3306 check backup</span><br></pre></td></tr></tbody></table></figure><p>上面的配置通过 <code>3306</code> 端口和 <code>3307</code> 端口进行读写分离，并且在负责写的 <code>3307</code> 端口中只有一个节点可写，其余两个节点作为 Backup 节点。对于 MySQL 的负载来说，更建议采用 MySQL 协议感知的程序来实现，例如 MySQL Router、ProxySql，MaxScale、MyCat 等数据库中间件。</p><h3 id="Keepalived-监控-Haproxy-运行状态"><a href="#Keepalived-监控-Haproxy-运行状态" class="headerlink" title="Keepalived 监控 Haproxy 运行状态"></a>Keepalived 监控 Haproxy 运行状态</h3><p>上述两个 Haproxy 容器内的 Keepalived 服务，彼此仅仅是基于心跳检测来实现双机热备（故障切换）。如果第一个 Haproxy 容器内的 Keepalived 服务（Master）正常运行，而 Haproxy 自身运行异常，那么将会出现 Haproxy 负载均衡服务失效，无法切换到备用的 Haproxy 负载均衡器上，最终导致后端的 Web 服务无法收到响应。所以，<strong>应该是要基于 Shell 脚本每隔一段时间检测 Haproxy 服务是否正常运行，而不是仅仅依靠 Keepalived 主备节点之间的心跳检测。</strong>比如，当检测到 Haproxy 服务不是正常运行，首先尝试启动 Haproxy 服务；若 Haproxy 服务重启失败，就应该关闭掉该节点上的 Keepalived 服务，并发送报警邮件，这样才能自动切换到 Keepalived 服务的 Backup 节点上。详细的解决方案建议参考 <a href="/posts/503c34e4.html#Keepalived-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE">这里</a> 的教程。</p><h2 id="PXC-集群数据备份"><a href="#PXC-集群数据备份" class="headerlink" title="PXC 集群数据备份"></a>PXC 集群数据备份</h2><h3 id="数据库备份方案"><a href="#数据库备份方案" class="headerlink" title="数据库备份方案"></a>数据库备份方案</h3><ul><li><p>冷备份</p><ul><li>冷备份是关闭数据库时候的备份方式，通常做法是拷贝数据文件。</li><li>是简单安全的一种备份方式，但不能在数据库运行时进行备份。</li><li>大型网站无法做到关闭业务备份数据，所以冷备份不是最佳选择。</li></ul></li><li><p>热备份</p><ul><li>热备份是在数据库运行状态下备份数据，MySQL 常见的热备份有 <code>LVM</code> 和 <code>XtraBackup</code> 两种方案。</li><li><code>LVM</code> 热备份方案<ul><li> Linux 的分区备份命令，可以备份任何数据库。</li><li>会对数据库加锁，备份期间只能读取数据库，而且命令复杂。</li></ul></li><li><code>XtraBackup</code> 热备份方案<ul><li>基于 InnoDB 的在线热备工具，开源免费</li><li>备份过程中不锁表，快速可靠</li><li>备份过程中不会打断正在执行地事务</li><li>备份数据经过压缩，占用磁盘空间小</li><li>能够非常快速地备份与恢复 MySQL 数据库</li></ul></li></ul></li><li><p>全量备份与增量备份</p><ul><li><code>全量备份</code>：备份全部数据。备份过程时间长，占用空间大。第一次备份要使用全量备份。</li><li><code>增量备份</code>： 只备份变化的那部分数据。备份的时间短，占用空间小。第二次以后可以使用增量备份</li></ul></li></ul><h3 id="PXC-全量备份（暂未验证）"><a href="#PXC-全量备份（暂未验证）" class="headerlink" title="PXC 全量备份（暂未验证）"></a>PXC 全量备份（暂未验证）</h3><ul><li>备份操作要在某个 PXC 集群节点的 Docker 容器内执行，但应该把备份数据保存到宿主机内，因此先创建用于存储备份数据的数据卷 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据卷，用于存储备份数据</span></span><br><span class="line">sudo docker volume create backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有数据卷</span></span><br><span class="line">sudo docker volume ls</span><br></pre></td></tr></tbody></table></figure><ul><li>挑选第二个 PXC 集群节点 <code>pxc-node2</code>，将其容器关闭并删除掉，然后重新创建一个挂载了 <code>backup</code> 数据卷的 <code>pxc-node2</code> 容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭容器</span></span><br><span class="line">sudo docker stop pxc-node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器，由于数据库的数据存放在数据卷 "pxc-v2" 中，所以数据不会丢失</span></span><br><span class="line">sudo docker rm pxc-node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建容器（增加挂载"backup"数据卷）</span></span><br><span class="line">sudo docker create -p 13307:3306 -v pxc-v2:/var/lib/mysql -v backup:/data -e MYSQL_ROOT_PASSWORD=123456 -e XTRABACKUP_PASSWORD=123456 -e CLUSTER_NAME=pxc -e CLUSTER_JOIN=pxc-node1 --name=pxc-node2 --net=pxc-network --ip 172.30.0.3 pxc</span><br></pre></td></tr></tbody></table></figure><ul><li>在新创建的 <code>pxc-node2</code> 容器中安装 <code>xtrabackup</code> 工具 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">sudo docker start pxc-node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用root权限连容器</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -u 0 -it pxc-node2 /bin/bash</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装存储库包</span></span><br><span class="line">yum install -y https://repo.percona.com/yum/percona-release-latest.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用存储库</span></span><br><span class="line">percona-release enable-only tools release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装XtraBackup工具</span></span><br><span class="line">yum install -y percona-xtrabackup-80</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 XtraBackup 全量备份数据库数据 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建存放备份数据的目录</span></span><br><span class="line">mkdir -p /data/backup/full</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全量备份数据库数据</span></span><br><span class="line">xtrabackup --backup -uroot -p123456 --target-dir=/data/backup/full</span><br></pre></td></tr></tbody></table></figure><h3 id="PXC-全量还原（暂未验证）"><a href="#PXC-全量还原（暂未验证）" class="headerlink" title="PXC 全量还原（暂未验证）"></a>PXC 全量还原（暂未验证）</h3><p>数据库可以热备份，但是不能热还原，否则会造成业务数据和还原数据的冲突。针对 PXC 集群，为了避免在还原过程中可能出现各节点数据同步冲突的问题，需要先解散原来的集群（删除所有集群节点），然后重新创建空白数据库节点，再执行数据库冷还原操作，最后再创建其他集群节点。还原前还要将热备份保存的未提交的事务回滚，还原之后重启 MySQL 服务器。</p><ul><li>关闭并删除所有 PXC 集群节点 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭容器</span></span><br><span class="line">sudo docker stop pxc-node1 pxc-node2 pxc-node3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">sudo docker rm pxc-node1 pxc-node2 pxc-node3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据卷（强烈建议在删除之前备份所有数据卷文件）</span></span><br><span class="line">sudo docker volume rm pxc-v1 pxc-v2 pxc-v3</span><br></pre></td></tr></tbody></table></figure><ul><li>按照之前的步骤重新创建第一个节点的容器 <code>pxc-node1</code>，并进入容器内，执行冷还原操作 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建第一个节点的数据卷</span></span><br><span class="line">docker volume create pxc-v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第一个节点的容器（增加挂载"backup"数据卷）</span></span><br><span class="line">sudo docker create -p 13306:3306 -v pxc-v1:/var/lib/mysql -v backup:/data -e MYSQL_ROOT_PASSWORD=123456 -e XTRABACKUP_PASSWORD=123456 -e CLUSTER_NAME=pxc --name=pxc-node1 --net=pxc-network --ip 172.30.0.2 pxc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动第一个节点的容器</span></span><br><span class="line">sudo docker start pxc-node1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用root权限连第一个节点的容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it -uroot pxc-node1 /bin/bash</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备还原</span></span><br><span class="line">xtrabackup --prepare --target-dir=/data/backup/full/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始冷还原</span></span><br><span class="line">xtrabackup --copy-back --target-dir=/data/backup/full/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改还原后的数据库文件属主</span></span><br><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 断开容器连接</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭第一个节点的容器</span></span><br><span class="line">docker stop pxc-node1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启第一个节点的容器</span></span><br><span class="line">docker start pxc-node1</span><br></pre></td></tr></tbody></table></figure><ul><li>创建第二个与第三个节点的容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建第二个节点的数据卷</span></span><br><span class="line">sudo docker volume create --name pxc-v2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第三个节点的数据卷</span></span><br><span class="line">sudo docker volume create --name pxc-v3</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建第二个节点（增加了CLUSTER_JOIN参数）</span></span><br><span class="line">sudo docker create -p 13307:3306 -v pxc-v2:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e XTRABACKUP_PASSWORD=123456 -e CLUSTER_NAME=pxc -e CLUSTER_JOIN=pxc-node1 --name=pxc-node2 --net=pxc-network --ip 172.30.0.3 pxc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第三个节点（增加了CLUSTER_JOIN参数）</span></span><br><span class="line">sudo docker create -p 13308:3306 -v pxc-v3:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e XTRABACKUP_PASSWORD=123456 -e CLUSTER_NAME=pxc -e CLUSTER_JOIN=pxc-node1 --name=pxc-node3 --net=pxc-network --ip 172.30.0.4 pxc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动第二节点（首次启动比较耗时间，因为需要同步第一个节点的数据）</span></span><br><span class="line">sudo docker start pxc-node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动第三节点（首次启动比较耗时间，因为需要同步第一个节点的的数据）</span></span><br><span class="line">sudo docker start pxc-node3</span><br></pre></td></tr></tbody></table></figure><h2 id="PXC-集群日常维护"><a href="#PXC-集群日常维护" class="headerlink" title="PXC 集群日常维护"></a>PXC 集群日常维护</h2><div class="admonition warning"><p class="admonition-title">特别注意</p><p>对于 PXC 集群节点的启动、关闭等操作，区分第一个节点（负责集群初始化）和其他节点，两者的操作步骤是不同的。</p></div><h3 id="正确关闭集群"><a href="#正确关闭集群" class="headerlink" title="正确关闭集群"></a>正确关闭集群</h3><p>如果第一个节点（负责集群初始化）不是最后一个离开集群的，那么它在一般情况下就不能再以第一个节点的形式启动了。这是因为从这个节点引导集群启动可能是不安全的，即这个节点可能不包含所有更新的数据。<strong>综上所述，PXC 集群节点的正确关闭顺序，应该与它们的启动顺序相反（类似栈结构 - 先进后出），即最先启动的节点应该最后关闭。</strong></p><ul><li>PXC 集群节点容器的正确关闭顺序 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭节点三</span></span><br><span class="line">sudo docker stop pxc-node3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭节点二</span></span><br><span class="line">sudo docker stop pxc-node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭节点一</span></span><br><span class="line">sudo docker stop pxc-node1</span><br></pre></td></tr></tbody></table></figure><ul><li>PXC 集群节点容器的正确启动顺序 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动节点一</span></span><br><span class="line">sudo docker start pxc-node1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动节点二</span></span><br><span class="line">sudo docker start pxc-node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动节点三</span></span><br><span class="line">sudo docker start pxc-node3</span><br></pre></td></tr></tbody></table></figure><h3 id="正确关闭与启动节点"><a href="#正确关闭与启动节点" class="headerlink" title="正确关闭与启动节点"></a>正确关闭与启动节点</h3><p>如果是希望 PXC 集群关闭某个节点（非第一个节点），正确的步骤如下：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭节点</span></span><br><span class="line">sudo docker stop pxc-node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">sudo docker ps -a</span><br></pre></td></tr></tbody></table></figure><p>某个节点（非第一个节点）关闭之后，其他维护工作也完成了，若希望将该节点重新加入 PXC 集群，可以执行以下命令：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动节点</span></span><br><span class="line">sudo docker start pxc-node2</span><br></pre></td></tr></tbody></table></figure><h3 id="第一个节点不是最后一个离开集群"><a href="#第一个节点不是最后一个离开集群" class="headerlink" title="第一个节点不是最后一个离开集群"></a>第一个节点不是最后一个离开集群</h3><p><strong>如果第一个节点（负责集群初始化）不是最后一个离开集群的，不能再以第一个节点的形式启动了。</strong></p><ul><li>第一个节点（负责集群初始化）关闭后，希望重新加入 PXC 集群，此时运行 <code>sudo docker start pxc-node1</code> 命令，会发现第一个节点的容器没有正常启动</li><li>启动失败的原因往往是：此时从第一个节点引导集群启动可能是不安全。由于该节点不是最后一个离开集群的节点（最后停掉的节点），可能没有包含所有更新的数据</li><li>如果此时所有集群节点都处于关闭状态<ul><li>首先逐一排查每个节点的数据卷目录，查看数据卷目录下是否存在 <code>grastate.dat</code> 文件，并找到 <code>safe_to_bootstrap=1</code> 的节点<ul><li>如果找到 <code>safe_to_bootstrap=1</code> 的节点，且它不是第一个节点（负责集群初始化）<ul><li>此时为了方便操作，建议先将所有节点容器关闭并删除掉，在删除所有节点容器之前，必须确保数据卷目录的数据不被误删，否则会丢失所有数据库数据</li><li>然后再按照 <a href="/posts/aba17375.html#%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2">上面的步骤</a>，重新创建并启动每一个 PXC 集群节点容器</li><li>最后再检查集群的数据是否可以正常同步</li></ul></li><li>如果找到 <code>safe_to_bootstrap=1</code> 的节点，且它是第一个节点（负责集群初始化），或者根本找不到 <code>safe_to_bootstrap=1</code> 的节点<ul><li>这时，需要通过 <code>sudo docker volume inspect pxc-v1</code> 得到第一个节点的数据卷目录路径，找到数据卷目录下的 <code>grastate.dat</code> 文件</li><li>打开第一个节点下的 <code>grastate.dat</code> 文件，将 <code>safe_to_bootstrap</code> 设置为 <code>1</code></li><li>然后直接使用 <code>sudo docker start pxc-node1</code> 命令强制从第一个节点启动</li><li>等第一个节点正常启动后，再接着启动其他节点</li><li>最后再检查集群的数据是否可以正常同步</li></ul></li></ul></li></ul></li><li>如果此时集群里还至少有一个节点存活（例如节点三存活着）<ul><li>首先删除第一个节点的容器，<code>sudo docker stop pxc-node1</code>、<code>sudo docker rm pxc-node1</code></li><li>重新创建一个新节点的容器，<code>sudo docker create -p 13306:3306 -v pxc-v1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e XTRABACKUP_PASSWORD=123456 -e CLUSTER_NAME=pxc -e CLUSTER_JOIN=pxc-node3 --name=pxc-node1 --net=pxc-network --ip 172.30.0.2 pxc</code></li><li>在创建新节点的容器时，是以普通节点形式（非第一个节点的形式）加入集群的，注意创建新节点容器的命令行参数是包含 <code>-e CLUSTER_JOIN=pxc-node3</code>，这里的 <code>pxc-node3</code> 是集群中存活着的节点三</li><li>然后启动新节点的容器，<code>sudo docker start pxc-node1</code></li><li>最后再检查集群的数据是否可以正常同步</li></ul></li></ul><h3 id="系统重启之后，PXC-集群启动失败"><a href="#系统重启之后，PXC-集群启动失败" class="headerlink" title="系统重启之后，PXC 集群启动失败"></a>系统重启之后，PXC 集群启动失败</h3><p>Docker 所在的 Windows/Linux 操作系统重启后，导致所有 PXC 集群节点都意外关闭了，此时选择 PXC 集群中的第一个节点容器进行重启，出现以下的错误信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] WSREP: It may not be safe to bootstrap the cluster from this node. It was not the last one to leave the cluster and may not contain all the updates. To force cluster bootstrap with this node, edit the grastate.dat file manually and set safe_to_bootstrap to 1 .</span><br></pre></td></tr></tbody></table></figure><ul><li>意思是从这个节点引导集群启动可能是不安全。由于该节点不是最后一个离开集群的节点（最后停掉的节点），可能没有包含所有更新的数据，强制从该节点启动，需要手工编辑该节点的 <code>grastate.dat</code> 文件，设置 <code>safe_to_bootstrap=1</code>。</li><li>当然了，一般情况下不需要强制从该节点启动，可以逐一排查每个节点下的 <code>grastate.dat</code> 文件，找到 <code>safe_to_bootstrap=1</code> 的节点。</li><li>如果 <code>safe_to_bootstrap=1</code> 的节点是第一个节点，那么可以直接在该节点上引导 PXC 集群启动，然后再启动其他节点。</li><li>如果 <code>safe_to_bootstrap=1</code> 的节点不是第一个节点，此时为了方便操作，建议先将所有节点容器关闭并删除掉，然后再按照 <a href="/posts/aba17375.html#%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2">上面的步骤</a>，重新创建并启动每一个 PXC 集群节点容器。</li><li>如果所有节点的 <code>safe_to_bootstrap</code> 都为 <code>0</code>，那么只能任意选择一个节点，更改该节点下的 <code>grastate.dat</code> 文件，将 <code>safe_to_bootstrap</code> 设置为 <code>1</code>，然后在该节点上引导 PXC 集群启动，最后再启动其他节点。</li><li><strong>无论是上述哪种情况，都必须等待第一个节点启动成功，也就是 PXC 集群初始化完成之后，才能接着启动其他节点，最后再检查集群的数据是否可以正常同步。</strong></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>grastate.dat</code> 文件的路径是 <code>/var/lib/docker/volumes/xxxx/_data/grastate.dat</code>，其中的 <code>xxx</code> 是容器数据卷的目录名称。</li></ul></div><h3 id="最坏情况，所有节点容器重新创建"><a href="#最坏情况，所有节点容器重新创建" class="headerlink" title="最坏情况，所有节点容器重新创建"></a>最坏情况，所有节点容器重新创建</h3><p>假设由于各种原因导致整个 PXC 集群无法正常启动，此时可以将所有节点容器关闭并删除掉（<strong>必须确保数据卷目录的数据不被误删，否则会丢失所有数据库数据</strong>），然后再按照 <a href="/posts/aba17375.html#%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2">上面的步骤</a>，重新创建并启动每一个 PXC 集群节点容器。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/wanglei957/p/11819547.html">Docker 部署 MySQL 集群</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/9370579.html">Haproxy 代理 MySQL 要考虑的问题</a></li><li><a href="https://cloud.tencent.com/developer/article/1929627">CentOS 7 部署 PXC 集群 【Docker + 单机多节点】</a></li><li><a href="https://www.cnblogs.com/ll409546297/p/17129532.html">MySQL 之 PXC 集群模式（Docker + MySQL + PXC 实现）</a></li><li><a href="https://www.cnblogs.com/nhdlb/p/14032657.html">Docker 部署 PXC 5.7 集群 - 搭建负载均衡实现双机热部署方案</a></li><li><a href="https://www.cnblogs.com/pengboke/p/15012571.html#node3">Docker 部署 PXC 集群 (Haproxy 负载均衡、Keepalived 高可用、XtraBackup 数据备份)</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 Docker 部署 MySQL 的 PXC 5.7 单机集群，包括使用 Haproxy + Keepalived 实现双机热备方案。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 高可用基础教程之四数据可靠性方案介绍</title>
    <link href="https://www.techgrow.cn/posts/56993278.html"/>
    <id>https://www.techgrow.cn/posts/56993278.html</id>
    <published>2023-10-22T12:13:32.000Z</published>
    <updated>2023-10-22T12:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/2f77f23a.html">MySQL 高可用基础教程之一主从复制方案介绍</a></li><li><a href="/posts/d6058b93.html">MySQL 高可用基础教程之二高可用架构方案介绍</a></li><li><a href="/posts/cc846db2.html">MySQL 高可用基础教程之三高可用架构方案介绍</a></li><li><a href="/posts/56993278.html">MySQL 高可用基础教程之四数据可靠性方案介绍</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="数据可靠性方案分类"><a href="#数据可靠性方案分类" class="headerlink" title="数据可靠性方案分类"></a>数据可靠性方案分类</h3><table><thead><tr><th>数据可靠性方案</th><th>说明</th></tr></thead><tbody><tr><td> RAID 10</td><td> 适用于对数据冗余性和性能要求较高的应用场景，如数据库服务器、虚拟化环境和高性能计算等。</td></tr><tr><td>SAN 存储网络</td><td>除了价格贵，没有太多缺点。</td></tr><tr><td>DRBD 磁盘复制</td><td> Linux 内核模块实现的磁盘块级别的同步复制技术。</td></tr></tbody></table><span id="more"></span><h2 id="RAID-10"><a href="#RAID-10" class="headerlink" title="RAID 10"></a>RAID 10</h2><p>RAID 10（Redundant Array of Independent Disks 10）是一种存储方案，它结合了 RAID 1（镜像）和 RAID 0（条带化）的特性。RAID 10 通过将多个磁盘组合在一起，提供了数据冗余和性能增强的优势。在 RAID 10 中，磁盘被分为两组，每组至少有两个磁盘。其中一组磁盘使用 RAID 1（镜像）技术，即数据被同时写入两个磁盘，提供了数据的冗余备份。另一组磁盘使用 RAID 0（条带化）技术，即数据被分块地写入多个磁盘，提供了更好的读写性能。</p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>RAID 10 数据可靠性方案在金融、银行领域使用的比较多。</li><li>RAID 10 适用于对数据冗余性和性能要求较高的应用场景，如数据库服务器、虚拟化环境和高性能计算等。</li><li>RAID 10 的容量利用率较低，如果容量是一个关键因素，可能需要考虑其他 RAID 级别。在选择 RAID 级别时，需要根据具体的需求和预算来权衡各种因素。</li></ul></div><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img data-src="../../../asset/2023/10/mysql-ha-17.png"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ul><li><code>数据冗余</code>：RAID 10 通过镜像技术提供了数据的冗余备份。如果一个磁盘发生故障，数据仍然可以从镜像磁盘中恢复，保证了数据的可靠性和可用性。</li><li><code>高性能</code>：RAID 10 通过条带化技术提供了更好的读写性能。数据可以同时从多个磁盘读取或写入，提高了数据访问的速度和吞吐量。</li><li><code>故障容忍</code>：由于 RAID 10 具有数据冗余性，当一个磁盘发生故障时，系统可以继续正常运行，并且可以在更换故障磁盘后进行数据恢复，减少了系统停机时间。</li></ul></li><li><p>缺点</p><ul><li><code>成本较高</code>：由于 RAID 10 需要使用多个磁盘进行数据镜像和条带化，所以成本较高。相比其他 RAID 级别，RAID 10 需要更多的磁盘。</li><li><code>容量利用率较低</code>：RAID 10 的容量利用率较低，因为数据被同时写入两个磁盘。例如，如果有 4 个 1TB 的磁盘组成 RAID 10，实际可用的存储容量只有 2TB。</li></ul></li></ul><h2 id="SAN-存储网络"><a href="#SAN-存储网络" class="headerlink" title="SAN 存储网络"></a>SAN 存储网络</h2><p>SAN（Storage Area Network）是一种专门用于存储数据的高速网络架构。它将存储设备（如磁盘阵列、磁带库等）与服务器连接起来，提供高性能、高可用性和可扩展性的共享存储解决方案。</p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>SAN 存储网络适用于对存储性能、可用性和扩展性要求较高的应用场景，如大型企业、数据中心、虚拟化环境等。</li><li>在选择和部署 SAN 存储网络时，需要根据具体的需求和预算来权衡各种因素，并确保与服务器和应用程序的兼容性。</li></ul></div><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ul><li><code>存储共享</code>：SAN 允许多台服务器共享存储设备，使得数据可以在不同的服务器之间共享和访问。这样可以提高数据的灵活性和共享性，减少存储资源的浪费。</li><li><code>高性能</code>：SAN 使用高速的网络连接（如光纤通道、以太网等），提供了高带宽和低延迟的数据传输。这使得存储设备可以提供更高的读写性能，满足对存储性能要求较高的应用场景。</li><li><code>可扩展性</code>：SAN 具有良好的可扩展性，可以根据需求灵活地扩展存储容量和性能。通过添加新的存储设备或扩展现有设备的容量，可以满足不断增长的存储需求。</li><li><code>管理简便</code>：SAN 提供了集中管理和监控的功能，使得存储资源的配置、监控和管理变得更加简便和高效。管理员可以通过集中的管理界面对存储设备进行配置和管理，提高了管理效率。</li><li><code>数据强一致性</code>：可以很好地保证数据的强一致性，不会因为 MySQL 的逻辑错误发生数据不一致的情况。</li><li><code>部署简单</code>：部署两节点即可，不依赖数据库实现，保障数据安全。</li></ul></li><li><p>缺点</p><ul><li><code>不具备故障转移</code>：需要考虑共享存储的高可用性。</li><li><code>成本较高</code>：相比于其他存储解决方案，SAN 的成本较高。它需要专用的硬件设备和高速网络连接，这增加了部署和维护的成本。</li><li><code>配置复杂性</code>：SAN 的配置和管理相对复杂，需要专业的知识和技能。对于不熟悉 SAN 的用户来说，配置和管理可能是一项具有挑战性的任务。</li></ul></li></ul><h2 id="DRBD-磁盘复制"><a href="#DRBD-磁盘复制" class="headerlink" title="DRBD 磁盘复制"></a>DRBD 磁盘复制</h2><p>DRBD（Distrubuted Replicated Block Device）是一种构建高可用分布式网络存储解决方案的专业工具（由 Linux 内核提供），可用于对服务器之间的磁盘、分区、逻辑卷等进行数据同步。当用户将数据写入本地磁盘时，会将数据发送到网络中另一台主机的磁盘上，这样的本地主机（主节点）与远程主机（备节点）的数据就可以保证实时同步。DRBD 主要用于数据传输、复制和同步，可以在网络存储节点之间实现可靠性更高的数据备份，也常用于构建高可用的存储节点及其他组件，如集群、负载均衡和存储服务器等。</p><div class="admonition note"><p class="admonition-title">DRBD 结合 MySQL 使用</p><p>DRBD 与 MySQL 结合使用可以实现高可用性的数据库方案。通过将 MySQL 数据库的数据目录配置为 DRBD 设备，加上额外的配置和管理工具（如 Pacemaker），可以为数据库提供实时复制和故障转移的能力，从而提高数据库的可靠性和可用性。当主节点发生故障时，系统可以自动切换到备节点，减少数据库服务的中断时间。<strong>DRBD 经典架构的组合是 MySQL + DRBD + Heartbeat。</strong></p></div><h3 id="整体架构-1"><a href="#整体架构-1" class="headerlink" title="整体架构"></a>整体架构</h3><p><img data-src="../../../asset/2023/10/mysql-ha-16.png"></p><p>在 MySQL 与 DRBD 方案中，通常会有两个节点：一个主节点和一个备节点。主节点负责处理所有的读写操作，并将数据实时复制到备节点上。备节点会持续地从主节点复制数据，以保持数据的一致性。当主节点发生故障时，备节点可以接管主节点的角色，成为新的主节点，继续提供数据库服务。这种故障转移过程是自动的，可以通过配置和管理工具（如 Pacemaker）来实现。需要注意的是，配置和管理 MySQL 与 DRBD 方案需要一定的技术知识和经验。此外，对网络的稳定性和带宽要求较高，以确保数据的实时复制和同步。因此，在实施该方案之前，建议进行充分的规划和测试，以确保系统的稳定性和可靠性。</p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ul><li>两节点即可，部署简单，切换逻辑简单。</li><li>相比于 SAN 储存网络，价格低廉。</li><li>保证数据的强一致性。</li></ul></li><li><p>缺点</p><ul><li>从库不提供读服务。</li><li>对 IO 性能的影响较大。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 MySQL 的数据可靠性方案，包括 RAID 10、SAN 存储网络、DRBD 磁盘复制等。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 高可用基础教程之三高可用架构方案介绍</title>
    <link href="https://www.techgrow.cn/posts/cc846db2.html"/>
    <id>https://www.techgrow.cn/posts/cc846db2.html</id>
    <published>2023-10-21T12:13:32.000Z</published>
    <updated>2023-10-21T12:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/2f77f23a.html">MySQL 高可用基础教程之一主从复制方案介绍</a></li><li><a href="/posts/d6058b93.html">MySQL 高可用基础教程之二高可用架构方案介绍</a></li><li><a href="/posts/cc846db2.html">MySQL 高可用基础教程之三高可用架构方案介绍</a></li><li><a href="/posts/56993278.html">MySQL 高可用基础教程之四数据可靠性方案介绍</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="高可用架构方案分类"><a href="#高可用架构方案分类" class="headerlink" title="高可用架构方案分类"></a>高可用架构方案分类</h3><table><thead><tr><th>高可用方案</th><th>保证数据强一致性</th><th>使用说明</th><th>描述</th></tr></thead><tbody><tr><td>主从复制</td><td>否</td><td>支持单主</td><td>只适用于对可用性和数据一致性要求较低的业务场景。</td></tr><tr><td>MMM</td><td> 否</td><td>支持单主</td><td>基本淘汰了，在一致性和高并发稳定性等方面有些问题。</td></tr><tr><td>MHA</td><td> 否</td><td>支持单主</td><td>有少数开发者还在用，但也有些问题，也是趋于淘汰的 MySQL 主从高可用方案。</td></tr><tr><td>MGR</td><td> 是</td><td>支持单主 / 多主</td><td>基于 MySQL 官方从 <code>5.7.17</code> 版本开始引入的组复制技术。</td></tr><tr><td>MySQL Cluster</td><td> 是</td><td>支持多主</td><td> MySQL 官方提供的一种分布式数据库解决方案，只支持 NDB 引擎。</td></tr><tr><td>Galera Cluster</td><td> 是</td><td>支持多主</td><td>引领时代的主从复制高可用技术。</td></tr><tr><td>Galera Cluster for MySQL</td><td> 是</td><td>支持多主</td><td> MySQL 对 Galera Cluster 的实现。</td></tr><tr><td>MariaDB Galera Cluster (MGC)</td><td> 是</td><td>支持多主</td><td> MariaDB 对 Galera Cluster 的实现。</td></tr><tr><td>Percona XtraDB Cluster (PXC)</td><td> 是</td><td>支持多主</td><td> Percona 对 Galera Cluster 的实现，目前业界使用 PXC 的会多一些。</td></tr><tr><td>MySQL InnoDB Cluster</td><td> 是</td><td>支持单主 / 多主</td><td> MySQL 官方推出的一套完整高可用性解决方案。</td></tr></tbody></table><span id="more"></span><h2 id="Galera-Cluster"><a href="#Galera-Cluster" class="headerlink" title="Galera Cluster"></a>Galera Cluster</h2><p><a href="https://galeracluster.com/">Galera Cluster</a> 是由 Codership 开源的一套基于同步多主复制的 MySQL 集群解决方案。目前 Galera Cluster 有三种版本（实现方案），分别是 Galera Cluster for MySQL、MariaDB Galera Cluster (MGC) 及 Percona Xtradb Cluster (PXC)。Galera Cluster 使用 Galera Replication 插件，通过在多个 MySQL 节点之间同步数据来实现高可用性和负载均衡。其本身具有 Multi-Master (多主) 特性，支持多点写入（<strong>所有节点都可以同时读写数据库</strong>），Galera Cluster 中每个实例都是对等的，互为主从。当客户端读写数据的时候，可以选择任一 MySQL 实例，对于读操作，每个实例读取到的数据都是相同的。对于写操作，当数据写入某一节点后，集群会将其同步到其它节点。这种架构不共享任何数据，是一种高冗余架构。</p><div class="admonition note"><p class="admonition-title">如何选择版本？</p><p>建议采用 Percona XtraDB Cluster，因为技术比较成熟，而且国内很多企业在生产线上用的更多一些。</p></div><h3 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h3><p>Galera Cluster for MySQL、MariaDB Galera Cluster (MGC) 与 Percona Xtradb Cluster (PXC) 三者的区别如下：</p><ul><li><p><code>版本不同</code></p><ul><li>三者使用的 Galera Cluster 版本不同，因此在功能和性能上存在一些的差异。</li></ul></li><li><p><code>发行版不同</code>：</p><ul><li>MariaDB Galera Cluster 是由 MariaDB 基金会开发的，支持 MariaDB 数据库。</li><li>Percona XtraDB Cluster 是由 Percona 公司开发的，支持 Percona Server 数据库。</li><li>Galera Cluster for MySQL 是由 Codership 公司开发的，支持 MySQL 和 Percona Server 数据库。</li></ul></li><li><p><code>功能不同</code>：</p><ul><li>Percona XtraDB Cluster 提供了一些额外的功能，例如在线扩容、在线更改节点角色等。</li><li>MariaDB Galera Cluster 支持 Galera Cluster for MySQL 的所有功能，包括多主写入、并行复制、自动故障检测和恢复等。</li></ul></li><li><p><code>许可证不同</code>：</p><ul><li>MariaDB Galera Cluster 使用 LGPLv2.1 许可证。</li><li>Galera Cluster for MySQL 和 Percona XtraDB Cluster 都使用 GPLv2 许可证。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">MariaDB 与 Percona Server 的关系</p><p>MariaDB 数据库是由原 MySQL 创始人开发，Percona Server 数据库由 Percona 公司开发（使用 XtraDB 存储引擎），两者都是从 MySQL 衍生出来的数据库分支。</p></div><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img data-src="../../../asset/2023/10/mysql-ha-9.png"></p><ul><li>Galera Cluster 的核心组件<ul><li><code>Galera Replication 插件</code>：Galera Replication 是一个基于同步复制的插件，用于实现数据的多主复制和一致性。它使用了多主复制协议，确保在集群中的所有节点之间的数据同步和一致性。</li><li><code>Primary Component</code>：Primary Component 是 Galera Cluster 中的主组件，负责处理所有的写操作和读操作。Primary Component 接收来自应用程序的写请求，并将数据复制到其他节点（Secondary Component）上。</li><li><code>Secondary Component</code>：Secondary Component 是 Galera Cluster 中的从组件，负责复制 Primary Component 上的数据。Secondary Component 通过与 Primary Component 进行通信，接收并应用 Primary Component 上的写操作，以保持数据的一致性。</li></ul></li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li><code>初始化集群</code>：在 Galera Cluster 中，首先需要配置和启动一个节点作为初始 Primary Component，并将其配置为 Galera Replication 插件的成员。然后，其他节点可以加入到集群中，并通过与 Primary Component 进行通信，获取数据并成为 Secondary Component。</li><li><code>数据同步和复制</code>：一旦集群初始化完成，Primary Component 开始接收来自应用程序的写请求，并将数据复制到其他节点上。Secondary Component 通过与 Primary Component 进行通信，接收并应用 Primary Component 上的写操作，以保持数据的一致性。</li><li><code>自动故障切换</code>：如果 Primary Component 发生故障，Galera Cluster 会自动选择一个 Secondary Component 作为新的 Primary Component，并将其他节点重新配置为新的 Secondary Component。这个过程是自动的，无需人工干预。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点<ul><li><code>高可用性</code>：Galera Cluster 通过数据的多主复制和自动故障切换，支持自动添加和剔除节点，实现了高可用性。即使某个节点发生故障，集群仍然可以继续提供服务。</li><li><code>数据强一致性</code>：Galera Cluster 使用多主复制协议，确保在集群中的所有节点之间的数据同步和一致性。在写操作提交之前，集群中的成员会达成一致，确保数据在所有节点上的复制是一致的。</li><li><code>简化配置和管理</code>：Galera Cluster 提供了简单易用的配置选项和管理工具，使得集群的配置和管理变得更加简单和方便。</li><li><code>可扩展性</code>：Galera Cluster 支持水平扩展，可以通过增加节点来扩展存储容量和处理能力。同时，由于数据的多主复制和负载均衡，可以实现更好的性能和吞吐量。</li><li><code>拥有成熟的社区</code>：Galera Cluster 拥有成熟的社区，国内有互联网公司在大规模使用。</li><li><code>使用体验一致</code>：用户可以直接连接 Galera Cluster 集群，使用感受上与 MySQL 完全一致。</li><li><code>同步复制</code>：Galera Cluster 使用了同步复制，且支持真正的并行复制（行级）。</li></ul></li><li>缺点<ul><li><code>网络稳定性</code>：Galera Cluster 对网络的稳定性要求较高，因为节点之间需要进行频繁的通信和数据同步。如果网络不稳定，可能会导致数据同步延迟或节点之间的通信故障。</li><li><code>写冲突</code>：由于 Galera Cluster 支持多主复制，如果应用程序在不同的节点上同时进行写操作，可能会导致写冲突和一致性问题。因此，需要在应用程序层面进行合理的设计和处理。</li><li><code>配置复杂性</code>：尽管 Galera Cluster 提供了简化的配置选项和管理工具，但对于不熟悉 Galera Cluster 的用户来说，配置可能是一项具有挑战性的任务。</li><li><code>需要安装补丁</code>：使用 Galera Cluster 时，需要提前为原生 MySQL 节点安装 Wsrep 补丁。</li><li><code>节点数需求</code>：搭建 Galera Cluster 时，要求至少有三个服务器节点，且多节点写入开销大。</li><li><code>使用限制</code><ul><li>不支持 GTID（全局事务标识符）。</li><li>不支持异步复制，所有节点必须同步复制。</li><li>不支持全局临时表，因为它们不能被复制。</li><li>不支持使用外键，因为这会导致复制延迟和性能问题。</li><li>不支持 DDL 语句的自动化复制，需要手动在每个节点上执行。</li><li>不支持非确定性函数，因为它们在不同节点上的结果可能不同。</li><li>不支持存储过程和函数的自动化复制，需要手动在每个节点上创建。</li><li>只支持使用 InnoDB 存储引擎，不支持 MyISAM、NDB 存储引擎。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>在使用 Galera Cluster 之前，建议进行充分的测试和评估，以确保它能够满足系统的可用性、性能和扩展性要求，并根据具体的应用场景和需求进行适当的配置和调整。</p></div><h2 id="Percona-XtraDB-Cluster"><a href="#Percona-XtraDB-Cluster" class="headerlink" title="Percona XtraDB Cluster"></a>Percona XtraDB Cluster</h2><p>Percona XtraDB Cluster（PXC）由 <a href="https://www.percona.com/">Percona</a> 公司开发，是一个基于 <a href="/posts/cc846db2.html#Galera-Cluster">Galera Cluster</a> 实现的高可用性和高性能的 MySQL 集群解决方案。它是由 Percona 开发的，建立在 Galera Replication 插件之上，提供了多主复制和数据同步的功能。</p><h3 id="PXC-的兼容性"><a href="#PXC-的兼容性" class="headerlink" title="PXC 的兼容性"></a>PXC 的兼容性</h3><ul><li>最小化的迁移（可以非常方便地从现有系统迁移到 PXC）。</li><li>快速地回退版本（无锁化、非常容易地恢复到非 PXC 系统）。</li><li>完全兼容已有的系统（InnoDB 存储引擎，优化器执行计划，完全相同的优化思路）。</li></ul><h3 id="PXC-的使用限制"><a href="#PXC-的使用限制" class="headerlink" title="PXC 的使用限制"></a>PXC 的使用限制</h3><ul><li>仅支持 InnoDB 存储引擎，而 MySQL 自带的系统库（如 <code>mysql</code>）里面有些表是使用 MyISAM 存储引擎，因此不能直接对系统库的表进行 DML 操作，比如 <code>INSERT INTO mysql.user</code>，但使用 <code>CREATE USER</code> 是没有问题的，它也是正确的使用方式。</li><li>不允许大事务的产生（否则的话后果很严重），允许的最大事务大小由 <code>wsrep_max_ws_rows</code> 和 <code>wsrep_max_ws_size</code> 变量定义，<code>LOAD DATA INFILE</code> 方式处理每 10000 行提交一次，对于大的事务将被分解众多小型事务。</li><li>对于写密集型应用需要控制单个节点的大小，单个节点的数据越大，新加节点如果采用自动添加，则可能会产生很大抖动（添加节点建议提前使用备份或者备份 + Binlog 进行数据同步，尽量减少抖动）。</li><li>集群高负载时应避免执行 <code>ALTER TABLE</code>、<code>IMPORT</code>、<code>EXPORT</code> 等操作，因为如果这些操作未在所有节点上同步执行，可能会导致节点不一致。</li><li>在多主模式中不支持 <code>LOCK TABLES</code> 以及 <code>UNLOCK TABLES</code> 锁定功能，如 <code>GET_LOCK ()</code>，<code>RELEASE_LOCK ()</code> 等也不被支持。</li><li>硬件配置短板限制，即整个集群的写吞吐量受最弱节点的限制，因此所有 PXC 节点的硬件配置要一致。如果一个节点变慢，整个集群会跟着变慢。</li><li>需要尽可能地控制 PXC 集群的规模，节点越多，数据同步速度越慢。</li><li>查询日志不能定向到表，即如果启用查询日志记录，则必须将日志转发到文件，而不能转发到表。</li><li><code>enforce_storage_engine=InnoDB</code> 与 <code>wsrep_replicate_myisam=OFF（默认）</code> 不兼容。</li><li><code>binlog_rows_query_log_events</code> 变量不受支持。</li><li>由于可能的提交回滚，XA 事务不受支持。</li><li>InnoDB 的虚假更改功能不受支持。</li><li>最小的集群大小是 3 个节点。</li><li>不能解决热点更新问题。</li></ul><h3 id="Replication-与-PXC-对比"><a href="#Replication-与-PXC-对比" class="headerlink" title="Replication 与 PXC 对比"></a>Replication 与 PXC 对比</h3><h4 id="方案介绍"><a href="#方案介绍" class="headerlink" title="方案介绍"></a>方案介绍</h4><p><img data-src="../../../asset/2023/10/mysql-ha-20.png"></p><ul><li>Replication 方案（主从复制）<ul><li>速度快，但仅能保证弱一致性，适用于保存价值不高的数据，比如日志、帖子、新闻等。</li><li>采用 Master-Slave 架构，在 Master 写入会同步到 Slave，能从 Slave 读出，但在 Slave 写入无法同步到 Master。</li><li>采用异步复制，Master 写入成功就向客户端返回成功，但是同步 Slave 可能失败，会造成无法从 Slave 读出的结果。</li></ul></li></ul><p><img data-src="../../../asset/2023/10/mysql-ha-21.png"></p><ul><li>Percona XtraDB Cluster（PXC）方案<ul><li>速度慢，但能保证强一致性，适用于保存价值较高的数据，比如订单、客户、支付数据等。</li><li>数据同步是双向的，在任一节点写入数据，都会同步到其他所有节点，在任何节点上都能同时读写。</li><li>采用同步复制，向任一节点写入数据，只有所有节点都同步成功后，才会向客户端返回成功。事务在所有节点要么同时提交，要么不提交。</li></ul></li></ul><h4 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h4><p><img data-src="../../../asset/2023/10/mysql-ha-10.png"></p><p><img data-src="../../../asset/2023/10/mysql-ha-11.png"></p><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><ul><li><p>数据一致性对比</p><ul><li>Replication 一般采用异步复制，无法保证数据的强一致性。</li><li>PXC 采用同步复制，事务在所有集群节点要么都提交，要么都不提交，可以保证数据的强一致性。</li></ul></li><li><p>写入性能对比</p><ul><li>Replication 写入速度快，但是不能保证数据的强一致性。</li><li>PXC 可以保证数据的强一致性，但写入速度慢（所有节点都可以同时读写）。</li><li>PXC 和 Replication 都只实现了数据的同步，并没有提供数据切分（分片）的的功能。</li></ul></li><li><p>两者的区别总结</p><ul><li>PXC 集群的所有节点都是可读可写，但 Replication 的从节点不能写入，因为主从同步是单向的，无法从 Slave 节点向 Master 节点同步。</li><li>PXC 的同步机制是同步进行的，这也是它能保证数据强一致性的根本原因，Replication 的同步机制是异步进行的，如果从节点停止同步，依然可以向主节点插入数据，且正确返回给客户端，造成主从节点的数据不一致。</li><li>PXC 是牺牲性能来保证数据的一致性，Replication 在性能上是高于 PXC 的，所以两者的使用场景是不一样的。<ul><li>Replication 适用于存储普通数据，能够容忍数据丢失，例如：购物车、用户行为日志等。</li><li>PXC 适用于存储重要数据，要求保证数据的强一致性，例如：订单信息、支付信息、用户信息等。</li></ul></li></ul></li></ul><h3 id="PXC-高性能高可用部署方案"><a href="#PXC-高性能高可用部署方案" class="headerlink" title="PXC 高性能高可用部署方案"></a>PXC 高性能高可用部署方案</h3><h4 id="PXC-集群高可用架构部署"><a href="#PXC-集群高可用架构部署" class="headerlink" title="PXC 集群高可用架构部署"></a>PXC 集群高可用架构部署</h4><p><img data-src="../../../asset/2023/10/mysql-ha-14.png"></p><p><img data-src="../../../asset/2023/10/mysql-ha-13.png"></p><h4 id="PXC-集群高性能架构部署"><a href="#PXC-集群高性能架构部署" class="headerlink" title="PXC 集群高性能架构部署"></a>PXC 集群高性能架构部署</h4><p><img data-src="../../../asset/2023/10/mysql-ha-12.png"></p><h4 id="PXC-集群混合架构部署"><a href="#PXC-集群混合架构部署" class="headerlink" title="PXC 集群混合架构部署"></a>PXC 集群混合架构部署</h4><p><img data-src="../../../asset/2023/10/mysql-ha-15.png"></p><h2 id="MySQL-InnoDB-Cluster"><a href="#MySQL-InnoDB-Cluster" class="headerlink" title="MySQL InnoDB Cluster"></a>MySQL InnoDB Cluster</h2><p>MySQL InnoDB Cluster 是 MySQL 官方推出的一套完整高可用性解决方案。</p><h3 id="整体架构-1"><a href="#整体架构-1" class="headerlink" title="整体架构"></a>整体架构</h3><ul><li>MySQL InnoDB Cluster 的核心组件<ul><li><code>MySQL Group Replication</code>：简称 MGR，是 MySQL 的主从同步高可用方案，包括数据同步及角色选举。</li><li><code>MySQL Router</code>：业务流量的统一入口，支持对 MGR 的主从角色判断，可以配置不同的端口分别对外提供读写服务，实现读写分离等功能。</li><li><code>MySQL Shell</code>：MySQL InnoDB Cluster 的管理工具，用来创建和管理集群。</li></ul></li></ul><p><img data-src="../../../asset/2023/10/mysql-ha-18.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.51cto.com/u_16099257/7022269">MySQL 高可用方案推荐</a></li><li><a href="https://bigdata.it168.com/a2016/0822/2871/000002871893.shtml">链家 MySQL 高可用架构设计</a></li><li><a href="https://mt.sohu.com/20170323/n484341088.shtml">10 款常见 MySQL 高可用方案选型解读</a></li><li><a href="https://www.php.cn/faq/554468.html">MySQL 中常见的高可用架构部署方案有哪些</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4NjE4NTUwNQ==&amp;mid=2247495043&amp;idx=8&amp;sn=85a4c8aa143ac9e11e1fea11ab134a1e">MySQL 高可用架构 - MMM、MHA、MGR、PXC</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 MySQL 的高可用架构方案，包括 Galera Cluster、Percona XtraDB Cluster 等。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 高可用基础教程之二高可用架构方案介绍</title>
    <link href="https://www.techgrow.cn/posts/d6058b93.html"/>
    <id>https://www.techgrow.cn/posts/d6058b93.html</id>
    <published>2023-10-18T12:13:32.000Z</published>
    <updated>2023-10-18T12:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/2f77f23a.html">MySQL 高可用基础教程之一主从复制方案介绍</a></li><li><a href="/posts/d6058b93.html">MySQL 高可用基础教程之二高可用架构方案介绍</a></li><li><a href="/posts/cc846db2.html">MySQL 高可用基础教程之三高可用架构方案介绍</a></li><li><a href="/posts/56993278.html">MySQL 高可用基础教程之四数据可靠性方案介绍</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="高可用架构方案分类"><a href="#高可用架构方案分类" class="headerlink" title="高可用架构方案分类"></a>高可用架构方案分类</h3><table><thead><tr><th>高可用方案</th><th>保证数据强一致性</th><th>使用说明</th><th>描述</th></tr></thead><tbody><tr><td>主从复制</td><td>否</td><td>支持单主</td><td>只适用于对可用性和数据一致性要求较低的业务场景。</td></tr><tr><td>MMM</td><td> 否</td><td>支持单主</td><td>基本淘汰了，在一致性和高并发稳定性等方面有些问题。</td></tr><tr><td>MHA</td><td> 否</td><td>支持单主</td><td>有少数开发者还在用，但也有些问题，也是趋于淘汰的 MySQL 主从高可用方案。</td></tr><tr><td>MGR</td><td> 是</td><td>支持单主 / 多主</td><td>基于 MySQL 官方从 <code>5.7.17</code> 版本开始引入的组复制技术。</td></tr><tr><td>MySQL Cluster</td><td> 是</td><td>支持多主</td><td> MySQL 官方提供的一种分布式数据库解决方案，只支持 NDB 引擎。</td></tr><tr><td>Galera Cluster</td><td> 是</td><td>支持多主</td><td>引领时代的主从复制高可用技术。</td></tr><tr><td>Galera Cluster for MySQL</td><td> 是</td><td>支持多主</td><td> MySQL 对 Galera Cluster 的实现。</td></tr><tr><td>MariaDB Galera Cluster (MGC)</td><td> 是</td><td>支持多主</td><td> MariaDB 对 Galera Cluster 的实现。</td></tr><tr><td>Percona XtraDB Cluster (PXC)</td><td> 是</td><td>支持多主</td><td> Percona 对 Galera Cluster 的实现，目前业界使用 PXC 的会多一些。</td></tr><tr><td>MySQL InnoDB Cluster</td><td> 是</td><td>支持单主 / 多主</td><td> MySQL 官方推出的一套完整高可用性解决方案。</td></tr></tbody></table><span id="more"></span><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从之间一般使用异步复制，这意味无法保证数据的一致性，对于数据一致性要求比较高的业务场景是不适用的（如金融、银行业务）。</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img data-src="../../../asset/2023/10/mysql-ha-19.png"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ul><li>架构简单，维护起来比较方便。</li></ul></li><li><p>缺点</p><ul><li>无法保证数据的一致性。</li><li>主库宕机后，整个系统都无法写入数据。</li><li>Proxy 存在单点问题，建议使用 Keepalived + HAProxy 实现数据库中间件的负载均衡。</li></ul></li></ul><h2 id="MMM"><a href="#MMM" class="headerlink" title="MMM"></a>MMM</h2><p>MMM（Master-Master Replication Manager）是一套支持 MySQL 双主故障切换和双主日常管理的脚本程序，可以实现 MySQL 数据库的高可用性和负载均衡。MMM 基于 Perl 语言开发，主要用于监控和管理 MySQL Master-Master（双主） 复制，可以说是 MySQL 主主复制的管理器。<strong>虽然叫做双主复制，但在业务上同一时刻只能有一个主库进行数据的写入，另一台主备库会提供部分读服务，以加速在主主切换时主备库的预热。另外，主备库会在主库失效时，进行主备切换和故障转移</strong>。可以说 MMM 这套脚本程序一方面实现了主备切换的功能，另一方面其内部附加的工具脚本也可以实现多个 Slave 节点的读负载均衡。<strong>简而言之，MMM 是一套基于 MySQL 主从复制的高可用性解决方案，通过使用双主复制架构、自动故障检测与切换机制、故障恢复机制，实现了 MySQL 数据库的高可用性和数据同步。</strong></p><div class="admonition warning"><p class="admonition-title">注意</p><p>MMM 方案基本淘汰了，在生产环境中不建议使用。</p></div><h3 id="整体架构-1"><a href="#整体架构-1" class="headerlink" title="整体架构"></a>整体架构</h3><p><img data-src="../../../asset/2023/10/mysql-ha-3.png"></p><ul><li>MMM 架构包括三大组件：监控器（Monitor）、代理（Agent）和 MySQL 实例。</li><li>在 MMM 中是通过一个 VIP（虚拟 IP）的机制来保证集群的高可用。在整个 MySQL 集群中，在主节点会提供一个 VIP 地址来提供数据读写服务，当出现故障的时候，VIP 就会从原来的主节点切换到其他节点，由其他节点提供服务。</li><li>VIP（虚拟 IP）是基于 ARP 协议，因此所有节点必须处于同一局域网。</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><code>工作原理</code>：MMM 采用了一种双主复制架构，其中有两个 MySQL 主服务器（Master1 和 Master2），它们之间通过 MySQL 的复制功能进行数据同步。在这种架构中，应用程序可以同时连接到 Master1 和 Master2，从而实现读写负载的分担和高可用性。</li><li><code>主从复制</code>：MMM 利用 MySQL 的主从复制机制，将一个 MySQL 主服务器（Master1）作为主节点，另一个 MySQL 主服务器（Master2）作为从节点。主节点接收写操作并将其复制到从节点，从而保持数据的同步。当主节点发生故障时，从节点可以自动接管主节点的角色，确保数据库的高可用性。</li><li><code>自动故障检测与切换</code>：MMM 具有自动检测主节点故障的能力。它通过监控主节点的心跳以及与从节点的复制延迟来确定主节点是否正常工作。如果主节点发生故障或延迟过高，MMM 会自动将从节点切换为主节点，并将所有写操作重定向到新的主节点。</li><li><code>故障恢复</code>：当主节点恢复正常工作后，MMM 可以自动将其重新加入复制拓扑，并将其配置为从节点。这样，当前的主节点（之前的从节点）会将数据同步到恢复的主节点，以确保数据的一致性。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>使用 MMM 可以有效地提高 MySQL 数据库的可用性和性能。特别注意的是，MMM 并不能解决所有的高可用问题，例如网络分区和数据一致性等问题。</p></div><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ul><li><code>高可用性</code>：MMM 通过自动故障检测和故障转移机制，可以快速将一个从节点提升为新的主节点，从而实现数据库的高可用性，减少系统的停机时间。</li><li><code>负载均衡</code>：MMM 可以根据节点的负载情况，将读操作分发到不同的节点上，从而实现负载均衡，提高系统的整体性能。</li><li><code>简单易用</code>：MMM 提供了一些管理工具，可以方便地进行节点的添加、删除和配置修改等操作，使得系统的管理和维护变得简单易用。</li><li><code>VIP 支持</code>：默认提供了读写 VIP（虚拟 IP）的支持。</li></ul></li><li><p>缺点：</p><ul><li><code>无法完全保证数据一致性</code>：由于 MMM 默认采用了 MySQL 的异步复制机制，主节点和从节点之间的同步存在一定的延迟，可能会导致数据的不一致。在某些场景下，需要额外的措施来确保数据的一致性。</li><li><code>单点故障</code>：虽然 MMM 可以自动进行故障转移，但在故障转移过程中，可能会存在一段时间的数据库不可用。如果 MMM 本身发生故障，可能会导致整个系统的不可用。</li><li><code>配置复杂性</code>：MMM 的配置相对复杂，需要对 MySQL 的复制机制和 MMM 的工作原理有一定的了解。在配置过程中，需要注意各个节点的配置一致性和正确性。</li><li><code>故障切换会丢事务</code>：出现故障切换时，容易丢失事务，建议主从库采用半同步复制方式解决，减少出问题的概率。</li><li><code>不支持 GTID</code>：MMM 不支持基于 GTID 的复制，只支持基于日志点的复制。</li><li><code>社区不活跃</code>：目前 MMM 开源社区已经缺少维护者。</li></ul></li></ul><h2 id="MHA"><a href="#MHA" class="headerlink" title="MHA"></a>MHA</h2><p>MHA（Master High Availability）是一种用于 MySQL 数据库的高可用性架构。它的设计目标是确保在主数据库发生故障时，能够快速自动地将备库（Slave）提升为新的主库，以保证系统的连续性和可用性。MHA 专门用于监控主库的状态，当发现 Master 节点发生故障的时候，会自动提升其中拥有最新数据的 Slave 节点成为新的 Master 节点；在此期间，MHA 会通过其他从节点获取额外的信息来避免数据一致性问题。MHA 还提供了一种在线切换 Master-Slave 节点的功能，可以根据需要进行切换。MHA 可在 30 秒内实现故障转移，同时最大程度确保数据一致性。</p><div class="admonition warning"><p class="admonition-title">注意</p><ul><li>MHA 方案比较适合旧版本的 MySQL，即小于 <code>5.7.17</code> 的版本，如 <code>5.5</code>、<code>5.6</code> 等。</li><li>MySQL 官方从 <code>5.7.17</code> 版本开始提供了组复制技术，因此版本号大于 <code>5.7.17</code> 的 MySQL，建议采用 MGR（MySQL Group Replication）或者其他高可用方案。</li></ul></div><h3 id="整体架构-2"><a href="#整体架构-2" class="headerlink" title="整体架构"></a>整体架构</h3><p><img data-src="../../../asset/2023/10/mysql-ha-4.png"></p><ul><li>MHA 由两部分组成，分别是 MHA Manager（管理节点）和 MHA Node（数据节点）。</li><li>MHA Manager 可以单独部署在一台独立的机器上管理单个或多个 Master-Slave 集群，也可以部署在一台 Slave 节点上。MHA Node 运行在每台 MySQL 服务器上。</li><li>Slave 节点是 MySQL 数据库的备库，负责同步主库的数据。MHA 会通过与 Slave 节点建立 SSH 连接，实时监测备库的状态。</li><li>Master 节点是 MySQL 数据库的主库，负责处理所有的写操作和读操作。MHA 会通过与 Master 节点建立 SSH 连接，实时监测主库的状态。</li><li>Manager 节点是 MHA 的核心组件，负责监控主库的状态并自动执行故障切换操作。它通过与 MySQL 主库和备库建立 SSH 连接，实时监测集群中的 Master 节点；<strong>当 Master 节点出现故障时，它可以自动将拥有最新数据的 Slave 节点提升为新的 Master 节点，然后将所有其他的 Slave 节点重新指向新的 Master 节点。</strong></li></ul><blockquote><p>MHA 可以扩展为多主多从的集群架构，如下图所示</p></blockquote><p><img data-src="../../../asset/2023/10/mysql-ha-5.png"></p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>目前 MHA 主要支持一主多从的架构，要搭建 MHA，则必须保证在一个 MySQL 复制集群中最少有三台数据库服务器，一主二从，即一台 Master 节点，一台充当备用 Master 节点，另外一台充当 Slave 节点，因为至少需要三台服务器。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>MHA 架构的工作流程如下：</p><ul><li>从宕机崩溃的 Master 中保存二进制日志事件（binlog events）</li><li>识别最新更新的 Slave 节点</li><li>应用差异的中继日志（relay log）到其他 Slave 节点</li><li>应用从 Master 保存的二进制日志事件（binlog events）</li><li>提升其中一个 Slave 节点为新 Master 节点</li><li>让其他的 Slave 节点连接新的 Master 节点进行复制</li></ul><h4 id="自动故障切换"><a href="#自动故障切换" class="headerlink" title="自动故障切换"></a>自动故障切换</h4><p>在 MHA 自动故障切换的过程中，MHA 会尝试从宕机的主服务器上最大限度的保存二进制日志，最大程度的保证数据的不丢失，但这并不总是可行的。例如，主服务器硬件故障或无法通过 SSH 访问，导致 MHA 无法保存二进制日志，只进行故障转移而丢失了最新的数据。使用从 MySQL 5.5 开始支持的半同步复制，可以大大降低数据丢失的风险。<strong>值得一提的是，MHA 很适合与半同步复制机制结合起来使用。</strong>如果只有一个 Slave 节点已经接收到了最新的二进制日志，MHA 可以将最新的二进制日志应用于其他所有的 Slave 节点上，因此可以保证所有节点的数据一致性。</p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点：</p><ul><li><code>自动故障切换</code>：MHA 能够自动检测主库的故障，并快速将备库提升为新的主库，减少了手动干预的需要，提高了系统的可用性。</li><li><code>实时监测</code>：MHA 通过与 Master 节点和 Slave 节点建立 SSH 连接，实时监测它们的状态，能够及时发现故障并采取相应的措施。</li><li><code>简化配置</code>：MHA 提供了简单易用的配置文件，可以轻松地配置主库和备库的信息，减少了配置的复杂性。</li><li><code>高可扩展性</code>：MHA 支持多个备库，可以根据需求灵活地扩展系统的容量和性能。</li><li><code>支持 GTID 与日志点</code>：支持基于 GTID 的复制模式，在进行故障转移时更不易产生数据丢失，同时还支持基于日志点的复制。</li><li><code>支持监控多个集群</code>：同一个监控节点可以监控多个集群。</li></ul></li><li><p>缺点：</p><ul><li><code>配置复杂性</code>：尽管 MHA 提供了简化的配置文件，但对于不熟悉 MHA 的用户来说，配置仍然可能是一项复杂的任务。特别是在涉及多个主库和备库的复杂环境中，配置可能变得更加困难。</li><li><code>依赖 SSH 连接</code>：MHA 通过 SSH 连接与主库和备库进行通信和监控。这意味着在配置和使用 MHA 时，必须确保 SSH 连接的可用性和稳定性，否则可能会导致 MHA 无法正常工作。由于需要基于 SSH 免认证配置，存在一定的安全隐患。</li><li><code>故障切换过程中的数据同步延迟</code>：在故障切换期间，MHA 需要将备库提升为新的主库，并重新配置其他备库作为新的从库。这个过程可能需要一些时间，导致在切换期间存在一定的数据同步延迟，这可能会对某些应用程序的数据一致性产生影响。</li><li><code>依赖 MySQL 复制功能</code>：MHA 依赖 MySQL 的半同步复制方式来实现数据的同步和复制。如果 MySQL 的复制功能出现问题，可能会导致 MHA 无法正常工作或数据同步不完整。</li><li><code>需要额外的硬件资源</code>：为了实现高可用性，MHA 需要至少一个备库来作为冗余备份。这意味着需要额外的硬件资源来支持备库的运行和数据复制，增加了系统的成本和复杂性。</li><li><code>只监控 Master 节点</code>：MHA 启动后只会对主数据库进行监控，并不关注 Slave 节点的运行状态，这可能会导致 Master 节点挂掉后切换到无效的 Slave 节点，从而导致系统崩溃。</li><li><code>需要配置 VIP</code>：MHA 需要编写脚本或利用第三方工具来实现 VIP（虚拟 IP）的配置。</li><li><code>存在脑裂的问题</code>：可能会因网络分区导致脑裂问题的发生。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>MHA 并不是万能的解决方案，它适用于大多数的 MySQL 数据库场景，但在特定的情况下可能需要根据实际需求进行定制化的配置和调整。此外，为了确保 MHA 的正常运行，还需要进行定期的监控和维护工作，以保证系统的稳定性和可靠性。</p></div><h2 id="MGR"><a href="#MGR" class="headerlink" title="MGR"></a>MGR</h2><p>MGR（MySQL Group Replication）是 MySQL 官方在 <code>5.7.17</code> 版本引进的一个数据库高可用解决方案，以插件形式提供，用于实现 MySQL 数据库的主从复制和自动故障切换。MGR 基于 MySQL 的 InnoDB 存储引擎和 Group Replication 插件实现，引入组复制主要是为了解决传统异步复制和半同步复制可能产生数据不一致的问题。<strong>值得一提的是，MGR 支持单主模式与多主模式，多主模式支持多点写入，MySQL 官方推荐使用单主模式。</strong></p><ul><li><p>MGR 架构的核心组件</p><ul><li><code>Group Replication 组件</code>：Group Replication 是 MySQL 官方提供的插件，用于实现多主复制和自动故障切换。它基于 Paxos 协议，通过在集群中的成员之间进行通信和协调，实现数据的同步和一致性。</li><li><code>Primary 节点</code>：Primary 节点是 MGR 集群中的主节点，负责处理所有的写操作和读操作。Primary 节点接收来自应用程序的写请求，并将数据复制到其他节点（Secondary 节点）上。</li><li><code>Secondary 节点</code>：Secondary 节点是 MGR 集群中的从节点，负责复制 Primary 节点上的数据。Secondary 节点通过与 Primary 节点进行通信，接收并应用 Primary 节点上的写操作，以保持数据的一致性。</li></ul></li><li><p>MGR 架构的工作流程</p><ul><li><code>初始化集群</code>：在 MGR 架构中，首先需要选择一个节点作为初始 Primary 节点，并将其配置为 Group Replication 组件的成员。然后，其他节点可以加入到集群中，并通过与 Primary 节点进行通信，获取数据并成为 Secondary 节点。</li><li><code>数据同步</code>：一旦集群初始化完成，Primary 节点开始接收来自应用程序的写请求，并将数据复制到其他节点上。Secondary 节点通过与 Primary 节点进行通信，接收并应用 Primary 节点上的写操作，以保持数据的一致性。</li><li><code>自动故障切换</code>：如果 Primary 节点发生故障，Group Replication 组件会自动选择一个 Secondary 节点作为新的 Primary 节点，并将其他节点重新配置为新的 Secondary 节点。这个过程是自动的，无需人工干预。</li></ul></li></ul><h3 id="整体架构-3"><a href="#整体架构-3" class="headerlink" title="整体架构"></a>整体架构</h3><p><img data-src="../../../asset/2023/10/mysql-ha-6.png"></p><h3 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>MGR 由若干个节点共同组成一个复制组，一个事务的提交，必须经过组内大多数节点（N / 2 + 1）决议并通过，才能得以提交。</li><li>MGR 基于分布式 Paxos 协议，实现组复制，保证数据的强一致性，自带故障检测和自动选主功能。</li><li>MGR 基于 ROW 格式的二进制日志文件和 GTID 特性。</li></ul><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ul><li><code>自动故障切换</code>：MGR 能够自动检测 Primary 节点的故障，并快速将一个 Secondary 节点提升为新的 Primary 节点，实现自动故障切换，提高了系统的可用性。只要有 N / 2 + 1 节点可用，集群就可用。</li><li><code>保证数据的强一致性</code>：MGR 使用 Paxos 协议来保证数据的强一致性。在写操作提交之前，集群中的成员会达成一致，确保数据在所有节点上的复制是一致的。</li><li><code>简化配置和管理</code>：MGR 提供了简单易用的配置选项和管理工具，使得集群的配置和管理变得更加简单和方便。</li><li><code>高可扩展性</code>：MGR 支持多主复制，可以根据需求灵活地扩展系统的容量和性能。</li><li><code>支持多主模式，但目前该技术还不是很成熟</code><ul><li>多主模式下，客户端可以随机向 MySQL 节点写入数据。</li><li>单主模式下，MGR 集群会选出 Primary 节点负责写请求，Primary 和 Secondary 节点都可以进行读请求的处理。</li></ul></li></ul></li><li><p>缺点</p><ul><li><code>网络稳定性</code>：MGR 对网络的稳定性要求较高，因为节点之间需要进行频繁的通信和数据同步。如果网络不稳定，可能会导致数据同步延迟或节点之间的通信故障。</li><li><code>数据冲突</code>：由于 MGR 支持多主复制，如果应用程序在不同的节点上同时进行写操作，可能会导致数据冲突和一致性问题。因此，需要在应用程序层面进行合理的设计和处理。</li><li><code>配置复杂性</code>：尽管 MGR 提供了简化的配置选项和管理工具，但对于不熟悉 MGR 的用户来说，配置仍然可能是一项复杂的任务。特别是在涉及多个节点和复杂环境中，配置可能变得更加困难。</li><li><code>存在较多限制</code>：<ul><li>仅支持 Innodb 储存引擎，且储存引擎的版本必须一致。</li><li>所有节点的 MySQL 版本必须一致，否则无法添加到 MGR 中。</li><li>不支持异构的 MySQL 节点，也就是说，所有 MySQL 节点的操作系统和版本必须一致。</li><li>只能在 GTID 模式下使用。</li><li>Binlog 的日志格式必须为 ROW 格式。</li><li>每个表都必须有主键，在进行事务冲突检测时需要利用主键值进行对比。</li><li>RP 和普通复制 Binlog 校验不能共存，需设置 <code>--binlog-checksum=none</code>。</li><li>不支持 <code>gap lock（间隙锁）</code>，隔离级别需设置为 <code>read_committed</code>。</li><li>不支持对表进行锁操作（如 <code>lock table</code>、<code>unlock table</code>）。</li><li>不支持在不同的 MGR 节点上，对同一个表分别执行 DML 和 DDL，可能会造成数据丢失或节点报错退出。</li><li>DDL 语句不支持原子性，不能检测冲突，执行后需自行校验是否一致。</li><li>多主模式下不支持使用外键，但单主模式下支持使用外键。</li><li>不支持 <code>serializable（串行）</code> 隔离级别。</li><li>不支持复制过滤（Replication Filters）设置。</li><li>最多支持 9 个节点，超过 9 个节点无法加入组。</li></ul></li></ul></li><li><p>适用场景</p><ul><li>要求数据强一致性的业务场景</li><li>希望对数据库的写服务提供高可用保障，但又不想安装第三方软件</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>在使用 MGR 之前，建议进行充分的测试和评估，以确保它能够满足系统的可用性和性能要求，并根据具体的应用场景和需求进行适当的配置和调整。</p></div><h2 id="MySQL-Cluster"><a href="#MySQL-Cluster" class="headerlink" title="MySQL Cluster"></a>MySQL Cluster</h2><p>MySQL Cluster （又叫 MySQL NDB Cluster）是 MySQL 官方开源的一种分布式数据库解决方案，旨在提供高可用性、可扩展性和实时性能。它基于 NDB（Network DataBase）存储引擎，使用多台服务器组成一个集群，提供数据的分片和复制，以实现高可用性和自动的读写负载均衡。值得一的是，MySQL Cluster 兼容 ACID 事务，不存在单点故障，支持自动水平扩容，可以保证数据的强一致性。</p><div class="admonition warning"><p class="admonition-title">注意</p><p>由于 MySQL Cluster 的使用和配置都比较复杂，该方案在国内并没有被大规模使用。</p></div><h3 id="整体架构-4"><a href="#整体架构-4" class="headerlink" title="整体架构"></a>整体架构</h3><p><img data-src="../../../asset/2023/10/mysql-ha-8.png"></p><ul><li>MySQL Cluster 架构的核心组件<ul><li><code>Management 节点</code>：Management 节点是 MySQL Cluster 的控制节点，负责集群的管理和配置。它负责监控集群中的各个节点，并协调数据的分片和复制。</li><li><code>Data 节点</code>：Data 节点是 MySQL Cluster 的数据节点，负责存储和处理数据。每个 Data 节点都运行 NDB 存储引擎，数据被分片存储在不同的 Data 节点上，以实现数据的分布和负载均衡。</li><li><code>SQL 节点</code>：SQL 节点是 MySQL Cluster 的查询节点，负责处理应用程序的查询请求。SQL 节点接收来自应用程序的 SQL 查询，并将查询分发到适当的 Data 节点上进行处理。</li></ul></li></ul><h3 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><p>MySQL Cluster 架构的工作流程如下：</p><ul><li><code>集群初始化</code>：在 MySQL Cluster 中，首先需要配置和启动 Management 节点，然后配置和启动 Data 节点和 SQL 节点。Management 节点负责监控和管理集群中的各个节点。</li><li><code>数据分片和复制</code>：一旦集群初始化完成，Management 节点会根据配置的规则将数据分片存储在不同的 Data 节点上。数据的复制和同步由 MySQL Cluster 自动处理，以保证数据的一致性和可用性。</li><li><code>查询处理</code>：当应用程序发送查询请求时，SQL 节点接收并解析查询，并将查询分发到适当的 Data 节点上进行处理。Data 节点返回查询结果给 SQL 节点，然后 SQL 节点将结果返回给应用程序。</li></ul><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ul><li><code>高可用性</code>：MySQL Cluster 通过数据的分片和复制，以及自动故障检测和恢复机制，实现了高可用性。即使某个节点发生故障，集群仍然可以继续提供服务。</li><li><code>可扩展性</code>：MySQL Cluster 支持水平扩展，可以通过增加 Data 节点来扩展存储容量和处理能力。同时，由于数据的分片和负载均衡，可以实现更好的性能和吞吐量。</li><li><code>实时性能</code>：MySQL Cluster 的设计目标之一是提供实时性能。通过将数据存储在内存中，并使用并行处理和分布式计算，可以实现较低的延迟和更高的吞吐量。</li><li><code>数据的强一致性</code>：MySQL Cluster 使用多副本复制和同步机制，以保证数据的强一致性。即使在节点故障或网络分区的情况下，数据仍然可以保持一致。</li></ul></li><li><p>缺点：</p><ul><li><code>配置复杂性</code>：MySQL Cluster 的配置相对复杂，需要考虑数据分片、复制和负载均衡等因素。对于不熟悉 MySQL Cluster 的用户来说，配置可能是一项具有挑战性的任务。</li><li><code>内存需求</code>：由于 MySQL Cluster 将数据存储在内存中，因此对内存的需求较高，需要根据数据量和性能需求来配置足够的内存资源。</li><li><code>存储引擎需求</code>：MySQL Cluster 需要使用 NDB 存储引擎，与 MySQL 常用引擎（如 Innodb 引擎）存在一定的差异。</li><li><code>网络稳定性</code>：MySQL Cluster 对网络的稳定性要求较高，因为节点之间需要进行频繁的通信和数据同步。如果网络不稳定，可能会导致数据同步延迟或节点之间的通信故障。</li><li><code>重启时间长</code>：重启的时候，数据节点将数据加载到内存需要很长时间。</li><li><code>备份和恢复</code>：MySQL Cluster 对数据备份和恢复并不友好。</li><li><code>节点数需求</code>：搭建 MySQL Cluster 时，要求至少有三个服务器节点。</li><li><code>存在较多限制</code>：如不支持外键，数据行不能超过 8K（不包括 BLOB 和 TEXT 中的数据）等。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>在使用 MySQL Cluster 之前，建议进行充分的测试和评估，以确保它能够满足系统的可用性、性能和扩展性要求，并根据具体的应用场景和需求进行适当的配置和调整。</p></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.51cto.com/u_16099257/7022269">MySQL 高可用方案推荐</a></li><li><a href="https://bigdata.it168.com/a2016/0822/2871/000002871893.shtml">链家 MySQL 高可用架构设计</a></li><li><a href="https://mt.sohu.com/20170323/n484341088.shtml">10 款常见 MySQL 高可用方案选型解读</a></li><li><a href="https://www.php.cn/faq/554468.html">MySQL 中常见的高可用架构部署方案有哪些</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4NjE4NTUwNQ==&amp;mid=2247495043&amp;idx=8&amp;sn=85a4c8aa143ac9e11e1fea11ab134a1e">MySQL 高可用架构 - MMM、MHA、MGR、PXC</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 MySQL 的高可用架构方案，包括 MMM、MHA、MGR、MySQL Cluster。</summary>
    
    
    
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
