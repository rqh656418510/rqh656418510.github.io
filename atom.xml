<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术空间</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2025-08-22T13:12:19.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何设计可以动态扩容缩容的分库分表方案</title>
    <link href="https://www.techgrow.cn/posts/af97a1f4.html"/>
    <id>https://www.techgrow.cn/posts/af97a1f4.html</id>
    <published>2025-08-22T13:12:19.000Z</published>
    <updated>2025-08-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/af97a1f4.html">如何设计可以动态扩容缩容的分库分表方案</a></li><li><a href="/posts/2df884fd.html">分库分表后，生产环境如何实现不停机迁移数据</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线上系统已经完成了分库分表方案的落地：库表建好、基于分库分表中间件的开发与测试也都顺利完成，数据能够均匀分布到各个库表中，系统也通过双写方案平滑迁移并成功切换到分库分表架构上。然而，随着业务持续增长，现有的库表再次面临瓶颈：单库容量接近上限、单表数据量过大、单库写入并发压力过高等问题，必须进行进一步的扩容。比如，原来是 3 个库，每个库 4 个表，现在需要扩容成 6 个库，每个库 8 个表。问题是：如何在不影响线上业务（即不停机）的情况下，进行动态扩容或缩容呢？</p><span id="more"></span><h2 id="停机扩容"><a href="#停机扩容" class="headerlink" title="停机扩容"></a>停机扩容</h2><p>停机扩容与 <a href="/posts/2df884fd.html#%E5%81%9C%E6%9C%BA%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE">停机迁移数据</a> 类似，步骤基本相同，唯一的区别是需要使用数据导入工具，将现有库表中的数据抽取并导入到新的库表中。但这种方式并不推荐，原因在于：既然已经采用了分库分表，说明数据量非常庞大，可能达到数亿甚至几十亿条记录，此时再采用停机迁移的方式风险极高。从单库单表迁移到分库分表架构时，数据量尚可接受，单表最多两三千万条，通过开发数据迁移工具，使用多台机器并行处理，1 小时内就能完成导入。但当系统基于分库分表架构运行一段时间后，例如当前有一共 3 个库和 12 个表，数据量达到 1 亿 ～ 2 亿条，仅导入数据就需要数小时。假设 6 点开始导入数据，直到导入完成，后续还要修改数据库连接配置、重新部署系统、业务测试验证，往往到 10 点才能完成，停机时间过长，线上业务无法承受。</p><h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><p>一开始就将分库分表架构规划为 32 个库，每个库 32 张表，共 1024 张表。这种设计基本能够满足国内大多数互联网公司的需求，无论是支撑并发能力还是数据容量都没有问题。通过一次性规划足够的库表数量（如 32 个库，每个库 32 张表）+ 固定取模路由规则（<code>2^n</code>）+ DBA 库级迁移工具支持，既能保证早期部署简单，又能支持后期平滑扩容或缩容，避免频繁停机迁移和复杂的数据重新分片工作。</p><ul><li>性能预估：<ul><li>每个库可承载约 1000 TPS（写入并发），则 32 个库总共可支撑 32000 TPS。</li><li>如果每个库承载到 1500 TPS，则总共可达 48000 TPS，接近 5 万 /s。</li><li>前端再加一个消息队列（MQ）进行削峰：<ul><li>MQ 写入 QPS 可达 8 万 /s，MQ 消费 QPS 可达 5 万 /s，可平滑处理高并发写入。</li></ul></li></ul></li><li>容量规划：<ul><li>32 个库，每个库 32 张表。</li><li>一共 1024 张表，每表存 500 万条数据，总容量可达 50 亿条数据。</li><li>对于国内绝大多数互联网公司，这个规模一般足够支撑多年。</li></ul></li><li>路由规则：<ul><li>库路由：<code>orderId % 32</code> → 确定库。</li><li>表路由：<code>(orderId / 32) % 32</code> → 确定表，必须先将 <code>orderId</code> 除以库数量，再对表数量进行取模运算，目的是：<ul><li>避免表内数据分布不均，导致热点数据集中在某几个表或库；</li><li>将数据均匀打散到 32 个库 × 32 张表，每个库内部的 32 张表都能均匀分布数据；</li><li>避免表的分布就和库的分布耦合在一起，比如库 0 里永远只会使用到表 0，库 1 永远只会使用到表 1；</li></ul></li><li>这种 基于 <code>2^n</code> 的取模方案，天然支持倍数扩容和缩容，减少扩容时路由规则变更的复杂度。</li></ul></li><li>扩容策略：<ul><li>首次分库分表就 “一步到位”，建立 32 个库，每个库 32 张表，避免频繁扩容。</li><li>早期阶段：<ul><li>可将多个逻辑库部署在同一台 MySQL 服务器上，例如 4 台 MySQL 服务器，每台 MySQL 服务器创建 8 个库，一共有 32 个库。</li></ul></li><li>后期扩展：<ul><li>当 MySQL 单机实例压力过大，可以申请多台 MySQL 服务器，进行倍数扩容（如从 4 台扩展至 8 台）；</li><li>扩容时只需要不断地在旧库和新的 MySQL 服务器之间做数据迁移，然后系统仅需更改库的连接地址，重新发布即可，路由规则无需变更；</li><li>最多可扩展至 32 台 MySQL 服务器（每台一个库，每个库 32 张表）。</li></ul></li></ul></li><li>缩容策略：<ul><li>如果需要减少 MySQL 服务器的数量，可以进行倍数缩容（如从 8 台扩展至 4 台），即物理合并 MySQL 服务器（保持逻辑库的总数量不变）；</li><li>比如，原来 32 个库分布在 8 台 MySQL 服务器上，现在迁移到 4 台 MySQL 服务器上，每台 MySQL 服务器上有 8 个库；</li><li>只需要将部分库的数据迁移到其他 MySQL 服务器，然后系统仅需更改库的连接地址，重新发布即可，路由规则无需变更。</li></ul></li><li>优势总结：<ul><li>DBA 通过成熟的工具迁移旧库至新的 MySQL 服务器即可完成扩缩容，业务代码无需处理复杂的数据迁移逻辑。</li><li>这种分库分表规划减少了后期频繁改造的成本，也能较好应对未来业务增长。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何设计可以动态扩容缩容的分库分表方案。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="架构设计" scheme="https://www.techgrow.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分库分表后，生产环境如何实现不停机迁移数据</title>
    <link href="https://www.techgrow.cn/posts/2df884fd.html"/>
    <id>https://www.techgrow.cn/posts/2df884fd.html</id>
    <published>2025-08-21T13:12:19.000Z</published>
    <updated>2025-08-21T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/af97a1f4.html">如何设计可以动态扩容缩容的分库分表方案</a></li><li><a href="/posts/2df884fd.html">分库分表后，生产环境如何实现不停机迁移数据</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假设目前线上系统是单库单表（即未分库分表），单表已有约 600 万条数据。计划将数据迁移到 3 个库、每个库 4 张表的分库分表架构中，每张表存放约 50 万条数据。已经选定了分库分表的中间件（例如 Sharding-JDBC 或 Mycat），问题是：如何在不影响线上业务（即不停机）的情况下，将系统平滑迁移到新的分库分表架构上？</p><div class="admonition note"><p class="admonition-title">为什么要分库分表？</p><p>分库分表主要是两个原因，要不就是单库并发压力太高，要不就是单库数据量太大。</p></div><span id="more"></span><h2 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h2><h3 id="停机迁移数据"><a href="#停机迁移数据" class="headerlink" title="停机迁移数据"></a>停机迁移数据</h3><p>这里先介绍一种不常用的方案 - 停机迁移，相对比较简单、粗暴，技术含量不高。在网站或 App 提前发布公告，通知用户 0 点到 6 点期间系统停机维护。凌晨 0 点开始运维，到点后先停机，系统停止服务，不再有新的流量写入，此时旧的单库单表数据库保持静止。接着运行事先准备好的一次性数据迁移工具，把单库单表中的数据批量导出，并按照分库分表规则导入到新库中。数据导入完成后，更新系统的数据库连接配置，同时上线新版本代码（因为分库分表后 SQL 或数据访问逻辑可能有改动）。最后启动系统，连接新的分库分表架构，进行业务验证。如果业务验证通过，就算迁移完成。不过，这种 “停机迁移” 的方案相对比较简单、粗暴，技术含量不高。</p><p><img data-src="../../../asset/2025/08/database-split-1.png"></p><blockquote><p>停机迁移方案通常包括以下几个核心步骤：</p></blockquote><ul><li>(1) 读取数据<ul><li>按分页（<code>limit/offset</code> 或者主键范围）从旧表里分批读取数据，避免一次性读 600 万导致 OOM 或锁表。</li><li>典型做法：<ul><li>根据主键（比如自增 ID）按范围扫描：<code>select * from old_table where id between x and y</code></li><li>每次取 1w ~ 5w 条，批量处理。</li></ul></li></ul></li><li>(2) 路由规则计算（分库分表规则映射）<ul><li>根据预设的分库分表规则（比如 <code>user_id % 6</code> → 定位到某个库某个表）。</li><li>数据迁移工具对每一条数据计算：<ul><li>属于哪个分库</li><li>属于哪个分表</li></ul></li><li>举个例子： <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user_id = 1025</span><br><span class="line">库号 = user_id % 3   （0 ~ 2）</span><br><span class="line">表号 = user_id % 4   （0 ~ 3）</span><br><span class="line">最终落点 = db_2.user_table_1</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>(3) 写入新库<ul><li>批量插入目标分表（<code>batch insert</code>），减少网络往返。</li><li>写入前可能需要做：<ul><li>字段映射（比如旧表字段和新表字段不完全一致）</li><li>数据清洗（处理非法数据、空值等）</li><li>主键处理（旧表用自增 ID，新表可能使用雪花 ID 或 UUID，需要重新生成）</li></ul></li></ul></li><li>(4) 数据校验<ul><li>迁移完一批数据后，进行校验：<ul><li>数量校验：源表 10 万条数据，目标表分散后总和也应该是 10 万条数据。</li><li>抽样校验：随机抽几条数据，对比新旧库的字段值是否一致。</li><li>全量校验（可选）：做 MD5 校验，或者比对哈希值。</li></ul></li></ul></li><li>(5) 日志与容错<ul><li>每批迁移要有日志，记录成功或者失败。</li><li>失败的数据要单独写入 “重试队列”。</li><li>支持断点续传（例如数据迁移中断，可以从上次 ID 继续跑）。</li></ul></li><li>(6) 收尾工作<ul><li>所有数据迁移完毕，全量校验通过。</li><li>更新系统的数据库连接配置，让系统指向新的分库分表架构。</li><li>上线新版本代码（因为分库分表后 SQL 或数据访问逻辑可能有调整）。</li><li>重启服务，进行业务验证，确认无误后切换工作正式完成。</li></ul></li></ul><h2 id="不停机迁移方案"><a href="#不停机迁移方案" class="headerlink" title="不停机迁移方案"></a>不停机迁移方案</h2><h3 id="双写迁移数据"><a href="#双写迁移数据" class="headerlink" title="双写迁移数据"></a>双写迁移数据</h3><p>双写迁移是目前最常用且较为稳妥的一种迁移方式，优点是不需要停机，也不用熬夜等凌晨运维窗口。核心思路：在系统中对所有写库操作（增、删、改）进行改造，不仅写入旧库，同时也写入新库，即所谓的 “双写”。这样可以保证在迁移期间，新库持续写入最新数据。在此基础上，通常需要配合以下机制：</p><ul><li><code>数据同步</code>：迁移启动前，先通过全量复制将旧库的历史数据导入新库，再通过 Binlog 或数据同步程序保证新旧库实时增量同步。这样新库能够与旧库保持一致性，不会出现 “有新数据但未同步” 的情况。</li><li><code>数据比对</code>：迁移过程中，需要定期进行新旧库的数据校验（例如按主键范围抽样比对行数、字段值校验、聚合校验等），确保两边数据在数量和内容上保持一致，避免出现漏同步、同步延迟或数据不一致的问题。</li><li><code>补偿机制</code>：若比对过程中发现差异，可通过重放 Binlog、补偿 SQL 或自动修复任务进行数据回补，保证最终一致性。补偿一般在后台异步执行，不影响业务正常运行。</li></ul><p><img data-src="../../../asset/2025/08/database-split-2.png"></p><blockquote><p>双写迁移方案通常包括以下几个核心步骤：</p></blockquote><ul><li>(1) 数据实时同步<ul><li>首先开发并部署一个数据同步程序，将旧库的历史数据全量复制到新库中。由于旧库仍然在对外提供写服务（例如订单持续写入），同步程序还需要实时捕获旧库的增量变更并写入新库。核心思路是 “全量复制 + 增量实时同步”。</li><li>数据实时同步的常见做法是基于 MySQL Binlog 实时同步，通过解析 Binlog 日志捕获 <code>INSERT/UPDATE/DELETE</code> 操作，再写入新库，从而保证新旧库数据基本保持一致。</li><li>写入新库时，可以通过 <code>gmt_modified</code> 等时间戳字段进行判断：若新库不存在该数据，则直接插入；若新库已有该数据，但旧库的版本更新（修改时间更晚），则覆盖写入。</li><li>这一过程对旧库和业务系统无侵入性，不需修改应用代码，也无需回滚，仅需额外部署新库和同步程序；即使同步程序对旧库产生影响，也可随时停掉，不影响线上业务。</li></ul></li><li>(2) 双写改造与部署<ul><li>在业务系统中改造写操作，使所有增删改操作同时作用于旧库和新库。常见方案包括：<ul><li><code>数据库中间件拦截</code>：利用 ShardingSphere、MyCAT 等支持双写或路由功能的中间件，在代理层统一拦截写操作，实现业务层零改动即可完成双写。但需关注复杂 SQL 与事务支持情况，确保中间件稳定可靠。</li><li><code>ORM/AOP 层拦截</code>：在 ORM 框架或 AOP 拦截器层统一实现双写逻辑，例如通过 MyBatis 插件 + 多数据源实现。业务层透明感知数据库操作即可完成双写，同时可顺带处理幂等、异常重试和事务顺序控制，前提是系统使用统一的 ORM 框架。</li><li><code>Binlog 增量同步</code>：也可继续使用 Binlog 方式（Canal、Maxwell、Debezium 等）捕获旧库变更并实时写入新库，这种方式对业务无侵入，适合大数据量场景，但需保证 Binlog、网络和同步工具的稳定性，并结合全量导入和校验机制保障数据完整性。</li></ul></li><li>上线部署系统完成双写改造的新版本代码，然后停掉前期的数据同步程序，确保新写入数据由业务逻辑直接写入新库。</li></ul></li><li>(3) 数据比对与补偿<ul><li>由于双写策略也不保证新旧库的强一致性，此时需要上线一个数据比对与补偿程序。</li><li>数据比对与补偿程序会对比旧库近期的数据变更，逐表逐行校验新旧库的数据是否一致。</li><li>若发现不一致的数据，则从旧库读取并写入新库进行补偿。</li><li>该过程可能需要多轮循环，直至新旧库数据完全一致。</li></ul></li><li>(4) 切换到新库<ul><li>当确认新旧库数据完全一致后，可以停掉数据比对和补偿程序。</li><li>上线部署仅依赖分库分表、去掉双写逻辑的新版本代码。</li><li>重新部署系统，此时所有读写流量切换到新库，旧库逐步进入下线流程。</li></ul></li></ul><blockquote><p>双写迁移方案需要注意以下地方：</p></blockquote><ul><li>事务一致性<ul><li>旧库与新库之间无法保证强一致事务，必须容忍 “临时不一致”。</li><li>遇到异常时，至少要保证旧库优先成功，新库可以重试补偿。</li></ul></li><li>异常与补偿机制<ul><li>双写失败时（例如新库宕机），要记录失败日志或写入消息队列，后续重试补偿。</li><li>可设计一个数据补偿任务（定时比对旧库与新库的数据），保证最终一致性。</li></ul></li><li>顺序与幂等<ul><li>确保双写执行顺序与业务一致（例如先 <code>INSERT</code> 再 <code>UPDATE</code>），避免错序写入。</li><li>所有操作必须支持幂等，防止重试引起脏数据。</li><li>建议使用幂等写入，比如 MySQL 的 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</li></ul></li><li>更新操作特殊处理<ul><li>新库数据可能不存在，直接执行 <code>UPDATE</code> 可能更新不到任何行。</li><li>建议采用 “存在则更新，否则插入” 的更新策略，例如 MySQL 的 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</li></ul></li><li>全量迁移与增量校验<ul><li>在正式双写之前，最好先做一次全量迁移（减少新库缺少数据的概率）。</li><li>启用双写后，后台跑比对和补偿任务，抽查或全量校验新旧库数据，自动补偿不一致的数据。</li></ul></li></ul><p>这种方案在迁移过程中业务不会中断，用户几乎无感知，可靠性高。因此，目前大多数公司在迁移生产系统的数据时，都会采用这种 “双写 + 校验” 的方案。</p><h2 id="扩展知识内容"><a href="#扩展知识内容" class="headerlink" title="扩展知识内容"></a>扩展知识内容</h2><h3 id="数据库在线迁移工具"><a href="#数据库在线迁移工具" class="headerlink" title="数据库在线迁移工具"></a>数据库在线迁移工具</h3><p>主流的数据库在线迁移工具有以下几种，支持迁移在线业务，依赖 “全量复制 + 增量实时同步 + 切换” 的方案。自建环境推荐使用 XtraBackup（全量复制） + MySQL Replication（增量追平） + Canal（增量消费、双写），云环境推荐使用云厂商的 DTS / DMS，直接提供全量 + 增量 + 切换的托管能力。</p><ul><li><p><strong>(1) MySQL 原生工具</strong></p><ul><li>MySQL Replication (主从复制)<ul><li> 概述：<ul><li>将新库作为旧库的从库，开启基于 Binlog 的主从复制。通常先做全量数据同步，再实时同步增量数据，追平后切换主库。</li></ul></li><li>优点：<ul><li>MySQL 自带、成熟稳定、社区支持广、对业务代码零侵入。</li><li>基于 Binlog，增量数据实时同步，保证数据一致性。</li></ul></li><li>缺点：<ul><li>跨机房或网络延迟大时，复制延迟问题明显。</li><li>切换为主库需要停写或短暂停机（秒级）。</li><li>不适用于大规模 DDL 变更或 MySQL 版本跨度过大的迁移。</li></ul></li></ul></li><li>MySQL Group Replication / InnoDB Cluster<ul><li> 概述：<ul><li>基于 MySQL 官方的高可用集群，支持多主、多从、动态扩容。</li><li>严格来说，这不是专门的 “在线迁移工具”，本质上是 MySQL 的高可用方案，只是可以顺便解决迁移问题。</li></ul></li><li>优点：<ul><li>支持多主写入、自动故障转移。</li><li>支持自动处理节点加入 / 离开，迁移过程中可降低人为操作风险。</li></ul></li><li>缺点：<ul><li>部署复杂，对网络延迟和数据库版本有严格要求。</li><li>多主模式下存在冲突处理问题。</li><li>性能相对普通主从复制略差。</li><li>跨机房支持不理想。</li></ul></li></ul></li></ul></li><li><p><strong>(2) 企业常用迁移工具</strong></p><ul><li><a href="https://github.com/percona/percona-xtrabackup">Percona XtraBackup</a><ul><li> 概述：<ul><li>用于 MySQL 的热备份，全量复制旧库数据到新库，然后结合 Binlog 或其他增量方案追平。</li></ul></li><li>优点：<ul><li>支持热备份，不锁表。</li><li>备份速度快，适合大数据量（TB 级别）场景。</li><li>一致性好，可与 MySQL 主从复制结合实现无缝切换。</li><li>开源、社区成熟，企业使用广泛。</li></ul></li><li>缺点：<ul><li>只解决全量迁移问题，增量追平仍需依赖 Binlog 或其他方案；</li><li>对磁盘空间和 I/O 有较高要求。</li></ul></li></ul></li><li><a href="https://github.com/percona/percona-toolkit">pt-table-sync（Percona Toolkit）</a><ul><li>概述：<ul><li>用于全量数据校验、增量数据同步和比对，基于对比源库和目标库数据差异，按需补齐。</li></ul></li><li>优点：<ul><li>支持在线比对数据差异，自动修复，保证一致性。</li><li>支持断点续传，适合长时间迁移。</li><li>可用作双写迁移、切换后的数据一致性保障。</li><li>可以作为 Binlog 同步之后的校验工具。</li></ul></li><li>缺点：<ul><li>性能开销大，对源库影响明显，尤其是大表，适合流量低峰期运行。</li><li>仅适合 MySQL，且在大表场景下校验速度慢。</li><li>配置和使用复杂，需要 DBA 熟悉其工作原理。</li></ul></li></ul></li></ul></li><li><p><strong>(3) 增量同步中间件</strong></p><ul><li><a href="https://github.com/alibaba/canal">Canal（阿里开源）</a><ul><li>基于 Binlog 订阅，支持异构同步（MySQL → MySQL / ElasticSearch / Kafka）。</li></ul></li><li><a href="https://github.com/debezium/debezium">Debezium（国外开源）</a><ul><li>基于 CDC（Change Data Capture），是一个开源的分布式平台，支持多种数据库实时同步。</li></ul></li><li><a href="https://github.com/alibaba/otter">Otter（阿里开源）</a><ul><li>基于 Canal + 分布式调度，适合分库分表场景。</li></ul></li><li>DTS（阿里云数据库传输服务） / DMS（腾讯云数据库传输服务）</li><li>主流云厂商的在线迁移工具，支持断点续传、实时增量同步。</li></ul></li></ul><blockquote><p>数据库典型在线迁移数据的步骤如下：</p></blockquote><ul><li>(1) 新增 MySQL 服务器，建好库表结构（与现有表结构保持一致）。</li><li>(2) 全量迁移历史数据（XtraBackup / 全量 Dump）。</li><li>(3) 开启 Binlog 增量订阅（Canal / DTS / 原生主从复制）。</li><li>(4) 实时同步增量数据，并进行数据校验。</li><li>(5) 业务切换流量到新库（通过中间件配置或 DNS / 服务发现）。</li><li>(6) 平滑下线旧库。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cloud.tencent.com/developer/article/2204209">不停机迁移数据库的解决方案</a></li><li><a href="https://blog.csdn.net/2301_78858041/article/details/147819741">如何零停机、零丢失迁移数据库</a></li><li><a href="https://cloud.tencent.com/developer/article/1663946">分库分表后，生产环境怎么实现不停机数据迁移</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍分库分表后，生产环境如何实现不停机迁移数据。</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="架构设计" scheme="https://www.techgrow.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门基础教程之二</title>
    <link href="https://www.techgrow.cn/posts/c57e8370.html"/>
    <id>https://www.techgrow.cn/posts/c57e8370.html</id>
    <published>2025-08-15T13:12:19.000Z</published>
    <updated>2025-08-15T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门基础教程之一</a></li><li><a href="/posts/c57e8370.html">Kubernetes 入门基础教程之二</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Youtube 视频下载工具使用</title>
    <link href="https://www.techgrow.cn/posts/3f99e39.html"/>
    <id>https://www.techgrow.cn/posts/3f99e39.html</id>
    <published>2025-08-09T13:16:21.000Z</published>
    <updated>2025-08-09T13:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/yt-dlp/yt-dlp">yt-dlp</a> 是一个功能丰富的命令行音频 / 视频下载器，支持<a href="https://github.com/yt-dlp/yt-dlp/blob/master/supportedsites.md">数千个站点</a>，支持断点续传和网络代理等功能。</p><span id="more"></span><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li><a href="https://github.com/yt-dlp/yt-dlp">yt-dlp</a></li><li><a href="https://github.com/ytdl-org/youtube-dl">youtube-dl</a></li></ul><h2 id="yt-dlp-安装步骤"><a href="#yt-dlp-安装步骤" class="headerlink" title="yt-dlp 安装步骤"></a>yt-dlp 安装步骤</h2><ul><li>Pip 安装（依赖 Python）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Linux</span> / Mac</span><br><span class="line">pip install<span class="params"> -U</span> yt-dlp</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 安装（二进制方式）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Linux</span> (可直接下载可执行文件)</span><br><span class="line"><span class="keyword"># https</span>://github.com/yt-dlp/yt-dlp/releases</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">wget<span class="params"> -O</span> yt-dlp https://github.com/yt-dlp/yt-dlp/releases/download/2025.07.21/yt-dlp_linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line">sudo mv yt-dlp /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件授权</span></span><br><span class="line">sudo chmod +x /usr/bin/yt-dlp</span><br></pre></td></tr></tbody></table></figure><ul><li>Windows 安装（二进制方式）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"># Windows</span> (可直接下载 Exe 可执行文件)</span><br><span class="line"><span class="keyword"># https</span>://github.com/yt-dlp/yt-dlp/releases</span><br></pre></td></tr></tbody></table></figure><h2 id="yt-dlp-使用方法"><a href="#yt-dlp-使用方法" class="headerlink" title="yt-dlp 使用方法"></a>yt-dlp 使用方法</h2><h3 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h3><ul><li>下载命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span> <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理 + 多线程加速）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> -N</span> 4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>下载命令（支持断点续传 + 代理 + 多线程加速 + 安全文件名）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> --restrict</span>-filenames<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> -N</span> 4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>参数说明</li></ul><table><thead><tr><th>参数</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td><code>-N</code></td><td>指定线程数量</td><td>使用多个线程进行下载，可以加快下载速度</td></tr><tr><td><code>-c</code></td><td>支持断点续传</td><td>从已下载部分直接接着下载，不会重头开始下载</td></tr><tr><td><code>--restrict-filenames</code></td><td>使用安全文件名</td><td>文件名最终会变成类似 <code>2_HOUR_STUDY_WITH_ME.mp4</code></td></tr><tr><td><code>--proxy "http://127.0.0.1:7890"</code></td><td>指定代理</td><td>支持 <code>http://</code>、<code>https://</code>、<code>socks5://</code> 等代理格式</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>YouTube 视频通常分成音频 + 视频两个流下载，<code>yt-dlp</code> 会自动合并处理。</li><li>如果是长视频，建议 <code>yt-dlp</code> 配合 <code>-c</code> 断点续传和 <code>-N</code> 多线程加速，这样即使下载中途断了，也能很快恢复。</li><li><code>-N</code> 参数对大部分 HTTP 分片流（DASH、HLS）有效，对单个 MP4 文件直链无效。有些代理或网络环境下，如果线程数太高，可能触发 YouTube 限制。</li></ul></div><h3 id="查看视频格式"><a href="#查看视频格式" class="headerlink" title="查看视频格式"></a>查看视频格式</h3><ul><li>查看视频支持的格式 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -F</span><span class="params"> --cookies</span>-from-browser chrome<span class="params">  -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:6860"</span> <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>查看视频支持的格式（指定代理和 Cookie）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -F</span><span class="params"> --cookies</span>-from-browser chrome<span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:6860"</span> <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="yt-dlp-使用问题"><a href="#yt-dlp-使用问题" class="headerlink" title="yt-dlp 使用问题"></a>yt-dlp 使用问题</h2><h3 id="缺少-Cookie-信息"><a href="#缺少-Cookie-信息" class="headerlink" title="缺少 Cookie 信息"></a>缺少 Cookie 信息</h3><blockquote><p>问题描述：下载 YouTube 视频时，触发了人机验证 / 登录验证（如下所示），<code>yt-dlp</code> 没法直接绕过，所以它提示要用浏览器 Cookie 来模拟已登录的状态。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: [youtube] 5Q2Pc-e-8Qc: Sign in to confirm you’re not a bot. Use --cookies-from-browser or --cookies for the authentication. See  https://github.com/yt-dlp/yt-dlp/wiki/FAQ#how-do-i-pass-cookies-to-yt-dlp  for how to manually pass cookies. Also see  https://github.com/yt-dlp/yt-dlp/wiki/Extractors#exporting-youtube-cookies  for tips on effectively exporting YouTube cookies</span><br></pre></td></tr></tbody></table></figure><blockquote><p>解决方法一：使用浏览器插件</p></blockquote><ul><li><p>(1) 安装浏览器插件</p><ul><li>推荐用 <code>Get cookies.txt</code>（Chrome）或 Firefox 的同类扩展插件。</li></ul></li><li><p>(2) 导出 Cookie 文件</p><ul><li>浏览器打开 <code>https://www.youtube.com</code></li><li>确保已经登录 Youtube</li><li> 点击扩展插件 → 导出 Cookies → 保存成 <code>cookies.txt</code> 文件</li></ul></li><li><p> (3) 让 <code>yt-dlp</code> 用 Cookie 文件下载</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span><span class="params"> --cookies</span> cookies.txt <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>解决方法二：从浏览器自动读取 Cookie</p></blockquote><ul><li><p>(1) <code>yt-dlp</code> 支持直接读取浏览器的 Cookie（需要本地环境支持）</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> --cookies</span>-from-browser chrome<span class="params"> -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:7890"</span> <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>(2) 参数说明</p><ul><li><code>--cookies-from-browser chrome</code> 表示从 Chrome 读取 Cookie，也支持用 <code>firefox</code>、<code>edge</code> 等。</li><li>要求本地浏览器已经登录了 YouTube，并且浏览器没有关掉 Cookie 保存功能。</li></ul></li></ul><h3 id="音频和视频合并失败"><a href="#音频和视频合并失败" class="headerlink" title="音频和视频合并失败"></a>音频和视频合并失败</h3><p>YouTube 视频通常分成音频 + 视频两个流下载，<code>yt-dlp</code> 会在两者下载完成后自动合并处理。但是，如果 <code>.webm</code> 音频是 Opus 编码，直接合并进 <code>.mp4</code> 会报错，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading webpage</span><br><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading tv client config</span><br><span class="line">[youtube] 5Q2Pc-e-8Qc: Downloading tv player API JSON</span><br><span class="line">[info] 5Q2Pc-e-8Qc: Downloading 1 format(s): 401+251</span><br><span class="line">[download] 2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].f401.mp4 has already been downloaded</span><br><span class="line">[download] 100% of    3.27GiB</span><br><span class="line">[download] 2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].f251.webm has already been downloaded</span><br><span class="line">[download] 100% of  111.71MiB</span><br><span class="line">[Merger] Merging formats into "2_-HOUR_STUDY_WITH_ME-[5Q2Pc-e-8Qc].webm"</span><br><span class="line">ERROR: Postprocessing: Conversion failed!  </span><br></pre></td></tr></tbody></table></figure><p>这种情况需要使用 Ffmpeg 先将音频转成 AAC 编码，然后再进行合并（前提是 <code>yt-dlp</code> 已经将 <code>.webm</code> 和 <code>.mp4</code> 文件都完整地下载到本地）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg<span class="params"> -i</span> video.mp4<span class="params"> -i</span> audio.webm<span class="params"> -c</span>:v copy<span class="params"> -c</span>:a aac<span class="params"> -b</span>:a 192k output.mp4</span><br></pre></td></tr></tbody></table></figure><h3 id="下载时合并音频和视频"><a href="#下载时合并音频和视频" class="headerlink" title="下载时合并音频和视频"></a>下载时合并音频和视频</h3><p>YouTube 视频通常分成音频 + 视频两个流下载，若希望 <code>yt-dlp</code> 在下载两者的时候直接合并，可以参考以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> <span class="string">"bv*+ba"</span><span class="params"> --merge</span>-output-format mp4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数 <code>-f "bv*+ba"</code> 是 <code>yt-dlp</code> 里的格式选择表达式，意思是：</p><ul><li><code>bv*</code> = best video stream（最好画质的视频流），<code>*</code> 表示不限编码类型（AV1、VP9、H.264 都可以）</li><li><code>ba</code> = best audio stream（最好音质的音频流）</li><li><code>+</code> = 选择视频流和音频流，并在下载后合并成一个文件</li></ul><h3 id="下载时指定视频的分辨率"><a href="#下载时指定视频的分辨率" class="headerlink" title="下载时指定视频的分辨率"></a>下载时指定视频的分辨率</h3><ul><li>查看视频支持的格式 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -F</span><span class="params"> --cookies</span>-from-browser chrome<span class="params">  -c</span><span class="params"> --proxy</span> <span class="string">"http://127.0.0.1:6860"</span> <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[info] Available formats for DXT9dF-WK-I:</span><br><span class="line">ID      EXT   RESOLUTION FPS CH │   FILESIZE   TBR PROTO │ VCODEC          VBR ACODEC      ABR ASR MORE INFO</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">249-drc webm  audio only      2 │   89.74MiB   51k https │ audio only          opus        51k 48k low, DRC, webm_dash</span><br><span class="line">250-drc webm  audio only      2 │  119.84MiB   67k https │ audio only          opus        67k 48k low, DRC, webm_dash</span><br><span class="line">249     webm  audio only      2 │   88.83MiB   50k https │ audio only          opus        50k 48k low, webm_dash</span><br><span class="line">250     webm  audio only      2 │  118.56MiB   67k https │ audio only          opus        67k 48k low, webm_dash</span><br><span class="line">140-drc m4a   audio only      2 │  229.94MiB  129k https │ audio only          mp4a.40.2  129k 44k medium, DRC, m4a_dash</span><br><span class="line">251-drc webm  audio only      2 │  241.29MiB  136k https │ audio only          opus       136k 48k medium, DRC, webm_dash</span><br><span class="line">140     m4a   audio only      2 │  229.94MiB  129k https │ audio only          mp4a.40.2  129k 44k medium, m4a_dash</span><br><span class="line">251     webm  audio only      2 │  239.12MiB  135k https │ audio only          opus       135k 48k medium, webm_dash</span><br><span class="line">244     webm  854x480     24    │  568.95MiB  320k https │ vp9            320k video only          480p, webm_dash</span><br><span class="line">397     mp4   854x480     24    │  342.40MiB  193k https │ av01.0.04M.08  193k video only          480p, mp4_dash</span><br><span class="line">136     mp4   1280x720    24    │  385.71MiB  217k https │ avc1.4d401f    217k video only          720p, mp4_dash</span><br><span class="line">247     webm  1280x720    24    │    1.05GiB  603k https │ vp9            603k video only          720p, webm_dash</span><br><span class="line">398     mp4   1280x720    24    │  653.15MiB  368k https │ av01.0.05M.08  368k video only          720p, mp4_dash</span><br><span class="line">137     mp4   1920x1080   24    │    1.59GiB  915k https │ avc1.640028    915k video only          1080p, mp4_dash</span><br><span class="line">248     webm  1920x1080   24    │    1.62GiB  934k https │ vp9            934k video only          1080p, webm_dash</span><br><span class="line">399     mp4   1920x1080   24    │    1.21GiB  699k https │ av01.0.08M.08  699k video only          1080p, mp4_dash</span><br><span class="line">271     webm  2560x1440   24    │    4.40GiB 2540k https │ vp9           2540k video only          1440p, webm_dash</span><br><span class="line">400     mp4   2560x1440   24    │    3.72GiB 2146k https │ av01.0.12M.08 2146k video only          1440p, mp4_dash</span><br><span class="line">313     webm  3840x2160   24    │   14.92GiB 8602k https │ vp9           8602k video only          2160p, webm_dash</span><br><span class="line">401     mp4   3840x2160   24    │    8.33GiB 4805k https │ av01.0.12M.08 4805k video only          2160p, mp4_dash</span><br></pre></td></tr></tbody></table></figure><ul><li>下载视频时指定分辨率 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> 137+140 <span class="string">"https://www.youtube.com/watch?v=xxxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><code>137</code> 表示 1920x1080 视频（<code>avc1</code> 编码标记，即 H.264 视频编码）</li><li><code>140</code> 表示 MP4 音频（<code>m4a</code> 音频编码）</li></ul><h3 id="下载时指定视频编码为-H-264"><a href="#下载时指定视频编码为-H-264" class="headerlink" title="下载时指定视频编码为 H.264"></a>下载时指定视频编码为 H.264</h3><p>若希望指定 <code>yt-dlp</code> 下载视频的编码格式为 H.264（在 YouTube 格式代码中，H.264 编码视频通常带有 <code>avc1</code> 标签），可以参考以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp<span class="params"> -f</span> <span class="string">"bv[codec^=avc1]+ba"</span><span class="params"> --merge</span>-output-format mp4 <span class="string">"https://www.youtube.com/watch?v=xxxx"</span></span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><code>-f "bv[codec^=avc1]+ba"</code><ul><li><code>bv</code> = best video stream（最好画质的视频流）</li><li><code>[codec^=avc1]</code> = <code>codec</code> 字段以 <code>avc1</code> 开头（H.264 的编码标记）</li><li><code>ba</code> = best audio stream（最好音质的音频流）</li><li><code>+</code> = 选择视频流和音频流，并在下载后合并成一个文件</li></ul></li><li><code>--merge-output-format mp4</code><ul><li>限制输出容器是 MP4（和 H.264 配合更好）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Youtube 视频下载工具的使用。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Redis 哨兵机制详解</title>
    <link href="https://www.techgrow.cn/posts/660eca58.html"/>
    <id>https://www.techgrow.cn/posts/660eca58.html</id>
    <published>2025-07-27T13:15:32.000Z</published>
    <updated>2025-07-27T13:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="哨兵机制的概念"><a href="#哨兵机制的概念" class="headerlink" title="哨兵机制的概念"></a>哨兵机制的概念</h2><p>Redis 有三种模式：分别是主从复制、哨兵模式、集群模式，后两者可以保证高可用。</p><ul><li><strong>哨兵（Sentinel）机制是什么</strong><ul><li>哨兵机制主要用于 Redis 主从架构下的故障检测与自动主从切换。</li><li>哨兵一个专门用于高可用的 Redis 组件（节点），不是用于存储数据的。</li><li>哨兵不参与数据同步和读写，而是专门负责监控、故障切换和通知客户端谁是主节点。</li><li>哨兵进程通常和 Redis 节点分开部署（也可以部署在同一台机器上，但进程独立）。</li><li>通常运行多个哨兵实例（即哨兵集群），实现冗余和仲裁。每个哨兵都会连接至 Master 节点和所有 Slave 节点，监控它们的状态信息。</li></ul></li></ul><span id="more"></span><ul><li><p><strong>哨兵（Sentinel）节点的作用是什么</strong></p><ul><li>监控（Monitor）：持续检查主节点和从节点是否存活（通过 PING 等）。</li><li>通知（Notification）：检测到故障后通知系统管理员或其他服务。</li><li>自动故障转移（Failover）：如果主节点不可用，选举一个从节点提升为新主节点。</li><li>服务发现（Discovery）：提供主节点的地址信息给客户端（可供自动重连）；如果发生了故障转移，会通知客户端新的主节点地址。</li></ul></li><li><p><strong>哨兵（Sentinel）节点不是从节点（Slave）</strong></p><ul><li>哨兵节点不负责同步数据，也不参与数据读写。</li><li>它只是通过 Redis 协议连接 Redis 实例，执行命令如 INFO、PING 来感知状态。</li><li>哨兵节点不保存业务数据，最多保存一些监控状态（内存中）。</li></ul></li><li><p><strong>为什么需要哨兵（Sentinel）机制</strong></p><ul><li>Redis 的主从复制机制主要用于实现数据备份和读请求的负载分担，但它本身并不具备自动容错和主节点自动切换的能力。因此，单纯依赖主从复制并不能保证系统的高可用性。具体表现如下：<ul><li>需要人工介入：当主节点发生故障时，Redis 本身无法自动完成故障切换，需要运维人员手动将某个从节点提升为新的主节点，并重新配置其他从节点同步新的主节点。</li><li>单点故障风险：主节点作为写操作的唯一入口，一旦宕机，系统的写操作将完全中断，严重影响服务可用性。</li><li>主节点写入能力受限：Redis 是单线程模型，主节点的写入吞吐受限于单机性能，无法横向扩展。</li><li>单机节点存储容量有限：Redis 通常运行在内存中，主节点的物理内存限制了存储能力。</li></ul></li><li>Redis 哨兵机制应运而生，用于增强 Redis 在主从架构下的高可用性。它具备以下能力：<ul><li>哨兵节点自动监控 Redis 实例状态（包括主节点和从节点）。</li><li>主节点宕机时，自动完成主从切换（Failover）。</li><li>通知支持 Sentinel 机制的客户端连接新的主节点。</li><li>协助管理 Redis 主从结构并确保一致性。</li></ul></li><li>若需要进一步提高 Redis 的可用性与扩展性，还可以使用 Redis Cluster（集群），它支持数据分片（水平扩展），具备原生的多主多从架构、高可用、以及容错能力。</li></ul></li></ul><h2 id="哨兵机制的原理"><a href="#哨兵机制的原理" class="headerlink" title="哨兵机制的原理"></a>哨兵机制的原理</h2><p>Redis 哨兵机制是通过在独立的哨兵节点上运行特定的哨兵进程来实现的。这些哨兵进程监控主从节点的状态，并在出现故障时自动完成故障转移，并通知应用方，实现高可用性。</p><ul><li><p><strong>(1) 哨兵选举：</strong></p><ul><li>在启动时，每个哨兵节点都会参与选举，其中一个哨兵节点会被选为领导者（Leader），负责协调其他哨兵节点执行故障转移。选举过程如下：<ul><li>每个在线的哨兵节点都有资格成为领导者。当某个哨兵判断主节点不可用后，会向其他哨兵节点发送 <code>is-master-down-by-addr</code> 命令，请求判断主节点状态并征求选票，希望被选为本轮的领导者。</li><li>其他哨兵节点在收到该命令后，会根据自身判断和是否已经投票的情况，决定是否同意对方成为领导者（每个哨兵在同一轮选举中只能投票一次）。</li><li>如果某个哨兵节点获得的选票数达到或超过 <code>总哨兵节点数 / 2 + 1</code>（即超过半数），则该哨兵节点将成为本轮选举的领导者；如果未能获得足够票数，则会进入下一轮选举，直到选出领导者为止。</li></ul></li></ul></li><li><p><strong>(2) 哨兵监控主从节点:</strong></p><ul><li>哨兵节点通过发送命令周期性地检查主从节点的健康状态，包括主节点是否在线、从节点是否同步等。</li><li>如果哨兵节点发现主节点不可用，它会触发一次故障转移操作，而且是由哨兵领导者负责处理主节点的故障转移。</li></ul></li><li><p><strong>(3) 哨兵执行故障转移：</strong></p><ul><li>一旦主节点被判定为不可用，哨兵节点会执行故障转移操作。它会从当前的从节点中选出一个新的主节点，并将其他从节点切换到新的主节点。这样，缓存系统可以继续提供服务，而无需人工介入。</li><li>故障转移过程：<ul><li>由哨兵节点定期监控主节点是否出现故障，哨兵节点会定期向主节点发送心跳 PING 来确认主节点是否存活。</li><li>如果主节点在 “一定时间范围” 内不响应 PONG 或者是回复了一个错误消息，那么这个哨兵节点会主观地（单方面地）认为这个主节点已经不可用了。</li></ul></li><li>确认新主节点：<ul><li>过滤掉不健康的从节点（如已下线、网络断连、长时间未响应哨兵 PING 命令的节点）。</li><li>在剩余的健康从节点中，优先选择优先级（Priority）最高的节点。</li><li>如果有多个从节点优先级相同，则选择复制偏移量（Replication Offset）最大的节点，即数据最接近原主节点的从节点。</li><li>若优先级和复制偏移量都相等，则选择节点 ID 字典序最小的节点作为新主节点。</li></ul></li></ul></li><li><p><strong>(4) 客户端重定向：</strong></p><ul><li>当主节点出现故障时，哨兵节点会自动发起主从切换（故障转移），选举一个新的从节点作为新的主节点。</li><li>哨兵节点不会直接通知客户端新的主节点地址，而是提供一个服务发现机制。客户端需要通过支持哨兵机制的客户端，从哨兵节点动态获取当前的主节点地址。</li><li>这样一来，客户端可以在主节点切换后，通过哨兵节点重新获取主节点信息，从而无感知地完成主节点重连，保证业务连续性。</li><li>此外，哨兵节点还会持续监控所有主节点和所有从节点的运行状态，如果某个从节点出现故障，哨兵节点会将其标记为下线；一旦从节点恢复，哨兵节点会自动将其重新加入主从复制架构，并使其同步当前主节点的数据，以维持整个架构的完整性。</li></ul></li></ul><h2 id="哨兵的部署架构"><a href="#哨兵的部署架构" class="headerlink" title="哨兵的部署架构"></a>哨兵的部署架构</h2><p>Redis Sentinel（哨兵）本身是一个分布式系统，通常以哨兵集群的形式部署，多个哨兵节点之间可以协同工作，保障系统的高可用性（如下图所示）。</p><p><img data-src="../../../asset/2025/07/redis-sentinel-3.png"></p><ul><li><strong>哨兵（Sentinel）故障转移的核心概念</strong></li></ul><table><thead><tr><th>概念</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td><code>quorum</code>（法定票数）</td><td>Master 节点从主观下线（sdown）到客观下线（odown）所需的同意哨兵数（即最少 N 个哨兵同时判断 Master 为宕机）</td><td>确保哨兵对 Master 宕机的判断具有一定共识，避免误判</td></tr><tr><td><code>majority</code>（多数哨兵）</td><td>执行故障转移操作时，要求同意执行故障转移的哨兵数量必须达到总数的一半以上，否则不会执行故障转移</td><td>为了避免「脑裂」现象，即多个哨兵在不同网络分区中同时尝试进行故障转移，导致系统不一致或混乱</td></tr></tbody></table><ul><li><p><strong>哨兵（Sentinel）的部署架构是什么</strong></p><ul><li>Redis Sentinel（哨兵）本身是一个分布式系统，通常以哨兵集群的形式部署，多个哨兵节点之间可以协同工作，保障系统的高可用性。<ul><li>哨兵通常以集群的形式部署，这样是为了保证哨兵的高可用性<ul><li><strong>哨兵集群要求至少需要部署 3 个哨兵实例，否则可能无法保证故障转移的正常执行，同时也为了实现多数投票机制，并提高容错能力。</strong></li><li><strong>哨兵集群 + Redis 主从架构能够提供高可用性，但无法做到数据零丢失。故障转移过程中可能存在数据未完整同步到从节点的风险，因此仅适用于对可用性要求高、但允许少量数据丢失的场景。</strong></li><li>由于哨兵 + Redis 主从是一种相对复杂的部署架构，建议在测试环境和生产环境中都进行充分的测试与故障演练，确保系统在各种异常情况下都能稳定运行。</li></ul></li><li>在发生故障转移时，是否将一个主节点判定为宕机，必须经过多数哨兵节点（Quorum）的同意。这涉及到分布式选举机制，用于确保故障转移的判断和执行具备一致性和可靠性。</li><li>即使部分哨兵节点发生故障，哨兵集群仍然能够正常工作。这是因为哨兵本身作为高可用机制的一部分，必须具备容错能力，若其自身是单点的，那就违背了其设计初衷。</li><li>目前使用的是 Sentinel <code>2.x 版本</code>。与 Sentinel <code>1.x</code> 相比，Sentinel <code>2.x</code> 重写了大量核心代码，主要目的是简化故障转移流程、提升算法健壮性和系统稳定性，使其更适用于生产环境中的高可用场景。</li></ul></li></ul></li><li><p><strong>为什么 Redis 哨兵集群只有 2 个节点会无法正常工作</strong></p><ul><li>以部署了 2 个哨兵实例的场景为例（配置：<code>quorum = 1</code>）：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></tbody></table></figure></li><li>当主节点 M1 宕机时，只要 S1 和 S2 中任意一个哨兵认为 M1 宕机，就可以发起主观下线（Subjective Down，简称 sdown）判断。接着，两个哨兵会通过选举机制，选举出其中一个哨兵来执行故障转移操作。</li><li>但是，哨兵系统执行真正的故障转移时，还需要满足 <code>majority</code> 要求，也就是多数哨兵节点同意执行故障转移。例如：<ul><li>2 个哨兵时，要求 <code>majority = 2</code></li><li>3 个哨兵时，要求 <code>majority = 2</code></li><li>4 个哨兵时，要求 <code>majority = 3</code></li><li>5 个哨兵时，要求 <code>majority = 3</code></li></ul></li><li>因此在 2 个哨兵节点的场景中，只有当两个哨兵都正常运行时，才满足 <code>majority</code> 的要求，才允许执行故障转移操作。</li><li>如果运行主节点 M1 和哨兵 S1 的那台机器宕机了，意味着主节点 M1 和哨兵 S1 同时失效，只剩下从节点 R1 和哨兵 S2 仍在运行。此时虽然还有一个哨兵存在（S2），但由于无法满足 <code>majority</code> 要求，故障转移将不会被执行，导致缓存系统始终处于不可用状态。</li></ul></li><li><p><strong>Redis 经典的 3 节点哨兵集群架构</strong></p><ul><li>以部署了 3 个哨兵实例的场景为例（配置：<code>quorum = 2</code>）：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       +----+</span><br><span class="line">       | M1 |</span><br><span class="line">       | S1 |</span><br><span class="line">       +----+</span><br><span class="line">          |</span><br><span class="line">+----+    |    +----+</span><br><span class="line">| R2 |----+----| R3 |</span><br><span class="line">| S2 |         | S3 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></tbody></table></figure></li><li>如果主节点 M1 所在的机器宕机，意味着主节点 M1 和哨兵 S1 同时失效，剩下的两个哨兵 S2 和 S3 仍在运行。此时：<ul><li>哨兵 S2 和 S3 可以一致地判断主节点 M1 宕机了（满足 <code>quorum = 2</code>），从而形成客观下线（odown）判断；</li><li>接着，S2 和 S3 两个哨兵会通过选举机制，选举出其中一个哨兵负责执行故障转移操作；</li><li>因为 3 个哨兵的 <code>majority</code> 要求为 2，而当前恰好有 2 个哨兵仍然存活，所以满足故障转移所需的条件。</li></ul></li><li>因此，在这种经典的 3 节点哨兵集群架构下，即使一台机器宕机，只要剩余的 2 个哨兵还在正常运行，依然可以完成故障转移，从而保证整个哨兵集群的高可用性。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>无论 Redis 是一主一从、一主多从的复制架构，都可以使用 Redis 的哨兵机制，官方更推荐使用一主多从的复制架构，这样可用性更高。</li></ul></div><h2 id="哨兵机制的使用"><a href="#哨兵机制的使用" class="headerlink" title="哨兵机制的使用"></a>哨兵机制的使用</h2><p>在 SpringBoot 项目中，使用 Lettuce 客户端连接 Redis 的一主多从 + 哨兵模式时，只需要在 <code>application.yml</code> 正确配置哨兵信息，SpringBoot 就会自动识别并创建 Lettuce 连接。</p><ul><li>SpringBoot 配置文件示例（<code>application.yml</code>）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span>             <span class="comment"># 主节点名称，对应哨兵配置中的 sentinel monitor 的名称</span></span><br><span class="line">      <span class="attr">nodes:</span>                       <span class="comment"># 哨兵节点列表（ip:port）</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourRedisPassword</span>    <span class="comment"># Redis 认证密码（如果开启了）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><ul><li>若希望使用从节点读取数据（主节点默认可以读写，但从节点只读不可写），可以使用以下 SpringBoot 配置信息 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span>             <span class="comment"># 主节点名称，对应哨兵配置中的 sentinel monitor 的名称</span></span><br><span class="line">      <span class="attr">nodes:</span>                       <span class="comment"># 哨兵节点列表（ip:port）</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourRedisPassword</span>    <span class="comment"># Redis 认证密码（如果开启了）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">read-from:</span> <span class="string">REPLICA_PREFERRED</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>Lettuce 的配置值</th><th>含义</th></tr></thead><tbody><tr><td><code>MASTER</code></td><td>所有请求都从主节点读取（默认）</td></tr><tr><td><code>MASTER_PREFERRED</code></td><td>优先主节点，主节点不可用时才从从节点读取</td></tr><tr><td><code>REPLICA</code>（或 <code>SLAVE</code>）</td><td>所有请求都从从节点读取</td></tr><tr><td><code>REPLICA_PREFERRED</code></td><td>优先从从节点读取，从节点不可用时回退到主节点</td></tr><tr><td><code>NEAREST</code></td><td>从网络延迟最小的节点读取（需要集群拓扑支持）</td></tr></tbody></table><ul><li>Redis 哨兵配置文件示例（<code>redis-sentinel.conf</code>）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控名为 mymaster 的主节点，IP 是 192.168.1.100，端口 6379，</span></span><br><span class="line"><span class="comment"># 至少有 2 个哨兵同时判断该主节点不可达时，才会被判定为主观下线（sdown）</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span> <span class="number">6379 </span><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 5000 毫秒（5 秒）内没有收到主节点的响应，哨兵就认为主节点已主观下线</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个故障转移（Failover）过程的超时时间：10 秒</span></span><br><span class="line"><span class="comment"># 包括选举新主节点、通知其他从节点进行复制、通知客户端更新配置等</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移时，最多同时有 1 个从节点并行地从新的主节点复制数据（同步）</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><ul><li>引入 Lettuce 依赖，使用 Lettuce 的默认连接工厂 </li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot 默认使用 Lettuce 作为 Redis 客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Redis 连接验证代码 </li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"testKey"</span>, <span class="string">"hello from sentinel"</span>);</span><br><span class="line">    String value = stringRedisTemplate.opsForValue().get(<span class="string">"testKey"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Redis 返回: "</span> + value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>SpringBoot 配置（<code>application.yml</code>）的注意事项<ul><li>主从节点的 IP 和端口不需要配置，哨兵模式下 Lettuce 客户端能自动发现主从拓扑结构。</li><li><code>mymaster</code> 一定要和哨兵配置文件（<code>redis-sentinel.conf</code>）里设置的一致。</li><li>Lettuce 默认支持哨兵模式，一般不需要额外配置；但是，如果哨兵模式使用 SSL，则需要显式配置连接工厂。</li><li>SpringBoot 的默认连接池支持读写分离，只需要配置 Lettuce 的 <code>read-from</code> 属性即可生效。</li><li>在 Redis 的主从复制或者集群架构中，主节点可以读写，但从节点默认是只读的，即可以响应读请求（如 <code>GET</code>、<code>MGET</code> 等），但不能写入数据。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>无论 Redis 是一主一从、一主多从还是集群架构，Redis 的主节点都可以读写，从节点默认是可以读（只读，不能写入）；但如果想实现真正的读写分离或者读负载均衡，还需要在客户端进行配置或开发支持（比如 Jedis、Lettuce 都支持手动配置是否访问从节点），因为 Redis 本身不会自动将读请求发送给从节点。由于 Redis 的主从同步可能存在延迟，如果业务对读取一致性要求较高（如读取后马上更新），那么就不要使用从节点读取数据。</p></div><h2 id="哨兵机制的问题"><a href="#哨兵机制的问题" class="headerlink" title="哨兵机制的问题"></a>哨兵机制的问题</h2><h3 id="如何避免脑裂现象"><a href="#如何避免脑裂现象" class="headerlink" title="如何避免脑裂现象"></a>如何避免脑裂现象</h3><ul><li><p><strong>Redis 哨兵集群的脑裂现象是指什么</strong></p><ul><li>指在出现网络分区或者部分哨兵节点失联的情况下，多个哨兵节点在没有达到 <code>majority</code>（多数哨兵）共识的前提下，分别认为 Master 节点宕机并发起故障转移，导致出现两个或多个 Master 节点，从而造成数据不一致或系统混乱。</li><li>值得一提的是，除了主从同步延迟外，脑裂现象也会导致 Redis 集群丢失部分缓存数据。</li></ul></li><li><p><strong>Redis 哨兵集群如何避免脑裂现象</strong></p><ul><li>设置合适的 <code>quorum</code>（法定票数），即某个哨兵要认为主节点下线，必须要有至少 <code>quorum</code> 个哨兵达成共识。</li><li>真正的故障转移必须经过 <code>majority</code> 个哨兵（多数哨兵）投票通过，避免少数哨兵单方面误判。</li><li>因此，只要哨兵总数为奇数（如 3 个或 5 个），且大多数哨兵能互通，就不会发生脑裂现象。<ul><li>举个例子，假设集群中有 3 个哨兵，并配置 <code>quorum = 2</code>，那么：<ul><li>只有至少 2 个哨兵都判断主节点不可用，才会触发故障转移；</li><li>此时，还需要过半（即至少 2 个）的哨兵同意发起故障转移，才能选出新的主节点；</li><li>如果由于网络问题分区成 <code>1 + 2</code> 的两组哨兵，单独的哨兵将无法满足 <code>quorum</code> 和 <code>majority</code> 条件，这样就不会误判，从而避免脑裂。</li></ul></li></ul></li></ul></li></ul><table><thead><tr><th>概念</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td><code>quorum</code>（法定票数）</td><td>Master 节点从主观下线（SDOWN）到客观下线（ODOWN）所需的同意哨兵数（即最少 N 个哨兵同时判断 Master 为宕机）</td><td>确保哨兵对 Master 宕机的判断具有一定共识，避免误判</td></tr><tr><td><code>majority</code>（多数哨兵）</td><td>执行故障转移操作时，要求同意执行故障转移的哨兵数量必须达到总数的一半以上，否则不会执行故障转移</td><td>为了避免「脑裂」现象，即多个哨兵在不同网络分区中同时尝试进行故障转移，导致系统不一致或混乱</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">网络分区是指什么</p><p>网络分区（Network Partition）是指由于网络故障，集群中的一部分节点之间无法正常通信，被分隔成了两个或多个 "孤岛"，每个孤岛只能看到自身可达的节点，看不到其他节点。在 Redis 的哨兵集群架构中，网络分区通常指的是：部分哨兵与主节点失去连接、部分哨兵之间失去通信、主从节点之间断联。这些都可能导致：误判主节点下线、多个哨兵同时发起故障转移、出现多个主节点（脑裂）。</p></div><h3 id="如何避免数据丢失"><a href="#如何避免数据丢失" class="headerlink" title="如何避免数据丢失"></a>如何避免数据丢失</h3><p>Redis 的哨兵机制主要用于主从架构下的故障检测与自动主备切换，但在某些特殊场景下，哨兵机制可能会导致数据丢失，主要包括以下两种情况：</p><ul><li><p><strong>(1) 异步复制导致的数据丢失</strong></p><ul><li>Redis 主从节点之间的数据同步是异步复制，这意味着主节点写入的数据不会立即同步到从节点。<ul><li>当主节点（Master）宕机时，可能仍有部分数据尚未同步写入到从节点（Slave）。</li><li>此时，如果哨兵进行故障转移，从节点被提升为新的主节点，那么这些未同步的数据将永久丢失。</li></ul></li><li>这种情况的本质是主从延迟造成的数据不一致，属于设计上的权衡（异步复制换取更高性能和低延迟）。</li></ul></li><li><p><strong>(2) 脑裂（Split-Brain）导致的数据丢失</strong></p><ul><li>脑裂指的是：主节点与其他哨兵和从节点之间发生网络分区，导致其在局部网络中 “孤岛运行”，而在整体视角下却被认为已宕机。<ul><li>在发生网络分区期间，哨兵可能判定主节点不可用（ODOWN - 客观不可用），并发起故障转移，将某个从节点提升为新的主节点。</li><li>但由于旧主节点实际上仍在运行，客户端可能仍将数据写入旧主节点，形成了两个 “主节点”（双主）。</li><li>当网络恢复时，旧主节点会被哨兵强制转为从节点，并从新主节点复制数据，这会导致旧主节点上的数据被清空。</li></ul></li><li>因此，在发生网络分区的这段时间内，写入旧主节点的数据会丢失，因为它从未被同步到新主节点上，并且在旧主节点恢复后被覆盖掉。</li></ul></li></ul><hr><p>Redis 提供以下两个配置项用于控制写请求行为，从而减少异步复制和脑裂导致的数据丢失。</p><ul><li><code>min-slaves-to-write 1</code>：要求至少有 1 个从节点处于正常连接状态，主节点才允许写入数据。</li><li><code>min-slaves-max-lag 10</code>：要求从节点的复制延迟（ACK 返回的时间）不能超过 10 秒，主节点才允许写入数据。</li></ul><p>当主节点检测到可以正常连接的从节点数量不足，或者所有从节点的复制延迟都超过 10 秒，那么主节点将拒绝客户端的写请求。</p><ul><li><p><strong>(1) 减少异步复制导致的数据丢失</strong></p><ul><li>Redis 的主从复制是异步的。如果主节点宕机，而有些数据尚未同步到从节点，那么这些数据将永久丢失。</li><li>通过设置 <code>min-slaves-max-lag</code>，主节点可以感知从节点复制数据的延迟。如果从节点响应太慢（比如都超过了 10 秒），主节点会拒绝客户端的写入请求，防止继续写入大量数据而无法同步，从而将主节点宕机时可能丢失的数据限制在一个可控的范围（如 10 秒）内。</li></ul></li><li><p><strong>(2) 减少脑裂导致的数据丢失</strong></p><ul><li>在出现脑裂的情况下，客户端可能仍向旧主节点写入数据，形成两个主节点（双主），导致数据不一致和丢失。</li><li>通过 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 这两个配置项，可以防止脑裂主节点继续接受写请求：<ul><li>如果旧主节点失去了所有从节点的连接；</li><li>且在 <code>min-slaves-max-lag</code> 时间（如 10 秒）内未收到任何从节点的 ACK 消息；</li><li>那么主节点将自动停止接受写请求。</li></ul></li><li>这样，即使发生脑裂，旧主节点也会在 10 秒内拒绝写入数据，最多只会丢失 10 秒的数据，大大降低了数据丢失的风险。</li></ul></li></ul><p>当 Redis 主节点拒绝写请求时，客户端可以采取如下策略进行容灾处理：</p><ul><li><strong>(1) 客户限流处理</strong><ul><li>对接口请求进行限流处理，减慢请求涌入的速度，防止请求堆积或爆发式增长。</li></ul></li><li><strong>(2) 异步重试机制</strong><ul><li>将待写入的数据缓存在本地磁盘或者 Kafka 消息队列中。</li><li>客户端定时从本地磁盘或者 Kafka 队列中获取数据（例如每隔 10 分钟），然后尝试将数据重新写回 Redis 主节点。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Redis 的哨兵机制，包括 SpringBoot 项目使用哨兵机制。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="缓存" scheme="https://www.techgrow.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Higress 入门教程 - 基础篇（2025 年）</title>
    <link href="https://www.techgrow.cn/posts/63cc9919.html"/>
    <id>https://www.techgrow.cn/posts/63cc9919.html</id>
    <published>2025-07-22T13:12:19.000Z</published>
    <updated>2025-07-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Higress 是基于阿里内部的 Envoy Gateway 实践沉淀、以开源 Istio + Envoy 为核心构建的下一代云原生网关，实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力，深度集成 Dubbo、Nacos、Sentinel 等微服务技术栈，能够帮助用户极大的降低网关的部署及运维成本。在标准上全面支持 Ingress 与 Gateway API，积极拥抱云原生下的标准 API 规范；同时，Higress Controller 也支持 Nginx Ingress 平滑迁移，可以帮助用户零成本快速迁移到 Higress。</p><span id="more"></span><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li><a href="https://github.com/alibaba/higress">Higress 官方项目</a></li><li><a href="https://higress.cn/docs/latest/overview/what-is-higress/">Higress 官方文档</a></li><li><a href="https://higress.cn/">Higress 官方网站</a></li></ul><h3 id="网关的分类"><a href="#网关的分类" class="headerlink" title="网关的分类"></a>网关的分类</h3><p>行业中通常把网关分为两个大类：流量网关与业务网关，流量网关主要提供全局性的、与后端业务无关的策略配置，例如阿里内部的的统一接入网关 Tengine 就是典型的流量网关；业务网关顾名思义主要提供独立业务域级别的、与后端业务紧耦合策略配置，随着应用架构模式从单体演进到现在的微服务，业务网关也有了新的叫法 - 微服务网关。</p><p><img data-src="../../../asset/2025/07/higress-7.png"></p><p>在虚拟化时期的微服务架构下，业务通常采用流量网关 + 微服务网关的两层架构，流量网关负责南北向流量调度和安全防护，微服务网关负责东西向流量调度和服务治理，而在容器和 K8s 主导的云原生时代，Ingress 成为 K8s 生态的网关标准，赋予了网关新的使命，使得流量网关 + 微服务网关合二为一成为可能。作为面向南北向的公网网关，使用 Waf 防护异常流量是很常规的需求，而且随着互联网环境变得越来越复杂，用户对防护的诉求是持续增强的，常规做法是将流量先接入 Waf 安全网关，过滤后再将流量转发给流量网关，最后到达微服务网关；Higress 希望通过内置 Waf 模块，使得用户的请求链接只经过 Higress 就可以同时完成 Waf 防护、流量分发、微服务治理，既可以降低链路 RT，也可以降低网关的运维复杂度。因此 Higress 实现了流量网关 + 微服务网关 + 安全网关三合一的高集成能力。</p><p><img data-src="../../../asset/2025/07/higress-8.png"></p><h2 id="Higress-简介"><a href="#Higress-简介" class="headerlink" title="Higress 简介"></a>Higress 简介</h2><h3 id="Higress-是什么"><a href="#Higress-是什么" class="headerlink" title="Higress 是什么"></a>Higress 是什么</h3><ul><li>Higress 是一款云原生 API 网关，内核基于 Istio 和 Envoy，可以用 Go/Rust/JS 等编写 Wasm 插件，提供了数十个现成的通用插件，以及开箱即用的控制台。</li><li>Higress 在阿里内部为解决 Tengine Reload 对长连接业务有损，以及 gRPC/Dubbo 负载均衡能力不足而诞生。</li><li>阿里云基于 Higress 构建了云原生 API 网关产品，为大量企业客户提供 99.99% 的网关高可用保障服务能力。</li><li>Higress 基于 AI 网关能力，支撑了通义千问 APP、百炼大模型 API、机器学习 PAI 平台等 AI 业务。同时服务国内头部的 AIGC 企业（如零一万物），以及 AI 产品（如 FastGPT）。</li></ul><p><img data-src="../../../asset/2025/07/higress-1.png"></p><h3 id="什么是-AI-网关"><a href="#什么是-AI-网关" class="headerlink" title="什么是 AI 网关"></a>什么是 AI 网关</h3><p>AI Gateway = AI Native API GatewayAI，网关的本质依然是 API 网关，AI 原生的意义在于，在这样的 API 网关里，AI 是一等公民。API 研发、API 供应、API 消费、以及 API 观测都基于 AI 场景下的需求，演进出全新的能力。</p><blockquote><p>这是传统 API 网关的功能范畴，AI 场景下仍然有其通用价值：</p></blockquote><p><img data-src="../../../asset/2025/07/higress-2.png"></p><blockquote><p>在 AI 场景下，基于 Higress 可以将 API 网关的功能范畴进一步扩展：</p></blockquote><p><img data-src="../../../asset/2025/07/higress-3.png"></p><h3 id="Higress-核心优势"><a href="#Higress-核心优势" class="headerlink" title="Higress 核心优势"></a>Higress 核心优势</h3><ul><li><p>生产等级</p><ul><li>脱胎于阿里巴巴多年生产验证的内部产品，支持每秒请求量达数十万级的大规模场景。</li><li>彻底摆脱 Nginx Reload 引起的流量抖动，配置变更毫秒级生效且业务无感。对 AI 业务等长连接场景特别友好。</li></ul></li><li><p>便于扩展</p><ul><li>提供丰富的官方插件库，涵盖 AI、流量管理、安全防护等常用功能，满足 90% 以上的业务场景需求。</li><li>主打 Wasm 插件扩展，通过沙箱隔离确保内存安全，支持多种编程语言，允许插件版本独立升级，实现流量无损热更新网关逻辑。</li></ul></li><li><p>安全易用</p><ul><li>基于 Ingress API 和 Gateway API 标准，提供开箱即用的 UI 控制台，WAF 防护插件、IP/Cookie CC 防护插件开箱即用。</li><li>支持对接 Let’s Encrypt 自动签发和续签免费证书，并且可以脱离 K8s 部署，一行 Docker 命令即可启动，方便个人开发者使用。</li></ul></li><li><p>流式处理</p><ul><li>支持真正的完全流式处理请求 / 响应 Body，Wasm 插件很方便地自定义处理 SSE（Server-Sent Events）等流式协议的报文。</li><li>在 AI 业务等大带宽场景下，可以显著降低内存开销。</li></ul></li></ul><h3 id="Higress-使用场景"><a href="#Higress-使用场景" class="headerlink" title="Higress 使用场景"></a>Higress 使用场景</h3><h4 id="AI-网关"><a href="#AI-网关" class="headerlink" title="AI 网关"></a>AI 网关</h4><p>Higress 能够用统一的协议对接国内外所有 LLM 模型厂商，同时具备丰富的 AI 可观测、多模型负载均衡 / Fallback、AI Token 流控、AI 缓存等能力：</p><p><img data-src="../../../asset/2025/07/higress-4.png"></p><h4 id="K8s-Ingress-网关"><a href="#K8s-Ingress-网关" class="headerlink" title="K8s Ingress 网关"></a>K8s Ingress 网关</h4><p>Higress 可以作为 K8s 集群的 Ingress 入口网关，并且兼容了大量 K8s Nginx Ingress 的注解，可以从 K8s Nginx Ingress 快速平滑迁移到 Higress。支持 Gateway API 标准，支持用户从 Ingress API 平滑迁移到 Gateway API。相比 ingress-nginx，资源开销大幅下降，路由变更生效速度有十倍提升。</p><p><img data-src="../../../asset/2025/07/higress-5.png"></p><h4 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h4><p>Higress 可以作为微服务网关，能够对接多种类型的注册中心发现服务配置路由，例如 Nacos、ZooKeeper、Consul、Eureka 等。并且深度集成了 Dubbo、Nacos、Sentinel 等微服务技术栈，基于 Envoy C++ 网关内核的出色性能，相比传统 Java 类微服务网关，可以显著降低资源使用率，减少成本。</p><p><img data-src="../../../asset/2025/07/higress-6.png"></p><h4 id="安全防护网关"><a href="#安全防护网关" class="headerlink" title="安全防护网关"></a>安全防护网关</h4><p>Higress 可以作为安全防护网关，提供 WAF 的能力，并且支持多种认证鉴权策略，例如 key-auth、hmac-auth、jwt-auth、basic-auth、oidc 等。</p><h3 id="Higress-整体架构"><a href="#Higress-整体架构" class="headerlink" title="Higress 整体架构"></a>Higress 整体架构</h3><ul><li>整体上 Higress 网关由控制面组件 Higress-Controller 和数据面组件 Higress-Gateway 组成。Higress-Gateway 负责承载数据流量，Higress-Controller 负责管理配置下发。</li><li>数据面组件 Higress-Gateway 是基于 Envoy 开发的网关组件，负责接收和处理流量，支持 HTTP/1.1、HTTP/2、gRPC 等协议，支持 TLS、mTLS、WAF、限流、熔断、重试、负载均衡、路由、转发、重定向、跨域等功能，也就是说真正的流量处理都是在 Higress-Gateway 中完成的。</li><li>控制面组件 Higress-Controller 负责管理配置下发，支持 Ingress API、Gateway API、Istio API，支持多种注册中心，支持多种认证鉴权策略，支持多种插件扩展机制，支持多种 CRD 实现流量精细化管理，也就是说所有的配置都是通过 Higress-Controller 下发到 Higress-Gateway 中的。</li></ul><p><img data-src="../../../asset/2025/07/higress-9.png"></p><h3 id="Higress-开发语言"><a href="#Higress-开发语言" class="headerlink" title="Higress 开发语言"></a>Higress 开发语言</h3><p>Higress 主要是基于 Envoy Proxy 开发的，核心是用 C++（Envoy 内核）和 Go（控制面、插件、扩展部分）组合实现的。</p><table><thead><tr><th>组件</th><th>语言</th><th>作用</th></tr></thead><tbody><tr><td> Envoy Proxy（数据面）</td><td>C++</td><td>Higress 的流量转发核心，负责 HTTP/TCP 代理、路由、负载均衡，使用 Envoy 做高性能转发。</td></tr><tr><td>控制面 / 插件 / 扩展逻辑</td><td> Go</td><td>Higress 提供了 Ingress、Gateway API 的控制逻辑、配置管理、Wasm 插件管理等，这部分主要用 Go 实现。</td></tr><tr><td>Wasm 插件（可选）</td><td>WebAssembly（多语言）</td><td>Higress 支持流量治理的 Wasm 扩展，用户可以用 Rust、C++、AssemblyScript 编写。</td></tr></tbody></table><p>为什么采用这种语言组合？</p><ul><li>C++（Envoy 内核）：高性能、云原生友好，成熟的代理框架。</li><li>Go（控制面、插件）：易于集成 Kubernetes，开发效率高，社区有大量的 Ingress/Gateway 生态。</li><li>Wasm（扩展能力）：支持动态扩展，不用重启服务。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/qq_45038038/article/details/136005591">下一代云原生网关 Higress</a></li><li><a href="https://www.51cto.com/article/786706.html">Higress 或许是目前最好的云原生网关</a></li><li><a href="https://zhuanlan.zhihu.com/p/21624794301">使用 Higress 统一替代 APISIX/Kong/Istio Ingress</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Higress 的基础使用。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 入门基础教程之一</title>
    <link href="https://www.techgrow.cn/posts/99bf51b3.html"/>
    <id>https://www.techgrow.cn/posts/99bf51b3.html</id>
    <published>2025-07-22T13:12:19.000Z</published>
    <updated>2025-07-22T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/99bf51b3.html">Kubernetes 入门基础教程之一</a></li><li><a href="/posts/c57e8370.html">Kubernetes 入门基础教程之二</a></li></ul><h2 id="Kubernetes-概述"><a href="#Kubernetes-概述" class="headerlink" title="Kubernetes 概述"></a>Kubernetes 概述</h2><h3 id="各种部署方式的区别"><a href="#各种部署方式的区别" class="headerlink" title="各种部署方式的区别"></a>各种部署方式的区别</h3><p>传统的应用部署方式是通过插件或脚本来安装应用，这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新、回滚等操作；当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能够快速部署，由于容器与底层设施、机器文件系统解耦的，所以它能在不同云、不同版本操作系统间进行迁移。容器占用资源少、部署快，每个应用可以被打包成一个容器镜像，每个应用与容器间成一对一关系也使容器有更大优势，使用容器可以在 <code>build</code> 或 <code>release</code> 的阶段，为应用创建容器镜像，因为每个应用不需要与其余的应用堆栈组合，也不依赖于生产环境基础结构，这使得从研发到测试、生产能提供一致环境。类似地，容器比虚拟机轻量、更 “透明”，这更便于监控和管理。</p><span id="more"></span><h3 id="Kubernetes-基本介绍"><a href="#Kubernetes-基本介绍" class="headerlink" title="Kubernetes 基本介绍"></a>Kubernetes 基本介绍</h3><p>Kubernetes 是 Google 于 2014 年 6 月正式开源的一个容器编排引擎，简称 K8s，是用 8 代替 8 个字符 <code>ubernete</code> 而成的缩写。Kubernetes 可用于管理云平台中多个主机上的容器化的应用，支持自动化部署、大规模扩缩容、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。Kubernetes 提供了应用部署、规划、更新、维护的一种机制。在 Kubernetes 中，可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p><h3 id="Kubernetes-功能介绍"><a href="#Kubernetes-功能介绍" class="headerlink" title="Kubernetes 功能介绍"></a>Kubernetes 功能介绍</h3><p>Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过 Kubernetes 能够进行应用的自动化部署和扩缩容。在 Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes 积累了作为 Google 生产环境运行工作负载 15 年的经验，并吸收了来自于社区的最佳想法和实践。Kubernetes 的核心功能如下：</p><ul><li>自动装箱：基于容器对应用运行环境的资源配置要求自动部署应用容器</li><li>自我修复：当容器运行失败时，会对容器进行重启；当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度；当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</li><li>水平扩展：通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</li><li>服务发现：用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡</li><li>滚动更新：可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</li><li>版本回退：可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</li><li>密钥和配置管理：在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署</li><li>存储编排：自动实现存储系统挂载及应用，这特别对有状态应用实现数据持久化非常重要；存储系统可以来自于本地目录、网络存储（NFS、Gluster、Ceph 等）、公共云存储服务</li><li>批处理：提供一次性任务，定时任务，满足批量数据处理和分析的场景</li></ul><h3 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h3><table><thead><tr><th>技术名称</th><th>技术描述</th></tr></thead><tbody><tr><td> YAML 配置文件</td><td>使用 YAML 文件定义 Kubernetes 资源，如 Pod、Service、Deployment 等，是声明式管理的基础。</td></tr><tr><td>kubectl 命令工具</td><td> Kubernetes 的命令行客户端工具，用于操作集群、部署资源、排查故障等。</td></tr><tr><td>Pod</td><td>Kubernetes 中最小的可调度单元，通常封装一个或多个容器，容器共享网络和存储。</td></tr><tr><td>Controller（控制器）</td><td>自动化资源管理的核心组件，如 Deployment、ReplicaSet、StatefulSet、DaemonSet 等控制器。</td></tr><tr><td>Service</td><td> 定义一组 Pod 的统一访问入口，支持负载均衡和服务发现。</td></tr><tr><td>Label</td><td> 给资源打标签的机制，支持资源的分类、选择、分组管理等，用于调度和服务发现。</td></tr><tr><td>Volume</td><td> 提供容器持久化或共享数据的机制，支持本地存储、NFS、云存储等。</td></tr><tr><td>PVC 和 PV</td><td>PVC（Persistent Volume Claim）是用户请求的存储资源，PV（Persistent Volume）是实际存储资源，解耦用户和存储实现。</td></tr><tr><td>Secret 和 ConfigMap</td><td>Secret 用于管理敏感数据，ConfigMap 用于存储配置数据，都可挂载进容器或作为环境变量使用。</td></tr><tr><td>Namespace</td><td> 提供资源隔离的逻辑空间，用于多租户环境或资源分类管理。</td></tr><tr><td>Probes（探针）</td><td>包括存活探针（liveness）和就绪探针（readiness），用于健康检查和控制流量转发。</td></tr><tr><td>API Server</td><td>Kubernetes 控制平面的核心组件，负责处理来自 kubectl 或其他客户端的请求，并与 Etcd、Controller（控制器）、Scheduler（调度器）等交互。</td></tr><tr><td>Scheduler（调度器）</td><td>根据资源需求、约束条件和策略将 Pod 分配到合适的节点。</td></tr><tr><td>集群安装机制与 RBAC</td><td> 安装机制包括 kubeadm、Kops、RKE 等，RBAC（基于角色的访问控制）用于权限管理和安全控制。</td></tr><tr><td>Helm</td><td>Kubernetes 的包管理工具，用于简化应用部署，支持版本管理、参数化配置等。</td></tr></tbody></table><h3 id="Kubernetes-核心概念"><a href="#Kubernetes-核心概念" class="headerlink" title="Kubernetes 核心概念"></a>Kubernetes 核心概念</h3><p>Kubernetes 三个核心概念（Pod、Controller、Service）的介绍如下：</p><ul><li><p>Pod（最小部署单元）</p><ul><li>Pod 是 Kubernetes 中最小的调度和运行单元。</li><li>本质上是一组容器的集合（通常是一个容器）。</li><li>容器之间共享网络（IP、端口）和存储卷。</li><li>Pod 的生命周期通常是短暂的，用于运行临时任务或被控制器自动重建。</li></ul></li><li><p>Controller（控制器）</p><ul><li>用于管理和自动化 Pod 的部署与副本数量。</li><li>支持无状态应用部署（如 Deployment）。</li><li>支持有状态应用部署（如 StatefulSet）。</li><li>可实现以下功能：<ul><li>保证指定数量的 Pod 实例持续运行。</li><li>在多个节点上部署同一类 Pod（如 DaemonSet）。</li><li>支持一次性任务（Job）和定时任务（CronJob）。</li></ul></li></ul></li><li><p>Service（服务）</p><ul><li>负责定义一组 Pod 的访问规则。</li><li>提供统一的访问入口（Cluster IP、NodePort、LoadBalancer 等），实现服务发现与负载均衡。</li><li>解决 Pod 动态 IP 和短生命周期带来的访问不稳定问题。</li></ul></li></ul><p>这三个核心概念的关系：</p><ul><li>Pod 是具体运行的实例。</li><li>Controller 管理 Pod 的创建、副本和调度。</li><li>Service 让外部或内部服务可以稳定地访问 Pod。</li></ul><h2 id="Kubernetes-集群搭建"><a href="#Kubernetes-集群搭建" class="headerlink" title="Kubernetes 集群搭建"></a>Kubernetes 集群搭建</h2><h3 id="集群架构组件"><a href="#集群架构组件" class="headerlink" title="集群架构组件"></a>集群架构组件</h3><p><img data-src="../../../asset/2025/07/k8s-1.png"></p><ul><li><p><code>Master（主控节点）</code>：Kubernetes 集群控制节点，负责对集群进行调度管理，接受集群外的用户去集群操作请求。Master 由 API Server、Scheduler、Controller Manager、Etcd 存储系统组成</p><ul><li>Scheduler：节点调度，选择 Node 节点来应用部署</li><li> API Server：集群统一入口，以 RESTful 接口将数据交给 Etcd 进行存储</li><li> Controller Manager：处理集群中的常规后台任务，一个资源对应一个控制器</li><li> Etcd 存储系统：用于存储集群相关的数据</li></ul></li><li><p><code>Node（工作节点）</code>：Kubernetes 集群工作节点，负责运行用户业务应用容器，Node 由 Kubelet、Kube-Proxy 和 Container Runtime 组成</p><ul><li>Kubelet：负责 Pod 对应的容器的创建、启停管理，与 Master 节点协作，实现集群管理的基本功能</li><li> Kube-Proxy：提供 Kubernetes 的通信与负载均衡功能的重要组件</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Etcd 是什么</p><ul><li>在分布式系统中，Etcd 是一个高可用、强一致性的分布式键值存储系统，在 Kubernetes 等系统中扮演着核心元数据存储和协调中心的角色。</li><li>Etcd 属于更底层的基础组件，使用 Raft 算法实现强一致性（满足 CAP 中的 C 和 P），提供了一致性的 KV 存储、watch、lease、事务等机制。</li></ul></div><h3 id="集群搭建规划"><a href="#集群搭建规划" class="headerlink" title="集群搭建规划"></a>集群搭建规划</h3><p>Kubernetes 集群有两种类型，包括单 Master 集群和多 Master 集群，为了提高集群的高可用性，生产环境一般采用多 Master 集群方案，如下图所示：</p><p><img data-src="../../../asset/2021/03/kubernetes-cluster-plan.png"></p><h3 id="集群搭建要求"><a href="#集群搭建要求" class="headerlink" title="集群搭建要求"></a>集群搭建要求</h3><p>搭建 Kubernetes 集群需要满足以下几个条件：</p><ul><li>一台或多台机器，建议操作系统 CentOS 7（64 位）</li><li>Master 节点的硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 20GB 或更多</li><li> Node 节点的硬件配置：4GB 或更多 RAM，4 个 CPU 或更多 CPU，硬盘 40GB 或更多</li><li>集群中所有机器之间的网络可以互通</li><li>系统内可以访问外网，需要拉取镜像</li><li>禁用 Swap 分区（必须）</li></ul><h3 id="集群搭建方式"><a href="#集群搭建方式" class="headerlink" title="集群搭建方式"></a>集群搭建方式</h3><p>目前生产环境搭建 Kubernetes 集群主要有以下两种方式：</p><ul><li><p><strong>Kubeadm</strong></p><ul><li><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">Kubeadm</a> 是一个 Kubernetes 部署工具，提供 <code>kubeadm init</code> 和 <code>kubeadm join</code> 命令，可用于快速搭建 Kubernetes 集群。</li></ul></li><li><p><strong>二进制包</strong></p><ul><li>从 Github 下载发行版的二进制包，手动部署每个组件，组成 Kubernetes 集群。Kubeadm 虽然降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。</li><li>如果想集群整体更可控，生产环境推荐使用二进制包搭建 Kubernetes 集群，虽然手动部署比较麻烦，但期间可以学习很多工作原理，也利于后期维护。</li></ul></li></ul><h3 id="集群搭建步骤"><a href="#集群搭建步骤" class="headerlink" title="集群搭建步骤"></a>集群搭建步骤</h3><h4 id="二进制包方式搭建集群"><a href="#二进制包方式搭建集群" class="headerlink" title="二进制包方式搭建集群"></a>二进制包方式搭建集群</h4><ul><li><a href="/posts/ccd6f2d4.html">基于二进制包方式搭建 Kubernetes 集群</a></li></ul><h4 id="Kubeadm-方式搭建集群"><a href="#Kubeadm-方式搭建集群" class="headerlink" title="Kubeadm 方式搭建集群"></a>Kubeadm 方式搭建集群</h4><ul><li><a href="/posts/b728042a.html">基于 Kubeadm 方式搭建 Kubernetes 集群</a></li></ul><h2 id="Kubernetes-核心技术-1"><a href="#Kubernetes-核心技术-1" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="kubectl-命令行工具"><a href="#kubectl-命令行工具" class="headerlink" title="kubectl 命令行工具"></a>kubectl 命令行工具</h3><p>kubectl 是 Kubernetes 集群的命令行工具，通过 kubectl 能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。</p><h4 id="kubectl-的语法"><a href="#kubectl-的语法" class="headerlink" title="kubectl 的语法"></a>kubectl 的语法</h4><ul><li><p>命令语法：<code>kubectl [command] [type] [name] [flags]</code></p></li><li><p><code>command</code>：</p><ul><li>指定要对资源执行的操作</li><li>例如：<code>create</code>、<code>get</code>、<code>describe</code> 和 <code>delete</code></li></ul></li><li><p><code>type</code>：</p><ul><li>指定资源类型，资源类型是大小写敏感的，开发者能够以单数、复数和缩略的形式。例如:</li><li><code>kubectl get pod pod1</code></li><li><code>kubectl get pods pod1</code></li><li><code>kubectl get po pod1</code></li><li><code>kubectl get nodes K8s-node1</code></li></ul></li><li><p><code>name</code>：</p><ul><li>指定资源的名称，名称大小写敏感。如果省略资源名称，则会显示所有的资源。例如：</li><li><code>kubectl get pods</code></li><li><code>kubectl get nodes</code></li><li><code>kubectl get nodes K8s-node1</code></li></ul></li><li><p><code>flags</code>：</p><ul><li>指定可选的参数。例如，可以使用 <code>-s</code> 或者 <code>-server</code> 参数指定 Kubernetes API Server 的地址和端口。</li></ul></li></ul><h4 id="kubectl-的使用帮助手册"><a href="#kubectl-的使用帮助手册" class="headerlink" title="kubectl 的使用帮助手册"></a>kubectl 的使用帮助手册</h4><p>可以使用 <code>kubectl --help</code> 命令查看 kubectl 命令的整体使用帮助，包括所有可用的主命令及其简要说明；还可以通过 <code>kubectl &lt;command&gt; --help</code> 获取某个具体子命令的详细使用手册和参数说明。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 kubectl 的所有主命令和帮助信息</span></span><br><span class="line"><span class="keyword"># kubectl</span><span class="params"> --help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kubectl get 子命令的详细用法和参数说明</span></span><br><span class="line"><span class="keyword"># kubectl</span> get<span class="params"> --help</span></span><br></pre></td></tr></tbody></table></figure><p>比如，<code>kubectl help</code> 命令输出的帮助内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">kubectl controls the Kubernetes cluster manager.</span><br><span class="line"></span><br><span class="line"> Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/</span><br><span class="line"></span><br><span class="line">Basic Commands (Beginner):</span><br><span class="line">  create        Create a resource from a file or from stdin.</span><br><span class="line">  expose        使用 replication controller, service, deployment 或者 pod 并暴露它作为一个 新的 Kubernetes</span><br><span class="line">Service</span><br><span class="line">  run           在集群中运行一个指定的镜像</span><br><span class="line">  set           为 objects 设置一个指定的特征</span><br><span class="line"></span><br><span class="line">Basic Commands (Intermediate):</span><br><span class="line">  explain       查看资源的文档</span><br><span class="line">  get           显示一个或更多 resources</span><br><span class="line">  edit          在服务器上编辑一个资源</span><br><span class="line">  delete        Delete resources by filenames, stdin, resources and names, or by resources and label selector</span><br><span class="line"></span><br><span class="line">Deploy Commands:</span><br><span class="line">  rollout       Manage the rollout of a resource</span><br><span class="line">  scale         Set a new size for a Deployment, ReplicaSet or Replication Controller</span><br><span class="line">  autoscale     自动调整一个 Deployment, ReplicaSet, 或者 ReplicationController 的副本数量</span><br><span class="line"></span><br><span class="line">Cluster Management Commands:</span><br><span class="line">  certificate   修改 certificate 资源.</span><br><span class="line">  cluster-info  显示集群信息</span><br><span class="line">  top           Display Resource (CPU/Memory/Storage) usage.</span><br><span class="line">  cordon        标记 node 为 unschedulable</span><br><span class="line">  uncordon      标记 node 为 schedulable</span><br><span class="line">  drain         Drain node in preparation for maintenance</span><br><span class="line">  taint         更新一个或者多个 node 上的 taints</span><br><span class="line"></span><br><span class="line">Troubleshooting and Debugging Commands:</span><br><span class="line">  describe      显示一个指定 resource 或者 group 的 resources 详情</span><br><span class="line">  logs          输出容器在 pod 中的日志</span><br><span class="line">  attach        Attach 到一个运行中的 container</span><br><span class="line">  exec          在一个 container 中执行一个命令</span><br><span class="line">  port-forward  Forward one or more local ports to a pod</span><br><span class="line">  proxy         运行一个 proxy 到 Kubernetes API server</span><br><span class="line">  cp            复制 files 和 directories 到 containers 和从容器中复制 files 和 directories.</span><br><span class="line">  auth          Inspect authorization</span><br><span class="line"></span><br><span class="line">Advanced Commands:</span><br><span class="line">  diff          Diff live version against would-be applied version</span><br><span class="line">  apply         通过文件名或标准输入流(stdin)对资源进行配置</span><br><span class="line">  patch         使用 strategic merge patch 更新一个资源的 field(s)</span><br><span class="line">  replace       通过 filename 或者 stdin替换一个资源</span><br><span class="line">  wait          Experimental: Wait for a specific condition on one or many resources.</span><br><span class="line">  convert       在不同的 API versions 转换配置文件</span><br><span class="line">  kustomize     Build a kustomization target from a directory or a remote url.</span><br><span class="line"></span><br><span class="line">Settings Commands:</span><br><span class="line">  label         更新在这个资源上的 labels</span><br><span class="line">  annotate      更新一个资源的注解</span><br><span class="line">  completion    Output shell completion code for the specified shell (bash or zsh)</span><br><span class="line"></span><br><span class="line">Other Commands:</span><br><span class="line">  alpha         Commands for features in alpha</span><br><span class="line">  api-resources Print the supported API resources on the server</span><br><span class="line">  api-versions  Print the supported API versions on the server, in the form of "group/version"</span><br><span class="line">  config        修改 kubeconfig 文件</span><br><span class="line">  plugin        Provides utilities for interacting with plugins.</span><br><span class="line">  version       输出 client 和 server 的版本信息</span><br><span class="line"></span><br><span class="line">Use "kubectl &lt;command&gt; --help" for more information about a given command.</span><br><span class="line">Use "kubectl options" for a list of global command-line options (applies to all commands).</span><br></pre></td></tr></tbody></table></figure><h4 id="kubectl-的子命令使用分类"><a href="#kubectl-的子命令使用分类" class="headerlink" title="kubectl 的子命令使用分类"></a>kubectl 的子命令使用分类</h4><ul><li>基础命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>create</code></td><td>通过文件名或标注输入创建资源</td></tr><tr><td><code>expose</code></td><td>将一个资源公开为一个新的 Service</td></tr><tr><td><code>run</code></td><td>在集群中运行一个特定的镜像</td></tr><tr><td><code>set</code></td><td>在对象上设置特定的功能</td></tr><tr><td><code>get</code></td><td>显示一个或多个资源</td></tr><tr><td><code>explain</code></td><td>文档参考资料</td></tr><tr><td><code>edit</code></td><td>使用默认的编辑器编辑一个资源</td></tr><tr><td><code>delete</code></td><td>通过文件名、标注输入、资源名或标注选择来删除资源</td></tr></tbody></table><ul><li> 部署命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>rollout</code></td><td>管理资源的发布</td></tr><tr><td><code>rolling-update</code></td><td>对某些类型的副本控制器滚动更新</td></tr><tr><td><code>scale</code></td><td>扩容或缩容 Pod 数量，Deployment、ReplicaSet、RC 或 Job</td></tr><tr><td><code>autoscale</code></td><td>创建一个自动选择扩容或缩容容器并设置 Pod 数量</td></tr></tbody></table><ul><li> 集群管理命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>certificate</code></td><td>修改证书资源</td></tr><tr><td><code>cluster-info</code></td><td>显示集群信息</td></tr><tr><td><code>top</code></td><td>显示资源（CPU/Memory/Storage）使用情况，需要 Heapster 运行</td></tr><tr><td><code>cordon</code></td><td>标记节点不可调度</td></tr><tr><td><code>uncordon</code></td><td>标记节点可调度</td></tr><tr><td><code>drain</code></td><td>驱逐节点上的应用，准备下线维护</td></tr><tr><td><code>taint</code></td><td>修改节点 Taint 标记</td></tr></tbody></table><ul><li>故障和调试命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>describe</code></td><td>显示特定资源或资源组的详细信息</td></tr><tr><td><code>logs</code></td><td>在一个 Pod 中打印一个容器日志。如 Pod 只有一个容器，容器名称是可选的</td></tr><tr><td><code>attach</code></td><td>附加到一个运行的容器</td></tr><tr><td><code>exec</code></td><td>执行命令到容器</td></tr><tr><td><code>port-forward</code></td><td>转发一个或多个本地端口到一个 Pod</td></tr><tr><td><code>proxy</code></td><td>运行一个 Proxy 到 Kubernetes API server</td></tr><tr><td><code>cp</code></td><td>拷贝文件和目录到容器中或从容器中拷贝出来</td></tr><tr><td><code>auth</code></td><td>检查授权</td></tr></tbody></table><ul><li>其他高级命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>apply</code></td><td>通过文件名或标准输入对资源应用配置</td></tr><tr><td><code>patch</code></td><td>使用补丁修改、更新资源的字段</td></tr><tr><td><code>replace</code></td><td>通过文件名或标准输入替换一个资源</td></tr><tr><td><code>convert</code></td><td>不同的 API 版本之间转换配置文件</td></tr></tbody></table><ul><li>其他设置命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>label</code></td><td>更新资源上的标签</td></tr><tr><td><code>annotate</code></td><td>更新资源上的注释</td></tr></tbody></table><ul><li>其他常用命令</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>completion</code></td><td>用于实现 kubectl 工具自动补全</td></tr><tr><td><code>api-versions</code></td><td>打印可用的 API 版本</td></tr><tr><td><code>config</code></td><td>修改 kubeconfig 文件（用于访问 API，比如凭证信息配置）</td></tr><tr><td><code>help</code></td><td>所有命令帮助</td></tr><tr><td><code>plugin</code></td><td>运行一个可执行插件</td></tr><tr><td><code>version</code></td><td>打印客户端和服务端的版本信息</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">最常用的命令</p><ul><li><code>kubectl get pods</code>：查看当前命名空间下所有 Pod 的状态信息。</li><li><code>kubectl get nodes</code>：查看集群中所有节点（Node）的状态信息。</li><li><code>kubectl get svc</code>： 查看当前命名空间下所有 Service（服务）资源的配置信息。</li><li><code>kubectl get cs</code>： 查看集群核心组件（ComponentStatus，如 Scheduler、Controller Manager 等）的运行状态，已过时不推荐使用。</li></ul></div><h3 id="YAML-资源编排"><a href="#YAML-资源编排" class="headerlink" title="YAML 资源编排"></a>YAML 资源编排</h3><p>在 Kubernetes 集群中，资源管理和资源对象的编排部署可以通过声明式的 YAML 文件来实现。用户可以将对资源对象的操作需求编写到 YAML 格式的配置文件中，这种文件称为资源清单文件。通过 kubectl 命令直接调用这些资源清单文件，就能够高效地完成大量资源对象的编排和部署工作。</p><h4 id="YAML-的概述"><a href="#YAML-的概述" class="headerlink" title="YAML 的概述"></a>YAML 的概述</h4><ul><li>YAML 是一个可读性高，用来表达数据序列的格式。</li><li>YAML 仍是一种标记语言，为了强调这种语言以数据作为中心，而不是以标记语言为重点。</li></ul><h4 id="YAML-的基本语法"><a href="#YAML-的基本语法" class="headerlink" title="YAML 的基本语法"></a>YAML 的基本语法</h4><ul><li>使用空格作为缩进；</li><li>缩进的空格数量不重要，只要相同层级的元素左侧对齐即可；</li><li>低版本缩进时，不允许使用 Tab 键，只允许使用空格；</li><li>使用 <code>---</code> 作为文档分隔符，表示一个 YAML 文件中的多文档边界；</li><li>使用 <code>#</code> 标识注释，从这个字符一直到行尾，都会被 YAML 解释器忽略。</li></ul><h4 id="YAML-支持的数据结构"><a href="#YAML-支持的数据结构" class="headerlink" title="YAML 支持的数据结构"></a>YAML 支持的数据结构</h4><ul><li>对象：键值对的集合，又称为映射 (Mapping) / 哈希 (Hash) / 字典 (Dictionary)</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对象类型：对象的一组键值对，使用冒号结构表示</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yaml 也允许另一种写法，将所有键值对写成一个行内对象</span></span><br><span class="line"><span class="attr">hash:</span> {<span class="attr">name:</span> <span class="string">Tom</span>, <span class="attr">age:</span> <span class="number">18</span>}</span><br></pre></td></tr></tbody></table></figure><ul><li>数组：一组按次序排列的值，又称为序列 (Sequence) / 列表 (List)</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 横向写法（行内数组）</span></span><br><span class="line"><span class="attr">fruits:</span> [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 纵向写法（可读性更好，推荐）</span></span><br><span class="line"><span class="attr">fruits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cherry</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合对象的数组（数组中每个元素都是一个对象）</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Alice</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">25</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Peter</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">30</span></span><br></pre></td></tr></tbody></table></figure><ul><li>多行字符串可以使用 <code>|</code> 保留换行符，也可以使用 <code>&gt;</code> 折叠换行 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 `|` 保留换行符</span></span><br><span class="line"><span class="attr">this:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br></pre></td></tr></tbody></table></figure><ul><li>多个 YAML 文档之间可以使用 <code>---</code> 文档分隔符分隔 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个文档（例如定义一个 ConfigMap）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">config1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 第二个文档（例如定义一个 Secret）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret1</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">BASE64_ENCODED_DATA</span></span><br></pre></td></tr></tbody></table></figure><h4 id="YAML-资源清单的描述方法"><a href="#YAML-资源清单的描述方法" class="headerlink" title="YAML 资源清单的描述方法"></a>YAML 资源清单的描述方法</h4><p>在 Kubernetes 中，用户通常使用 YAML 格式的配置文件来定义和创建符合预期状态的集群资源（如 Pod、Deployment 等）。这类遵循 Kubernetes API 规范、用于描述资源对象及其期望状态的 YAML 文件，被称为资源清单（Manifest）。</p><ul><li>常用字段（<strong>必须存在的属性</strong>）</li></ul><table><thead><tr><th>参数名</th><th>字段类型</th><th>说明</th></tr></thead><tbody><tr><td><code>version</code></td><td>String</td><td>K8s API 的版本，目前基本是 <code>v1</code>，可以用 <code>kubectl api-versions</code> 命令查询</td></tr><tr><td><code>kind</code></td><td>String</td><td>YAML 文件定义的资源类型和角色，例如：<code>Pod</code></td></tr><tr><td><code>metadata</code></td><td>Object</td><td> 元数据对象，固定值写 <code>metadata</code></td></tr><tr><td><code>metadata.name</code></td><td>String</td><td> 元数据对象的名字，由用户定义，例如命名 Pod 的名字</td></tr><tr><td><code>metadata.namespace</code></td><td>String</td><td> 元数据对象的命名空间，由用户定义</td></tr><tr><td><code>spec</code></td><td>Object</td><td> 详细定义对象，固定值写 <code>spec</code></td></tr><tr><td><code>spec.containers[]</code></td><td>list</td><td>spec 对象的容器列表定义，是一个列表</td></tr><tr><td><code>spec.containers[].name</code></td><td>String</td><td> 定义容器的名称</td></tr><tr><td><code>spec.containers[].image</code></td><td>String</td><td> 定义容器使用的镜像名称</td></tr></tbody></table><ul><li>资源清单的定义示例（创建一个 Nginx 的 Pod）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>更完整的资源清单定义示例（创建一个 Nginx 的 Deployment）</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><ul><li>最后可以使用 <code>kubectl apply -f xxxx.yaml</code> 命令来执行这个资源清单</li></ul><h4 id="快速生成-YAML-资源清单"><a href="#快速生成-YAML-资源清单" class="headerlink" title="快速生成 YAML 资源清单"></a>快速生成 YAML 资源清单</h4><ul><li>(1) 第一种方式：使用 <code>kubectl create</code> 命令快速生成 YAML 的配置模板内容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速生成 YAML 配置模板内容，--dry-run=client 表示只在客户端进行验证和生成请求，而不把资源真正提交到 API Server</span></span><br><span class="line"><span class="keyword"># kubectl</span> create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者将生成 YAML 配置模板内容输出到文件中</span></span><br><span class="line"><span class="keyword"># kubectl</span> create deployment nginx<span class="params"> --image</span>=nginx<span class="params"> --dry</span>-run=client<span class="params"> -o</span> yaml &gt; nginx.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> {}</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line"><span class="attr">status:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 第二种方式：使用 <code>kubectl get</code> 命令导出正在运行的资源对象的 YAML 配置内容 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前正在运行的 Deployment</span></span><br><span class="line"><span class="keyword"># kubectl</span> get deployments</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   1/1     1            1           2d12h</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出当前正在运行的 Deployment 的 YAML 配置内容</span></span><br><span class="line"><span class="keyword"># kubectl</span> get deployment nginx<span class="params"> -o</span> yaml &gt; nginx.yaml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">deployment.kubernetes.io/revision:</span> <span class="string">"1"</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">  <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:labels:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:app:</span> {}</span><br><span class="line">      <span class="attr">f:spec:</span></span><br><span class="line">        <span class="attr">f:progressDeadlineSeconds:</span> {}</span><br><span class="line">        <span class="attr">f:replicas:</span> {}</span><br><span class="line">        <span class="attr">f:revisionHistoryLimit:</span> {}</span><br><span class="line">        <span class="attr">f:selector:</span></span><br><span class="line">          <span class="attr">f:matchLabels:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:app:</span> {}</span><br><span class="line">        <span class="attr">f:strategy:</span></span><br><span class="line">          <span class="attr">f:rollingUpdate:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:maxSurge:</span> {}</span><br><span class="line">            <span class="attr">f:maxUnavailable:</span> {}</span><br><span class="line">          <span class="attr">f:type:</span> {}</span><br><span class="line">        <span class="attr">f:template:</span></span><br><span class="line">          <span class="attr">f:metadata:</span></span><br><span class="line">            <span class="attr">f:labels:</span></span><br><span class="line">              <span class="string">.:</span> {}</span><br><span class="line">              <span class="attr">f:app:</span> {}</span><br><span class="line">          <span class="attr">f:spec:</span></span><br><span class="line">            <span class="attr">f:containers:</span></span><br><span class="line">              <span class="string">k:{"name":"nginx"}:</span></span><br><span class="line">                <span class="string">.:</span> {}</span><br><span class="line">                <span class="attr">f:image:</span> {}</span><br><span class="line">                <span class="attr">f:imagePullPolicy:</span> {}</span><br><span class="line">                <span class="attr">f:name:</span> {}</span><br><span class="line">                <span class="attr">f:resources:</span> {}</span><br><span class="line">                <span class="attr">f:terminationMessagePath:</span> {}</span><br><span class="line">                <span class="attr">f:terminationMessagePolicy:</span> {}</span><br><span class="line">            <span class="attr">f:dnsPolicy:</span> {}</span><br><span class="line">            <span class="attr">f:restartPolicy:</span> {}</span><br><span class="line">            <span class="attr">f:schedulerName:</span> {}</span><br><span class="line">            <span class="attr">f:securityContext:</span> {}</span><br><span class="line">            <span class="attr">f:terminationGracePeriodSeconds:</span> {}</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubectl-create</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:annotations:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="attr">f:deployment.kubernetes.io/revision:</span> {}</span><br><span class="line">      <span class="attr">f:status:</span></span><br><span class="line">        <span class="attr">f:availableReplicas:</span> {}</span><br><span class="line">        <span class="attr">f:conditions:</span></span><br><span class="line">          <span class="string">.:</span> {}</span><br><span class="line">          <span class="string">k:{"type":"Available"}:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> {}</span><br><span class="line">            <span class="attr">f:lastUpdateTime:</span> {}</span><br><span class="line">            <span class="attr">f:message:</span> {}</span><br><span class="line">            <span class="attr">f:reason:</span> {}</span><br><span class="line">            <span class="attr">f:status:</span> {}</span><br><span class="line">            <span class="attr">f:type:</span> {}</span><br><span class="line">          <span class="string">k:{"type":"Progressing"}:</span></span><br><span class="line">            <span class="string">.:</span> {}</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> {}</span><br><span class="line">            <span class="attr">f:lastUpdateTime:</span> {}</span><br><span class="line">            <span class="attr">f:message:</span> {}</span><br><span class="line">            <span class="attr">f:reason:</span> {}</span><br><span class="line">            <span class="attr">f:status:</span> {}</span><br><span class="line">            <span class="attr">f:type:</span> {}</span><br><span class="line">        <span class="attr">f:observedGeneration:</span> {}</span><br><span class="line">        <span class="attr">f:readyReplicas:</span> {}</span><br><span class="line">        <span class="attr">f:replicas:</span> {}</span><br><span class="line">        <span class="attr">f:updatedReplicas:</span> {}</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kube-controller-manager</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"300851"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/apis/apps/v1/namespaces/default/deployments/nginx</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">f8edd19f-3292-45ac-ad16-932611f528a8</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> {}</span><br><span class="line">        <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">        <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">      <span class="attr">securityContext:</span> {}</span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">availableReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">"2025-07-22T14:09:51Z"</span></span><br><span class="line">    <span class="attr">lastUpdateTime:</span> <span class="string">"2025-07-22T14:10:24Z"</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">ReplicaSet</span> <span class="string">"nginx-6799fc88d8"</span> <span class="string">has</span> <span class="string">successfully</span> <span class="string">progressed.</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">NewReplicaSetAvailable</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">"True"</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Progressing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">    <span class="attr">lastUpdateTime:</span> <span class="string">"2025-08-07T03:19:49Z"</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">Deployment</span> <span class="string">has</span> <span class="string">minimum</span> <span class="string">availability.</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">"True"</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Available</span></span><br><span class="line">  <span class="attr">observedGeneration:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">readyReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">updatedReplicas:</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><h4 id="Pod-的基础概念"><a href="#Pod-的基础概念" class="headerlink" title="Pod 的基础概念"></a>Pod 的基础概念</h4><h5 id="Pod-的概述"><a href="#Pod-的概述" class="headerlink" title="Pod 的概述"></a>Pod 的概述</h5><p>Pod 是 Kubernetes 中可以创建和管理的最小资源单元，是用户在资源对象模型中创建或部署的基本单位，也是 Kubernetes 上运行容器化应用的直接载体。Kubernetes 并不会直接管理容器，而是通过管理 Pod 来间接管理容器。一个 Pod 通常由一个或多个容器组成，这些容器共享网络、存储等资源，并作为一个整体被调度和管理。在 Kubernetes 中，其他资源对象主要用于支撑或扩展 Pod 的功能，例如：Controller 资源用于管理和控制 Pod 的生命周期；Service 或 Ingress 资源用于暴露和访问 Pod；而 PersistentVolume (PV) 等存储资源用于为 Pod 提供持久化存储支持。此外，每个 Pod 都包含一个特殊的系统容器，称为 Pause 容器，它作为 Pod 的 “根容器” 存在，用于占据 Pod 的网络命名空间等资源。除了 Pause 容器，Pod 中还包含一个或多个紧密相关的用户业务容器，所有业务容器都在同一个 Namespace 里面，可以实现网络共享；这些容器协同工作，共同完成某项具体的业务功能。</p><h5 id="Pod-的特性"><a href="#Pod-的特性" class="headerlink" title="Pod 的特性"></a>Pod 的特性</h5><ul><li><p><strong>资源共享</strong></p><ul><li>一个 Pod 里的多个容器可以共享存储和网络，可以看作一个逻辑的主机（服务器），共享 Namespace（命名空间）、Cgroups（控制组）或者其他的隔离资源。</li><li>同一个 Pod 中的多个容器共享同一个 Network Namespace，因此它们共享同一个 IP 地址和端口空间。也就是说，Pod 内的容器可以通过 <code>localhost</code> 进行通信。需要注意的是，多个容器在同一个 Pod 中运行时，应避免端口冲突。不同的 Pod 之间具有各自独立的 IP 地址，默认情况下，不同 Pod 中的容器之间不能通过 IPC 机制通信（除非做了特殊配置），通常使用 Pod 的 IP 地址进行网络通信。</li><li>一个 Pod 中的多个容器可以共享同一个存储卷，该存储卷作为 Pod 的一部分被定义，并可以挂载到该 Pod 内所有容器的文件系统中，从而实现数据共享和持久化存储。</li></ul></li><li><p><strong>生命周期短暂</strong></p><ul><li>Pod 是生命周期相对短暂的组件，例如当 Pod 所在的节点发生故障时，该节点上的 Pod 会被重新调度到其他节点上运行。但需要注意的是，重新调度后创建的是一个全新的 Pod，与原来的 Pod 没有任何关联，原有的状态、数据和标识都会丢失，二者之间没有任何直接关系。</li></ul></li><li><p><strong>平坦的网络</strong></p><ul><li>Kubernetes 集群中的所有 Pod 都处于同一个共享的网络地址空间中，这意味着每个 Pod 都可以通过其他 Pod 的 IP 地址直接进行访问和通信，无需进行额外的网络配置。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Docker 容器与宿主机进程的关系</p><ul><li>Docker 容器里的进程没有独立 Linux 内核，使用的是宿主机内核，它本质就是宿主机进程。</li><li>Docker 容器只是由 Linux 内核提供的隔离（Namespace） + 资源限制（Cgroups）环境。</li><li>当宿主机关掉 Docker 容器主进程，容器就会退出运行（容器生命周期依赖主进程）。换言之，Docker 容器主进程如果挂掉，容器就会停止运行。</li><li>Docker 容器的 Linux 内核版本永远等于宿主机的内核版本，更换镜像也换不掉内核。比如，当宿主机内核版本低（例如 <code>3.3</code>），容器里即使是最新版本的 Ubuntu，也无法使用高版本内核才有的特性（比如一些新 Cgroup 特性、eBPF）。</li></ul></div><h5 id="Pod-的分类"><a href="#Pod-的分类" class="headerlink" title="Pod 的分类"></a>Pod 的分类</h5><p>Pod 有两种类型：</p><ul><li><p><strong>普通 Pod</strong>  </p><ul><li> 普通 Pod 被创建后会被存储到 Etcd 中，随后由 Kubernetes Master 调度到某个特定的 Node 上并与之绑定。该 Node 上的 kubelet 进程会负责将 Pod 实例化为一组相关的容器（如 Docker 容器）并启动它们。默认情况下，如果 Pod 中的某个容器停止运行，Kubernetes 会自动检测并重启该 Pod 内的所有容器。如果 Pod 所在的 Node 发生宕机，Kubernetes 会将该 Node 上的所有 Pod 重新调度到其他可用节点上。</li></ul></li><li><p><strong>静态 Pod</strong>  </p><ul><li> 静态 Pod 是由 kubelet 直接管理的特殊 Pod，仅存在于特定的 Node 上。它们不受 API Server 管理，也无法与 ReplicationController、Deployment 或 DaemonSet 等控制器关联。此外，kubelet 对静态 Pod 的健康检查能力有限，通常仅能监控其运行状态，而不会像普通 Pod 那样提供完整的健康检查机制。</li></ul></li></ul><h5 id="Pod-的定义"><a href="#Pod-的定义" class="headerlink" title="Pod 的定义"></a>Pod 的定义</h5><p>定义 Pod 的 YAML 配置示例如下（<code>&lt;string&gt;</code> 是占位符，需要根据实际情况填写）：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="comment"># 元数据</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="comment"># 时间配置</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">0</span>            <span class="comment"># 检查间隔时间</span></span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 安全配置</span></span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span>       <span class="comment"># 重启策略，可选值: Always、Never、OnFailure，默认 Always</span></span><br><span class="line">  <span class="attr">nodeSelector:</span>               <span class="comment"># 节点选择，将 Pod 调度到包含这些 Label 的 Node 上</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">value</span>                <span class="comment"># 以 key:value 格式指定</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span>          <span class="comment"># 是否使用主机网络模式，默认 false（不使用）</span></span><br><span class="line">  <span class="comment"># 共享存储卷列表</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">      <span class="attr">emptyDir:</span> {}</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">host-volume</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/path/on/host</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">configmap-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&lt;string&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-的运行方式"><a href="#Pod-的运行方式" class="headerlink" title="Pod 的运行方式"></a>Pod 的运行方式</h5><p><strong>在 Kubernetes 中，运行的容器要求其主程序必须始终在前台运行，而不能以后台方式执行。如果应用默认是以后台运行的方式启动，就需要进行修改，使其在前台运行。否则，当 kubelet 创建包含该容器的 Pod 并执行启动命令后，会因为容器立即退出而认为该 Pod 已经结束，从而立刻销毁该 Pod。</strong>如果该 Pod 是由控制器（如 ReplicationController）管理的，那么就会不断尝试重新创建和销毁 Pod，陷入无限循环。需要注意的是，一个 Pod 可以由一个或多个容器组成。</p><ul><li>下面的 YAML 配置内容定义了一个包含单个容器的 Pod，容器使用的是官方 Tomcat 镜像，并包含基本的端口和挂载配置 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mytomcat</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">tomcat:9.0</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/local/tomcat/webapps</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat-data</span></span><br><span class="line">      <span class="attr">emptyDir:</span> {}</span><br></pre></td></tr></tbody></table></figure><ul><li>YAML 配置内容的详细说明</li></ul><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td><code>metadata.name</code></td><td>Pod 的名称，必须唯一</td></tr><tr><td><code>metadata.labels</code></td><td>标签，用于标识和选择 Pod</td></tr><tr><td><code>spec.containers</code></td><td>容器列表，一个 Pod 可包含一个或多个容器</td></tr><tr><td><code>spec.containers[].name</code></td><td>容器的名称，在 Pod 内部唯一</td></tr><tr><td><code>spec.containers[].image</code></td><td>容器使用的镜像，这里是 <code>tomcat:9.0</code></td></tr><tr><td><code>spec.containers[].ports</code></td><td>容器开放的端口列表</td></tr><tr><td><code>spec.containers[].ports[].containerPort</code></td><td>容器内部监听的端口号（如 Tomcat 默认 8080）</td></tr><tr><td><code>spec.containers[].volumeMounts</code></td><td>容器内挂载的卷配置</td></tr><tr><td><code>spec.containers[].volumeMounts[].name</code></td><td>要挂载的卷名称，对应 <code>spec.volumes</code> 中定义的名称</td></tr><tr><td><code>spec.containers[].volumeMounts[].mountPath</code></td><td>挂载点路径，如 <code>/usr/local/tomcat/webapps</code></td></tr><tr><td><code>spec.volumes</code></td><td>定义 Pod 中使用的卷</td></tr><tr><td><code>spec.volumes[].name</code></td><td>卷的名称，与 <code>volumeMounts</code> 中的名称对应</td></tr><tr><td><code>spec.volumes[].emptyDir</code></td><td>使用一个空目录卷，Pod 删除时数据也会被清除</td></tr></tbody></table><h5 id="Pod-的生命周期"><a href="#Pod-的生命周期" class="headerlink" title="Pod 的生命周期"></a>Pod 的生命周期</h5><p>Pod 的生命周期状态有以下几种：</p><table><thead><tr><th>生命周期状态</th><th>说明</th></tr></thead><tbody><tr><td> Pending</td><td>API Server 已创建该 Pod，但 Pod 中的一个或多个容器的镜像尚未创建（包括镜像下载过程）。</td></tr><tr><td>Running</td><td>Pod 内所有容器已创建，且至少有一个容器处于运行状态（包括正在启动或重启的状态）。</td></tr><tr><td>Completed</td><td>Pod 内所有容器均已成功执行并退出，且不会再重启。</td></tr><tr><td>Failed</td><td>Pod 内所有容器均已退出，但至少有一个容器退出失败。</td></tr><tr><td>Unknown</td><td> 由于某些原因（如网络通信不畅）无法获取 Pod 的状态。</td></tr></tbody></table><h5 id="Pod-的状态条件"><a href="#Pod-的状态条件" class="headerlink" title="Pod 的状态条件"></a>Pod 的状态条件</h5><p>Pod 的状态条件（Conditions）有以下几种：</p><table><thead><tr><th>状态条件</th><th>触发时机</th><th>正常状态</th><th>说明</th></tr></thead><tbody><tr><td><code>PodScheduled</code></td><td>当 Scheduler 为 Pod 分配了目标 Node 节点后</td><td><code>True</code></td><td>表示 Pod 已被调度到某个 Node 上。如果为 <code>False</code>，可能是集群资源不足或调度约束冲突。</td></tr><tr><td><code>Initialized</code></td><td>当所有 Init 容器（如果有）成功执行完成后</td><td><code>True</code></td><td>仅对包含 Init 容器的 Pod 有意义。若 Init 容器失败，此条件会显示 <code>False</code> 并记录原因。</td></tr><tr><td><code>ContainersReady</code></td><td>当 Pod 内所有主容器（非 Init 容器）的状态均为 <code>Running</code> 时</td><td><code>True</code></td><td>仅表示容器已启动，但不保证容器内应用已就绪（需结合 Readiness Probe（就绪探针）判断）。</td></tr><tr><td><code>Ready</code></td><td>当 Pod 满足以下条件时：<br>1. 所有主容器 <code>Running</code>；<br>2. 通过 Readiness Probe（就绪探针）检测（如果配置了）。</td><td><code>True</code></td><td>表示 Pod 可正常接收流量。若为 <code>False</code>，该 Pod 会被从 Service 的 Endpoints 中移除。</td></tr></tbody></table><p>Pod 状态条件的附加说明</p><ul><li>(1) 状态值：<ul><li>每个 Condition 的状态可能是 <code>True</code>、<code>False</code> 或 <code>Unknown</code>。</li></ul></li><li>(2) 依赖关系：  <ul><li><code>PodScheduled</code> → <code>Initialized</code> → <code>ContainersReady</code> → <code>Ready</code>（存在先后顺序）。  </li></ul></li><li>(3) 常见问题：  <ul><li>若 <code>PodScheduled=False</code>，需检查节点资源或亲和性规则。  </li><li>若 <code>Initialized=False</code>，需排查 Init 容器的日志。  </li><li>若 <code>Ready=False</code> 但 <code>ContainersReady=True</code>，通常是 Readiness Probe（就绪探针）配置问题。  </li></ul></li><li>(4) 查看命令：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以结构化格式提取 Pod 状态条件（Conditions）的详细信息</span></span><br><span class="line">kubectl get pod &lt;pod-name&gt;<span class="params"> -o</span> jsonpath=<span class="string">'{.status.conditions}'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用 describe 查看 Pod 的详细状态</span></span><br><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="Pod-的重启策略"><a href="#Pod-的重启策略" class="headerlink" title="Pod 的重启策略"></a>Pod 的重启策略</h5><p>Pod 的重启策略包括 Always、OnFailure 和 Never，默认值是 Always。</p><table><thead><tr><th>重启策略</th><th>说明</th></tr></thead><tbody><tr><td> Always</td><td> 默认值，当容器退出时，总是由 kubelet 自动重启该容器（适用于长期运行的 Pod，如 Web 服务）。</td></tr><tr><td>OnFailure</td><td> 仅在容器异常退出（非 0 状态码）时，由 kubelet 自动重启该容器（适合批处理任务）。</td></tr><tr><td>Never</td><td> 无论容器如何退出，kubelet 都不会重启该容器（适合一次性任务）。</td></tr></tbody></table><p>Pode 重启策略的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mynginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span>  <span class="comment"># Pod 的重启策略</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-的状态转换"><a href="#Pod-的状态转换" class="headerlink" title="Pod 的状态转换"></a>Pod 的状态转换</h5><p>Pod 生命周期状态的转换表（基于容器事件和重启策略）如下：</p><table><thead><tr><th>Pod 包含的容器数</th><th> Pod 当前的运行状态</th><th>发生的事件</th><th> Pod 的结果状态（RestartPolicy = Always）</th><th>Pod 的结果状态（RestartPolicy = OnFailure）</th><th>Pod 的结果状态（RestartPolicy = Never）</th></tr></thead><tbody><tr><td>1 个容器</td><td> Running</td><td> 容器成功退出</td><td> Running</td><td>Succeeded</td><td>Succeeded</td></tr><tr><td>1 个容器</td><td> Running</td><td> 容器失败退出</td><td> Running</td><td>Running</td><td>Failed</td></tr><tr><td>2 个容器</td><td> Running</td><td> 其中 1 个容器失败退出</td><td> Running</td><td>Running</td><td>Running</td></tr><tr><td>2 个容器</td><td> Running</td><td>2 个容器被 OOM 终止</td><td> Running</td><td>Running</td><td>Failed</td></tr></tbody></table><ul><li> 关键说明：<ul><li><strong>OOM</strong>：表示容器因内存不足（Out Of Memory）被系统终止</li><li>状态转换规则：<ul><li><code>Always</code>：任何容器终止都会触发重启（保持 Running 状态）</li><li><code>OnFailure</code>：仅当容器异常退出（非 0 状态码 / OOM）时重启</li><li><code>Never</code>：容器终止后直接反映最终状态（Succeeded/Failed）</li></ul></li><li>多容器 Pod 的状态由所有容器的综合状态决定</li></ul></li></ul><h5 id="Pod-的健康检查"><a href="#Pod-的健康检查" class="headerlink" title="Pod 的健康检查"></a>Pod 的健康检查</h5><p>Kubernetes 提供以下三种探针（Probe）来监控容器的运行状态：</p><ul><li><p>存活探针（<code>livenessProbe</code>）</p><ul><li>作用：检测容器是否正常运行。如果检测不通过，Kubernetes 会杀死容器并根据 <code>restartPolicy（重启策略）</code> 重启容器。</li><li>适用场景：用于修复死锁、无响应的应用（如数据库卡死）。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">exec:</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"cat"</span>, <span class="string">"/tmp/healthy"</span>]  <span class="comment"># 执行命令检查文件是否存在</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">5</span>              <span class="comment"># 容器启动后等待5秒开始检查</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span>                    <span class="comment"># 每5秒检查一次</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">3</span>                 <span class="comment"># 连续失败3次后判定为不健康</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>就绪探针（<code>readinessProbe</code>）</p><ul><li>作用：检测容器是否准备好接收流量。如果检测不通过，Kubernetes 会将 Pod 从 Service 的 Endpoints 中剔除，并且 Pod 会被标记为 <code>NotReady</code>，但不会被重启。</li><li>适用场景：用于控制流量进入（如应用启动时需要加载大量数据）。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/healthz</span>                    <span class="comment"># 发送 HTTP 请求进行检测</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">10</span>             <span class="comment"># 容器启动后等待10秒开始检查</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">3</span>                    <span class="comment"># 每3秒检查一次</span></span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">1</span>                 <span class="comment"># 成功1次即标记为就绪</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>启动探针（<code>startupProbe</code>）</p><ul><li>作用：从 Kubernetes <code>1.16+</code> 版本开始引入，专门检测慢启动应用是否完成初始化。在启动探针成功之前，其他探针不会生效。可以避免因应用启动过慢，导致被存活 / 就绪探针误杀。</li><li>适用场景：启动时间较长的应用（如 Java/SpringBoot 应用、需要加载大数据量的服务）。</li><li>配置示例：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">startupProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health</span>             <span class="comment"># Spring Boot 健康检查端点</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">30</span>                 <span class="comment"># 允许的最大失败次数</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">10</span>                    <span class="comment"># 每10秒检查一次</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>探针（Probe）支持以下三种检测方法</p></li></ul><table><thead><tr><th>检测方法</th><th>说明</th><th>配置示例</th></tr></thead><tbody><tr><td><code>exec</code></td><td>执行容器内的命令，返回状态码为 0 时，表示检测成功</td><td><code>command: ["cat", "/tmp/healthy"]</code></td></tr><tr><td><code>httpGet</code></td><td>发送 HTTP 请求，状态码在 200 - 399 范围内时，表示检测成功。</td><td><code>httpGet: { path: /health, port: 80 }</code></td></tr><tr><td><code>tcpSocket</code></td><td>尝试建立 TCP 连接，端口可以联通时，即表示检测成功。</td><td><code>tcpSocket: { port: 3306 }</code></td></tr></tbody></table><ul><li> 探针（Probe）的关键参数说明</li></ul><table><thead><tr><th>参数</th><th>作用</th><th>默认值</th><th>适用探针类型</th></tr></thead><tbody><tr><td><code>initialDelaySeconds</code></td><td>容器启动后等待多少秒开始第一次检查（避免容器未完成启动造成误判）。</td><td>0</td><td>liveness、readiness、startup</td></tr><tr><td><code>periodSeconds</code></td><td>每次健康检查的间隔时间。</td><td>10</td><td>liveness、readiness</td></tr><tr><td><code>timeoutSeconds</code></td><td>单次检查的超时时间（超过此时长未响应视为失败）。</td><td>1</td><td>liveness、readiness</td></tr><tr><td><code>failureThreshold</code></td><td>连续失败多少次后标记为不健康。</td><td>3</td><td>liveness、readiness、startup</td></tr><tr><td><code>successThreshold</code></td><td>对于已标记为不健康的容器，需要连续成功多少次才会重新标记为健康。</td><td>1</td><td>liveness、readiness</td></tr></tbody></table><p>容器健康检测（基于存活探针）的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-exec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">touch</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">30</span><span class="string">;</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/healthy</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><p>启动探针、存活探针和就绪探针三者可以混合使用：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">springboot-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-springboot-app:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="comment"># 启动探针（给予充足启动时间）</span></span><br><span class="line">    <span class="attr">startupProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="comment"># 存活检查（启动探针成功后生效）</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment"># 就绪检查（启动探针成功后生效）</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/actuator/health/readiness</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pod-的资源限制"><a href="#Pod-的资源限制" class="headerlink" title="Pod 的资源限制"></a>Pod 的资源限制</h5><p>每个 Pod 都可以对其可使用的 Node 节点计算资源设置限额。Kubernetes 支持对以下两种计算资源进行配额限制：</p><ul><li><p>资源类型  </p><ul><li>CPU 资源：以绝对值的 CPU 数量为单位（比如 <code>500m</code> 表示 0.5 个 CPU 核心）。</li><li>Memory 资源：内存大小以字节数为单位（比如 <code>512Mi</code> 表示 512 MiB 内存）。</li></ul></li><li><p>配额参数  </p><ul><li>每种资源需要定义两个关键参数：  </li><li>Requests<ul><li> 表示该资源的最小申请量。</li><li>Kubernetes 调度器会确保 Node 节点剩余资源大于等于 Requests 值，否则 Pod 无法被调度。</li></ul></li><li>Limits<ul><li> 表示该资源的最大允许使用量。若容器尝试使用超过 Limits 的资源：<ul><li>对于 CPU 资源，容器会被限制（Throttled）。</li><li>对于 Memory 资源，容器可能被 Kubernetes 终止（OOM Kill）并重启。</li></ul></li></ul></li></ul></li></ul><p>Pod 资源限制的配置示例如下，表示 MySQL 容器申请最少 <code>0.25</code> 个 CPU 以及 <code>64MiB</code> 内存，在运行过程中容器所能使用的最大资源配额为 <code>0.5</code> 个 CPU 以及 <code>128MiB</code> 内存。</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"128Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"500m"</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">CPU 资源限制的单位</p><ul><li>(1) 在 Kubernetes 的资源限制配置中，<code>cpu: "500m"</code> 表示 500 毫核（millicores）。</li><li>(2) <code>1m = 0.001 个 CPU 核心</code>，而 <code>500m</code> 等价于 <code>0.5</code> 个 CPU 核心（即 50% 的单核算力）。</li><li>(3) Kubernetes 常见的 CPU 单位如下表所示：</li></ul></div><table><thead><tr><th>CPU 单位</th><th>含义</th><th>配置示例</th></tr></thead><tbody><tr><td><code>1</code></td><td>1 个完整的 CPU 核心</td><td><code>cpu: "1"</code></td></tr><tr><td><code>1000m</code></td><td>1 个完整的 CPU 核心</td><td><code>cpu: "1000m"</code></td></tr><tr><td><code>500m</code></td><td>0.5 核（即 50% 的单核算力）</td><td><code>cpu: "500m"</code></td></tr><tr><td><code>250m</code></td><td>0.25 核（即 25% 的单核算力）</td><td><code>cpu: "250m"</code></td></tr></tbody></table><h5 id="Pod-的镜像拉取策略"><a href="#Pod-的镜像拉取策略" class="headerlink" title="Pod 的镜像拉取策略"></a>Pod 的镜像拉取策略</h5><p>Pod 有以下几种镜像拉取策略：</p><table><thead><tr><th>策略名称</th><th>描述</th></tr></thead><tbody><tr><td><code>IfNotPresent</code></td><td>默认值，只有当镜像在宿主机上不存在时才会拉取</td></tr><tr><td><code>Always</code></td><td>每次创建 Pod 时都会重新拉取一次镜像（即使宿主机上已存在）</td></tr><tr><td><code>Never</code></td><td>Pod 永远不会主动拉取镜像，仅使用宿主机上已有的镜像（若宿主机上不存在，则报错）</td></tr></tbody></table><p>Pode 镜像拉取策略的配置示例如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mynginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>   <span class="comment"># Pod 的镜像拉取策略</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Pod-的调度策略"><a href="#Pod-的调度策略" class="headerlink" title="Pod 的调度策略"></a>Pod 的调度策略</h4><h5 id="Pod-的创建流程"><a href="#Pod-的创建流程" class="headerlink" title="Pod 的创建流程"></a>Pod 的创建流程</h5><p><img data-src="../../../asset/2025/08/k8s-pod-create.png"></p><ul><li><p>(1) 用户提交 Pod 创建请求</p><ul><li>用户通过 <code>kubectl</code> 命令行工具或其他客户端工具提交 Pod 创建请求</li><li>请求会发送到 Master 节点的 API Server</li></ul></li><li><p>(2) API Server 处理</p><ul><li>API Server 接收并验证请求</li><li>将 Pod 配置信息写入 Etcd 进行持久化存储</li></ul></li><li><p> (3) Scheduler 调度</p><ul><li>Scheduler 组件监控 API Server，发现有未调度的新 Pod</li><li>Scheduler 通过调度算法（考虑资源需求、节点亲和性等）选择最适合的 Node 节点</li><li> Scheduler 将调度决策（绑定信息）通过 API Server 更新到 Etcd</li></ul></li><li><p>(4) Node 节点执行</p><ul><li>目标 Node 上的 kubelet 组件会定期查询 API Server</li><li>kubelet 发现分配给本节点的 Pod 信息（从 Etcd 读取）</li><li>kubelet 根据 Pod 描述文件:<ul><li> 通过容器运行时（如 Docker、Containerd）创建容器</li><li>配置容器网络、存储等资源</li><li>启动容器</li></ul></li></ul></li><li><p> (5) 状态更新</p><ul><li>kubelet 监控容器状态，并将容器最新状态报告给 API Server</li><li>API Server 将 Pod 状态信息写入 Etcd</li><li> 用户可以通过 <code>kubectl</code> 命令行工具查看 Pod 的运行状态</li></ul></li></ul><h5 id="Pod-影响调度的因素"><a href="#Pod-影响调度的因素" class="headerlink" title="Pod 影响调度的因素"></a>Pod 影响调度的因素</h5><p>影响 Pod 调度的主要因素有以下几种：</p><ul><li><p><strong>(1) Pod 资源限制（Resource Requests）</strong></p><ul><li>核心机制：<ul><li>Pod 通过 <code>resources.requests</code> 声明所需的最小资源量</li><li>调度器（Scheduler）根据这些请求寻找有足够资源的节点</li></ul></li><li>示例配置：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br></pre></td></tr></tbody></table></figure></li><li>调度行为：<ul><li>调度器会排除所有可用资源（Allocatable）小于请求值的节点</li><li>资源包括 CPU、内存、GPU 等</li><li>实际调度基于节点的剩余资源（Allocatable - Requested）</li></ul></li></ul></li><li><p><strong>(2) 节点选择器（Node Selector）</strong></p><ul><li>核心机制：<ul><li>通过 <code>nodeSelector</code> 字段指定 Pod 必须运行在具有特定标签的节点上</li><li>这是简单的节点选择约束方式</li></ul></li><li>示例配置：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">env_role:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br></pre></td></tr></tbody></table></figure></li><li>节点的标签操作：<ul><li>给节点打上标签：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes &lt;node-name&gt; env_role=prod</span><br></pre></td></tr></tbody></table></figure></li><li>查看节点上的标签：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes<span class="params"> --show</span>-labels</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p><strong>(3) 节点亲和性（Node Affinity）</strong></p><ul><li>比 <code>nodeSelector</code> 字段更灵活的规则</li><li>支持硬亲和性（约束条件必须满足）和软亲和性（尝试满足约束条件，但不保证满足）</li><li>支持常用操作：<code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>Gt</code>、<code>Lt</code>、<code>DoesNotExist</code></li><li>示例配置：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="comment"># 硬亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">env_role</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">      <span class="comment"># 软亲和性</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">group</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">otherprod</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>(4) 污点和容忍（Taints and Tolerations）</strong></p><ul><li>节点可以设置污点（Taints）来拒绝普通 Pod 的调度</li><li>节点设置污点后，Pod 必须声明相应容忍（Tolerations）才能被调度</li><li>污点（Taints）<ul><li>污点的类型：<ul><li><code>NoSchedule</code>  <ul><li>作用：<ul><li>默认值，新 Pod 无法调度到该节点（除非明确容忍此污点）</li><li>已运行的 Pod 若不容忍此污点，不会被驱逐（Evict）</li></ul></li><li>场景：保留节点给特定用途（如 GPU 节点、生产环境专用节点）</li></ul></li><li><code>PreferNoSchedule</code>  <ul><li>作用：<ul><li>调度器尽量避免将 Pod 分配到该节点，但若无其他可用节点仍会调度，不驱逐已运行的 Pod</li><li> 已运行的 Pod 若不容忍此污点，不会被驱逐（Evict）</li></ul></li><li>场景：软性隔离（如临时维护节点，但不强制拒绝调度）</li></ul></li><li><code>NoExecute</code>  <ul><li>作用：  <ul><li>新 Pod 无法调度到该节点（同 <code>NoSchedule</code>）</li><li>已运行的 Pod 若不容忍此污点，会被驱逐（Evict）</li></ul></li><li>场景：节点故障维护或紧急隔离（如节点磁盘故障需立即迁移所有 Pod）</li></ul></li></ul></li><li>污点的适用场景：<ul><li>专用节点隔离：保留节点给特定 Pod（如 GPU 节点只运行 AI 任务）</li><li>节点维护：标记节点为不可调度（如 <code>NoSchedule</code>），避免新 Pod 被分配到正在维护的节点</li><li>特殊硬件限制：防止普通 Pod 调度到带特殊硬件（如 FPGA）的节点</li></ul></li></ul></li><li>容忍（Tolerations）<ul><li>容忍的类型<ul><li><code>NoSchedule</code>  <ul><li>作用：允许 Pod 调度到带有 <code>NoSchedule</code> 污点的节点 </li><li>场景：让关键 Pod（如存储服务）无视节点的硬性隔离规则</li></ul></li><li><code>PreferNoSchedule</code>  <ul><li>作用：允许 Pod 调度到带有 <code>PreferNoSchedule</code> 污点的节点（但调度器仍可能优先选择其他节点）</li><li>场景：非关键 Pod 在资源不足时仍可使用软隔离节点</li></ul></li><li><code>NoExecute</code>  <ul><li>作用：<ul><li>允许 Pod 调度到带有 <code>NoExecute</code> 污点的节点</li><li>豁免驱逐：即使节点新增 <code>NoExecute</code> 污点，Pod 也不会被驱逐</li></ul></li><li>场景：守护进程（如日志收集器）需长期运行，无视节点维护状态</li></ul></li><li><code>空值</code>（不指定 <code>effect</code> 字段）<ul><li>作用：容忍所有污点类型（包括未来可能新增的类型）</li><li>场景：超级特权 Pod（如集群管理组件）需在任何节点运行</li></ul></li></ul></li><li>容忍的适用场景：<ul><li>特权 Pod 调度：允许关键 Pod（如日志收集组件）无视污点，调度到任意节点</li><li>故障恢复：容忍 <code>NoExecute</code> 污点，使 Pod 在节点故障时不被驱逐（如数据库 Pod）</li><li>共享特殊节点：让普通 Pod 通过容忍临时使用专用节点（如容忍 GPU 节点污点）</li></ul></li></ul></li><li>节点的污点操作：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给节点打污点</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;=&lt;value&gt;:NoSchedule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点的污点</span></span><br><span class="line">kubectl describe node &lt;node-name&gt; | grep Taint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的单个污点（末尾的 "-" 符号表示删除）</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;:NoSchedule-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的指定键的所有污点（末尾的 "-" 符号表示删除）</span></span><br><span class="line">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点的所有污点</span></span><br><span class="line">kubectl patch nodes &lt;node-name&gt;<span class="params"> -p</span> <span class="string">'{"spec":{"taints":[]}}'</span></span><br></pre></td></tr></tbody></table></figure></li><li>示例配置：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="comment"># 仅容忍 NoSchedule 污点</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"dedicated"</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">"gpu"</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 容忍 NoExecute 污点（并豁免驱逐）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"node.kubernetes.io/unreachable"</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">"NoExecute"</span></span><br><span class="line">    <span class="attr">tolerationSeconds:</span> <span class="number">600</span>  <span class="comment"># 延迟 600 秒后驱逐（可选）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 容忍所有污点（危险！慎用！）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>(5) Pod 间亲和性和反亲和性</strong></p><ul><li>控制 Pod 与其他 Pod 的共存关系</li><li>示例配置：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">"cache"</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">"kubernetes.io/hostname"</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><div class="admonition note"><p class="admonition-title">Pod 调度的决策流程</p><ul><li>(1) 调度器过滤阶段：排除不满足条件的节点 (资源不足、标签不匹配等)。</li><li>(2) 评分阶段：对剩余节点打分 (考虑资源平衡、亲和性等因素)。</li><li>(3) 绑定阶段：选择最高分节点，将绑定信息写入 API Server。</li></ul></div>]]></content>
    
    
    <summary type="html">本文主要介绍 Kubernetes 的入门使用教程。</summary>
    
    
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AI 应用（AI-Agent）开发新范式</title>
    <link href="https://www.techgrow.cn/posts/a7fade9c.html"/>
    <id>https://www.techgrow.cn/posts/a7fade9c.html</id>
    <published>2025-07-22T11:41:00.000Z</published>
    <updated>2025-07-22T11:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><div class="row"><embed src="/pdf/AI应用（AI-Agent）开发新范式.pdf" width="100%" height="1024px" isolation="isolate" type="application/pdf"></div>]]></content>
    
    
    <summary type="html">AI 应用 与 AI Agent 开发新范式。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="AI" scheme="https://www.techgrow.cn/tags/AI/"/>
    
    <category term="在线电子书" scheme="https://www.techgrow.cn/tags/%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 手写高性能网络库（Muduo）</title>
    <link href="https://www.techgrow.cn/posts/dbb10768.html"/>
    <id>https://www.techgrow.cn/posts/dbb10768.html</id>
    <published>2025-07-15T13:55:33.000Z</published>
    <updated>2025-07-15T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写高性能网络库（Muduo）</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 实现类似于 Muduo 这样的高性能网路库。</p>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 开发一款高性能网络库（Muduo）。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMake 开发随笔</title>
    <link href="https://www.techgrow.cn/posts/5e16ffff.html"/>
    <id>https://www.techgrow.cn/posts/5e16ffff.html</id>
    <published>2025-06-25T15:36:32.000Z</published>
    <updated>2025-06-25T15:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="源文件路径"><a href="#源文件路径" class="headerlink" title="源文件路径"></a>源文件路径</h2><table><thead><tr><th>变量名</th><th>含义</th><th>会因 <code>add_subdirectory()</code> 变化</th><th>会因 <code>project()</code> 变化</th><th>用途</th><th>推荐使用场景</th></tr></thead><tbody><tr><td><code>CMAKE_SOURCE_DIR</code></td><td>顶层 CMake 项目的源代码目录（CMake 最初运行的目录）</td><td>❌ 否</td><td>❌ 否</td><td>全局设置、根路径引用</td><td>获取整个 CMake 项目的根目录</td></tr><tr><td><code>PROJECT_SOURCE_DIR</code></td><td>当前 <code>project()</code> 指令所在目录</td><td>✅ 是</td><td>✅ 是</td><td>模块级路径引用（推荐）</td><td>获取当前模块（Project）目录</td></tr><tr><td><code>CMAKE_CURRENT_SOURCE_DIR</code></td><td>当前 <code>CMakeLists.txt</code> 文件所在目录</td><td>✅ 是</td><td>❌ 否</td><td>当前目录相关文件引用（强烈推荐）</td><td>获取当前 CMakeLists 所在目录</td></tr></tbody></table><span id="more"></span>]]></content>
    
    
    <summary type="html">本文主要介绍记录 CMake 日常开发中的使用技巧和踩坑经历。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发随笔" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 实现 RPC 分布式网络通信框架</title>
    <link href="https://www.techgrow.cn/posts/5e6aa28a.html"/>
    <id>https://www.techgrow.cn/posts/5e6aa28a.html</id>
    <published>2025-06-08T13:55:33.000Z</published>
    <updated>2025-06-21T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写高性能网络库（Muduo）</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 Muduo 高性能网络库 + Protobuf 开发 RPC 框架，并使用中间件 ZooKeeper。</p><span id="more"></span><h3 id="开发工具列表"><a href="#开发工具列表" class="headerlink" title="开发工具列表"></a>开发工具列表</h3><table><thead><tr><th>软件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>17</code></td><td>高版本的 Protobuf 库依赖 C++ 17</td></tr><tr><td>Boost</td><td><code>1.74.0.3</code></td><td>Muduo 库依赖 Boost 库</td></tr><tr><td> Muduo</td><td><code>2.0.3</code></td><td><a href="https://github.com/chenshuo/muduo">Muduo 库</a>，基于 C++ 开发，用于网络编程</td></tr><tr><td> Protobuf</td><td><code>31.1</code></td><td><a href="https://github.com/protocolbuffers/protobuf">Protobuf 库</a>，核心代码主要是用 C++ 开发</td></tr><tr><td> ZooKeeper C API</td><td><code>3.8.0</code></td><td>ZooKeeper 提供的原生 C API，基于 C 语言开发</td></tr><tr><td> G++（GCC）</td><td><code>12.2.0</code></td><td>建议使用 <code>9</code> 版本的 G++（GCC） 编译器</td></tr><tr><td> CMake</td><td><code>3.25.1</code></td><td>C/C++ 项目构建工具</td></tr><tr><td> ZooKeeper</td><td><code>3.8.0</code></td><td>ZooKeeper 服务器</td></tr><tr><td> Linux</td><td><code>Debian 12</code></td><td>Muduo 库不支持 Windows 平台</td></tr><tr><td> Visual Studio Code</td><td><code>1.100.2</code></td><td>使用 VSCode 远程开发特性</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">平台兼容性说明</p><p>由于使用了 Muduo 库，且 Muduo 库仅支持 Linux 平台；因此本文提供的所有 RPC 框架代码支持在 Linux 平台运行，不支持 Windows 平台，默认是基于 Debian 12 进行远程开发。</p></div><h3 id="开源-RPC-框架"><a href="#开源-RPC-框架" class="headerlink" title="开源 RPC 框架"></a>开源 RPC 框架</h3><h4 id="大厂开源框架"><a href="#大厂开源框架" class="headerlink" title="大厂开源框架"></a>大厂开源框架</h4><ul><li><a href="https://github.com/grpc/grpc">gRPC</a> 是一个由 Google 开源、基于 HTTP/2 和 Protocol Buffers 的高性能 RPC 框架，使用 C++ 开发，支持多种语言（如 Go、Java、Python 等）。</li><li><a href="https://github.com/apache/brpc">bRPC</a> 是百度开源的高性能、可扩展的 RPC 框架，主要用于服务器间通信，采用 C++ 编写，广泛应用于百度内部大规模分布式系统中。</li><li><a href="https://github.com/Tencent/phxrpc">phxrpc</a> 是腾讯微信后台团队推出的一个非常简洁小巧的 RPC 框架，编译生成的库只有 450K。</li></ul><h4 id="个人开源框架"><a href="#个人开源框架" class="headerlink" title="个人开源框架"></a>个人开源框架</h4><ul><li><a href="https://github.com/Gooddbird/tinyrpc">tinyrpc</a> - c++ async rpc framework. 14w+ qps.</li><li><a href="https://github.com/Gooddbird/rocket">rocket</a> - c++ rpc framework, simplified version of tinyrpc.</li><li><a href="https://github.com/qicosmos/rest_rpc">rest_rpc</a>  - modern c++, simple, easy to use rpc framework.</li><li><a href="https://github.com/rpclib/rpclib">rpclib</a> - a modern c++ msgpack-RPC server and client library.</li><li><a href="https://github.com/TarsCloud/TarsCpp?tab=readme-ov-file">TarsCpp</a> - c++ language framework rpc source code implementation.</li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="集群和分布式"><a href="#集群和分布式" class="headerlink" title="集群和分布式"></a>集群和分布式</h3><ul><li><p><strong>集群</strong></p><ul><li>概念<ul><li>每一台服务器独立运行一个工程的所有模块。</li></ul></li><li>优点<ul><li>部署简单：每台机器部署一样的工程，维护相对简单。</li><li>容错性强：某台机器宕机，其它机器可以顶上，保证服务连续。</li><li>扩展方便：增加机器即可横向扩展，提高并发处理能力。</li><li>负载均衡容易：前端加个负载均衡器即可实现请求均衡分发。</li></ul></li><li>缺点<ul><li>资源浪费：每台机器都部署所有模块，某些模块可能资源使用率低。</li><li>维护更新不灵活：改动一个模块需要重新部署整个工程。</li><li>扩展粒度粗：不能单独扩展某个压力大的模块（有些模块是 CPU 密集型，有些模块是 I/O 密集型），只能整体扩容。</li></ul></li></ul></li><li><p><strong>分布式</strong></p><ul><li>概念<ul><li>一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务。</li><li>每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</li></ul></li><li>优点<ul><li>资源利用率高：按模块实际资源需求进行部署，提高系统整体资源使用效率。</li><li>扩展灵活：哪个模块压力大就单独扩展它，不影响其它模块。</li><li>服务解耦：模块之间独立部署、独立维护，开发和运维更灵活。</li><li>技术异构性好：不同模块可以使用不同的技术栈，更自由地选择工具。</li></ul></li><li>缺点<ul><li>系统复杂度高：涉及服务间通信、分布式事务、网络延迟等问题。</li><li>开发运维成本高：部署、调试、监控、容错等方面的技术要求更高。</li><li>依赖网络稳定性：模块之间通过网络通信，一旦网络出问题可能会引发级联故障。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">详细图解说明</p><ul><li><a href="../../../asset/2025/01/cluster-distribute-1.png">集群和分布式的理解</a></li><li><a href="../../../asset/2024/12/dubbo-16.png">单体架构的部署拓扑图</a></li><li><a href="../../../asset/2024/12/dubbo-15.png">集群架构的部署拓扑图</a></li><li><a href="../../../asset/2024/12/dubbo-14.png">分布式架构的部署拓扑图</a></li></ul></div><div class="admonition warning"><p class="admonition-title">特别注意</p><p><strong>在企业的生产环境中，集群和分布式是并存的，两者并不是分开的。</strong></p></div><h3 id="RPC-通信原理"><a href="#RPC-通信原理" class="headerlink" title="RPC 通信原理"></a>RPC 通信原理</h3><p>RPC（Remote Procedure Call）远程过程调用的工作流程如下图所示：</p><p><img data-src="../../../asset/2025/06/cxx-rpc-1.png"></p><ul><li><strong>黄色部分</strong>：设计 RPC 方法参数的打包和解析，也就是数据的序列化和反序列化，可以使用 Protobuf 实现。</li><li><strong>绿色部分</strong>：网络通信部分，包括寻找 RPC 服务主机、发起 RPC 调用请求和响应 RPC 调用结果，可以使用 Muduo 网络库和 ZooKeeper（用于服务注册与发现）实现 。</li></ul><h3 id="网络-I-O-模型"><a href="#网络-I-O-模型" class="headerlink" title="网络 I/O 模型"></a>网络 I/O 模型</h3><p>主流的网络 I/O 模型有以下几种，Muduo 采用的是第四种（<code>reactors in threads - one loop per thread</code>）。</p><ul><li><p>(1) <code>accept + read/write</code></p><ul><li>不适用于并发服务器</li></ul></li><li><p> (2) <code>accept + fork - process-pre-connection</code></p><ul><li>适合并发连接数不大，计算任务工作量大于 Fork 的开销。</li></ul></li><li><p>(3) <code>accept + thread - thread-pre-connection</code></p><ul><li>比第二种网络 I/O 模型的开销小了一点，但是并发造成的线程堆积过多。</li></ul></li><li><p>(4) <code>reactors in threads - one loop per thread</code></p><ul><li>这是 Muduo 库的网络设计方案，底层实质上是基于 Linux 的 <code>epoll</code> + <code>pthread</code> 线程池实现，且依赖了 Boost 库，适用于并发连接数较大的场景。</li><li>有一个 Main Reactor 负载 Accept 连接，然后将连接分发给某个 SubReactor（采用轮询的方式来选择 SubReactor），该连接的所用操作都在那个 SubReactor 所处的线程中完成。多个连接可能被分派到多个线程中被处理，以充分利用 CPU。</li><li>有一个 Base I/O Thread 负责 Accept 新的连接，接收到新的连接以后，使用轮询的方式在 Reactor Pool 中找到合适的 SubReactor 将这个连接挂载上去，这个连接上的所有任务都在这个 SubReactor  所处的线程中完成。</li><li>Reactor Poll 的大小是固定的，根据 CPU 的核心数量来确定。如果有过多的耗费 CPU 资源的计算任务，可以提交到 ThreadPool 线程池中专门处理耗时的计算任务。</li></ul></li><li><p>(5) <code>reactors in process - one loop pre process</code></p><ul><li>这是 Nginx 服务器的网络设计方案，基于进程设计，采用多个 Reactors 充当 I/O 进程和工作进程，通过一个 <code>accept</code> 锁，完美解决多个 Reactors 之间的 “惊群现象”。</li></ul></li></ul><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p>本文基于 C++ 实现 RPC 框架时，使用到以下框架，主要包括 Muduo、Protobuf、ZooKeeper C API。</p><h3 id="Muduo-的简介"><a href="#Muduo-的简介" class="headerlink" title="Muduo 的简介"></a>Muduo 的简介</h3><p>Muduo 是一个用 C++ 编写的高性能、基于事件驱动的网络库，专门设计用于构建 Linux 下高并发、低延迟的网络服务，特别适合开发分布式系统、微服务、消息中间件、网络游戏服务器等后端程序。</p><ul><li><p>核心特性</p><ul><li>基于事件驱动模型：使用 Reactor 模式，即单线程 I/O + 多线程计算。</li><li>高性能：使用 <code>epoll</code> I/O 多路复用技术、非阻塞 I/O、零内存拷贝技术。</li><li>线程安全：网络部分是线程安全的，使用线程池和回调。</li><li>C++ 11 标准：需要使用支持 C++ 11 的编译器。</li><li>仅支持 Linux 平台：利用 Linux 特性优化性能，不支持跨平台。</li><li>可组合性强：解耦的模块设计，便于扩展和组合。</li></ul></li><li><p>核心模块</p><ul><li><code>base</code>（基础模块）<ul><li>非网络相关的通用工具</li><li>如线程池、时间戳、日志系统、原子操作等</li></ul></li><li><code>net</code>（网络模块）<ul><li>TCP 服务器 / 客户端模型</li><li> Reactor 事件分发器</li><li> Buffer、Channel、EventLoop、TcpConnection 等核心组件</li></ul></li></ul></li><li><p>核心组件</p><ul><li>EventLoop<ul><li> 事件循环，是每个线程的核心对象</li><li>封装了 <code>epoll</code> 库，处理文件描述符的读写事件</li></ul></li><li> Channel<ul><li> 表示一个 <code>fd</code>（文件描述符）及其感兴趣的事件（如读写）</li><li>是 EventLoop 与具体 I/O 事件之间的桥梁</li></ul></li><li> Poller<ul><li> 封装 <code>epoll</code> 或 <code>poll</code> 的接口（Muduo 默认用 <code>epoll</code>）</li></ul></li><li>TcpServer / TcpClient<ul><li> 高层封装，简化服务端和客户端的使用</li><li>支持多线程连接处理</li></ul></li><li> Callback 机制<ul><li>所有 I/O 事件都通过用户注册的回调函数处理（高扩展性）</li></ul></li></ul></li><li><p>性能优势</p><ul><li>完全采用非阻塞、异步 I/O 模型</li><li>使用智能指针管理资源（如 <code>std::shared_ptr&lt;TcpConnection&gt;</code>）</li><li>零内存拷贝的数据缓冲机制（Buffer）</li><li>合理利用多线程资源（EventLoopThreadPool）</li></ul></li><li><p>适用场景</p><ul><li>高并发 TCP 服务器（如 Redis、MQTT、游戏网关）</li><li>微服务通信框架（可自定义通信协议）</li><li>高性能 HTTP 服务（支持 HTTP 1.0/1.1）</li><li>自研 RPC 系统</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">平台兼容性</p><ul><li>Muduo 库只支持 Linux 平台，不兼容 Windows 平台，因为其底层使用了 Linux 平台的 <code>pthread</code> 和 <code>epoll</code>。</li></ul></div><h3 id="Protobuf-的简介"><a href="#Protobuf-的简介" class="headerlink" title="Protobuf 的简介"></a>Protobuf 的简介</h3><ul><li><p>Protocol Buffers（简称 Protobuf）是 Google 提出的一种高效、可扩展的结构化数据序列化格式，用于数据交换。它独立于平台和编程语言，具有良好的跨平台兼容性和扩展性。</p></li><li><p>Google 为多种主流编程语言提供了 Protobuf 的官方实现，包括 Java、C#、C++、Go 和 Python 等。每种语言的实现都包含相应的编译器插件（<code>protoc</code>）和运行时库，使得开发者可以在不同语言间无缝进行数据通信。</p></li><li><p>由于 Protobuf 采用紧凑的二进制编码格式，其序列化和反序列化效率远高于基于文本的格式。相比 XML，Protobuf 的传输效率可提高约 20 倍；相比 JSON，也有近 10 倍的性能提升。这使得它特别适用于对性能要求高的场景。</p></li><li><p>Protobuf 广泛应用于分布式系统间的数据通信、异构平台的数据交换，也适合用作网络传输协议的数据格式、高效配置文件的载体、或用于数据持久化存储。作为一种兼具效率与可维护性的序列化方案，Protobuf 在大规模系统设计中具有极高的实用价值。</p></li></ul><h3 id="ZooKeeper-C-API-的简介"><a href="#ZooKeeper-C-API-的简介" class="headerlink" title="ZooKeeper C API 的简介"></a>ZooKeeper C API 的简介</h3><p>ZooKeeper C API 是 ZooKeeper 提供的一套原生 C 语言接口，它提供两个版本，包括 <code>libzookeeper_mt</code>（多线程版）和 <code>libzookeeper_st</code>（单线程版），可以用于 C/C++ 编写客户端程序，通常使用的是 <code>libzookeeper_mt</code>（多线程版）。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-Boost-库"><a href="#安装-Boost-库" class="headerlink" title="安装 Boost 库"></a>安装 Boost 库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Boost 的所有组件和头文件</span></span><br><span class="line">sudo apt-get install -y libboost-all-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Bootst 版本</span></span><br><span class="line">sudo dpkg -s libboost-all-dev | grep Version</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>由于 Muduo 使用了 Boost 库（如 <code>boost::any</code>），因此需要安装 Boost 库。</p></div><h3 id="安裝-Muduo-库"><a href="#安裝-Muduo-库" class="headerlink" title="安裝 Muduo 库"></a>安裝 Muduo 库</h3><ul><li>编译安装 Muduo 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chenshuo/muduo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入代码目录</span></span><br><span class="line"><span class="built_in">cd</span> muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Muduo 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Muduo 库的静态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep muduo</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Muduo 的编译依赖 CMake 和 Boost 库，默认编译生成的是静态库（<code>.a</code>），如果需要编译生成共享库（<code>.so</code>），可以自行修改 <code>CMakeLists.txt</code> 中的配置。</li><li>Muduo 支持 C++ 11，仅支持 Linux 平台，不支持 Windows 平台，建议使用 <code>7.x</code> 及以后版本的 <code>g++</code> 编译器。</li></ul></div><h3 id="安装-Protobuf-库"><a href="#安装-Protobuf-库" class="headerlink" title="安装 Protobuf 库"></a>安装 Protobuf 库</h3><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Protobuf 各个版本的源码包可以从 <a href="https://github.com/protocolbuffers/protobuf/releases">GitHub Release</a> 下载得到。</li><li>Protobuf 从 <code>3.21</code> 版本开始，Google 官方已经弃用了 <code>autogen.sh</code> 和 <code>configure</code> 构建系统，转而使用 CMake 作为主要构建系统。</li><li>Protobuf 从源码编译后，默认只会生成 <code>.a</code> 静态库文件，若希望生成 <code>.so</code> 动态库文件，需要在编译时添加 CMake 参数 <code>-DBUILD_SHARED_LIBS=ON</code>，加上参数后只会生成 <code>.so</code> 动态库文件。</li></ul></div><ul><li>安装依赖包 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install cmake g++ make git wget</span><br></pre></td></tr></tbody></table></figure><ul><li>编译安装 Protobuf 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://github.com/protocolbuffers/protobuf/archive/refs/tags/v31.1.tar.gz -O protobuf-v31.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf protobuf-v31.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cd</span> protobuf-31.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化子模块</span></span><br><span class="line">git init &amp;&amp; git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件（Makefile）</span></span><br><span class="line">cmake .. -DBUILD_SHARED_LIBS=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码（耗时较长）</span></span><br><span class="line">make -j2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装（包括可执行文件、头文件和库）</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 Protobuf 库安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Protobuf 库的版本</span></span><br><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Protobuf 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/google/protobuf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Protobuf 库的动态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib/libproto*</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-ZooKeeper-中间件"><a href="#安装-ZooKeeper-中间件" class="headerlink" title="安装 ZooKeeper 中间件"></a>安装 ZooKeeper 中间件</h3><h4 id="安装-ZooKeeper-服务器"><a href="#安装-ZooKeeper-服务器" class="headerlink" title="安装 ZooKeeper 服务器"></a>安装 ZooKeeper 服务器</h4><ul><li>安装 ZooKeeper 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ZooKeeper 客户端和服务器</span></span><br><span class="line">sudo apt install -y zookeeper zookeeperd</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 ZooKeeper 客户端的软链接 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 客户端的安装位置</span></span><br><span class="line">sudo dpkg -L zookeeper | grep -E <span class="string">'zkCli.sh|zkEnv.sh'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 ZooKeeper 客户端的软链接（方便以后直接运行客户端）</span></span><br><span class="line">sudo ln -s /usr/share/zookeeper/bin/zkCli.sh /usr/<span class="built_in">local</span>/bin/zkCli.sh</span><br><span class="line">sudo ln -s /usr/share/zookeeper/bin/zkEnv.sh /usr/<span class="built_in">local</span>/bin/zkEnv.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 ZooKeeper 服务器安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 服务器的运行状态</span></span><br><span class="line">sudo systemctl status zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 ZooKeeper 客户端连接 ZooKeeper 服务器</span></span><br><span class="line">zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></tbody></table></figure><ul><li>ZooKeeper 服务器的安装信息</li></ul><table><thead><tr><th>安装信息</th><th>说明</th></tr></thead><tbody><tr><td>默认的监听端口</td><td><code>2181</code></td></tr><tr><td>默认的数据目录</td><td><code>/tmp/zookeeper</code></td></tr><tr><td>默认配置文件的路径</td><td><code>/etc/zookeeper/conf/zoo.cfg</code></td></tr></tbody></table><h4 id="安装-ZooKeeper-C-API-库"><a href="#安装-ZooKeeper-C-API-库" class="headerlink" title="安装 ZooKeeper C API 库"></a>安装 ZooKeeper C API 库</h4><p>由于本文的 RPC 项目使用 ZooKeeper C API 库来实现 RPC 服务动态注册和发现，因此需要安装 ZooKeeper C API 库。值得一提的是，ZooKeeper 提供了一个 <code>libzookeeper_mt</code>（多线程版）或 <code>libzookeeper_st</code>（单线程版）原生 C API，可以用于 C/C++ 编写客户端程序，通常使用的是 <code>libzookeeper_mt</code>（多线程版）。在 Linux 系统上，除了可以通过 APT / YUM 包管理工具直接安装 ZooKeeper C API 库，还可以手动编译 ZooKeeper 的源码来安装 ZooKeeper C API 库，具体编译步骤为 <code>.configure</code> + <code>make</code> + <code>makeinstall</code>，默认会编译生成多线程版本的库（<code>libzookeeper_mt.so</code>）和单线程版的库（如 <code>libzookeeper_st.so</code>）。</p><ul><li>安装 ZooKeeper C API 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ZooKeeper 多线程版的开发包（单线程版本是：libzookeeper-st-dev）</span></span><br><span class="line">sudo apt install -y libzookeeper-mt-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 ZooKeeper C API 库安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 的头文件</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep zookeeper.h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 的静态库</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep <span class="string">'\.a$'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 的动态库</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep <span class="string">'\.so'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>ZooKeeper C API 库的安装信息</li></ul><table><thead><tr><th>安装信息</th><th>说明</th></tr></thead><tbody><tr><td>头文件的路径</td><td><code>/usr/include/zookeeper/zookeeper.h</code></td></tr><tr><td>静态库的路径</td><td><code>/usr/lib/x86_64-linux-gnu/libzookeeper_mt.a</code></td></tr><tr><td>动态库的路径</td><td><code>/usr/lib/x86_64-linux-gnu/libzookeeper_mt.so</code></td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">使用原生 ZooKeeper C API 库的注意事项</p><ul><li>(1) 设置监听 Watcher 是一次性的，监听事件触发后 Watch 会立即失效，ZooKeeper 不会自动重新注册。若希望持续监听同一个节点变化，需要在回调中手动再次注册 Watch。</li><li>(2) ZNode 节点仅支持存储简单的 <code>byte</code> 字节数组（最大 1MB），不具备结构化存储能力。如果需要存储结构体或对象，需要自行将其转换为字节数组，例如使用 JSON、Protobuf 等序列化方式进行编码与解码。</li></ul></div><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">c++-project-mprpc</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── conf</span><br><span class="line">│   └── rpc.conf</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── consumer</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── rpcconsumer.cc</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   ├── friend.pb.cc</span><br><span class="line">│   │   ├── friend.pb.h</span><br><span class="line">│   │   ├── user.pb.cc</span><br><span class="line">│   │   └── user.pb.h</span><br><span class="line">│   ├── proto</span><br><span class="line">│   │   ├── friend.proto</span><br><span class="line">│   │   └── user.proto</span><br><span class="line">│   └── provider</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">│       └── rpcprovider.cc</span><br><span class="line">├── lib</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   ├── rpcheader.pb.cc</span><br><span class="line">│   │   └── rpcheader.pb.h</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   ├── lockqueue.h</span><br><span class="line">│   │   ├── logger.h</span><br><span class="line">│   │   ├── mprpccontext.h</span><br><span class="line">│   │   ├── mprpcchannel.h</span><br><span class="line">│   │   ├── mprpcconfig.h</span><br><span class="line">│   │   ├── mprpccontroller.h</span><br><span class="line">│   │   ├── mprpcprovider.h</span><br><span class="line">│   │   ├── networkutil.h</span><br><span class="line">│   │   └── zookeeperclient.h</span><br><span class="line">│   ├── logger.cc</span><br><span class="line">│   ├── mprpccontext.cc</span><br><span class="line">│   ├── mprpcchannel.cc</span><br><span class="line">│   ├── mprpcconfig.cc</span><br><span class="line">│   ├── mprpccontroller.cc</span><br><span class="line">│   ├── mprpcprovider.cc</span><br><span class="line">│   ├── networkutil.cc</span><br><span class="line">│   ├── proto</span><br><span class="line">│   │   └── rpcheader.proto</span><br><span class="line">│   └── zookeeperclient.cc</span><br><span class="line">└── test</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── protobuf</span><br><span class="line">    │   ├── CMakeLists.txt</span><br><span class="line">    │   ├── generated</span><br><span class="line">    │   │   ├── addressbook.pb.cc</span><br><span class="line">    │   │   ├── addressbook.pb.h</span><br><span class="line">    │   │   ├── friendservice.pb.cc</span><br><span class="line">    │   │   ├── friendservice.pb.h</span><br><span class="line">    │   │   ├── groupservice.pb.cc</span><br><span class="line">    │   │   ├── groupservice.pb.h</span><br><span class="line">    │   │   ├── userservice.pb.cc</span><br><span class="line">    │   │   └── userservice.pb.h</span><br><span class="line">    │   ├── main.cc</span><br><span class="line">    │   └── proto</span><br><span class="line">    │       ├── addressbook.proto</span><br><span class="line">    │       ├── friendservice.proto</span><br><span class="line">    │       ├── groupservice.proto</span><br><span class="line">    │       └── userservice.proto</span><br><span class="line">    └── zookeeper</span><br><span class="line">        ├── CMakeLists.txt</span><br><span class="line">        └── main.cc</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>目录名称</th><th>目录说明</th></tr></thead><tbody><tr><td><code>build</code></td><td>CMake 编译构建项目的目录（项目首次编译后才会有）</td></tr><tr><td><code>bin</code></td><td>存放项目编译生成的可执行文件的目录（项目首次编译后才会有）</td></tr><tr><td><code>lib</code></td><td>存放项目编译生成的 RPC 框架头文件和静态库的目录（项目首次编译后才会有）</td></tr><tr><td><code>conf</code></td><td>存放 RPC 框架的配置文件</td></tr><tr><td><code>proto</code></td><td>存放 Protobuf 的 <code>.proto</code> 协议文件</td></tr><tr><td><code>generated</code></td><td>存放根据 <code>.proto</code> 协议文件生成的 C++ 头文件和源文件</td></tr><tr><td><code>src</code></td><td>RPC 框架源码</td></tr><tr><td><code>test</code></td><td>第三方库的测试代码</td></tr><tr><td><code>test/protobuf/</code></td><td>Protobuf 的测试代码</td></tr><tr><td><code>test/zookeeper/</code></td><td>ZooKeeper 的测试代码</td></tr><tr><td><code>example</code></td><td>RPC 框架的使用案例代码</td></tr><tr><td><code>example/provider</code></td><td>RPC 框架（服务提供者）的使用案例代码</td></tr><tr><td><code>example/consumer</code></td><td>RPC 框架（服务调用者）的使用案例代码</td></tr><tr><td><code>autobuild.sh</code></td><td>项目一键编译构建的脚本文件</td></tr></tbody></table><h3 id="项目原理"><a href="#项目原理" class="headerlink" title="项目原理"></a>项目原理</h3><p><img data-src="../../../asset/2025/06/cxx-rpc-2.png"></p><h3 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h3><p>基于 C++ 开发 RPC 框架时，使用到以下技术：</p><ul><li>单例模式</li><li> Conf 配置文件读取</li><li> Muduo 网络库编程</li><li> CMake 构建项目集成编译环境</li><li>异步日志记录（线程同步通信实现）</li><li>Protobuf 数据序列化和反序列化协议</li><li> ZooKeeper 分布式一致性协调服务应用以及编程</li></ul><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><h3 id="RPC-框架核心代码"><a href="#RPC-框架核心代码" class="headerlink" title="RPC 框架核心代码"></a>RPC 框架核心代码</h3><p>由于篇幅有限，下面只给出 RPC 框架项目的核心代码，完整的项目代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-mprpc">这里</a> 获取得到。</p><h4 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h4><ul><li><code>networkutil.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ifaddrs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络工具类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkUtil</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkUtil&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地的 IP 地址，可指定网络接口名称（比如 eth0）</span></span><br><span class="line">    <span class="function">std::string <span class="title">FindLocalIp</span><span class="params">(<span class="keyword">const</span> std::string&amp; network_interface = <span class="string">""</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个未被占用的端口，可指定端口区间（比如 [7000, 9000]）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindAvailablePort</span><span class="params">(<span class="keyword">int</span> low = <span class="number">7000</span>, <span class="keyword">int</span> high = <span class="number">9000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">NetworkUtil</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">NetworkUtil</span>(<span class="keyword">const</span> NetworkUtil&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    NetworkUtil&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NetworkUtil&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>networkutil.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"networkutil.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">NetworkUtil&amp; <span class="title">NetworkUtil::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> NetworkUtil instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本地的 IP 地址，可指定网络接口名称（比如 eth0）</span></span><br><span class="line"><span class="function">std::string <span class="title">NetworkUtil::FindLocalIp</span><span class="params">(<span class="keyword">const</span> std::string&amp; network_interface)</span> </span>{</span><br><span class="line">    std::string result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地网络接口的信息链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span>* <span class="title">ifaddr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getifaddrs</span>(&amp;ifaddr) == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// Fallback 处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历本地网络接口的信息链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* ifa = ifaddr; ifa; ifa = ifa-&gt;ifa_next) {</span><br><span class="line">        <span class="keyword">if</span> (!ifa-&gt;ifa_addr || ifa-&gt;ifa_addr-&gt;sa_family != AF_INET) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取网络接口的名称</span></span><br><span class="line">        <span class="function">std::string <span class="title">name</span><span class="params">(ifa-&gt;ifa_name)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过 lo 接口（回环接口）</span></span><br><span class="line">        <span class="keyword">if</span> (ifa-&gt;ifa_flags &amp; IFF_LOOPBACK) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指定了网络接口（如 eth0），且匹配上了，就直接使用</span></span><br><span class="line">        <span class="keyword">if</span> (!network_interface.<span class="built_in">empty</span>() &amp;&amp; name == network_interface) {</span><br><span class="line">            <span class="keyword">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;((struct sockaddr_in*)ifa-&gt;ifa_addr)-&gt;sin_addr, ip, <span class="built_in"><span class="keyword">sizeof</span></span>(ip));</span><br><span class="line">            result = ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认选择 eth0、ens33、enp0s3 等常见有线网卡</span></span><br><span class="line">        <span class="keyword">if</span> (network_interface.<span class="built_in">empty</span>() &amp;&amp; (name.<span class="built_in">find</span>(<span class="string">"eth"</span>) == <span class="number">0</span> || name.<span class="built_in">find</span>(<span class="string">"en"</span>) == <span class="number">0</span>)) {</span><br><span class="line">            <span class="keyword">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;((struct sockaddr_in*)ifa-&gt;ifa_addr)-&gt;sin_addr, ip, <span class="built_in"><span class="keyword">sizeof</span></span>(ip));</span><br><span class="line">            result = ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">freeifaddrs</span>(ifaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">empty</span>() ? <span class="string">"127.0.0.1"</span> : result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个未被占用的端口，可指定端口区间（比如 [7000, 9000]）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NetworkUtil::FindAvailablePort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历指定区间内的所有端口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> port = low; port &lt;= high; ++port) {</span><br><span class="line">        <span class="comment">// 创建一个 IPv4 TCP Socket</span></span><br><span class="line">        <span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 创建 Socket 失败，尝试下一个端口</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 Socket 地址，绑定到任意本地地址（0.0.0.0）和当前端口</span></span><br><span class="line">        sockaddr_in addr{};</span><br><span class="line">        addr.sin_family = AF_INET;</span><br><span class="line">        addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Socket 选项：SO_REUSEADDR 允许端口重复绑定（避免 TIME_WAIT 问题）</span></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in"><span class="keyword">sizeof</span></span>(opt));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试将 Socket 绑定到指定端口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (sockaddr*)&amp;addr, <span class="built_in"><span class="keyword">sizeof</span></span>(addr)) == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 绑定成功，释放资源（因为这里只是探测端口是否可用）</span></span><br><span class="line">            <span class="built_in">close</span>(sockfd);</span><br><span class="line">            <span class="comment">// 返回找到的可用端口</span></span><br><span class="line">            <span class="keyword">return</span> port;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 端口绑定失败，说明端口已被占用或其他错误，释放资源</span></span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历完指定的端口区间，没有找到可用端口，返回 -1 表示失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="异步日志记录"><a href="#异步日志记录" class="headerlink" title="异步日志记录"></a>异步日志记录</h4><ul><li><code>lockqueue.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步写日志的日志队列（线程安全）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 往队尾插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入数据</span></span><br><span class="line">        m_queue.<span class="built_in">push</span>(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒日志写入线程去消费队列中的数据</span></span><br><span class="line">        m_condvariable.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往队头弹出数据</span></span><br><span class="line">    <span class="function">T <span class="title">Pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到队列不为空或者已退出</span></span><br><span class="line">        m_condvariable.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>() || m_exit; });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视业务逻辑而定，可以返回空数据或者抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (m_exit &amp;&amp; m_queue.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">return</span> {};</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取队头元素</span></span><br><span class="line">        T data = m_queue.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出队头元素</span></span><br><span class="line">        m_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭队列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 设置退出标志</span></span><br><span class="line">        m_exit = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 唤醒正在等待的日志写入线程</span></span><br><span class="line">        m_condvariable.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取退出标志</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isExit</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> m_exit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex m_mutex;                      <span class="comment">// 互斥锁</span></span><br><span class="line">    std::queue&lt;T&gt; m_queue;                   <span class="comment">// 队列</span></span><br><span class="line">    std::condition_variable m_condvariable;  <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="keyword">bool</span> m_exit = <span class="literal">false</span>;                     <span class="comment">// 退出标志，用于避免发生线程死锁</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>logger.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lockqueue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG(logmsgformat, ...)                                \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= DEBUG) {                        \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {DEBUG, c, thread_id};                 \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO(logmsgformat, ...)                                 \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= INFO) {                         \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {INFO, c, thread_id};                  \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_WARN(logmsgformat, ...)                                 \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= WARN) {                         \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {WARN, c, thread_id};                  \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERROR(logmsgformat, ...)                                \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= ERROR) {                        \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {ERROR, c, thread_id};                 \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别（DEBUG &lt; INFO &lt; WARN &lt; ERROR）</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LogLevel</span> {</span></span><br><span class="line">    DEBUG,  <span class="comment">// 调试日志信息</span></span><br><span class="line">    INFO,   <span class="comment">// 普通日志信息</span></span><br><span class="line">    WARN,   <span class="comment">// 警告日志信息</span></span><br><span class="line">    ERROR,  <span class="comment">// 错误日志信息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LogMessage</span> {</span></span><br><span class="line">    LogLevel m_loglevel;         <span class="comment">// 日志级别</span></span><br><span class="line">    std::string m_logcontent;    <span class="comment">// 日志内容</span></span><br><span class="line">    std::thread::id m_threadid;  <span class="comment">// 打印日志的线程的 ID</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mprpc 框架提供的日志系统（单例对象，异步写入日志文件）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Logger&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入日志信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Log</span><span class="params">(<span class="keyword">const</span> LogMessage&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取日志级别</span></span><br><span class="line">    <span class="function">LogLevel <span class="title">GetLogLevel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetLogLevel</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LogLevel m_loglevel;             <span class="comment">// 记录日志级别</span></span><br><span class="line">    std::thread m_writeThread;       <span class="comment">// 日志写入线程</span></span><br><span class="line">    LockQueue&lt;LogMessage&gt; m_lckQue;  <span class="comment">// 日志缓冲队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="keyword">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算操作符</span></span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取日志级别的名称</span></span><br><span class="line">    <span class="function">std::string <span class="title">LogLevelToString</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>logger.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Logger::<span class="built_in">Logger</span>() {</span><br><span class="line">    <span class="comment">// 设置默认的日志级别</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_loglevel = INFO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动专门写日志文件的线程</span></span><br><span class="line">    m_writeThread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 获取当前日期</span></span><br><span class="line">            <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            tm* now_tm = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取日志文件的名称</span></span><br><span class="line">            <span class="keyword">char</span> file_name[<span class="number">128</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(file_name, <span class="string">"%d-%d-%d-log.txt"</span>, now_tm-&gt;tm_year + <span class="number">1900</span>, now_tm-&gt;tm_mon + <span class="number">1</span>, now_tm-&gt;tm_mday);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开日志文件</span></span><br><span class="line">            FILE* pf = <span class="built_in">fopen</span>(file_name, <span class="string">"a+"</span>);</span><br><span class="line">            <span class="keyword">if</span> (pf == <span class="literal">nullptr</span>) {</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"logger file "</span> &lt;&lt; file_name &lt;&lt; <span class="string">" open failed!"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从日志缓冲队列获取日志信息（会阻塞当前线程，直到日志队列不为空）</span></span><br><span class="line">            LogMessage message = m_lckQue.<span class="built_in">Pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查退出标志</span></span><br><span class="line">            <span class="keyword">if</span> (m_lckQue.<span class="built_in">isExit</span>()) {</span><br><span class="line">                <span class="comment">// 关闭日志文件</span></span><br><span class="line">                <span class="built_in">fclose</span>(pf);</span><br><span class="line">                <span class="comment">// 跳出外层 For 循环，结束日志写入线程的运行（会丢失未被写入的日志信息）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取打印日志信息的线程的 ID（可能为负数）</span></span><br><span class="line">            std::thread::id real_thread_id = message.m_threadid;</span><br><span class="line">            std::ostringstream oss;</span><br><span class="line">            oss &lt;&lt; real_thread_id;</span><br><span class="line">            std::string log_thread_id = oss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取日志内容和日志级别的名称</span></span><br><span class="line">            std::string&amp; log_content = message.m_logcontent;</span><br><span class="line">            std::string log_level_name = <span class="built_in">LogLevelToString</span>(message.m_loglevel);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前时间</span></span><br><span class="line">            <span class="keyword">char</span> time_buf[<span class="number">128</span>] = {<span class="number">0</span>};</span><br><span class="line">            <span class="built_in">sprintf</span>(time_buf, <span class="string">"%d-%d-%d %d:%d:%d =&gt; %d [%s] "</span>, now_tm-&gt;tm_year + <span class="number">1900</span>, now_tm-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                    now_tm-&gt;tm_mday, now_tm-&gt;tm_hour, now_tm-&gt;tm_min, now_tm-&gt;tm_sec, log_thread_id.<span class="built_in">c_str</span>(),</span><br><span class="line">                    log_level_name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加当前时间到日志内容的最前面</span></span><br><span class="line">            log_content.<span class="built_in">insert</span>(<span class="number">0</span>, time_buf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加换行符到日志内容的最后面</span></span><br><span class="line">            log_content.<span class="built_in">append</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志内容到控制台</span></span><br><span class="line">            std::cout &lt;&lt; log_content;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将日志内容写入日志文件</span></span><br><span class="line">            <span class="built_in">fputs</span>(log_content.<span class="built_in">c_str</span>(), pf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭日志文件</span></span><br><span class="line">            <span class="built_in">fclose</span>(pf);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Logger::~<span class="built_in">Logger</span>() {</span><br><span class="line">    <span class="comment">// 关闭队列，通知日志写入线程停止运行，避免发生线程死锁</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_lckQue.<span class="built_in">Stop</span>();</span><br><span class="line">    <span class="comment">// 等待日志线程安全退出</span></span><br><span class="line">    <span class="keyword">if</span> (m_writeThread.<span class="built_in">joinable</span>()) {</span><br><span class="line">        m_writeThread.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入日志信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::Log</span><span class="params">(<span class="keyword">const</span> LogMessage&amp; message)</span> </span>{</span><br><span class="line">    <span class="comment">// 将日志信息写入缓冲队列中</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_lckQue.<span class="built_in">Push</span>(message);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::SetLogLevel</span><span class="params">(LogLevel level)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_loglevel = level;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别</span></span><br><span class="line"><span class="function">LogLevel <span class="title">Logger::GetLogLevel</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_loglevel;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别的名称</span></span><br><span class="line"><span class="function">std::string <span class="title">Logger::LogLevelToString</span><span class="params">(LogLevel level)</span> </span>{</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (level) {</span><br><span class="line">        <span class="keyword">case</span> DEBUG:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DEBUG"</span>;</span><br><span class="line">        <span class="keyword">case</span> INFO:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"INFO"</span>;</span><br><span class="line">        <span class="keyword">case</span> WARN:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"WARN"</span>;</span><br><span class="line">        <span class="keyword">case</span> ERROR:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"UNKNOWN"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h4><ul><li><code>rpc.conf</code> 配置文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ZooKeeper的IP地址（必填）</span><br><span class="line">zk_server_host=127.0.0.1</span><br><span class="line"># ZooKeeper的端口号（必填）</span><br><span class="line">zk_server_port=2181</span><br><span class="line"># RPC服务提供者优先使用的网卡接口（可选）</span><br><span class="line">rpc_network_interface=eth1</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcconfig.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string ZK_SERVER_HOST_KEY = <span class="string">"zk_server_host"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string ZK_SERVER_PORT_KEY = <span class="string">"zk_server_port"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string RPC_NETWORK_INTERFACE_KEY = <span class="string">"rpc_network_interface"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 框架读取配置文件的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcConfig</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* config_file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">Load</span><span class="params">(<span class="keyword">const</span> std::string&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置信息（无需考虑线程安全问题）</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Trim</span><span class="params">(std::string&amp; str)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcconfig.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcconfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcConfig::LoadConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* config_file)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断是否已经加载过配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (!m_configMap.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开配置文件</span></span><br><span class="line">    FILE* pf = <span class="built_in">fopen</span>(config_file, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == pf) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"config file "</span> &lt;&lt; config_file &lt;&lt; <span class="string">" is not exist!"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析配置文件</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), pf)) {</span><br><span class="line">        <span class="function">std::string <span class="title">src_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line">        <span class="built_in">Trim</span>(src_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断注释内容</span></span><br><span class="line">        <span class="keyword">if</span> (src_buf.<span class="built_in">empty</span>() || src_buf[<span class="number">0</span>] == <span class="string">'#'</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        <span class="keyword">int</span> idx = src_buf.<span class="built_in">find_first_of</span>(<span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">-1</span>) {</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置项的 Key</span></span><br><span class="line">        std::string key = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置项的 Value</span></span><br><span class="line">        std::string value = src_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查配置项的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (key.<span class="built_in">empty</span>() || value.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储配置项</span></span><br><span class="line">        m_configMap.<span class="built_in">insert</span>({key, value});</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s=%s"</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(pf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::Load</span><span class="params">(<span class="keyword">const</span> std::string&amp; key)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">return</span> it != m_configMap.<span class="built_in">end</span>() ? it-&gt;second : <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcConfig::Trim</span><span class="params">(std::string&amp; str)</span> </span>{</span><br><span class="line">    <span class="comment">// 定义空白字符</span></span><br><span class="line">    <span class="keyword">const</span> std::string whitespace = <span class="string">" \n\r\t"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除字符串前面多余的空白字符</span></span><br><span class="line">    <span class="keyword">size_t</span> start = str.<span class="built_in">find_first_not_of</span>(whitespace);</span><br><span class="line">    <span class="keyword">if</span> (start != std::string::npos) {</span><br><span class="line">        str = str.<span class="built_in">substr</span>(start);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 字符串全是空白字符</span></span><br><span class="line">        str.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除字符串后面多余的空白字符</span></span><br><span class="line">    <span class="keyword">size_t</span> end = str.<span class="built_in">find_last_not_of</span>(whitespace);</span><br><span class="line">    <span class="keyword">if</span> (end != std::string::npos) {</span><br><span class="line">        str = str.<span class="built_in">substr</span>(<span class="number">0</span>, end + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Protobuf-协议文件"><a href="#Protobuf-协议文件" class="headerlink" title="Protobuf 协议文件"></a>Protobuf 协议文件</h4><ul><li><code>rpcheader.proto</code> 协议文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package mprpc;</span><br><span class="line"></span><br><span class="line">message RpcHeader {</span><br><span class="line">    // RPC 调用的服务名称</span><br><span class="line">    bytes service_name = 1;</span><br><span class="line"></span><br><span class="line">    // RPC 调用的方法名称</span><br><span class="line">    bytes method_name = 2;</span><br><span class="line"></span><br><span class="line">    // RPC 调用的参数长度（参数的序列化字符串的长度）</span><br><span class="line">    uint32 args_size = 3;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的初始化"><a href="#RPC-框架的初始化" class="headerlink" title="RPC 框架的初始化"></a>RPC 框架的初始化</h4><ul><li><code>mprpccontext.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcchannel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcconfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeper 节点的路径前缀</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> std::string ZNODE_PATH_PREFIX = <span class="string">"/mprpc/services"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MPRPC 框架的上下文类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcContext</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MprpcContext&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 RPC 框架</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MprpcConfig&amp; <span class="title">GetConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置信息</span></span><br><span class="line">    <span class="keyword">static</span> MprpcConfig m_config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">MprpcContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">MprpcContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MprpcContext</span>(<span class="keyword">const</span> MprpcContext&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    MprpcContext&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MprpcContext&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpccontext.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员变量</span></span><br><span class="line">MprpcConfig MprpcContext::m_config;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">MprpcContext::<span class="built_in">MprpcContext</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MprpcContext::~<span class="built_in">MprpcContext</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">MprpcContext&amp; <span class="title">MprpcContext::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> MprpcContext singleton;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印命令帮助内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowArgsHelp</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"format: command -i &lt;configfile&gt;"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 RPC 框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcContext::Init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">        <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">        <span class="comment">// 退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令行获取配置文件的路径</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">"i:"</span>)) != <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (c) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"invalid command args!"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">                <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">':'</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"need &lt;configfile&gt;"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">                <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"loading rpc config file %s"</span>, config_file.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置文件内容</span></span><br><span class="line">    m_config.<span class="built_in">LoadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置信息</span></span><br><span class="line"><span class="function">MprpcConfig&amp; <span class="title">MprpcContext::GetConfig</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_config;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的服务注册"><a href="#RPC-框架的服务注册" class="headerlink" title="RPC 框架的服务注册"></a>RPC 框架的服务注册</h4><ul><li><code>mprpcprovider.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"google/protobuf/service.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 框架专门提供用来发布 RPC 服务的网络对象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RpcProvider</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PublishService</span><span class="params">(google::protobuf::Service* service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// TCP 服务器的事件回环</span></span><br><span class="line">    muduo::net::EventLoop m_eventloop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 服务信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ServiceInfo</span> {</span></span><br><span class="line">        <span class="comment">// RPC 服务</span></span><br><span class="line">        google::protobuf::Service* m_service;</span><br><span class="line">        <span class="comment">// RPC 服务拥有的方法</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="keyword">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储注册成功的 RPC 服务的集合</span></span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 TCP 连接的创建和断开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理已建立 TCP 连接的读写事件（比如接收客户端发送的数据）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于序列化 RPC 调用的响应结果和发送网络响应数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcprovider.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcprovider.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"networkutil.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpcheader.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布 RPC 服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::PublishService</span><span class="params">(google::protobuf::Service* service)</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 服务的信息</span></span><br><span class="line">    ServiceInfo servcieInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的描述信息</span></span><br><span class="line">    <span class="keyword">const</span> google::protobuf::ServiceDescriptor* pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的完整名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">serviceName</span><span class="params">(pserviceDesc-&gt;full_name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的方法数量</span></span><br><span class="line">    <span class="keyword">int</span> methodCount = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 RPC 服务的所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) {</span><br><span class="line">        <span class="comment">// 获取 RPC 服务的方法的描述信息</span></span><br><span class="line">        <span class="keyword">const</span> google::protobuf::MethodDescriptor* pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        <span class="comment">// 获取 RPC 服务的方法的名称</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> std::string <span class="title">methodName</span><span class="params">(pmethodDesc-&gt;name())</span></span>;</span><br><span class="line">        <span class="comment">// 存储 RPC 服务的方法的描述信息</span></span><br><span class="line">        servcieInfo.m_methodMap.<span class="built_in">insert</span>({methodName, pmethodDesc});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 RPC 服务的信息</span></span><br><span class="line">    servcieInfo.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>({serviceName, servcieInfo});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取配置信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_host = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_HOST_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_port = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_PORT_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_network_interface =</span><br><span class="line">        MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(RPC_NETWORK_INTERFACE_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务提供者的 IP 和端口</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_server_ip = NetworkUtil::<span class="built_in">GetInstance</span>().<span class="built_in">FindLocalIp</span>(rpc_network_interface);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rpc_server_port = NetworkUtil::<span class="built_in">GetInstance</span>().<span class="built_in">FindAvailablePort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 服务提供者的端口是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == rpc_server_port) {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"not found available port for rpc server!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 TCP 服务器</span></span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(rpc_server_ip, rpc_server_port)</span></span>;</span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">tcpServer</span><span class="params">(&amp;m_eventloop, address, <span class="string">"RpcProvider"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP 连接创建和断开的回调</span></span><br><span class="line">    tcpServer.<span class="built_in">setConnectionCallback</span>(<span class="built_in">bind</span>(&amp;RpcProvider::onConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置已建立 TCP 连接读写事件的回调</span></span><br><span class="line">    tcpServer.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        <span class="built_in">bind</span>(&amp;RpcProvider::onMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 EventLoop 的线程数量（比如：1 个 I/O 线程，3 个 Worker 线程）</span></span><br><span class="line">    tcpServer.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ZK 客户端</span></span><br><span class="line">    ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="keyword">bool</span> started = zkClient.<span class="built_in">Start</span>(zk_server_host, <span class="built_in">atoi</span>(zk_server_port.<span class="built_in">c_str</span>()));</span><br><span class="line">    <span class="comment">// ZK 服务端连接失败</span></span><br><span class="line">    <span class="keyword">if</span> (!started) {</span><br><span class="line">        <span class="comment">// 停止往下继续执行，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有已发布的 RPC 服务注册进 ZK 服务端</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; service : m_serviceMap) {</span><br><span class="line">        <span class="comment">// RPC 服务的 IP 和端口信息</span></span><br><span class="line">        <span class="keyword">const</span> std::string rpc_address = rpc_server_ip + <span class="string">":"</span> + std::<span class="built_in">to_string</span>(rpc_server_port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RPC 服务的名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">        <span class="keyword">const</span> std::string service_name = service.first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的路径前缀，比如 /mprpc/services/user.UserServiceRpc</span></span><br><span class="line">        <span class="keyword">const</span> std::string path_prefix = ZNODE_PATH_PREFIX + <span class="string">"/"</span> + service_name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的完整路径，比如 /mprpc/services/user.UserServiceRpc/127.0.0.1:7070</span></span><br><span class="line">        <span class="keyword">const</span> std::string node_full_path = path_prefix + <span class="string">"/"</span> + rpc_address;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的数据，比如 127.0.0.1:7070</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* node_data = rpc_address.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的数据长度</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> node_data_len = rpc_address.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ZNode 节点（临时节点）</span></span><br><span class="line">        <span class="keyword">const</span> std::string created_path =</span><br><span class="line">            zkClient.<span class="built_in">CreateRecursive</span>(node_full_path.<span class="built_in">c_str</span>(), node_data, node_data_len, ZOO_EPHEMERAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 ZNode 节点是否创建成功（即 RPC 服务是否注册成功）</span></span><br><span class="line">        <span class="keyword">if</span> (!created_path.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="comment">// ZNode 节点创建成功</span></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"success to register rpc service, name: %s, path: %s, data: %s"</span>, service_name.<span class="built_in">c_str</span>(),</span><br><span class="line">                     node_full_path.<span class="built_in">c_str</span>(), node_data);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// ZNode 节点创建失败</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"failed to register rpc service, name: %s, path: %s, data: %s"</span>, service_name.<span class="built_in">c_str</span>(),</span><br><span class="line">                      node_full_path.<span class="built_in">c_str</span>(), node_data);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"rpc provider start at %s:%d"</span>, rpc_server_ip.<span class="built_in">c_str</span>(), rpc_server_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 TCP 服务器</span></span><br><span class="line">    tcpServer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以阻塞方式等待新客户端的连接、已连接客户端的读写事件等</span></span><br><span class="line">    m_eventloop.<span class="built_in">loop</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 TCP 连接的创建和断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;<span class="built_in">connected</span>()) {</span><br><span class="line">        <span class="comment">// 断开连接（释放资源）</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 TCP 连接的读写事件（比如接收客户端发送的数据）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 接收到的字符流，数据格式：header_size（4 字节） + header_str（service_name + method_name + args_size） + args_str</span></span><br><span class="line">    <span class="keyword">const</span> std::string recv_buf = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前 4 个字节的内容</span></span><br><span class="line">    <span class="keyword">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="keyword">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 header_size 读取请求数据头的原始字符流</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的基础信息</span></span><br><span class="line">    std::string service_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="keyword">uint32_t</span> args_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 请求数据头的反序列化</span></span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    <span class="keyword">if</span> (rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str)) {</span><br><span class="line">        <span class="comment">// 数据反序列化成功</span></span><br><span class="line">        service_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 数据反序列化失败</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc header string %s unserialize error!"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的参数的字符流数据</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"header_size: %u"</span>, header_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"rpc_header_str: %s"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"service_name: %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"method_name: %s"</span>, method_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_size: %u"</span>, args_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_str: %s"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 RPC 服务</span></span><br><span class="line">    <span class="keyword">auto</span> sit = m_serviceMap.<span class="built_in">find</span>(service_name);</span><br><span class="line">    <span class="comment">// 如果找不到对应的 RPC 服务</span></span><br><span class="line">    <span class="keyword">if</span> (sit == m_serviceMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc service %s is not exist!"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 RPC 服务的方法</span></span><br><span class="line">    <span class="keyword">auto</span> mit = sit-&gt;second.m_methodMap.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span> (mit == sit-&gt;second.m_methodMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc method %s::%s is not exist!"</span>, service_name.<span class="built_in">c_str</span>(), method_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的服务和方法</span></span><br><span class="line">    google::protobuf::Service* service = sit-&gt;second.m_service;</span><br><span class="line">    <span class="keyword">const</span> google::protobuf::MethodDescriptor* method = mit-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反序列化生成本地 RPC 方法调用的请求参数</span></span><br><span class="line">    google::protobuf::Message* request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span> (!request-&gt;<span class="built_in">ParseFromString</span>(rpc_args_str)) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc request args '%s' unserialize error!"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成本地 RPC 方法调用的响应结果</span></span><br><span class="line">    google::protobuf::Message* response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地 RPC 方法调用的回调，实际上调用的是 RpcProvider::SendRpcResponse()</span></span><br><span class="line">    google::protobuf::Closure* done =</span><br><span class="line">        google::protobuf::NewCallback&lt;RpcProvider, <span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp;, google::protobuf::Message*&gt;(</span><br><span class="line">            <span class="keyword">this</span>, &amp;RpcProvider::SendRpcResponse, conn, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 节点的本地方法</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于序列化 RPC 调用的响应结果和发送网络响应数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::SendRpcResponse</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span> </span>{</span><br><span class="line">    <span class="comment">// 序列化 RPC 调用的响应结果</span></span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span> (response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str)) {</span><br><span class="line">        <span class="comment">// 通过网络将本地 RPC 方法的执行结果发送给 RPC 服务调用方</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc response serialize error!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 模拟 HTTP 的短连接服务，由 RPC 服务提供方主动断开连接</span></span><br><span class="line">    conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的服务调用"><a href="#RPC-框架的服务调用" class="headerlink" title="RPC 框架的服务调用"></a>RPC 框架的服务调用</h4><ul><li><code>mprpccontroller.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcController</span> :</span> <span class="keyword">public</span> google::protobuf::RpcController {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MprpcController</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Failed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">ErrorText</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFailed</span><span class="params">(<span class="keyword">const</span> std::string&amp; reason)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前未实现具体的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartCancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsCanceled</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_failed;          <span class="comment">// RPC 方法执行过程中的状态</span></span><br><span class="line">    std::string m_errText;  <span class="comment">// RPC 方法执行过程中的错误信息</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpccontroller.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"></span><br><span class="line">MprpcController::<span class="built_in">MprpcController</span>() {</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errText = <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::Reset</span><span class="params">()</span> </span>{</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errText = <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MprpcController::Failed</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_failed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">MprpcController::ErrorText</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_errText;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::SetFailed</span><span class="params">(<span class="keyword">const</span> std::string&amp; reason)</span> </span>{</span><br><span class="line">    m_failed = <span class="literal">true</span>;</span><br><span class="line">    m_errText = reason;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(reason.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::StartCancel</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MprpcController::IsCanceled</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcchannel.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/message.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcChannel</span> :</span> <span class="keyword">public</span> google::protobuf::RpcChannel {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 随机生成一个整数，范围 [0, range-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomInt</span><span class="params">(<span class="keyword">int</span> range)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一实现 RPC 方法调用的数据序列化和网络数据发送（针对 RPC 服务调用者）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CallMethod</span><span class="params">(<span class="keyword">const</span> google::protobuf::MethodDescriptor* method, google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> google::protobuf::Message* request, google::protobuf::Message* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                    google::protobuf::Closure* done)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcchannel.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcchannel.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpcheader.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成一个整数，范围 [0, range-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MprpcChannel::randomInt</span><span class="params">(<span class="keyword">int</span> range)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (range &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::mt19937 <span class="title">gen</span><span class="params">(std::random_device{}())</span></span>;</span><br><span class="line">        std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>, range - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dis</span>(gen);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一实现 RPC 方法调用的数据序列化和网络数据发送（针对 RPC 服务调用者）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcChannel::CallMethod</span><span class="params">(<span class="keyword">const</span> google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                              google::protobuf::RpcController* controller, <span class="keyword">const</span> google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                              google::protobuf::Message* response, google::protobuf::Closure* done)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 RPC 服务的完整名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">service_name</span><span class="params">(method-&gt;service()-&gt;full_name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的方法名称</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">method_name</span><span class="params">(method-&gt;name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用参数的序列化字符串的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> args_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_args_str;</span><br><span class="line">    <span class="keyword">if</span> (request-&gt;<span class="built_in">SerializeToString</span>(&amp;rpc_args_str)) {</span><br><span class="line">        args_size = rpc_args_str.<span class="built_in">size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"rpc request serialize error!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 RPC 调用的请求数据头</span></span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    rpcHeader.<span class="built_in">set_service_name</span>(service_name);</span><br><span class="line">    rpcHeader.<span class="built_in">set_method_name</span>(method_name);</span><br><span class="line">    rpcHeader.<span class="built_in">set_args_size</span>(args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 请求数据头的序列化字符串的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    <span class="keyword">if</span> (rpcHeader.<span class="built_in">SerializeToString</span>(&amp;rpc_header_str)) {</span><br><span class="line">        header_size = rpc_header_str.<span class="built_in">size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"rpc header serialize error!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络发送的数据，格式：header_size（4 字节） + header_str（service_name + method_name + args_size） + args_str</span></span><br><span class="line">    std::string rpc_send_str;</span><br><span class="line">    rpc_send_str.<span class="built_in">insert</span>(<span class="number">0</span>, std::<span class="built_in">string</span>((<span class="keyword">char</span>*)&amp;header_size, <span class="number">4</span>));</span><br><span class="line">    rpc_send_str += rpc_header_str;</span><br><span class="line">    rpc_send_str += rpc_args_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"header_size: %u"</span>, header_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"rpc_header_str: %s"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"service_name: %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"method_name: %s"</span>, method_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_size: %u"</span>, args_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_str: %s"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地创建一个 TCP 客户端</span></span><br><span class="line">    <span class="keyword">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clientfd) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"create socket failed, errno is %d"</span>, errno);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ZK 服务端的连接信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_host = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_HOST_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_port = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_PORT_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ZK 客户端</span></span><br><span class="line">    ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="keyword">bool</span> started = zkClient.<span class="built_in">Start</span>(zk_server_host, <span class="built_in">atoi</span>(zk_server_port.<span class="built_in">c_str</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ZK 服务端启动失败</span></span><br><span class="line">    <span class="keyword">if</span> (!started) {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"zookeeper client connect failed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 服务对应的 ZNode 节点的路径，比如 /mprpc/services/user.UserServiceRpc</span></span><br><span class="line">    <span class="keyword">const</span> std::string node_path = ZNODE_PATH_PREFIX + <span class="string">"/"</span> + service_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ZNode 子节点列表（即已注册的 RPC 服务列表），比如 127.0.0.1:7070</span></span><br><span class="line">    std::vector&lt;std::string&gt; child_list = zkClient.<span class="built_in">GetChildren</span>(node_path.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ZNode 子节点列表为空（即查找不到已注册的 RPC 服务）</span></span><br><span class="line">    <span class="keyword">if</span> (child_list.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"not found rpc service %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机获取一个 RPC 服务提供者的地址，比如 127.0.0.1:7070</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = child_list.<span class="built_in">size</span>() == <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">randomInt</span>(child_list.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_addr = child_list[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 PRC 服务提供者的 IP 和端口</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> pos = rpc_provider_addr.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="comment">// 如果 RPC 服务提供者的地址无效</span></span><br><span class="line">    <span class="keyword">if</span> (std::string::npos == pos) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"invalid rpc service address %s"</span>, rpc_provider_addr.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_ip = rpc_provider_addr.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_port = rpc_provider_addr.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"ready to invoke rpc service, name: %s, address: %s"</span>, service_name.<span class="built_in">c_str</span>(), rpc_provider_addr.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装 TCP 客户端的连接信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(rpc_provider_port.<span class="built_in">c_str</span>()));</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(rpc_provider_ip.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 TCP 客户端连接 RPC 服务节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">connect</span>(clientfd, (struct sockaddr*)&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr))) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"connect server failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络发送 RPC 调用的请求参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">send</span>(clientfd, rpc_send_str.<span class="built_in">c_str</span>(), rpc_send_str.<span class="built_in">size</span>(), <span class="number">0</span>)) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"send rpc rquest failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络接收 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">int</span> recv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> recv_buf[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (recv_size = <span class="built_in">recv</span>(clientfd, recv_buf, <span class="number">1024</span>, <span class="number">0</span>))) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"receive rpc response failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (!response-&gt;<span class="built_in">ParseFromArray</span>(recv_buf, recv_size)) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"rpc response unserialize failed, response content is %s"</span>, recv_buf);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ZooKeeper-的访问操作"><a href="#ZooKeeper-的访问操作" class="headerlink" title="ZooKeeper 的访问操作"></a>ZooKeeper 的访问操作</h4><ul><li><code>zookeeperclient.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zookeeper/zookeeper.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ZNode 节点的状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ZNodeStatus</span> {</span></span><br><span class="line">    EXIST,     <span class="comment">// 已存在</span></span><br><span class="line">    NOTEXIST,  <span class="comment">// 不存在</span></span><br><span class="line">    UNKNOWN    <span class="comment">// 未知状态</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeper 客户端的封装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Start</span><span class="params">(<span class="keyword">const</span> std::string &amp;host, <span class="keyword">const</span> <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 创建 ZNode 节点</span></span><br><span class="line">    <span class="function">std::string <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen = <span class="number">0</span>, <span class="keyword">int</span> mode = ZOO_PERSISTENT)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 递归创建 ZNode 节点</span></span><br><span class="line">    <span class="function">std::string <span class="title">CreateRecursive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen = <span class="number">0</span>, <span class="keyword">int</span> mode = ZOO_PERSISTENT)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取子节点列表</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">GetChildren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的数据</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的状态</span></span><br><span class="line">    <span class="function">Stat <span class="title">GetStat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="function">ZNodeStatus <span class="title">Exist</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">zhandle_t</span> *m_zhandle;  <span class="comment">// ZK 的客户端句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>zookeeperclient.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////// ZK 客户端同步操作扩展代码 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步检查 ZNode 节点是否存在的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncExistsContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;              <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;  <span class="comment">// 检查结果</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步检查 ZNode 是否存在的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_exists_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> struct Stat *stat, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    SyncExistsContext *ctx = (SyncExistsContext *)data;</span><br><span class="line">    <span class="comment">// 存储检查结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line">    <span class="comment">// 唤醒正在等待检查结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步检查 ZNode 节点是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_exists_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncExistsContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aexists</span>(zh, path, watch, znode_exists_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待检查结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回检查结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建 ZNode 节点的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncCreateContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                 <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;     <span class="comment">// 创建结果</span></span><br><span class="line">    <span class="keyword">char</span> path_buf[<span class="number">512</span>] = {<span class="number">0</span>};  <span class="comment">// 用于返回实际创建的节点路径</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步创建 ZNode 节点的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_create_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncCreateContext *ctx = (SyncCreateContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储创建结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储实际创建的节点路径</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; path) {</span><br><span class="line">        <span class="built_in">strncpy</span>(ctx-&gt;path_buf, path, <span class="built_in"><span class="keyword">sizeof</span></span>(ctx-&gt;path_buf) - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待创建结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建 ZNode 节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_create_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">const</span> struct ACL_vector *acl,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> mode, <span class="keyword">char</span> *path_buf_out, <span class="keyword">int</span> path_buf_out_len)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncCreateContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_acreate</span>(zh, path, data, datalen, acl, mode, znode_create_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待检查结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回实际创建的节点路径</span></span><br><span class="line">    <span class="keyword">if</span> (path_buf_out &amp;&amp; path_buf_out_len &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">strncpy</span>(path_buf_out, ctx.path_buf, path_buf_out_len - <span class="number">1</span>);</span><br><span class="line">        path_buf_out[path_buf_out_len - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回检查结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 节点数据和状态的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncGetContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                    <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;        <span class="comment">// 操作结果</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="literal">nullptr</span>;          <span class="comment">// 数据缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> buf_len = <span class="number">0</span>;              <span class="comment">// 数据缓冲区的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> *<span class="title">stat</span> =</span> <span class="literal">nullptr</span>;  <span class="comment">// ZNode 节点的状态</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取 ZNode 节点数据和状态的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_get_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> value_len, <span class="keyword">const</span> struct Stat *stat, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetContext *ctx = (SyncGetContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储操作结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 ZNode 节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (rc == ZOK &amp;&amp; stat &amp;&amp; ctx-&gt;stat) {</span><br><span class="line">        *ctx-&gt;stat = *stat;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 ZNode 节点的数据</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; value &amp;&amp; value_len &gt; <span class="number">0</span> &amp;&amp; ctx-&gt;buf &amp;&amp; ctx-&gt;buf_len &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> copy_len = (value_len &lt; ctx-&gt;buf_len - <span class="number">1</span>) ? value_len : ctx-&gt;buf_len - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ctx-&gt;buf, value, copy_len);</span><br><span class="line">        ctx-&gt;buf[copy_len] = <span class="string">'\0'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待获取结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 节点的数据和状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_get_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch, <span class="keyword">char</span> *buf_out, <span class="keyword">int</span> buf_out_len, struct Stat *stat_out)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetContext ctx;</span><br><span class="line">    ctx.stat = stat_out;</span><br><span class="line">    ctx.buf = buf_out;</span><br><span class="line">    ctx.buf_len = buf_out_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aget</span>(zh, path, watch, znode_get_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待获取结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回操作结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 子节点列表的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncGetChildrenContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                          <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;              <span class="comment">// 操作结果</span></span><br><span class="line">    std::vector&lt;std::string&gt; children;  <span class="comment">// 子节点列表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取 ZNode 子节点列表的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zoo_get_children_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> struct String_vector *strings, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetChildrenContext *ctx = (SyncGetChildrenContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储操作结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储子节点列表</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; strings) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings-&gt;count; i++) {</span><br><span class="line">            ctx-&gt;children.<span class="built_in">emplace_back</span>(strings-&gt;data[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待获取结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 子节点列表</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">zoo_get_children_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch)</span> </span>{</span><br><span class="line">    <span class="comment">// 子节点列表</span></span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetChildrenContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aget_children</span>(zh, path, watch, zoo_get_children_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待获取结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取子节点列表成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == ctx.rc) {</span><br><span class="line">        <span class="comment">// 直接转移 children 所有权给 result</span></span><br><span class="line">        result = std::<span class="built_in">move</span>(ctx.children);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取子节点列表失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"failed to get children of node %s"</span>, path);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回子节点列表</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的 Watcher 监听器，接收 ZkServer 给 ZkClient 发送的通知</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_watcher</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">int</span> type, <span class="keyword">int</span> state, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">void</span> *watcherCtx)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断接收到的事件类型是不是会话事件类型</span></span><br><span class="line">    <span class="keyword">if</span> (type == ZOO_SESSION_EVENT) {</span><br><span class="line">        <span class="comment">// ZK 客户端连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (state == ZOO_CONNECTED_STATE) {</span><br><span class="line">            <span class="comment">// 从 ZK 客户端的上下文中获取预设置的信号量</span></span><br><span class="line">            <span class="keyword">sem_t</span> *init_sem = (<span class="keyword">sem_t</span> *)<span class="built_in">zoo_get_context</span>(zh);</span><br><span class="line">            <span class="comment">// 唤醒正在等待 ZK 客户端初始化完成的线程</span></span><br><span class="line">            <span class="built_in">sem_post</span>(init_sem);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ZK 客户端身份认证失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == ZOO_AUTH_FAILED_STATE) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper auth failed"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ZK 客户端会话过期</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == ZOO_EXPIRED_SESSION_STATE) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper session expired"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////// ZK 客户端实现代码 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ZkClient::<span class="built_in">ZkClient</span>() : <span class="built_in">m_zhandle</span>(<span class="literal">nullptr</span>) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ZkClient::~<span class="built_in">ZkClient</span>() {</span><br><span class="line">    <span class="keyword">if</span> (m_zhandle != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="comment">// 关闭 ZK 的客户端句柄（释放资源）</span></span><br><span class="line">        <span class="built_in">zookeeper_close</span>(m_zhandle);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 ZK 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ZkClient::Start</span><span class="params">(<span class="keyword">const</span> std::string &amp;host, <span class="keyword">const</span> <span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">    <span class="comment">// 拼接 ZK 服务端的连接信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string conn_str = host + <span class="string">":"</span> + std::<span class="built_in">to_string</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 ZK 的客户端句柄，连接 ZK 服务端（特别注意：这里是异步初始化）</span></span><br><span class="line"><span class="comment">     * ZooKeeper C API 的多线程版本有三个线程，包括：</span></span><br><span class="line"><span class="comment">     * (1) API 调用线程（当前调用 ZK API 的线程）</span></span><br><span class="line"><span class="comment">     * (2) 网络 I/O 线程，基于 pthread_create() + poll 实现</span></span><br><span class="line"><span class="comment">     * (3) Watcher 回调线程，基于 pthread_create() 实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    m_zhandle = <span class="built_in">zookeeper_init</span>(conn_str.<span class="built_in">c_str</span>(), global_watcher, <span class="number">30000</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_zhandle) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper client init failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> init_sem;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;init_sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将信号量存放到 ZK 客户端的上下文中</span></span><br><span class="line">    <span class="built_in">zoo_set_context</span>(m_zhandle, &amp;init_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置等待 ZK 客户端连接的超时时间（10 秒）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;ts);</span><br><span class="line">    ts.tv_sec += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待 ZK 客户端初始化完成</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sem_timedwait</span>(&amp;init_sem, &amp;ts) != <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;init_sem);</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper client connect timeout"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;init_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"zookeeper client init success"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上根据指定的 Path 创建 ZNode 节点</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">int</span> mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZNode 节点已存在</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">"znode %s create failed, because it existed"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ZNode 节点不存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ZNONODE == flag) {</span><br><span class="line">        <span class="comment">// 实际创建的节点路径</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> path_buf_len = <span class="number">512</span>;</span><br><span class="line">        <span class="keyword">char</span> path_buf[path_buf_len] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步创建 ZNode 节点</span></span><br><span class="line">        flag = <span class="built_in">zoo_create_sync</span>(m_zhandle, path, data, datalen, &amp;ZOO_OPEN_ACL_UNSAFE, mode, path_buf, path_buf_len);</span><br><span class="line">        <span class="comment">// 节点创建成功</span></span><br><span class="line">        <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"znode %s create success"</span>, path_buf);</span><br><span class="line">            <span class="comment">// 返回实际创建的节点路径</span></span><br><span class="line">            <span class="keyword">return</span> path_buf;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 节点创建失败</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">            <span class="comment">// 返回空字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发生错误，比如会话过期、身份认证失败等</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 递归创建 ZNode 节点</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::CreateRecursive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">int</span> mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::string current_path;</span><br><span class="line">    std::string result_path;</span><br><span class="line">    <span class="keyword">size_t</span> current_pos = <span class="number">1</span>;       <span class="comment">// 跳过第一个 '/'</span></span><br><span class="line">    <span class="function">std::string <span class="title">full_path</span><span class="params">(path)</span></span>;  <span class="comment">// 拷贝节点路径，避免修改原始字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_pos &lt;= full_path.<span class="built_in">size</span>()) {</span><br><span class="line">        <span class="keyword">size_t</span> next_pos = full_path.<span class="built_in">find</span>(<span class="string">'/'</span>, current_pos);</span><br><span class="line">        <span class="keyword">if</span> (next_pos == std::string::npos) {</span><br><span class="line">            <span class="comment">// 最后一级路径（完整路径）</span></span><br><span class="line">            current_path = full_path;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            current_path = full_path.<span class="built_in">substr</span>(<span class="number">0</span>, next_pos);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> is_last_path = (next_pos == std::string::npos);   <span class="comment">// 是否为最后一级路径</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *path_data = is_last_path ? data : <span class="string">""</span>;      <span class="comment">// 父路径不写入数据</span></span><br><span class="line">        <span class="keyword">int</span> path_data_len = is_last_path ? datalen : <span class="number">0</span>;        <span class="comment">// 父路径的数据长度为零</span></span><br><span class="line">        <span class="keyword">int</span> path_mode = is_last_path ? mode : ZOO_PERSISTENT;  <span class="comment">// 父路径为持久节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        std::string created_path = <span class="built_in">Create</span>(current_path.<span class="built_in">c_str</span>(), path_data, path_data_len, path_mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果节点创建失败</span></span><br><span class="line">        <span class="keyword">if</span> (created_path.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="comment">// 判断节点是否存在</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, current_path.<span class="built_in">c_str</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 如果节点存在，使用（兼容）已存在的节点</span></span><br><span class="line">            <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">                created_path = current_path;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果节点不存在或者发生错误，则直接返回空字符串</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 打印日志信息</span></span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">                <span class="comment">// 返回空字符串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是最后一级路径，则跳出 While 循环</span></span><br><span class="line">        <span class="keyword">if</span> (is_last_path) {</span><br><span class="line">            result_path = created_path;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        current_pos = next_pos + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_path;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取子节点列表</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">ZkClient::GetChildren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空列表</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取子节点列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">zoo_get_children_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的数据</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::GetData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> data_buf_len = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">char</span> data_buf[data_buf_len] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取 ZNode 节点的数据</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_get_sync</span>(m_zhandle, path, <span class="number">0</span>, data_buf, data_buf_len, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 获取节点数据成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 返回节点数据</span></span><br><span class="line">        <span class="keyword">return</span> data_buf;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取节点数据失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"get znode data failed, path: %s"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的状态</span></span><br><span class="line"><span class="function">Stat <span class="title">ZkClient::GetStat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空数据</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">stat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取 ZNode 节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_get_sync</span>(m_zhandle, path, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;stat);</span><br><span class="line">    <span class="comment">// 获取节点状态成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 返回节点状态</span></span><br><span class="line">        <span class="keyword">return</span> stat;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取节点状态失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"get znode stat failed, path: %s"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空数据</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 判断 ZNode 节点是否存在</span></span><br><span class="line"><span class="function">ZNodeStatus <span class="title">ZkClient::Exist</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZNode 节点已存在</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="keyword">return</span> EXIST;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ZNode 节点不存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ZNONODE == flag) {</span><br><span class="line">        <span class="keyword">return</span> NOTEXIST;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发生错误，比如会话过期、身份认证失败等</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查节点路径是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ZkClient::checkPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">nullptr</span> || path[<span class="number">0</span>] != <span class="string">'/'</span>) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"invalid node path: %s"</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="RPC-框架测试代码"><a href="#RPC-框架测试代码" class="headerlink" title="RPC 框架测试代码"></a>RPC 框架测试代码</h3><p>这里的项目测试代码位于 <code>example</code> 目录下，实质是 RPC 框架的使用案例代码，用于给 RPC 框架的第三方使用者演示如何发布和调用 RPC 服务。</p><h4 id="Protobuf-协议文件-1"><a href="#Protobuf-协议文件-1" class="headerlink" title="Protobuf 协议文件"></a>Protobuf 协议文件</h4><ul><li><code>user.proto</code> 协议文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package user;</span><br><span class="line"></span><br><span class="line">// 允许生成通用的 C++ 服务接口（可选项）</span><br><span class="line">option cc_generic_services = true;</span><br><span class="line"></span><br><span class="line">// 请求结果</span><br><span class="line">message ResultCode {</span><br><span class="line">    uint32 errcode = 1; </span><br><span class="line">    bytes errmsg = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 登录请求</span><br><span class="line">message LoginRequest {</span><br><span class="line">    bytes name = 1;</span><br><span class="line">    bytes password = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 登录响应</span><br><span class="line">message LoginResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    bool success = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 注册请求</span><br><span class="line">message RegisterRequest {</span><br><span class="line">    bytes name = 1;</span><br><span class="line">    bytes password = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 注册响应</span><br><span class="line">message RegisterResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    bool success = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义RPC服务接口类和服务函数</span><br><span class="line">service UserServiceRpc {</span><br><span class="line">    rpc Register(RegisterRequest) returns (RegisterResponse);</span><br><span class="line"></span><br><span class="line">    rpc Login(LoginRequest) returns (LoginResponse);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>friend.proto</code> 协议文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package friends;</span><br><span class="line"></span><br><span class="line">// 允许生成通用的 C++ 服务接口（可选项）</span><br><span class="line">option cc_generic_services = true;</span><br><span class="line"></span><br><span class="line">// 请求结果</span><br><span class="line">message ResultCode {</span><br><span class="line">    uint32 errcode = 1; </span><br><span class="line">    bytes errmsg = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 好友信息</span><br><span class="line">message Friend {</span><br><span class="line">    uint32 userid = 1;</span><br><span class="line">    bytes username = 2;</span><br><span class="line"></span><br><span class="line">    // 枚举类型</span><br><span class="line">    enum SEX {</span><br><span class="line">        MAN = 0;</span><br><span class="line">        WOMAN = 1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SEX sex = 3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取好友列表的请求</span><br><span class="line">message GetFriendListRequest {</span><br><span class="line">    uint32 userid = 1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取好友列表的响应</span><br><span class="line">message GetFriendListResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    // 好友列表</span><br><span class="line">    repeated Friend friends = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义RPC服务接口类和服务函数</span><br><span class="line">service FriendServiceRpc {</span><br><span class="line">    rpc GetFriendList(GetFriendListRequest) returns (GetFriendListResponse);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-RPC-框架提供服务"><a href="#使用-RPC-框架提供服务" class="headerlink" title="使用 RPC 框架提供服务"></a>使用 RPC 框架提供服务</h4><ul><li><code>rpcprovider.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcprovider.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 服务，继承基类 UserServiceRpc（由 Protobuf 自动生成）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> :</span> <span class="keyword">public</span> user::UserServiceRpc {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 本地的登录函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Login</span><span class="params">(std::string name, std::string password)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local Login function, name: %s, password: %s"</span>, name.<span class="built_in">c_str</span>(), password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地的注册函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Register</span><span class="params">(std::string name, std::string password)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local Register function, name: %s, password: %s"</span>, name.<span class="built_in">c_str</span>(), password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 UserServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Login</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::user::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">               ::user::LoginResponse* response, ::google::protobuf::Closure* done)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string password = request-&gt;<span class="built_in">password</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        <span class="keyword">bool</span> success = <span class="built_in">Login</span>(name, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        user::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(success);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给 RPC 服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 UserServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::user::RegisterRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ::user::RegisterResponse* response, ::google::protobuf::Closure* done)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string password = request-&gt;<span class="built_in">password</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        <span class="keyword">bool</span> success = <span class="built_in">Register</span>(name, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        user::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(success);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给RPC服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 服务，继承基类 FriendServiceRpc（由 Protobuf 自动生成）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendServcie</span> :</span> <span class="keyword">public</span> friends::FriendServiceRpc {</span><br><span class="line">    <span class="comment">// 本地获取好友列表的函数</span></span><br><span class="line">    <span class="function">std::vector&lt;friends::Friend&gt; <span class="title">GetFriendList</span><span class="params">(<span class="keyword">uint32_t</span> userid)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local GetFriendList function, userid: %u"</span>, userid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        std::vector&lt;friends::Friend&gt; result;</span><br><span class="line"></span><br><span class="line">        friends::Friend f1;</span><br><span class="line">        f1.<span class="built_in">set_userid</span>(<span class="number">1</span>);</span><br><span class="line">        f1.<span class="built_in">set_username</span>(<span class="string">"Jim"</span>);</span><br><span class="line">        f1.<span class="built_in">set_sex</span>(friends::Friend::MAN);</span><br><span class="line">        result.<span class="built_in">push_back</span>(f1);</span><br><span class="line"></span><br><span class="line">        friends::Friend f2;</span><br><span class="line">        f2.<span class="built_in">set_userid</span>(<span class="number">2</span>);</span><br><span class="line">        f2.<span class="built_in">set_username</span>(<span class="string">"Tom"</span>);</span><br><span class="line">        f2.<span class="built_in">set_sex</span>(friends::Friend::MAN);</span><br><span class="line">        result.<span class="built_in">push_back</span>(f2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 FriendServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetFriendList</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::friends::GetFriendListRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::friends::GetFriendListResponse* response, ::google::protobuf::Closure* done)</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        <span class="keyword">uint32_t</span> userid = request-&gt;<span class="built_in">userid</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        std::vector&lt;friends::Friend&gt; friends = <span class="built_in">GetFriendList</span>(userid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        friends::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应的数据</span></span><br><span class="line">        <span class="keyword">for</span> (friends::Friend&amp; item : friends) {</span><br><span class="line">            friends::Friend* f = response-&gt;<span class="built_in">add_friends</span>();</span><br><span class="line">            f-&gt;<span class="built_in">set_sex</span>(item.<span class="built_in">sex</span>());</span><br><span class="line">            f-&gt;<span class="built_in">set_userid</span>(item.<span class="built_in">userid</span>());</span><br><span class="line">            f-&gt;<span class="built_in">set_username</span>(item.<span class="built_in">username</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给RPC服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 RPC 服务的发布</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    Logger::<span class="built_in">GetInstance</span>().<span class="built_in">SetLogLevel</span>(INFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 框架的初始化操作（比如加载 RPC 配置文件）</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"init rpc framework..."</span>);</span><br><span class="line">    MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用来发布 RPC 服务的网络对象类</span></span><br><span class="line">    RpcProvider provider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    provider.<span class="built_in">PublishService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    provider.<span class="built_in">PublishService</span>(<span class="keyword">new</span> <span class="built_in">FriendServcie</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-RPC-框架调用服务"><a href="#使用-RPC-框架调用服务" class="headerlink" title="使用 RPC 框架调用服务"></a>使用 RPC 框架调用服务</h4><ul><li><code>rpcconsumer.cc</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 注册方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">user::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    user::RegisterRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">"jim"</span>);</span><br><span class="line">    request.<span class="built_in">set_password</span>(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    user::RegisterResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">Register</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function Register invoke success"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function Register invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 登录方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Login</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">user::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    user::LoginRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">"jim"</span>);</span><br><span class="line">    request.<span class="built_in">set_password</span>(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    user::LoginResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">Login</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function Login invoke success"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function Login invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 获取好友列表方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetFriendList</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">friends::FriendServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    friends::GetFriendListRequest request;</span><br><span class="line">    request.<span class="built_in">set_userid</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    friends::GetFriendListResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">GetFriendList</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function GetFriendList invoke success"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取返回的数据</span></span><br><span class="line">        <span class="keyword">auto</span> friends = response.<span class="built_in">friends</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : friends) {</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"userid: %u, username: %s, sex: %d"</span>, item.<span class="built_in">userid</span>(), item.<span class="built_in">username</span>().<span class="built_in">c_str</span>(), item.<span class="built_in">sex</span>());</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function GetFriendList invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 RPC 服务的调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    Logger::<span class="built_in">GetInstance</span>().<span class="built_in">SetLogLevel</span>(INFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 框架的初始化操作（比如加载 RPC 配置文件）</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"init rpc framework..."</span>);</span><br><span class="line">    MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 注册方法</span></span><br><span class="line">    <span class="built_in">Register</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 登录方法</span></span><br><span class="line">    <span class="built_in">Login</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 获取好友列表方法</span></span><br><span class="line">    <span class="built_in">GetFriendList</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待一段时间，在程序结束之前，尽量让日志信息都被写入日志文件</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="项目代码下载"><a href="#项目代码下载" class="headerlink" title="项目代码下载"></a>项目代码下载</h3><p>完整的 RPC 框架项目代码可以在 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-mprpc">这里</a> 下载得到。</p><h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><ul><li>(1) 更改 <code>conf</code> 目录下的 <code>rpc.conf</code> 配置文件，指定 ZooKeeper 服务器的 IP 和端口号等信息 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ZooKeeper的IP地址（必填）</span><br><span class="line">zk_server_host=127.0.0.1</span><br><span class="line"># ZooKeeper的端口号（必填）</span><br><span class="line">zk_server_port=2181</span><br><span class="line"># RPC服务提供者优先使用的网卡接口（可选）</span><br><span class="line">rpc_network_interface=eth1</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 通过 CMake 编译构建整个项目 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权脚本执行</span></span><br><span class="line">chmod +x autobuild.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一键编译构建脚本</span></span><br><span class="line">./autobuild.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 启动 ZooKeeper 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 ZooKeeper 服务器</span></span><br><span class="line">sudo systemctl start zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 服务器的运行状态</span></span><br><span class="line">sudo systemctl status zookeeper</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 启动 RPC 服务提供者的案例程序 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 RPC 服务提供者的案例程序（可使用相同的命令启动多个 RPC 服务提供者，不需要考虑端口冲突问题）</span></span><br><span class="line">./example_rpc_provider -i rpc.conf</span><br></pre></td></tr></tbody></table></figure><ul><li>(5) 启动 RPC 服务调用者的案例程序 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 RPC 服务调用者的案例程序（可使用相同的命令启动多个 RPC 服务调用者，不需要考虑端口冲突问题）</span></span><br><span class="line">./example_rpc_consumer -i rpc.conf</span><br></pre></td></tr></tbody></table></figure><ul><li>(6) 查看 RPC 框架运行输出的日志文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 RPC 框架运行输出的日志文件（请自行更改日志文件名）</span></span><br><span class="line">vim 2025-06-12-log.txt</span><br></pre></td></tr></tbody></table></figure><h2 id="项目调试"><a href="#项目调试" class="headerlink" title="项目调试"></a>项目调试</h2><ul><li>GDB 调试 C/C++ 代码，可用于定位线程死锁等问题的发生 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GDB 调试指定的可执行文件（应用程序）</span></span><br><span class="line">gdb example_rpc_provider</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 设置断点（格式：源文件名称＋行号）</span></span><br><span class="line">(gdb) <span class="built_in">break</span> mprpcconfig.cc:19</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 指定参数运行应用程序（运行后，会停留在断点处）</span></span><br><span class="line">(gdb) run -i rpc.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 断点调试 - 运行下一行代码</span></span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 断点调试 - 查看指定变量的值</span></span><br><span class="line">(gdb) p src_buf</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 退出调试</span></span><br><span class="line">(gdb) quit</span><br></pre></td></tr></tbody></table></figure><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><p>在上述的 RPC 框架代码中，每当 RPC 服务端处理完成一个 RPC 请求后，都会主动断开与 RPC 客户端的 TCP 连接；同样，RPC 客户端在获取到响应结果后，也会主动断开与 RPC 服务端的 TCP 连接。这种实现方式属于短连接模式，在生产环境中通常比较少见。原因如下：</p><ul><li><p>TCP 连接的创建和释放代价较高，每次请求都涉及：</p><ul><li>三次握手（建立连接）</li><li>四次挥手（关闭连接）</li></ul></li><li><p>在高并发场景下，频繁建立和关闭 TCP 连接会导致：</p><ul><li>系统资源消耗大（文件描述符、内核网络栈负载）</li><li>服务端的性能瓶颈，特别是处理大量短时请求时</li></ul></li></ul><p>以阿里巴巴开源的 RPC 框架 Dubbo 为例，Dubbo 默认采用 TCP 的单一长连接和 NIO 异步通信模型，其主要特点是：</p><ul><li>客户端与服务端之间建立持久化的长连接（通常是连接池或多路复用）</li><li>异步非阻塞通信（基于 Netty 实现）</li><li>复用连接发送多次请求，避免了重复的 TCP 握手和断开操作，显著降低了网络资源和 CPU 消耗</li></ul><p>因此在生产环境中，建议使用 TCP 的单一长连接和 NIO 异步通信模型（Muduo 网络库天生支持），以此保证 RPC 框架的高并发性能。值得一提的是，使用 TCP 长连接后，需要额外处理 TCP 分包的问题，也就是将 TCP 字节流里的数据识别为一个个消息（RPC 请求消息）。</p><table><thead><tr><th>模式</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td>短连接（请求 - 响应后立即断开）</td><td>简单实现，资源浪费大</td><td>一般用于简单的 HTTP/1.0 接口或调试环境</td></tr><tr><td>长连接（复用 TCP 连接）</td><td>性能优越，适合高并发</td><td> gRPC、Dubbo、Redis、数据库连接等</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/18340f27.html">ZooKeeper 入门系列教程</a></li><li><a href="/posts/46940ea4.html">C++ 快速上手使用 Protobuf</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 如何实现 RPC 分布式网络通信框架，使用了 Muduo、Protobuf、ZooKeeper 等技术。</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="RPC" scheme="https://www.techgrow.cn/tags/RPC/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 开发集群聊天服务器</title>
    <link href="https://www.techgrow.cn/posts/e635f0aa.html"/>
    <id>https://www.techgrow.cn/posts/e635f0aa.html</id>
    <published>2025-05-29T13:55:33.000Z</published>
    <updated>2025-06-04T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写高性能网络库（Muduo）</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 实现集群聊天服务器，使用了 Json 库和 Muduo 网络库，并引入了 Redis、MySQL、Nginx 中间件。</p><span id="more"></span><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><table><thead><tr><th>软件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>11</code></td><td></td></tr><tr><td>Boost</td><td><code>1.74.0.3</code></td><td>Muduo 库依赖 Boost 库</td></tr><tr><td> Muduo</td><td><code>2.0.3</code></td><td><a href="https://github.com/chenshuo/muduo">Muduo 库</a>，基于 C++ 开发，用于网络编程</td></tr><tr><td> hiredis</td><td><code>1.3.0</code></td><td><a href="https://github.com/redis/hiredis">Reids 库</a> ，基于 C 语言开发，用于操作 Redis</td></tr><tr><td>nlohmann/json</td><td><code>3.12.0</code></td><td><a href="https://github.com/nlohmann/json">Json 库</a>，基于 C++ 开发，用于 Json 序列化和反序列化</td></tr><tr><td> MySQL C API （Connector/C）</td><td><code>8.4.5</code></td><td>用于读写 MySQL 数据库，基于 C 语言开发</td></tr><tr><td> Redis</td><td><code>7.0.15</code></td><td>Redis 服务器</td></tr><tr><td> MySQL</td><td><code>8.4.5</code></td><td>MySQL 服务器</td></tr><tr><td> Nginx</td><td><code>1.28.0</code></td><td>Nginx 服务器</td></tr><tr><td> G++（GCC）</td><td><code>12.2.0</code></td><td>建议使用 <code>5.5</code>、<code>7.5</code> 版本的 G++（GCC） 编译器</td></tr><tr><td> CMake</td><td><code>3.25.1</code></td><td>C/C++ 项目构建工具</td></tr><tr><td> Linux</td><td><code>Debian 12</code></td><td>Muduo 库不支持 Windows 平台</td></tr><tr><td> Visual Studio Code</td><td><code>1.100.2</code></td><td>使用 VSCode 远程开发特性</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">平台兼容性说明</p><p>由于使用了 Muduo 库，且 Muduo 库仅支持 Linux 平台；因此本文提供的所有 C++ 集群聊天服务器代码支持在 Linux 平台运行，不支持 Windows 平台，默认是基于 Debian 12 进行远程开发。</p></div><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>使用 C++ 开发 Linux 应用时，常见的开发环境有以下几种：</p><ul><li>(1) <a href="https://blog.csdn.net/icacxygh001/article/details/120981354">Linux 环境下直接使用 VSCode、Clion 等 IDE 进行本地开发</a></li><li> (2) <a href="https://blog.csdn.net/xiaowangabc1/article/details/147927306">Windows + VSCode + MinGW 搭建本地 C/C++ 开发环境</a></li><li> (3) <a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89469717">Windows + Visual Studio 搭建远程 Linux 跨平台项目</a></li><li> (4) <a href="/posts/630b5e44.html">Windows + VSCode 搭建远程 Linux 开发环境</a></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>上面介绍的三种开发环境，任意选择一种自己熟悉的就可以；如果日常使用的是 Windows 系统，建议选择第四种开发环境（VSCode 远程开发）；如果习惯使用 Linux 系统，强烈建议选择第一种开发环境（Linux 本地开发）。</p></div><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><ul><li>安装常用的工具 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装开发工具</span></span><br><span class="line">sudo apt-get install -y vim git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装网络工具</span></span><br><span class="line">sudo apt-get install -y wget curl telnet netcat-openbsd socat tcpdump hping3</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-GCC"><a href="#安装-GCC" class="headerlink" title="安装 GCC"></a>安装 GCC</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC、G++、GDB</span></span><br><span class="line">sudo apt-get install -y build-essential gdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 GCC 版本</span></span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 G++ 版本</span></span><br><span class="line">g++ --version</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-CMake"><a href="#安装-CMake" class="headerlink" title="安装 CMake"></a>安装 CMake</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 CMake</span></span><br><span class="line">sudo apt-get -y install cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 CMake 版本</span></span><br><span class="line">cmake -version</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><ul><li>安装 Redis</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Redis</span></span><br><span class="line">sudo apt-get install -y redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 Redis</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Redis 的运行状态</span></span><br><span class="line">sudo systemctl status redis-server</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Redis 版本</span></span><br><span class="line">redis-server --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 客户端执行 Ping 操作</span></span><br><span class="line">redis-cli ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 Redis 服务器响应以下内容，则说明 Redis 服务器正常运行</span></span><br><span class="line">PONG</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">Redis 默认配置文件的路径</p><p>通过 APT 安装 Redis 服务器后，其主配置文件的路径为 <code>/etc/redis/redis.conf</code>。</p></div><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><ul><li>安装依赖包 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖软件（比如 pcre、zlib、ssl）</span></span><br><span class="line">sudo apt install -y build-essential libpcre3 libpcre3-dev zlib1g zlib1g-dev libssl-dev</span><br></pre></td></tr></tbody></table></figure><ul><li>编译安装 Nginx</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://nginx.org/download/nginx-1.28.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf nginx-1.28.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.28.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">./configure --with-stream --with-http_ssl_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure><ul><li>Nginx 安装说明</li></ul><table><thead><tr><th>安装说明</th><th>路径</th></tr></thead><tbody><tr><td> Nginx 默认安装路径</td><td><code>/usr/local/nginx</code></td></tr><tr><td>Nginx 主配置文件路径</td><td><code>/usr/local/nginx/conf/nginx.conf</code></td></tr><tr><td>Nginx 二进制可执行文件路径</td><td><code>/usr/local/nginx/sbin/nginx</code></td></tr></tbody></table><ul><li>Nginx 管理命令 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 Nginx</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优雅关闭 Nginx</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s quit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立刻关闭 Nginx</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 Nginx 配置文件</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载 Nginx 配置文件</span></span><br><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 Systemd 服务（实现 Nginx 服务自启动）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Systemd 服务配置文件，添加以下配置内容</span></span><br><span class="line">sudo vi /etc/systemd/system/nginx.service</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=The NGINX HTTP and reverse proxy server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s quit</span><br><span class="line">PIDFile=/usr/<span class="built_in">local</span>/nginx/logs/nginx.pid</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重载系统配置文件</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 Nginx 服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 Nginx 服务</span></span><br><span class="line">sudo systemctl start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Nginx 服务的运行状态</span></span><br><span class="line">sudo systemctl status nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优雅关闭 Nginx 服务</span></span><br><span class="line">sudo systemctl stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载 Nginx 服务的配置文件</span></span><br><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Nginx <code>1.9.0</code> 版本之前，Nginx 仅支持基于 HTTP 协议 的 Web 服务器负载均衡，无法处理 TCP 层的流量转发。自 Nginx <code>1.9.0</code> 版本开始，官方引入了名为 <code>stream</code> 的新模块，使 Nginx 能够支持基于 TCP 和 UDP 的四层负载均衡，从而扩展了其在数据库代理、邮件服务、消息中间件等非 HTTP 场景中的应用能力。值得一提的是，尽管 <code>stream</code> 模块在 <code>1.9.0</code> 版本中开始被引入，但在官方源码中该模块默认并未启用。因此，在编译 Nginx 源码时，如果希望使用 <code>stream</code> 模块的功能，则必须显式添加 <code>--with-stream</code> 编译参数，这样才能将其集成进最终构建的二进制可执行文件中。</p></div><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><ul><li>添加 MySQL 官方 APT 源 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 APT 配置包（访问 https://dev.mysql.com/downloads/repo/apt/ 可以获取最新版本）</span></span><br><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.8.34-1_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 APT 配置包</span></span><br><span class="line"><span class="comment"># 在安装过程中会弹出配置界面，通常默认选择的是 MySQL 8.4 版本，如果需要安装其他版本（如 8.0），可以按回车键进入子菜单选择其他版本</span></span><br><span class="line"><span class="comment"># 由于集群聊天服务器需要使用到 MySQL 客户端，因此还需要安装 MySQL Connectors（不需要改动选择，因为默认已经选择安装）</span></span><br><span class="line">sudo dpkg -i mysql-apt-config_0.8.34-1_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 APT 索引</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></tbody></table></figure><ul><li>安装 MySQL</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 MySQL（安装过程中会提示输入 MySQL 的 root 用户的密码）</span></span><br><span class="line">sudo apt-get install -y mysql-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动 MySQL</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 MySQL 的运行状态</span></span><br><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">MySQL 默认配置文件的路径</p><p>通过 APT 安装 MySQL 服务器后，其主配置文件的路径为 <code>/etc/mysql/my.cnf</code>。</p></div><ul><li>安装 MySQL C API 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 MySQL 客户端开发包（包含了 MySQL C API 的头文件和动态库文件）</span></span><br><span class="line">sudo apt-get install -y libmysqlclient-dev</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 MySQL 安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录 MySQL</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 MySQL 版本</span></span><br><span class="line"><span class="keyword">select</span> version();</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 MySQL C API 库的安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /usr -iname libmysqlclient*</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.a</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.so.24</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmysqlclient.so.24.0.5</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">MySQL C API 库</p><p>本文使用 <code>libmysqlclient.so</code> 库来操作 MySQL 数据库，该库称为 MySQL C API（也叫 Connector/C），它是基于 C 语言实现的。C++ 项目也可以使用这个库，只要用 <code>extern "C"</code> 来链接（或者直接使用 MySQL 提供的头文件中已经加好的处理）。</p></div><h3 id="安装-Boost-库"><a href="#安装-Boost-库" class="headerlink" title="安装 Boost 库"></a>安装 Boost 库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Boost 的所有组件和头文件</span></span><br><span class="line">sudo apt-get install -y libboost-all-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Bootst 版本</span></span><br><span class="line">sudo dpkg -s libboost-all-dev | grep Version</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>由于 Muduo 使用了 Boost 库（如 <code>boost::any</code>），因此需要安装 Boost 库。</p></div><h3 id="安装-Muduo-库"><a href="#安装-Muduo-库" class="headerlink" title="安装 Muduo 库"></a>安装 Muduo 库</h3><ul><li>编译安装 Muduo 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chenshuo/muduo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入代码目录</span></span><br><span class="line"><span class="built_in">cd</span> muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Muduo 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Muduo 库的静态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep muduo</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Muduo 的编译依赖 CMake 和 Boost 库，默认编译生成的是静态库（<code>.a</code>），如果需要编译生成共享库（<code>.so</code>），可以自行修改 <code>CMakeLists.txt</code> 中的配置。</li><li>Muduo 支持 C++ 11，仅支持 Linux 平台，不支持 Windows 平台，建议使用 <code>7.x</code> 及以后版本的 <code>g++</code> 编译器。</li></ul></div><h3 id="安装-Hiredis-库"><a href="#安装-Hiredis-库" class="headerlink" title="安装 Hiredis 库"></a>安装 Hiredis 库</h3><ul><li>编译安装 Hiredis 库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/redis/hiredis.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> hiredis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Hiredis 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/hiredis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Hiredis 库的静态库和动态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep hiredis</span><br></pre></td></tr></tbody></table></figure><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h3><ul><li>客户端新用户注册</li><li>客户端用户登录</li><li>添加好友和添加群组</li><li>好友聊天</li><li>群组聊天</li><li>离线消息</li><li> Nginx 配置 TCP 负载均衡</li><li>集群聊天系统支持客户端跨服务器通信</li></ul><h3 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h3><ul><li>掌握 Json 的编程应用</li><li>掌握 CMake 构建自动化编译环境</li><li>掌握 Muduo 网络库的编程以及实现原理</li><li>掌握 Nginx 配置部署 TCP 负载均衡器的应用以及原理</li><li>掌握服务器的网络 I/O 模块、业务模块、数据模块分层的设计思想</li><li>掌握 Redis 发布 - 订阅的编程实践以及应用原理</li></ul><h3 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h3><p>在集群聊天服务器项目中，使用 Nginx 作为 TCP 负载均衡器，同时使用 Redis 的发布 - 订阅特性来解决客户端跨服务器通信问题。整体工作流程如下图所示：</p><p><img data-src="../../../asset/2025/06/cluster-chat-loadbalance-1.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p>Nginx 单机作为负载均衡器时，经过合理的系统参数优化和配置（如 <code>ulimit</code>、内核参数调整等），通常可以稳定支撑 5 万～6 万个并发 TCP 连接。但是，由于 Nginx 本质上是属于应用层的四层代理，其性能仍受限于单机的 CPU、内存、网络带宽和文件描述符等资源限制。若需支持 超过 10 万甚至上百万的并发 TCP 连接，可采用 LVS + Keepalived + Nginx 的分层架构实现更高性能、更高可用性、更强伸缩性的负载均衡方案，该方案的部署拓扑结构 <a href="../../../asset/2025/06/cluster-chat-loadbalance-2.png">如图</a> 所示。</p></div><h3 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h3><ul><li>单例设计模式</li><li> Muduo 网络库</li><li> MySQL 数据库编程</li><li> CMake 构建编译环境</li><li> Json 序列化和反序列化</li><li> Nginx 的 TCP 负载均衡器使用</li><li> Redis 的发布 - 订阅编程实践</li></ul><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><h3 id="Nginx-负载均衡配置"><a href="#Nginx-负载均衡配置" class="headerlink" title="Nginx 负载均衡配置"></a>Nginx 负载均衡配置</h3><p>在集群聊天服务器项目中，由于使用了 Nginx 作为 TCP 负载均衡器，因此需要在 Nginx 的配置文件中（<code>nginx.conf</code>）添加 <code>stream</code> 模块的配置内容，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">events {</span><br><span class="line">  ........</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># nginx tcp loadbalance config</span><br><span class="line">stream {</span><br><span class="line">    # 集群聊天的服务器列表</span><br><span class="line">    upstream chat_server {</span><br><span class="line">        server 127.0.0.1:6000 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">        server 127.0.0.1:6002 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    # TCP 负载均衡器（负责转发流量）</span><br><span class="line">    server {</span><br><span class="line">        listen 8000;</span><br><span class="line">        proxy_pass chat_server;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">http {</span><br><span class="line">  ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Redis-发布-订阅使用"><a href="#Redis-发布-订阅使用" class="headerlink" title="Redis 发布 - 订阅使用"></a>Redis 发布 - 订阅使用</h3><p>在集群聊天服务器项目中，使用 Redis 的发布 - 订阅特性来解决客户端跨服务器通信问题。Reids 的发布 - 订阅功能，主要使用以下几个 Redis 命令来实现：</p><ul><li>订阅指定的 Channel</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe news</span><br></pre></td></tr></tbody></table></figure><ul><li>发布消息到指定的 Channel</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish news <span class="string">"hello"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>取消订阅指定的 Channel</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsubscribe news</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>在集群聊天服务器项目中，为了方便操作 Redis，会使用到 <a href="https://github.com/redis/hiredis">Hiredis</a> 库。</p></div><h3 id="MySQL-数据库初始化"><a href="#MySQL-数据库初始化" class="headerlink" title="MySQL 数据库初始化"></a>MySQL 数据库初始化</h3><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>C++ 集群聊天服务器项目的数据库表设计如下：</p><p><img data-src="../../../asset/2025/05/cxx-cluster-chat-server-1.png"></p><h4 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h4><ul><li>创建数据库 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `chat` <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></tbody></table></figure><ul><li>切换数据库 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE `chat`;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建用户表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `state` enum(<span class="string">'online'</span>,<span class="string">'offline'</span>) <span class="keyword">DEFAULT</span> <span class="string">'offline'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `name` (`name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">22</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建好友表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `friend` (</span><br><span class="line">  `userid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `friendid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `userid` (`userid`,`friendid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建用户组表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `allgroup` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `groupname` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `groupdesc` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `groupname` (`groupname`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建用户与用户组关联表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `groupuser` (</span><br><span class="line">  `groupid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `userid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `grouprole` enum(<span class="string">'creator'</span>,<span class="string">'normal'</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `groupid` (`groupid`,`userid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建离线消息表 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `offlinemessage` (</span><br><span class="line">  `userid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `message` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `createtime` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><h3 id="集群聊天服务器开发"><a href="#集群聊天服务器开发" class="headerlink" title="集群聊天服务器开发"></a>集群聊天服务器开发</h3><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── sql</span><br><span class="line">│&nbsp;&nbsp; └── db.sql</span><br><span class="line">├── include</span><br><span class="line">│   ├── public</span><br><span class="line">│   │   ├── config.hpp</span><br><span class="line">│   │   ├── public.hpp</span><br><span class="line">│   │   └── times.hpp</span><br><span class="line">│   └── server</span><br><span class="line">│       ├── chatserver.hpp</span><br><span class="line">│       ├── chatservice.hpp</span><br><span class="line">│       ├── dao</span><br><span class="line">│       │   ├── friendmodel.hpp</span><br><span class="line">│       │   ├── groupmodel.hpp</span><br><span class="line">│       │   ├── groupusermodel.hpp</span><br><span class="line">│       │   ├── offlinemessagemodel.hpp</span><br><span class="line">│       │   └── usermodel.hpp</span><br><span class="line">│       ├── db</span><br><span class="line">│       │   └── db.hpp</span><br><span class="line">│       ├── domain</span><br><span class="line">│       │   ├── friend.hpp</span><br><span class="line">│       │   ├── group.hpp</span><br><span class="line">│       │   ├── groupuser.hpp</span><br><span class="line">│       │   ├── offlinemessage.hpp</span><br><span class="line">│       │   └── user.hpp</span><br><span class="line">│       └── redis</span><br><span class="line">│           └── redis.hpp</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── main.cpp</span><br><span class="line">│   └── server</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">│       ├── chatserver.cpp</span><br><span class="line">│       ├── chatservice.cpp</span><br><span class="line">│       ├── dao</span><br><span class="line">│       │   ├── friendmodel.cpp</span><br><span class="line">│       │   ├── groupmodel.cpp</span><br><span class="line">│       │   ├── groupusermodel.cpp</span><br><span class="line">│       │   ├── offlinemessagemodel.cpp</span><br><span class="line">│       │   └── usermodel.cpp</span><br><span class="line">│       ├── db</span><br><span class="line">│       │   └── db.cpp</span><br><span class="line">│       ├── main.cpp</span><br><span class="line">│       └── redis</span><br><span class="line">│           └── redis.cpp</span><br><span class="line">└── thirdparty</span><br><span class="line">    └── json.hpp</span><br></pre></td></tr></tbody></table></figure><h4 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h4><div class="admonition note"><p class="admonition-title">下载完整的项目代码</p><p>由于篇幅有限，下面只给出集群聊天服务端和客户端的部分核心代码，完整的项目代码可以在 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-cluster-chat-server">这里</a> 下载得到。</p></div><h5 id="公共核心代码"><a href="#公共核心代码" class="headerlink" title="公共核心代码"></a>公共核心代码</h5><ul><li><code>include/public/config.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局配置信息的头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 连接信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_IP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> DB_PORT = <span class="number">3306</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_USER = <span class="string">"root"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_PASSWORD = <span class="string">"Cxx_Chat_12345"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string DB_NAME = <span class="string">"chat"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis 连接信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> string REDIS_IP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> REDIS_PORT = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CONFIG_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>include/public/public.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUBLIC_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误编码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ErrorCode</span> {</span></span><br><span class="line">    SUCCESS = <span class="number">0</span>,           <span class="comment">// 请求处理成功</span></span><br><span class="line">    REGISTER_FAIL,         <span class="comment">// 注册失败</span></span><br><span class="line">    REPEAT_REGISTER,       <span class="comment">// 用户名已被注册</span></span><br><span class="line">    LOGIN_AUTH_FAIL,       <span class="comment">// 用户名或密码不正确</span></span><br><span class="line">    REPEAT_LOGIN,          <span class="comment">// 账号在其他设备已登录</span></span><br><span class="line">    ADD_FRIEND_FAIL,       <span class="comment">// 添加好友失败</span></span><br><span class="line">    JOIN_GROUP_FAIL,       <span class="comment">// 加入群组失败</span></span><br><span class="line">    SINGLE_CHAT_FAIL,      <span class="comment">// 一对一聊天失败</span></span><br><span class="line">    GROUP_CHAT_FAIL,       <span class="comment">// 群组聊天失败</span></span><br><span class="line">    INVALID_MESSAGE_TYPE,  <span class="comment">// 消息类型无效</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MsgType</span> {</span></span><br><span class="line">    LOGIN_MSG = <span class="number">1</span>,         <span class="comment">// 登录消息</span></span><br><span class="line">    LOGIN_MSG_ACK,         <span class="comment">// 登录响应消息</span></span><br><span class="line">    REGISTER_MSG,          <span class="comment">// 注册消息</span></span><br><span class="line">    REGISTER_MSG_ACK,      <span class="comment">// 注册响应消息</span></span><br><span class="line">    SINGLE_CHAT_MSG,       <span class="comment">// 一对一聊天消息</span></span><br><span class="line">    SINGLE_CHAT_MSG_ACK,   <span class="comment">// 一对一聊天响应消息</span></span><br><span class="line">    ADD_FRIEND_MSG,        <span class="comment">// 添加好友消息</span></span><br><span class="line">    ADD_FRIEND_MSG_ACK,    <span class="comment">// 添加好友响应消息</span></span><br><span class="line">    CREATE_GROUP_MSG,      <span class="comment">// 创建群组消息</span></span><br><span class="line">    CREATE_GROUP_MSG_ACK,  <span class="comment">// 创建群组响应消息</span></span><br><span class="line">    JOIN_GROUP_MSG,        <span class="comment">// 加入群组消息</span></span><br><span class="line">    JOIN_GROUP_MSG_ACK,    <span class="comment">// 加入群组响应消息</span></span><br><span class="line">    GROUP_CHAT_MSG,        <span class="comment">// 群聊天消息</span></span><br><span class="line">    GROUP_CHAT_MSG_ACK,    <span class="comment">// 群聊天响应消息</span></span><br><span class="line">    LOGIN_OUT_MSG,         <span class="comment">// 退出登录消息</span></span><br><span class="line">    LOGIN_OUT_MSG_ACK,     <span class="comment">// 退出登录响应消息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// PUBLIC_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>include/public/times.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIMES_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/c_local_time_adjustor.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/posix_time/posix_time.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间戳（单位：毫秒）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">getTimestampMs</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前系统的时间点</span></span><br><span class="line">    chrono::system_clock::time_point now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 转换为时间戳</span></span><br><span class="line">    <span class="keyword">return</span> chrono::duration_cast&lt;chrono::milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间戳（单位：毫秒）格式化为系统本地时间的字符串</span></span><br><span class="line"><span class="comment">// timestampMs: Unix 时间戳（自 1970-01-01 00:00:00 UTC 起的毫秒数）</span></span><br><span class="line"><span class="comment">// formatStr: 格式化字符串，例如 "%Y-%m-%d %H:%M:%S"</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">formatTimestampLocal</span><span class="params">(<span class="keyword">long</span> timestampMs, <span class="keyword">const</span> std::string&amp; formatStr)</span> </span>{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::posix_time;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::gregorian;</span><br><span class="line">    <span class="keyword">using</span> boost::date_time::c_local_adjustor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 UTC 时间：从 epoch 加上毫秒数</span></span><br><span class="line">    <span class="function">ptime <span class="title">epoch</span><span class="params">(date(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">    time_duration duration = <span class="built_in">milliseconds</span>(timestampMs);</span><br><span class="line">    ptime utc_time = epoch + duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为系统本地时间</span></span><br><span class="line">    <span class="keyword">typedef</span> c_local_adjustor&lt;ptime&gt; local_adj;</span><br><span class="line">    ptime local_time = local_adj::<span class="built_in">utc_to_local</span>(utc_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化输出</span></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    time_facet* facet = <span class="keyword">new</span> <span class="built_in">time_facet</span>(formatStr.<span class="built_in">c_str</span>());</span><br><span class="line">    oss.<span class="built_in">imbue</span>(std::<span class="built_in">locale</span>(std::locale::<span class="built_in">classic</span>(), facet));</span><br><span class="line">    oss &lt;&lt; local_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// TIMES_H</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="服务端核心代码"><a href="#服务端核心代码" class="headerlink" title="服务端核心代码"></a>服务端核心代码</h5><div class="admonition note"><p class="admonition-title">提示</p><p>在集群聊天服务端中，使用了 Json 库和 Muduo 网络库，并引入了 MySQL、Redis。</p></div><h6 id="Redis-操作代码"><a href="#Redis-操作代码" class="headerlink" title="Redis 操作代码"></a>Redis 操作代码</h6><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Redis 安装完成后，切记不要设置密码，否则下面的 C++ 代码将无法正常连接 Redis 服务器，这是因为下面的 C++ 代码并没有实现 Redis 的身份认证功能。</p></div><ul><li><code>include/server/redis/redis.hpp</code> 头文件 </li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> REDIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis 操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Redis</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Redis</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接redis服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向redis指定的通道subscribe消息</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">int</span> channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向redis指定的通道unsubscribe消息</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unsubscribe</span><span class="params">(<span class="keyword">int</span> channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在独立线程中异步接收订阅通道中的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">observer_channel_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向redis指定的通道publish消息</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">publish</span><span class="params">(<span class="keyword">int</span> channel, string message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化向业务层上报通道消息的回调对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init_notify_handler</span><span class="params">(function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, string)&gt; fn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// hiredis同步上下文对象（即redis客户端），负责publish消息</span></span><br><span class="line">    redisContext *_publish_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hiredis同步上下文对象（即redis客户端），负责subscribe消息</span></span><br><span class="line">    redisContext *_subcribe_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调操作，收到订阅的消息，给service层上报</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, string)&gt; _notify_message_handler;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/redis/redis.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Redis::<span class="built_in">Redis</span>() : _publish_context(<span class="literal">nullptr</span>), _subcribe_context(<span class="literal">nullptr</span>) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Redis::~<span class="built_in">Redis</span>() {</span><br><span class="line">    <span class="keyword">if</span> (_publish_context != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">redisFree</span>(_publish_context);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_subcribe_context != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">redisFree</span>(_subcribe_context);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接redis服务器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::connect</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 负责publish发布消息的上下文对象（即redis客户端）</span></span><br><span class="line">    _publish_context = <span class="built_in">redisConnect</span>(REDIS_IP.<span class="built_in">c_str</span>(), REDIS_PORT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == _publish_context || _publish_context-&gt;err) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"connect redis failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (_publish_context) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"connect redis error: "</span> &lt;&lt; _publish_context-&gt;errstr &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">redisFree</span>(_publish_context);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负责subscribe订阅消息的上下文对象（即redis客户端）</span></span><br><span class="line">    _subcribe_context = <span class="built_in">redisConnect</span>(REDIS_IP.<span class="built_in">c_str</span>(), REDIS_PORT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == _subcribe_context || _subcribe_context-&gt;err) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"connect redis failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (_subcribe_context) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"connect redis error: "</span> &lt;&lt; _subcribe_context-&gt;errstr &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">redisFree</span>(_subcribe_context);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在单独的线程中，监听通道上的事件，有消息就给业务层进行上报</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([&amp;]() { observer_channel_message(); })</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"connect redis success!"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向redis指定的通道subscribe消息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::subscribe</span><span class="params">(<span class="keyword">int</span> channel)</span> </span>{</span><br><span class="line">    <span class="comment">// SUBSCRIBE命令本身会造成线程阻塞等待通道里面发生消息，这里只做订阅通道，不接收通道消息</span></span><br><span class="line">    <span class="comment">// 通道消息的接收专门在observer_channel_message()函数中的独立线程中进行</span></span><br><span class="line">    <span class="comment">// 这里只负责发送订阅命令，不阻塞接收Redis服务器的响应消息，否则会和notifyMsg线程抢占响应资源</span></span><br><span class="line">    <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisAppendCommand</span>(<span class="keyword">this</span>-&gt;_subcribe_context, <span class="string">"SUBSCRIBE %d"</span>, channel)) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"subscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// redisBufferWrite()函数可以循环发送缓冲区中的数据，直到缓冲区数据发送完毕（done被置为1）</span></span><br><span class="line">    <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) {</span><br><span class="line">        <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisBufferWrite</span>(<span class="keyword">this</span>-&gt;_subcribe_context, &amp;done)) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"subscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向redis指定的通道unsubscribe消息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::unsubscribe</span><span class="params">(<span class="keyword">int</span> channel)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisAppendCommand</span>(<span class="keyword">this</span>-&gt;_subcribe_context, <span class="string">"UNSUBSCRIBE %d"</span>, channel)) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"unsubscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// redisBufferWrite()函数可以循环发送缓冲区中的数据，直到缓冲区数据发送完毕（done被置为1）</span></span><br><span class="line">    <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) {</span><br><span class="line">        <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisBufferWrite</span>(<span class="keyword">this</span>-&gt;_subcribe_context, &amp;done)) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"unsubscribe command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在独立线程中异步接收订阅通道中的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Redis::observer_channel_message</span><span class="params">()</span> </span>{</span><br><span class="line">    redisReply *reply = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (REDIS_OK == <span class="built_in">redisGetReply</span>(<span class="keyword">this</span>-&gt;_subcribe_context, (<span class="keyword">void</span> **)&amp;reply)) {</span><br><span class="line">        <span class="comment">// 订阅收到的消息是一个带三个元素的数组</span></span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="literal">nullptr</span> &amp;&amp; reply-&gt;element[<span class="number">2</span>] != <span class="literal">nullptr</span> &amp;&amp; reply-&gt;element[<span class="number">2</span>]-&gt;str != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="comment">// 给业务层上报通道上发生的消息</span></span><br><span class="line">            _notify_message_handler(<span class="built_in">atoi</span>(reply-&gt;element[<span class="number">1</span>]-&gt;str), reply-&gt;element[<span class="number">2</span>]-&gt;str);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; observer_channel_message quit &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向redis指定的通道publish消息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Redis::publish</span><span class="params">(<span class="keyword">int</span> channel, string message)</span> </span>{</span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">    redisReply *reply = (redisReply *)<span class="built_in">redisCommand</span>(_publish_context, <span class="string">"PUBLISH %d %s"</span>, channel, message.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == reply) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"publish command execute failed!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化向业务层上报通道消息的回调对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Redis::init_notify_handler</span><span class="params">(function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, string)&gt; fn)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;_notify_message_handler = fn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="MySQL-操作代码"><a href="#MySQL-操作代码" class="headerlink" title="MySQL 操作代码"></a>MySQL 操作代码</h6><div class="admonition note"><p class="admonition-title">提示</p><p>这里使用 MySQL C API（Connector/C）库来读写 MySQL 数据库，该库基于 C 语言开发。</p></div><ul><li><code>include/server/db/db.hpp</code> 源文件 </li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DB_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化数据库连接</span></span><br><span class="line">    <span class="built_in">MySQL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放数据库连接</span></span><br><span class="line">    ~<span class="built_in">MySQL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新操作</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询操作</span></span><br><span class="line">    <span class="function">MYSQL_RES *<span class="title">query</span><span class="params">(string sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据库连接</span></span><br><span class="line">    <span class="function">MYSQL *<span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *_conn;  <span class="comment">// 数据库连接</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// DB_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/db/db.cpp</code> 源文件 </li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"db.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数据库连接</span></span><br><span class="line">MySQL::<span class="built_in">MySQL</span>() {</span><br><span class="line">    _conn = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放数据库连接</span></span><br><span class="line">MySQL::~<span class="built_in">MySQL</span>() {</span><br><span class="line">    <span class="keyword">if</span> (_conn != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">mysql_close</span>(_conn);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MySQL::connect</span><span class="params">()</span> </span>{</span><br><span class="line">    MYSQL *p = <span class="built_in">mysql_real_connect</span>(_conn, DB_IP.<span class="built_in">c_str</span>(), DB_USER.<span class="built_in">c_str</span>(), DB_PASSWORD.<span class="built_in">c_str</span>(), DB_NAME.<span class="built_in">c_str</span>(), DB_PORT,</span><br><span class="line">                                  <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="comment">// C和C++代码默认的编码字符是ASCII，如果不设置，从MySQL查询到的中文内容可能会显示？乱码</span></span><br><span class="line">        <span class="built_in">mysql_query</span>(_conn, <span class="string">"set names utf8mb4"</span>);</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"connect mysql success!"</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"connect mysql failed!"</span>;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="built_in">mysql_error</span>(_conn);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MySQL::update</span><span class="params">(string sql)</span> </span>{</span><br><span class="line">    LOG_DEBUG &lt;&lt; sql;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) {</span><br><span class="line">        LOG_ERROR &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">" "</span> &lt;&lt; sql &lt;&lt; <span class="string">" execute failed!"</span>;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="built_in">mysql_error</span>(_conn);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="function">MYSQL_RES *<span class="title">MySQL::query</span><span class="params">(string sql)</span> </span>{</span><br><span class="line">    LOG_DEBUG &lt;&lt; sql;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) {</span><br><span class="line">        LOG_ERROR &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">" "</span> &lt;&lt; sql &lt;&lt; <span class="string">" execute failed!"</span>;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="built_in">mysql_error</span>(_conn);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_store_result</span>(_conn);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据库连接</span></span><br><span class="line"><span class="function">MYSQL *<span class="title">MySQL::getConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> _conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="聊天服务端代码"><a href="#聊天服务端代码" class="headerlink" title="聊天服务端代码"></a>聊天服务端代码</h6><blockquote><p>聊天服务器的代码</p></blockquote><ul><li><code>include/server/chatserver.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CHATSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHATSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器的头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天服务器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ChatServer</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">const</span> string&amp; nameArg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ChatServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 处理用户的连接创建和断开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用户读写事件（比如接收客户端发送的数据）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    TcpServer _server;  <span class="comment">// TCP 服务器对象</span></span><br><span class="line">    EventLoop* _loop;   <span class="comment">// 指向事件回环的指针</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CHATSERVER_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/chatserver.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"chatserver.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"chatservice.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ChatServer::<span class="built_in">ChatServer</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">const</span> string&amp; nameArg)</span><br><span class="line">    : _server(loop, listenAddr, nameArg), _loop(loop) {</span><br><span class="line">    <span class="comment">// 设置服务端注册用户连接的创建和断开回调</span></span><br><span class="line">    _server.<span class="built_in">setConnectionCallback</span>(<span class="built_in">bind</span>(&amp;ChatServer::onConnection, <span class="keyword">this</span>, placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务端注册用户读写事件的回调</span></span><br><span class="line">    _server.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        <span class="built_in">bind</span>(&amp;ChatServer::onMessage, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置EventLoop的线程数量（比如：1个I/O线程，3个Worker线程）</span></span><br><span class="line">    _server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ChatServer::~<span class="built_in">ChatServer</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 开启事件循环处理</span></span><br><span class="line">    _server.<span class="built_in">start</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户的连接创建和断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;<span class="built_in">connected</span>()) {</span><br><span class="line">        <span class="comment">// 处理用户连接关闭的情况</span></span><br><span class="line">        ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">clientConnClose</span>(conn);</span><br><span class="line">        <span class="comment">// 断开连接（释放资源）</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户读写事件（比如接收客户端发送的数据）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取客户端发送的数据</span></span><br><span class="line">    string message = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"server received message : "</span> &lt;&lt; message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON 字符串反序列化</span></span><br><span class="line">    json jsonObj = json::<span class="built_in">parse</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非法消息直接忽略处理</span></span><br><span class="line">    <span class="keyword">if</span> (!jsonObj.<span class="built_in">contains</span>(<span class="string">"msgType"</span>)) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::INVALID_MESSAGE_TYPE;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"消息类型无效"</span>;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="keyword">int</span> msgType = jsonObj[<span class="string">"msgType"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息处理器</span></span><br><span class="line">    <span class="keyword">auto</span> msgHandler = ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">getMsgHandler</span>(msgType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用消息处理器，执行相应的业务处理</span></span><br><span class="line">    <span class="built_in">msgHandler</span>(conn, make_shared&lt;json&gt;(jsonObj), time);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>聊天核心业务的代码</p></blockquote><ul><li><code>include/server/chatservice.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CHATSERVICE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHATSERVICE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天核心业务的头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friendmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"groupmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"groupusermodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessagemodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usermodel.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理消息的回调类型（使用智能指针是为了兼容低版本的G++编译器）</span></span><br><span class="line"><span class="keyword">using</span> MsgHandler = function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天服务器的业务类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatService</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ChatService* <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理登录业务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理注册业务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reg</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理一对一聊天消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">singleChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理添加好友消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFriend</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理创建群组消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理加入群组消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">joinGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理群聊天消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">groupChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理退出登录消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loginOut</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息对应的处理器</span></span><br><span class="line">    <span class="function">MsgHandler <span class="title">getMsgHandler</span><span class="params">(<span class="keyword">int</span> msgType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理Redis订阅通道中发生的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRedisSubScribeMessage</span><span class="params">(<span class="keyword">int</span> userid, string msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用户连接关闭的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clientConnClose</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理服务器退出（Ctrl+C）后的业务重置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">ChatService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">ChatService</span>(<span class="keyword">const</span> ChatService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    ChatService&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ChatService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联消息ID和消息处理器（用于解耦业务代码）</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, MsgHandler&gt; _msgHandlerMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储在线用户的通信连接（操作时必须自行保证线程安全）</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, TcpConnectionPtr&gt; _userConnMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥锁，保证 _userConnMap 的线程安全</span></span><br><span class="line">    mutex _connMapmutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// User 表的数据操作对象</span></span><br><span class="line">    UserModel _userModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OfflineMessage 表的数据操作对象</span></span><br><span class="line">    OfflineMessageModel _offflineMessageModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Friend 表的数据操作对象</span></span><br><span class="line">    FriendModel _friendModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Group 表的数据操作对象</span></span><br><span class="line">    GroupModel _groupModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GroupUser 表的数据操作对象</span></span><br><span class="line">    GroupUserModel _groupUserModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis 操作对象</span></span><br><span class="line">    Redis _redis;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CHATSERVICE_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/chatservice.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器的业务实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"chatservice.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friendmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessagemodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"times.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usermodel.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ChatService::<span class="built_in">ChatService</span>() {</span><br><span class="line">    <span class="comment">// 连接Redis服务器</span></span><br><span class="line">    <span class="keyword">if</span> (_redis.<span class="built_in">connect</span>()) {</span><br><span class="line">        <span class="comment">// 设置Redis订阅通道的回调对象（负责处理Redis订阅消息）</span></span><br><span class="line">        _redis.<span class="built_in">init_notify_handler</span>(</span><br><span class="line">            <span class="built_in">bind</span>(&amp;ChatService::handleRedisSubScribeMessage, <span class="keyword">this</span>, placeholders::_1, placeholders::_2));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联登录业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(</span><br><span class="line">        {MsgType::LOGIN_MSG, <span class="built_in">bind</span>(&amp;ChatService::login, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联注册业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(</span><br><span class="line">        {MsgType::REGISTER_MSG, <span class="built_in">bind</span>(&amp;ChatService::reg, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联一对一聊天业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::SINGLE_CHAT_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::singleChat, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联添加好友业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::ADD_FRIEND_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::addFriend, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联添加群组业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::CREATE_GROUP_MSG, <span class="built_in">bind</span>(&amp;ChatService::createGroup, <span class="keyword">this</span>, placeholders::_1,</span><br><span class="line">                                                           placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联加入群组业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::JOIN_GROUP_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::joinGroup, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联群聊天业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::GROUP_CHAT_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::groupChat, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">    <span class="comment">// 关联退出登录业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>({MsgType::LOGIN_OUT_MSG,</span><br><span class="line">                           <span class="built_in">bind</span>(&amp;ChatService::loginOut, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3)});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">ChatService* <span class="title">ChatService::instance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> ChatService instance;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取消息对应的处理器</span></span><br><span class="line"><span class="function">MsgHandler <span class="title">ChatService::getMsgHandler</span><span class="params">(<span class="keyword">int</span> msgType)</span> </span>{</span><br><span class="line">    <span class="comment">// 查找消息处理器</span></span><br><span class="line">    <span class="keyword">auto</span> it = _msgHandlerMap.<span class="built_in">find</span>(msgType);</span><br><span class="line">    <span class="comment">// 如果消息处理器不存在</span></span><br><span class="line">    <span class="keyword">if</span> (it == _msgHandlerMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 返回一个默认的消息处理器（空操作）</span></span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            LOG_ERROR &lt;&lt; <span class="string">"not found message handler by message type "</span> &lt;&lt; msgType;</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> _msgHandlerMap[msgType];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理Redis订阅通道中发生的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::handleRedisSubScribeMessage</span><span class="params">(<span class="keyword">int</span> userid, string msg)</span> </span>{</span><br><span class="line">    <span class="comment">// JSON 反序列化</span></span><br><span class="line">    json js = json::<span class="built_in">parse</span>(msg.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送的时间</span></span><br><span class="line">    <span class="keyword">long</span> timestamp = js[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息接收者的连接信息</span></span><br><span class="line">    <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(userid);</span><br><span class="line">    <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 消息接收者在线（指在当前聊天服务器中），直接转发消息</span></span><br><span class="line">        it-&gt;second-&gt;<span class="built_in">send</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 当接收到Redis订阅消息时，如果消息接收者刚好下线，则存储离线消息</span></span><br><span class="line">        OfflineMessage <span class="built_in">msg</span>(userid, js.<span class="built_in">dump</span>(), timestamp);</span><br><span class="line">        _offflineMessageModel.<span class="built_in">insert</span>(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理登录业务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::login</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    string name = (*data)[<span class="string">"name"</span>].get&lt;string&gt;();</span><br><span class="line">    string password = (*data)[<span class="string">"password"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户信息</span></span><br><span class="line">    User user = _userModel.<span class="built_in">selectByName</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">    <span class="keyword">if</span> (user.<span class="built_in">getId</span>() != <span class="number">-1</span> &amp;&amp; user.<span class="built_in">getPassword</span>() == password) {</span><br><span class="line">        <span class="comment">// 重复登录</span></span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">getState</span>() == <span class="string">"online"</span>) {</span><br><span class="line">            <span class="comment">// 返回数据给客户端</span></span><br><span class="line">            json response;</span><br><span class="line">            response[<span class="string">"errNum"</span>] = ErrorCode::REPEAT_LOGIN;</span><br><span class="line">            response[<span class="string">"errMsg"</span>] = <span class="string">"该账号在其他设备已登录"</span>;</span><br><span class="line">            response[<span class="string">"msgType"</span>] = MsgType::LOGIN_MSG_ACK;</span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 登录成功</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            unique_lock&lt;mutex&gt; <span class="built_in">lock</span>(_connMapmutex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储在线用户的通信连接</span></span><br><span class="line">            _userConnMap.<span class="built_in">insert</span>({user.<span class="built_in">getId</span>(), conn});</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放互斥锁</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向Redis订阅Channel</span></span><br><span class="line">            _redis.<span class="built_in">subscribe</span>(user.<span class="built_in">getId</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新用户登录状态</span></span><br><span class="line">            user.<span class="built_in">setState</span>(<span class="string">"online"</span>);</span><br><span class="line">            _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回给客户端的数据</span></span><br><span class="line">            json response;</span><br><span class="line">            response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">            response[<span class="string">"userId"</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">            response[<span class="string">"userName"</span>] = user.<span class="built_in">getName</span>();</span><br><span class="line">            response[<span class="string">"msgType"</span>] = MsgType::LOGIN_MSG_ACK;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询该用户是否有离线消息</span></span><br><span class="line">            vector&lt;OfflineMessage&gt; messages = _offflineMessageModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (!messages.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="comment">// 返回该用户的所有离线消息</span></span><br><span class="line">                response[<span class="string">"offlinemsg"</span>] = messages;</span><br><span class="line">                <span class="comment">// 读取该用户的离线消息后，将该用户的离线消息全部删除掉</span></span><br><span class="line">                _offflineMessageModel.<span class="built_in">remove</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询该用户的好友列表</span></span><br><span class="line">            vector&lt;User&gt; friends = _friendModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (!friends.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="comment">// 返回该用户的好友列表</span></span><br><span class="line">                response[<span class="string">"friends"</span>] = friends;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询该用户的群组列表</span></span><br><span class="line">            vector&lt;Group&gt; groups = _groupUserModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (!groups.<span class="built_in">empty</span>()) {</span><br><span class="line">                response[<span class="string">"groups"</span>] = groups;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回数据给客户端</span></span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 登录失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::LOGIN_AUTH_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"用户名或密码不正确"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::LOGIN_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理注册业务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::reg</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建用户对象</span></span><br><span class="line">    string name = (*data)[<span class="string">"name"</span>].get&lt;string&gt;();</span><br><span class="line">    string password = (*data)[<span class="string">"password"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户名是否已被注册</span></span><br><span class="line">    User oldUser = _userModel.<span class="built_in">selectByName</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (oldUser.<span class="built_in">getId</span>() != <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::REPEAT_REGISTER;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"用户名已被注册"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::REGISTER_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户记录</span></span><br><span class="line">    <span class="function">User <span class="title">newUser</span><span class="params">(name, password)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> result = _userModel.<span class="built_in">insert</span>(newUser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户记录成功</span></span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">        response[<span class="string">"userId"</span>] = newUser.<span class="built_in">getId</span>();</span><br><span class="line">        response[<span class="string">"userName"</span>] = newUser.<span class="built_in">getName</span>();</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::REGISTER_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 插入用户记录失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::REGISTER_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"用户注册失败"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::REGISTER_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理一对一聊天消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::singleChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 消息发送者的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> fromId = (*data)[<span class="string">"fromId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送者的用户名称</span></span><br><span class="line">    string fromName = (*data)[<span class="string">"fromName"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送者的消息内容</span></span><br><span class="line">    string fromMsg = (*data)[<span class="string">"fromMsg"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送的时间戳</span></span><br><span class="line">    <span class="keyword">long</span> fromTimestamp = (*data)[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息接收者的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> toId = (*data)[<span class="string">"toId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息接收者是否在当前聊天服务器中</span></span><br><span class="line">    <span class="keyword">bool</span> toExisted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否已经添加消息接收者为好友</span></span><br><span class="line">    Friend friendRel = _friendModel.<span class="built_in">select</span>(fromId, toId);</span><br><span class="line">    <span class="keyword">if</span> (friendRel.<span class="built_in">getUserId</span>() == <span class="number">-1</span> || friendRel.<span class="built_in">getFriendId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::SINGLE_CHAT_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"未添加对方好友, 无法进行一对一聊天"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::SINGLE_CHAT_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息接收者的连接信息</span></span><br><span class="line">    <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(toId);</span><br><span class="line">    <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 记录消息接收者在线（指在当前聊天服务器中）</span></span><br><span class="line">        toExisted = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 消息接收者在线（指在当前聊天服务器中），直接转发消息</span></span><br><span class="line">        it-&gt;second-&gt;<span class="built_in">send</span>((*data).<span class="built_in">dump</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息接收者不在当前聊天服务器中</span></span><br><span class="line">    <span class="keyword">if</span> (!toExisted) {</span><br><span class="line">        User toUser = _userModel.<span class="built_in">select</span>(toId);</span><br><span class="line">        <span class="comment">// 判断消息接收者是否在线（指在其他聊天服务器中）</span></span><br><span class="line">        <span class="keyword">if</span> (toUser.<span class="built_in">getState</span>() == <span class="string">"online"</span>) {</span><br><span class="line">            <span class="comment">// 消息接收者在线，通过Redis发布消息</span></span><br><span class="line">            _redis.<span class="built_in">publish</span>(toId, (*data).<span class="built_in">dump</span>());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 消息接收者不在线，存储离线消息</span></span><br><span class="line">            OfflineMessage <span class="built_in">msg</span>(toId, (*data).<span class="built_in">dump</span>(), fromTimestamp);</span><br><span class="line">            _offflineMessageModel.<span class="built_in">insert</span>(msg);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::SINGLE_CHAT_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理添加好友消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::addFriend</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好友的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> friendId = (*data)[<span class="string">"friendId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制不允许添加自己为好友</span></span><br><span class="line">    <span class="keyword">if</span> (userId == friendId) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::ADD_FRIEND_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"不允许添加自己为好友"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::ADD_FRIEND_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断好友是否真实存在</span></span><br><span class="line">    User friendUser = _userModel.<span class="built_in">select</span>(friendId);</span><br><span class="line">    <span class="keyword">if</span> (friendUser.<span class="built_in">getId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::ADD_FRIEND_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"好友ID不存在"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::ADD_FRIEND_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增好友关系</span></span><br><span class="line">    _friendModel.<span class="built_in">insert</span>(userId, friendId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::ADD_FRIEND_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理创建群组消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::createGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组名称</span></span><br><span class="line">    string groupName = (*data)[<span class="string">"groupName"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组描述</span></span><br><span class="line">    string groupDesc = (*data)[<span class="string">"groupDesc"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增群组</span></span><br><span class="line">    <span class="function">Group <span class="title">group</span><span class="params">(groupName, groupDesc)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> result = _groupModel.<span class="built_in">insert</span>(group);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加群组的创建人信息</span></span><br><span class="line">    <span class="keyword">if</span> (result &amp;&amp; group.<span class="built_in">getId</span>() != <span class="number">-1</span>) {</span><br><span class="line">        GroupUser groupUser;</span><br><span class="line">        groupUser.<span class="built_in">setGroupId</span>(group.<span class="built_in">getId</span>());</span><br><span class="line">        groupUser.<span class="built_in">setUserId</span>(userId);</span><br><span class="line">        groupUser.<span class="built_in">setGroupRole</span>(<span class="string">"creator"</span>);</span><br><span class="line">        <span class="comment">// 新增群组和用户的关联信息</span></span><br><span class="line">        _groupUserModel.<span class="built_in">insert</span>(groupUser);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"groupId"</span>] = group.<span class="built_in">getId</span>();</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::CREATE_GROUP_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理加入群组消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::joinGroup</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组ID</span></span><br><span class="line">    <span class="keyword">int</span> groupId = (*data)[<span class="string">"groupId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断群组是否真实存在</span></span><br><span class="line">    Group group = _groupModel.<span class="built_in">select</span>(groupId);</span><br><span class="line">    <span class="keyword">if</span> (group.<span class="built_in">getId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::JOIN_GROUP_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"群组ID不存在"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::JOIN_GROUP_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增群组和用户的关联信息</span></span><br><span class="line">    <span class="function">GroupUser <span class="title">groupUser</span><span class="params">(groupId, userId, <span class="string">"normal"</span>)</span></span>;</span><br><span class="line">    _groupUserModel.<span class="built_in">insert</span>(groupUser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::JOIN_GROUP_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理群聊天消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::groupChat</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 消息发送者的用户ID</span></span><br><span class="line">    <span class="keyword">int</span> fromId = (*data)[<span class="string">"fromId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送者的用户名称</span></span><br><span class="line">    string fromName = (*data)[<span class="string">"fromName"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送的时间戳</span></span><br><span class="line">    <span class="keyword">long</span> fromTimestamp = (*data)[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组的ID</span></span><br><span class="line">    <span class="keyword">int</span> groupId = (*data)[<span class="string">"groupId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 群组消息的内容</span></span><br><span class="line">    string groupMsg = (*data)[<span class="string">"groupMsg"</span>].get&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户是否已经加入群组</span></span><br><span class="line">    GroupUser groupUser = _groupUserModel.<span class="built_in">select</span>(groupId, fromId);</span><br><span class="line">    <span class="keyword">if</span> (groupUser.<span class="built_in">getGroupId</span>() == <span class="number">-1</span> || groupUser.<span class="built_in">getUserId</span>() == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 返回数据给客户端</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">"errNum"</span>] = ErrorCode::JOIN_GROUP_FAIL;</span><br><span class="line">        response[<span class="string">"errMsg"</span>] = <span class="string">"未加入该群组, 无法进行群聊"</span>;</span><br><span class="line">        response[<span class="string">"msgType"</span>] = MsgType::JOIN_GROUP_MSG_ACK;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询群组内的用户（除了发送群组消息的用户）</span></span><br><span class="line">    vector&lt;User&gt; users = _groupUserModel.<span class="built_in">selectGroupUsers</span>(groupId, fromId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理群聊消息</span></span><br><span class="line">    <span class="keyword">if</span> (!users.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        unique_lock&lt;mutex&gt; lock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历群组内的用户</span></span><br><span class="line">        <span class="keyword">for</span> (User&amp; user : users) {</span><br><span class="line">            <span class="comment">// 获取用户的连接信息</span></span><br><span class="line">            <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">            <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">                <span class="comment">// 用户在线（指在当前聊天服务器中），直接转发群聊消息</span></span><br><span class="line">                it-&gt;second-&gt;<span class="built_in">send</span>((*data).<span class="built_in">dump</span>());</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                User toUser = _userModel.<span class="built_in">select</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">                <span class="comment">// 判断用户是否在线（指在其他聊天服务器中）</span></span><br><span class="line">                <span class="keyword">if</span> (toUser.<span class="built_in">getState</span>() == <span class="string">"online"</span>) {</span><br><span class="line">                    <span class="comment">// 用户在线，通过Redis发布群聊消息</span></span><br><span class="line">                    _redis.<span class="built_in">publish</span>(user.<span class="built_in">getId</span>(), (*data).<span class="built_in">dump</span>());</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 用户不在线，存储离线群聊消息</span></span><br><span class="line">                    OfflineMessage message;</span><br><span class="line">                    message.<span class="built_in">setUserId</span>(user.<span class="built_in">getId</span>());</span><br><span class="line">                    message.<span class="built_in">setCreateTime</span>(fromTimestamp);</span><br><span class="line">                    message.<span class="built_in">setMessage</span>((*data).<span class="built_in">dump</span>());</span><br><span class="line">                    _offflineMessageModel.<span class="built_in">insert</span>(message);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::GROUP_CHAT_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理退出登录消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::loginOut</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, <span class="keyword">const</span> shared_ptr&lt;json&gt;&amp; data, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前用户的ID</span></span><br><span class="line">    <span class="keyword">int</span> userId = (*data)[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除连接信息</span></span><br><span class="line">    <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(userId);</span><br><span class="line">    <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>()) {</span><br><span class="line">        _userConnMap.<span class="built_in">erase</span>(it-&gt;first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往Redis取消订阅Channel</span></span><br><span class="line">    _redis.<span class="built_in">unsubscribe</span>(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新用户的登录状态</span></span><br><span class="line">    User user;</span><br><span class="line">    user.<span class="built_in">setId</span>(userId);</span><br><span class="line">    user.<span class="built_in">setState</span>(<span class="string">"offline"</span>);</span><br><span class="line">    _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据给客户端</span></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">"errNum"</span>] = ErrorCode::SUCCESS;</span><br><span class="line">    response[<span class="string">"msgType"</span>] = MsgType::LOGIN_OUT_MSG_ACK;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户连接关闭的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::clientConnClose</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="comment">// 用户信息</span></span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMapmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Map表中删除用户对应的连接信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = _userConnMap.<span class="built_in">begin</span>(); it != _userConnMap.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second == conn) {</span><br><span class="line">            <span class="comment">// 记录用户ID</span></span><br><span class="line">            user.<span class="built_in">setId</span>(it-&gt;first);</span><br><span class="line">            <span class="comment">// 移除连接信息</span></span><br><span class="line">            _userConnMap.<span class="built_in">erase</span>(it-&gt;first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user.<span class="built_in">getId</span>() != <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// 往Redis取消订阅Channel</span></span><br><span class="line">        _redis.<span class="built_in">unsubscribe</span>(user.<span class="built_in">getId</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新用户的登录状态</span></span><br><span class="line">        user.<span class="built_in">setState</span>(<span class="string">"offline"</span>);</span><br><span class="line">        _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理服务器退出（Ctrl+C）后的业务重置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatService::reset</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 重置所有用户的登录状态</span></span><br><span class="line">    _userModel.<span class="built_in">resetState</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>数据库业务操作的代码</p></blockquote><ul><li><code>include/server/dao/friendmodel.hpp</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FRIENDMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRIENDMODEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Friend 表的数据操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendModel</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加好友关系</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找好友列表</span></span><br><span class="line">    <span class="function">vector&lt;User&gt; <span class="title">select</span><span class="params">(<span class="keyword">int</span> userid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找好友关系</span></span><br><span class="line">    <span class="function">Friend <span class="title">select</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// FRIENDMODEL_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>src/server/dao/friendmodel.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;friendmodel.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"db.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加好友关系</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FriendModel::insert</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> sql[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 SQL 语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">"insert into friend(userid, friendid) values(%d, %d)"</span>, userid, friendid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 SQL 语句</span></span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>() &amp;&amp; mysql.<span class="built_in">update</span>(sql)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找好友列表</span></span><br><span class="line"><span class="function">vector&lt;User&gt; <span class="title">FriendModel::select</span><span class="params">(<span class="keyword">int</span> userid)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> sql[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询结果</span></span><br><span class="line">    vector&lt;User&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 SQL 语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql,</span><br><span class="line">            <span class="string">"select u.id, u.name, u.state from friend f inner join user u on f.friendid = u.id where f.userid = %d"</span>,</span><br><span class="line">            userid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 SQL 语句</span></span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>()) {</span><br><span class="line">        MYSQL_RES* res = mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">mysql_num_rows</span>(res) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 获取所有查询结果</span></span><br><span class="line">            MYSQL_ROW row;</span><br><span class="line">            <span class="keyword">while</span> ((row = <span class="built_in">mysql_fetch_row</span>(res)) != <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">int</span> id = <span class="built_in">atoi</span>(row[<span class="number">0</span>]);</span><br><span class="line">                string name = row[<span class="number">1</span>];</span><br><span class="line">                string state = row[<span class="number">2</span>];</span><br><span class="line">                result.<span class="built_in">emplace_back</span>(id, name, state);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回查询结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找好友关系</span></span><br><span class="line"><span class="function">Friend <span class="title">FriendModel::select</span><span class="params">(<span class="keyword">int</span> userid, <span class="keyword">int</span> friendid)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> sql[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询结果</span></span><br><span class="line">    Friend result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 SQL 语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">"select userid, friendid from friend where userid = %d and friendid = %d"</span>, userid, friendid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 SQL 语句</span></span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>()) {</span><br><span class="line">        MYSQL_RES* res = mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">mysql_num_rows</span>(res) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 获取所有查询结果</span></span><br><span class="line">            MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res);</span><br><span class="line">            result.<span class="built_in">setUserId</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">            result.<span class="built_in">setFriendId</span>(<span class="built_in">atoi</span>(row[<span class="number">1</span>]));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回查询结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="客户端核心代码"><a href="#客户端核心代码" class="headerlink" title="客户端核心代码"></a>客户端核心代码</h5><h6 id="聊天客户端代码"><a href="#聊天客户端代码" class="headerlink" title="聊天客户端代码"></a>聊天客户端代码</h6><div class="admonition note"><p class="admonition-title">提示</p><p>在集群聊天客户端中，使用了 Linux 的 <code>socket</code> 和 <code>semaphore</code>，并没有引入 Muduo 网络库。</p></div><ul><li><code>src/client/main.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"group.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"groupmodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessage.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"offlinemessagemodel.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"times.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usermodel.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录当前登录用户的基本信息</span></span><br><span class="line">User g_currentUser;</span><br><span class="line"><span class="comment">// 记录当前登录用户的好友列表信息</span></span><br><span class="line">vector&lt;User&gt; g_currentUserFriendList;</span><br><span class="line"><span class="comment">// 记录当前登录用户的群组列表信息</span></span><br><span class="line">vector&lt;Group&gt; g_currentUserGroupList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于读/写线程之间的通信</span></span><br><span class="line"><span class="keyword">sem_t</span> rwsem;</span><br><span class="line"><span class="comment">// 控制主菜单程序运行</span></span><br><span class="line"><span class="keyword">bool</span> isMainMenuRunning = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 记录用户的登录状态</span></span><br><span class="line"><span class="keyword">atomic_bool</span> g_isLoginSuccess{<span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主菜单程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainMenu</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 子线程接收到消息后的处理逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readTaskHandler</span><span class="params">(<span class="keyword">int</span> clientfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示当前登录用户的基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showCurrentUserData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////首页功能/////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天客户端程序实现, 主线程用作消息发送线程, 子线程用作消息接收线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"command invalid, example: ./chat_client 127.0.0.1 8000"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析通过命令行参数传递的IP和端口号</span></span><br><span class="line">    <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建client端的socket</span></span><br><span class="line">    <span class="keyword">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clientfd) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"socket create failed"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填写client需要连接的服务器信息（IP和端口号）</span></span><br><span class="line">    sockaddr_in server;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sockaddr_in));</span><br><span class="line"></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client和server进行连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">connect</span>(clientfd, (sockaddr *)&amp;server, <span class="built_in"><span class="keyword">sizeof</span></span>(sockaddr_in))) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"connect server failed"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化读写线程通信用的信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;rwsem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器成功, 启动一个接收消息的子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">readTask</span><span class="params">(readTaskHandler, clientfd)</span></span>;</span><br><span class="line">    readTask.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程用于接收用户输入, 负责发送数据</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 显示首页面菜单: 登录、注册、退出程序</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"========================"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"1. login"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"2. register"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"3. quit"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"========================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户输入验证循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"choice: "</span>;</span><br><span class="line">            cin &gt;&gt; choice;</span><br><span class="line">            <span class="comment">// 判断输入是否合法</span></span><br><span class="line">            <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) {</span><br><span class="line">                <span class="comment">// 输入不是整数，清除错误标志</span></span><br><span class="line">                cin.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">                cin.<span class="built_in">ignore</span>(<span class="number">10000</span>, <span class="string">'\n'</span>);</span><br><span class="line">                cerr &lt;&lt; <span class="string">"invalid choice!"</span> &lt;&lt; endl;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 清除残留的换行符</span></span><br><span class="line">                cin.<span class="built_in">ignore</span>(<span class="number">10000</span>, <span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据用户输入执行操作</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (choice) {</span><br><span class="line">            <span class="comment">// 登录业务</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: {</span><br><span class="line">                <span class="keyword">char</span> name[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                <span class="keyword">char</span> password[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                cout &lt;&lt; <span class="string">"user name: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(name, <span class="number">50</span>);</span><br><span class="line">                cout &lt;&lt; <span class="string">"user password: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(password, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">                json js;</span><br><span class="line">                js[<span class="string">"msgType"</span>] = LOGIN_MSG;</span><br><span class="line">                js[<span class="string">"name"</span>] = name;</span><br><span class="line">                js[<span class="string">"password"</span>] = password;</span><br><span class="line">                string request = js.<span class="built_in">dump</span>();</span><br><span class="line"></span><br><span class="line">                g_isLoginSuccess = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, request.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(request.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) {</span><br><span class="line">                    cerr &lt;&lt; <span class="string">"send login msg error: "</span> &lt;&lt; request &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待信号量, 由子线程处理完登录的响应消息后, 通知主线程继续执行</span></span><br><span class="line">                <span class="built_in">sem_wait</span>(&amp;rwsem);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 用户登录成功</span></span><br><span class="line">                <span class="keyword">if</span> (g_isLoginSuccess) {</span><br><span class="line">                    <span class="comment">// 进入聊天主菜单</span></span><br><span class="line">                    isMainMenuRunning = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">mainMenu</span>(clientfd);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 注册业务</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: {</span><br><span class="line">                <span class="keyword">char</span> name[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                <span class="keyword">char</span> pwd[<span class="number">50</span>] = {<span class="number">0</span>};</span><br><span class="line">                cout &lt;&lt; <span class="string">"user name: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(name, <span class="number">50</span>);</span><br><span class="line">                cout &lt;&lt; <span class="string">"user password: "</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(pwd, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">                json js;</span><br><span class="line">                js[<span class="string">"msgType"</span>] = REGISTER_MSG;</span><br><span class="line">                js[<span class="string">"name"</span>] = name;</span><br><span class="line">                js[<span class="string">"password"</span>] = pwd;</span><br><span class="line">                string request = js.<span class="built_in">dump</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, request.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(request.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) {</span><br><span class="line">                    cerr &lt;&lt; <span class="string">"send reg msg error: "</span> &lt;&lt; request &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待信号量, 由子线程处理完注册的响应消息后, 通知主线程继续执行</span></span><br><span class="line">                <span class="built_in">sem_wait</span>(&amp;rwsem);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 退出程序业务</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">close</span>(clientfd);</span><br><span class="line">                <span class="built_in">sem_destroy</span>(&amp;rwsem);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cerr &lt;&lt; <span class="string">"invalid choice!"</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理注册的响应逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRegResponse</span><span class="params">(json &amp;responsejs)</span> </span>{</span><br><span class="line">    <span class="comment">// 注册失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != responsejs[<span class="string">"errNum"</span>].get&lt;<span class="keyword">int</span>&gt;()) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"注册失败: "</span> &lt;&lt; responsejs[<span class="string">"errMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 注册成功</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"注册成功, 用户ID: "</span> &lt;&lt; responsejs[<span class="string">"userId"</span>] &lt;&lt; <span class="string">" , 用户名称: "</span> &lt;&lt; responsejs[<span class="string">"userName"</span>].get&lt;string&gt;()</span><br><span class="line">             &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理登录的响应逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoginResponse</span><span class="params">(json &amp;responsejs)</span> </span>{</span><br><span class="line">    <span class="comment">// 登录失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != responsejs[<span class="string">"errNum"</span>].get&lt;<span class="keyword">int</span>&gt;()) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"登录失败: "</span> &lt;&lt; responsejs[<span class="string">"errMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">        g_isLoginSuccess = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 记录当前登录用户的基本信息</span></span><br><span class="line">        g_currentUser.<span class="built_in">setId</span>(responsejs[<span class="string">"userId"</span>].get&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        g_currentUser.<span class="built_in">setName</span>(responsejs[<span class="string">"userName"</span>].get&lt;string&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前用户的好友列表信息</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">"friends"</span>)) {</span><br><span class="line">            <span class="comment">// 初始化好友列表</span></span><br><span class="line">            g_currentUserFriendList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            vector&lt;User&gt; vec = responsejs[<span class="string">"friends"</span>];</span><br><span class="line">            <span class="keyword">for</span> (User &amp;user : vec) {</span><br><span class="line">                g_currentUserFriendList.<span class="built_in">push_back</span>(user);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前用户的群组列表信息</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">"groups"</span>)) {</span><br><span class="line">            <span class="comment">// 初始化群组列表</span></span><br><span class="line">            g_currentUserGroupList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            vector&lt;Group&gt; vec = responsejs[<span class="string">"groups"</span>];</span><br><span class="line">            <span class="keyword">for</span> (Group &amp;group : vec) {</span><br><span class="line">                g_currentUserGroupList.<span class="built_in">push_back</span>(group);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示登录用户的基本信息</span></span><br><span class="line">        <span class="built_in">showCurrentUserData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示当前用户的离线消息（个人聊天信息或者群组消息）</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">"offlinemsg"</span>)) {</span><br><span class="line">            vector&lt;OfflineMessage&gt; vec = responsejs[<span class="string">"offlinemsg"</span>];</span><br><span class="line">            <span class="keyword">for</span> (OfflineMessage &amp;message : vec) {</span><br><span class="line">                <span class="comment">// 离线消息的内容（JSON字符串）</span></span><br><span class="line">                json content = json::<span class="built_in">parse</span>(message.<span class="built_in">getMessage</span>());</span><br><span class="line">                <span class="comment">// 离线消息的发送时间</span></span><br><span class="line">                string datetime = formatTimestampLocal(message.<span class="built_in">getCreateTime</span>(), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">                <span class="comment">// 打印一对一聊天消息</span></span><br><span class="line">                <span class="keyword">if</span> (SINGLE_CHAT_MSG == content[<span class="string">"msgType"</span>].get&lt;<span class="keyword">int</span>&gt;()) {</span><br><span class="line">                    cout &lt;&lt; <span class="string">"好友消息["</span> &lt;&lt; content[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" "</span></span><br><span class="line">                         &lt;&lt; content[<span class="string">"fromName"</span>].get&lt;string&gt;() &lt;&lt; <span class="string">" said: "</span> &lt;&lt; content[<span class="string">"fromMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 打印群组聊天消息</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    cout &lt;&lt; <span class="string">"群聊消息["</span> &lt;&lt; content[<span class="string">"groupId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" ["</span> &lt;&lt; content[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span></span><br><span class="line">                         &lt;&lt; content[<span class="string">"fromName"</span>].get&lt;string&gt;() &lt;&lt; <span class="string">" said: "</span> &lt;&lt; content[<span class="string">"groupMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        g_isLoginSuccess = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程（接收消息的线程）执行的业务逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readTaskHandler</span><span class="params">(<span class="keyword">int</span> clientfd)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">recv</span>(clientfd, buffer, <span class="number">1024</span>, <span class="number">0</span>);  <span class="comment">// 阻塞等待消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == len || <span class="number">0</span> == len) {</span><br><span class="line">            <span class="built_in">close</span>(clientfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收ChatServer转发的数据, 反序列化生成JSON数据对象</span></span><br><span class="line">        json js = json::<span class="built_in">parse</span>(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息类型</span></span><br><span class="line">        <span class="keyword">int</span> msgType = js[<span class="string">"msgType"</span>].get&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 错误编码</span></span><br><span class="line">        <span class="keyword">int</span> errNum = js.<span class="built_in">contains</span>(<span class="string">"errNum"</span>) ? js[<span class="string">"errNum"</span>].get&lt;<span class="keyword">int</span>&gt;() : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理接收到的一对一聊天消息</span></span><br><span class="line">        <span class="keyword">if</span> (SINGLE_CHAT_MSG == msgType) {</span><br><span class="line">            string datetime = formatTimestampLocal(js[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;(), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">"好友消息["</span> &lt;&lt; js[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" "</span> &lt;&lt; js[<span class="string">"fromName"</span>].get&lt;string&gt;()</span><br><span class="line">                 &lt;&lt; <span class="string">" said: "</span> &lt;&lt; js[<span class="string">"fromMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理接收到的群组聊天消息</span></span><br><span class="line">        <span class="keyword">if</span> (GROUP_CHAT_MSG == msgType) {</span><br><span class="line">            string datetime = formatTimestampLocal(js[<span class="string">"fromTimestamp"</span>].get&lt;<span class="keyword">long</span>&gt;(), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">"群聊消息["</span> &lt;&lt; js[<span class="string">"groupId"</span>] &lt;&lt; <span class="string">"] "</span> &lt;&lt; datetime &lt;&lt; <span class="string">" ["</span> &lt;&lt; js[<span class="string">"fromId"</span>] &lt;&lt; <span class="string">"] "</span></span><br><span class="line">                 &lt;&lt; js[<span class="string">"fromName"</span>].get&lt;string&gt;() &lt;&lt; <span class="string">" said: "</span> &lt;&lt; js[<span class="string">"groupMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理登录响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (LOGIN_MSG_ACK == msgType) {</span><br><span class="line">            <span class="built_in">doLoginResponse</span>(js);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;rwsem);  <span class="comment">// 通知主线程, 登录结果处理完成</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理注册响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (REGISTER_MSG_ACK == msgType) {</span><br><span class="line">            <span class="built_in">doRegResponse</span>(js);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;rwsem);  <span class="comment">// 通知主线程, 注册结果处理完成</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理成功创建群组响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (CREATE_GROUP_MSG_ACK == msgType &amp;&amp; SUCCESS == errNum) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"群组创建成功, 群组ID: "</span> &lt;&lt; js[<span class="string">"groupId"</span>].get&lt;<span class="keyword">int</span>&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理成功加入群组响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (JOIN_GROUP_MSG_ACK == msgType &amp;&amp; SUCCESS == errNum) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"加入群组成功"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理成功添加好友响应的业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (ADD_FRIEND_MSG_ACK == msgType &amp;&amp; SUCCESS == errNum) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"好友添加成功"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理其他业务的错误响应</span></span><br><span class="line">        <span class="keyword">if</span> (SUCCESS != errNum &amp;&amp; js.<span class="built_in">contains</span>(<span class="string">"errMsg"</span>)) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"操作失败: "</span> &lt;&lt; js[<span class="string">"errMsg"</span>].get&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示当前登录成功用户的基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showCurrentUserData</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"======================login user======================"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"current login user =&gt; id:"</span> &lt;&lt; g_currentUser.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" name:"</span> &lt;&lt; g_currentUser.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------friend list---------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!g_currentUserFriendList.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">for</span> (User &amp;user : g_currentUserFriendList) {</span><br><span class="line">            cout &lt;&lt; user.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getName</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getState</span>() &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------group list----------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!g_currentUserGroupList.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">for</span> (Group &amp;group : g_currentUserGroupList) {</span><br><span class="line">            cout &lt;&lt; group.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; group.<span class="built_in">getGroupName</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; group.<span class="built_in">getGroupDesc</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (User &amp;user : group.<span class="built_in">getUsers</span>()) {</span><br><span class="line">                cout &lt;&lt; user.<span class="built_in">getId</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getName</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; user.<span class="built_in">getState</span>() &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"======================================================"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////主菜单功能/////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "help" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span> fd = <span class="number">0</span>, string str = <span class="string">""</span>)</span></span>;</span><br><span class="line"><span class="comment">// "singlechat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">singlechat</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "addfriend" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfriend</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "creategroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creategroup</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "joingroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joingroup</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "groupchat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">groupchat</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"><span class="comment">// "loginout" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loginout</span><span class="params">(<span class="keyword">int</span>, string)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统支持的客户端命令列表</span></span><br><span class="line">unordered_map&lt;string, string&gt; commandMap = {{<span class="string">"help"</span>, <span class="string">"显示所有支持的命令, 格式 help"</span>},</span><br><span class="line">                                            {<span class="string">"singlechat"</span>, <span class="string">"一对一聊天, 格式 singlechat:friendid:message"</span>},</span><br><span class="line">                                            {<span class="string">"addfriend"</span>, <span class="string">"添加好友, 格式 addfriend:friendid"</span>},</span><br><span class="line">                                            {<span class="string">"creategroup"</span>, <span class="string">"创建群组, 格式 creategroup:groupname:groupdesc"</span>},</span><br><span class="line">                                            {<span class="string">"joingroup"</span>, <span class="string">"加入群组, 格式 joingroup:groupid"</span>},</span><br><span class="line">                                            {<span class="string">"groupchat"</span>, <span class="string">"群组聊天, 格式 groupchat:groupid:message"</span>},</span><br><span class="line">                                            {<span class="string">"loginout"</span>, <span class="string">"退出登录, 格式 loginout"</span>}};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册系统支持的客户端命令处理</span></span><br><span class="line">unordered_map&lt;string, function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, string)&gt;&gt; commandHandlerMap = {</span><br><span class="line">    {<span class="string">"help"</span>, help},           {<span class="string">"singlechat"</span>, singlechat}, {<span class="string">"addfriend"</span>, addfriend}, {<span class="string">"creategroup"</span>, creategroup},</span><br><span class="line">    {<span class="string">"joingroup"</span>, joingroup}, {<span class="string">"groupchat"</span>, groupchat},   {<span class="string">"loginout"</span>, loginout}};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主菜单程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainMenu</span><span class="params">(<span class="keyword">int</span> clientfd)</span> </span>{</span><br><span class="line">    <span class="built_in">help</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">while</span> (isMainMenuRunning) {</span><br><span class="line">        <span class="comment">// 存储用户选择执行的命令</span></span><br><span class="line">        string command;</span><br><span class="line">        cin.<span class="built_in">getline</span>(buffer, <span class="number">1024</span>);</span><br><span class="line">        <span class="function">string <span class="title">commandbuf</span><span class="params">(buffer)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> idx = commandbuf.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">            command = commandbuf;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            command = commandbuf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找相应命令的事件处理器</span></span><br><span class="line">        <span class="keyword">auto</span> it = commandHandlerMap.<span class="built_in">find</span>(command);</span><br><span class="line">        <span class="keyword">if</span> (it == commandHandlerMap.<span class="built_in">end</span>()) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"invalid input command!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用相应命令的事件处理回调函数</span></span><br><span class="line">        it-&gt;<span class="built_in">second</span>(clientfd, commandbuf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, commandbuf.<span class="built_in">size</span>() - idx));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "help" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>, string)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"&gt;&gt;&gt; show command list &gt;&gt;&gt; "</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : commandMap) {</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">" : "</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "addfriend" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfriend</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式: friendid</span></span><br><span class="line">    <span class="keyword">int</span> friendId = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (friendId &lt;= <span class="number">0</span>) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"add friend command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = ADD_FRIEND_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"friendId"</span>] = friendId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send add friend msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "singlechat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">singlechat</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式: friendid:message</span></span><br><span class="line">    <span class="keyword">int</span> idx = str.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"single chat command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> friendId = <span class="built_in">atoi</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>, idx).<span class="built_in">c_str</span>());</span><br><span class="line">    string message = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = SINGLE_CHAT_MSG;</span><br><span class="line">    request[<span class="string">"fromId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"fromName"</span>] = g_currentUser.<span class="built_in">getName</span>();</span><br><span class="line">    request[<span class="string">"fromMsg"</span>] = message;</span><br><span class="line">    request[<span class="string">"fromTimestamp"</span>] = <span class="built_in">getTimestampMs</span>();</span><br><span class="line">    request[<span class="string">"toId"</span>] = friendId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send single chat msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "creategroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creategroup</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式: groupname:groupdesc</span></span><br><span class="line">    <span class="keyword">int</span> idx = str.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"create group command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    string groupName = str.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">    string groupDesc = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = CREATE_GROUP_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"groupName"</span>] = groupName;</span><br><span class="line">    request[<span class="string">"groupDesc"</span>] = groupDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send create group msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "joingroup" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joingroup</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式：groupid</span></span><br><span class="line">    <span class="keyword">int</span> groupId = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (groupId &lt;= <span class="number">0</span>) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"join group command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = JOIN_GROUP_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"groupId"</span>] = groupId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send join group msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "groupchat" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">groupchat</span><span class="params">(<span class="keyword">int</span> clientfd, string str)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据格式：groupid:message</span></span><br><span class="line">    <span class="keyword">int</span> idx = str.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == idx) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"group chat command invalid!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> groupId = <span class="built_in">atoi</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>, idx).<span class="built_in">c_str</span>());</span><br><span class="line">    string groupMsg = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = GROUP_CHAT_MSG;</span><br><span class="line">    request[<span class="string">"fromId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    request[<span class="string">"fromName"</span>] = g_currentUser.<span class="built_in">getName</span>();</span><br><span class="line">    request[<span class="string">"fromTimestamp"</span>] = <span class="built_in">getTimestampMs</span>();</span><br><span class="line">    request[<span class="string">"groupId"</span>] = groupId;</span><br><span class="line">    request[<span class="string">"groupMsg"</span>] = groupMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send group chat msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// "loginout" command handler</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loginout</span><span class="params">(<span class="keyword">int</span> clientfd, string)</span> </span>{</span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    json request;</span><br><span class="line">    request[<span class="string">"msgType"</span>] = LOGIN_OUT_MSG;</span><br><span class="line">    request[<span class="string">"userId"</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    string buffer = request.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == len) {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"send login out msg error -&gt; "</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        isMainMenuRunning = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h4><ul><li><p>(1) 启动 Nginx、Redis、MySQL 服务，并配置 Nginx 的 TCP 负载均衡器</p></li><li><p>(2) 启动集群聊天服务端程序</p><ul><li>启动第一个聊天服务端程序：<code>./bin/chat_server 127.0.0.1 6000</code></li><li>启动第二个聊天服务端程序：<code>./bin/chat_server 127.0.0.1 6002</code></li></ul></li><li><p>(3) 启动集群聊天客户端程序</p><ul><li>启动第一个聊天客户端程序：<code>./bin/chat_client 127.0.0.1 8000</code>，连接的是 Nginx 的 TCP 负载均衡器</li><li>启动第二个聊天客户端程序：<code>./bin/chat_client 127.0.0.1 8000</code>，连接的是 Nginx 的 TCP 负载均衡器</li></ul></li></ul><h2 id="项目输出"><a href="#项目输出" class="headerlink" title="项目输出"></a>项目输出</h2><h3 id="输出求职简历"><a href="#输出求职简历" class="headerlink" title="输出求职简历"></a>输出求职简历</h3><ul><li><p>项目名称</p><ul><li>集群聊天服务器</li><li>基于 Muduo 网络库实现的集群聊天服务器</li></ul></li><li><p>开发工具</p><ul><li>VSCode 远程 Linux 开发</li><li> CMake 构建 C/C++ 项目</li><li> Linux Shell 编写项目自动编译脚本</li></ul></li><li><p>项目内容</p><ul><li>使用 Muduo 网络库实现项目的网络核心模块，提供高并发网络 I/O 服务，解耦网络和业务模块的代码</li><li>使用 Json 序列化和反序列化消息作为私有通信协议</li><li>配置 Nginx 基于 TCP 的负载均衡，实现聊天服务器的集群功能，提高后端服务的并发能力</li><li>基于 Redis 的发布 - 订阅功能，实现客户端跨服务器通信</li><li>使用 MySQL 关系型数据库作为项目数据的落地存储</li><li>使用数据库连接池提高数据库的访问性能</li></ul></li><li><p>项目收获</p><ul><li>熟悉了基于 Muduo 网络库进行服务端程序开发</li><li>掌握了 Nginx 的 TCP 负载均衡配置</li><li>掌握了 MySQL 和服务端中间件 Redis 的应用</li></ul></li><li><p>项目问题</p><ul><li>问题描述<ul><li>通过代码脚本或者专业的压测工具（比如 JMeter）测试聊天服务器的并发性能</li></ul></li><li>问题解决<ul><li>设置进程可使用文件描述符（<code>fd</code>）资源的上限数量，提高聊天服务器的并发性能</li></ul></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在面试流程中描述项目内容时，切忌详细罗列项目中的业务，重点是介绍项目用到什么技术，突出技术点 。</p></div><h3 id="常见的面试题"><a href="#常见的面试题" class="headerlink" title="常见的面试题"></a>常见的面试题</h3><h4 id="为什么要使用-Redis"><a href="#为什么要使用-Redis" class="headerlink" title="为什么要使用 Redis"></a>为什么要使用 Redis</h4><ul><li><p>问题描述</p><ul><li>为什么要使用 Redis 来实现客户端跨服务器通信？各个聊天服务器之间能不能直接进行通信呢？</li></ul></li><li><p>问题解答</p><ul><li><a href="../../../asset/2025/06/cxx-chatserver-qa-1.png">这里的设计</a>，会在各个 ChatServer 服务器互相之间直接建立 TCP 连接进行通信，相当于在服务器网络之间进行广播。这样的设计使得各个服务器之间耦合度太高，不利于系统扩展，并且会占用系统大量的 Socket 资源，各服务器之间的带宽压力很大，不能够节省资源给更多的客户端提供服务，因此绝对不是一个好的设计。</li><li>集群部署的服务器之间进行通信，最好的方式就是引入消息队列中间件，解耦各个服务器，使整个系统松耦合，提高服务器的响应能力，节省服务器的带宽资源，整体的设计应该 <a href="../../../asset/2025/06/cxx-chatserver-qa-2.png">如此</a>。</li><li>在集群环境中，经常使用的消息队列中间件有 ActiveMQ、RabbitMQ、Kafka、RocketMQ 等，它们都是应用场景广泛并且性能很好的消息队列，供集群服务器、分布式服务之间进行消息通信。限于集群聊天服务器项目的业务并不是非常复杂，并且对并发性能也没有太高的要求，因此消息队列选型的是 - Redis 发布 - 订阅。</li></ul></li></ul><h4 id="Redis-实现的功能不稳定"><a href="#Redis-实现的功能不稳定" class="headerlink" title="Redis 实现的功能不稳定"></a>Redis 实现的功能不稳定</h4><ul><li><p>问题描述</p><ul><li>当消息的生产速度大于消息的消费速度时，随着时间的推移，会造成 Redis 积压消息；如果消息积压的数量太大，会导致内存占用激增，Redis 最终可能会宕机。</li></ul></li><li><p>问题解答</p><ul><li>使用消息队列中间件替代 Redis 的发布 - 订阅功能，比如 Kafka、RabbitMQ、RocketMQ 等。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Redis 的主要功能有：缓存数据库（支持持久化）、分布式锁、发布 - 订阅，其中发布 - 订阅功能只适用于非核心业务、流量不是很大的业务。</p></div><h4 id="如何保证消息的可靠传输"><a href="#如何保证消息的可靠传输" class="headerlink" title="如何保证消息的可靠传输"></a>如何保证消息的可靠传输</h4><ul><li><p>问题描述</p><ul><li>如何保证客户端发送出去的消息，一定能够被服务端接收到，从而保证消息不丢失呢？</li></ul></li><li><p>问题解答</p><ul><li>在业务层中，可以通过消息序号 + ACK 应答机制实现消息的可靠传输，实现步骤如下：</li><li>(1) 客户端发送的每条消息都附加一个递增的 <code>seq</code> 序号（比如 1、2、3）。</li><li>(2) 客户端将未被确认的消息保存在本地的缓存队列中，用于后续重发和确认处理。</li><li>(3) 服务端收到消息后，返回 ACK 应答给客户端，标明确认的消息序号（比如 <code>seq:1</code>）。</li><li>(4) 客户端处理 ACK 响应：客户端接收到 ACK 响应后，从本地缓存队列中移除对应 <code>seq</code> 的消息，表示消息已被成功确认。</li><li>(5) 消息重发机制：客户端启动一个定时器线程，定时扫描缓存队列中未被确认的消息（比如每 3 秒扫描一次）。如果某条消息在一定时间内（比如 5 秒）未收到 ACK 确认，则自动重发该消息，直到收到服务端的 ACK 确认或者超过最大重试次数。</li></ul></li></ul><h4 id="如何保证数据传输的安全性"><a href="#如何保证数据传输的安全性" class="headerlink" title="如何保证数据传输的安全性"></a>如何保证数据传输的安全性</h4><ul><li><p>问题描述</p><ul><li>由于数据（比如聊天消息）是明文传输的，存在一定的数据安全问题，如何解决？</li></ul></li><li><p>问题解答</p><ul><li>使用对称加密算法（如 AES）和非对称加密算法（如 RSA）来保证数据传输的安全性，实现步骤如下：</li><li>(1) 客户端登录时，使用服务端的 RSA 公钥加密数据，其中的数据包含一个随机生成的 AES 密钥和登录信息，然后将加密后的数据发送给服务端。</li><li>(2) 服务端收到数据后，使用自己的 RSA 私钥解密数据，获得客户端的 AES 密钥和登录信息，并完成身份验证。</li><li>(3) 后续通信阶段，客户端与服务端使用同一个 AES 密钥对数据进行对称加密和解密，从而实现高效且安全的数据传输。</li><li>(4) AES 密钥应为一次性生成的会话密钥（Session Key）。RSA 加解密只用于密钥交换和登录信息保护，后续通信使用高性能的 AES 加解密。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">加密算法介绍</p><ul><li>在大型的 IM 软件（比如 QQ）中，会同时使用到对称加密算法和非对称加密算法，兼顾考虑数据安全性和加解密效率。</li><li><code>对称加密算法</code>：使用同一个密钥进行加密和解密，速度快，但需要考虑安全地共享密钥。常见的对称加密算法包括 DES、AES、3DES 等。</li><li><code>非对称加密算法</code>：使用一对公钥和私钥，公钥负责加密、私钥负责解密，安全性高，速度慢，适用于密钥交换与身份验证。常见的非对称加密算法包括 DSA、RSA、ECC 等。</li></ul></div><h4 id="客户端消息如何按顺序显示"><a href="#客户端消息如何按顺序显示" class="headerlink" title="客户端消息如何按顺序显示"></a>客户端消息如何按顺序显示</h4><ul><li><p>问题描述</p><ul><li>客户端接收到服务端发送的消息，如何按顺序显示？</li></ul></li><li><p>问题解答</p><ul><li>(1) 服务端消息加序号：服务端发送的每条消息都附加一个递增的 <code>seq</code> 序号，每个用户或会话维护独立的 <code>seq</code> 序号。</li><li>(2) 客户端缓存乱序消息：客户端接收到消息后，放入本地的有序缓存中，并使用 <code>expected_seq</code> 表示下一条应该显示的消息的序号。</li><li>(3) 按序显示 + 缓存清理：若客户端接收到消息序号等于 <code>expected_seq</code>，则立即显示，并从缓存中继续查找后续的连续消息，依次显示。</li><li>(4) 处理乱序和丢包：如果客户端接收到的是 <code>seq &gt; expected_seq</code>，则先缓存消息，暂时不显示。若某条消息长时间未到达，可发起消息重传请求或跳过处理。</li></ul></li></ul><h4 id="历史聊天消息应该如何存储"><a href="#历史聊天消息应该如何存储" class="headerlink" title="历史聊天消息应该如何存储"></a>历史聊天消息应该如何存储</h4><ul><li><p>问题描述</p><ul><li>历史聊天消息，有哪些存储方案？</li></ul></li><li><p>问题解答</p><ul><li>本地消息存储<ul><li>使用 SQLite 等嵌入式数据库：轻量、便于查询，适合单设备离线存储。</li><li>使用本地文件系统：以用户或群组为单位创建文件夹，按日期或大小分多个文件保存，适合大批量存储，读取简单但查询不方便。</li></ul></li><li>云端消息存储<ul><li>使用关系型数据库（如 MySQL）：结构化存储，支持高效查询和分页加载，适合结构清晰的聊天记录。</li><li>使用文件存储系统（如对象存储或分布式文件系统）：适合存储大批量的聊天原始记录或备份数据，读取顺序性强，但查询性能较弱。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">大规模系统中的历史聊天消息存储</p><ul><li>(1) 消息队列 + 消息落库架构，提升写入性能。</li><li>(2) Elasticsearch 作为全文索引系统，用于历史聊天记录搜索。</li><li>(3) 冷热数据分离：近期消息存储在数据库，历史消息转存在文件存储系统（如对象存储或分布式文件系统）。</li></ul></div><h4 id="如何感知客户端在线还是掉线"><a href="#如何感知客户端在线还是掉线" class="headerlink" title="如何感知客户端在线还是掉线"></a>如何感知客户端在线还是掉线</h4><ul><li><p>问题描述</p><ul><li>如果网络拥堵严重，ChatServer（聊天服务端）如何感知 ChatClient（聊天客户端）在线还是掉线呢？</li></ul></li><li><p>问题解答</p><ul><li>在 ChatServer（聊天服务端）和 ChatClient（聊天客户端）之间实现心跳保持机制，实现步骤如下：<ul><li>(1) 客户端定期发送心跳包（比如：每秒发一次 <code>MSG_TYPE: heartbeat</code>）</li><li>(2) 服务端为每个客户端维护一个心跳计数器，每秒自动加一</li><li> (3) 服务端每收到一次客户端发送的心跳包，就将该客户端的心跳计数器归零</li><li> (4) 若客户端的心跳计数器超过 5（即 5 秒内未收到心跳），则判断客户端已掉线</li><li> (5) 客户端掉线后，服务端开始清理该客户端的连接和资源</li></ul></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>TCP 传输层有 Keepalive 机制，可以通过 Linux 内核参数来调整（如下表所示）。但是，ChatServer 不能依赖该机制来实现心跳保持机制，因为 ChatServer 检测到 ChatClient 掉线后，需要主动清理相应的连接和资源。</li></ul></div><table><thead><tr><th>参数名</th><th>作用</th><th>默认值（一般情况）</th></tr></thead><tbody><tr><td><code>net.ipv4.tcp_keepalive_time</code></td><td>TCP 连接空闲多久后开始发送 Keepalive 探测包（单位：秒）</td><td>7200 秒（2 小时）</td></tr><tr><td><code>net.ipv4.tcp_keepalive_intvl</code></td><td>发送 Keepalive 探测包之间的时间间隔（单位：秒）</td><td>75 秒</td></tr><tr><td><code>net.ipv4.tcp_keepalive_probes</code></td><td>Keepalive 最大探测次数，超过则认定连接失效（断开）</td><td>9 次</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/m0_74795952/article/details/145707561">C++ 实现集群聊天服务器</a></li><li><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/97895611">C++ 使用 Redis 发布 - 订阅功能遇到的问题</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 开发集群聊天服务器，使用了 Muduo、Json、MySQL、Redis、Linux 等技术。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="网络编程" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMake 快速入门指南</title>
    <link href="https://www.techgrow.cn/posts/effcb0d2.html"/>
    <id>https://www.techgrow.cn/posts/effcb0d2.html</id>
    <published>2025-05-27T14:25:49.000Z</published>
    <updated>2025-05-27T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<div class="row"><embed src="/pdf/CMake快速入门指南.pdf" width="100%" height="1024px" isolation="isolate" type="application/pdf"></div>]]></content>
    
    
    <summary type="html">本文主要介绍 CMake 的快速入门教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="在线电子书" scheme="https://www.techgrow.cn/tags/%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>大型电商网站商品详情页系统的架构设计</title>
    <link href="https://www.techgrow.cn/posts/f49eb46a.html"/>
    <id>https://www.techgrow.cn/posts/f49eb46a.html</id>
    <published>2025-05-27T13:43:32.000Z</published>
    <updated>2025-05-27T13:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="页面静态化方案"><a href="#页面静态化方案" class="headerlink" title="页面静态化方案"></a>页面静态化方案</h2><p>电商网站通常拥有上千万级商品，每个商品都有独立的详情页。为了提升页面响应速度，常采用页面静态化（生成静态 HTML 文件）技术。</p><h3 id="小型电商网站的页面静态化"><a href="#小型电商网站的页面静态化" class="headerlink" title="小型电商网站的页面静态化"></a>小型电商网站的页面静态化</h3><h4 id="页面静态化处理"><a href="#页面静态化处理" class="headerlink" title="页面静态化处理"></a>页面静态化处理</h4><ul><li><p>核心思路：</p><ul><li>开发一个页面静态化系统，将网站所有页面（如首页、商品详情页等）预先生成为静态 HTML 文件。</li><li>用户访问时，直接由 Nginx 返回对应的静态 HTML 文件的内容，无需查询数据库或执行后端代码。</li></ul></li><li><p>优点：</p><ul><li>高性能：无需每次请求都进行数据库交互或逻辑处理，响应速度快。</li><li>简单高效：适合页面数量有限的场景（几十到几万个页面）。</li></ul></li><li><p>缺点：</p><ul><li>不适合大规模网站，若页面数量达到亿级别，任何模板改动（如样式、文字等）都需要重新全量生成所有页面，耗时耗资源，不可行。</li></ul></li></ul><span id="more"></span><p><img data-src="../../../asset/2025/08/web-page-static-1.png"></p><h4 id="静态-HTML-文件更新"><a href="#静态-HTML-文件更新" class="headerlink" title="静态 HTML 文件更新"></a>静态 HTML 文件更新</h4><div class="admonition warning"><p class="admonition-title">思考</p><p>页面静态化系统预先生成所有静态 HTML 文件后，如果有多个 Nginx 对外提供服务，那如何动态更新多个 Nginx 服务器上的静态 HTML 文件呢？</p></div><p>结合版本控制与配置管理工具实现静态 HTML 文件的更新，这是最常用、最规范的方法，利用自动化工具完成分发和生效。</p><ul><li>流程：<ul><li>生成：页面静态化系统将网站所有页面预先生成为静态 HTML 文件。</li><li>存储：将新的静态 HTML 文件存放在一个版本控制系统（如 Git）中，这便于管理版本、回顾历史、协同工作。</li><li>触发：开发人员将修改后的静态 HTML 文件推送（<code>git push</code>）到 Git 仓库（如 GitLab/GitHub）。</li><li>自动分发：通过 CI/CD 工具（如 Jenkins， GitLab CI）监听 Git 仓库的变更。一旦有新的推送，CI/CD 工具自动触发部署脚本。</li><li>执行部署脚本：脚本通过配置管理工具（如 Ansible、SaltStack、Puppet）或简单的 <code>rsync</code> 命令，将新的静态 HTML 文件同步到所有 Nginx 服务器的指定目录下。</li></ul></li><li>优点：<ul><li>自动化、可追溯、规范性强，非常适合大规模集群。</li></ul></li><li>缺点：<ul><li>需要同时维护和理解一整套工具链（GitLab/GitHub、CI/CD、Ansible/SaltStack 等），对运维和开发团队的技术能力要求较高。</li></ul></li><li>适用场景：<ul><li>几十台到上万台服务器规模的管理，自动化优势能得到极大体现。</li></ul></li></ul><h3 id="大型电商网站的页面静态化"><a href="#大型电商网站的页面静态化" class="headerlink" title="大型电商网站的页面静态化"></a>大型电商网站的页面静态化</h3><h4 id="页面静态化处理-1"><a href="#页面静态化处理-1" class="headerlink" title="页面静态化处理"></a>页面静态化处理</h4><p>通过 “本地模板 + 多级缓存（本地缓存 + Redis 缓存） + 消息队列” 的方式，在不牺牲太多性能的前提下，完美解决了大型电商网站海量商品详情页数据动态更新和模板全局更新的难题，是一种兼具高性能、高时效性和高可扩展性的优秀方案。</p><ul><li><p>核心思路</p><ul><li>不再预生成所有静态 HTML 页面，而是采用 “本地模板 + 动态数据” 的方式，在收到请求时实时渲染页面。</li></ul></li><li><p>架构组成</p><ul><li><p>(1) 本地模板与缓存：</p><ul><li>Nginx 服务器本地存有 HTML 模板文件。</li><li>渲染所需的数据也在 Nginx 本地有一份缓存（如存储在内存中），有效期较短（例如 10 分钟）。</li></ul></li><li><p>(2) 请求处理流程：</p><ul><li>用户请求到达 Nginx。</li><li>Nginx 首先使用本地的 HTML 模板文件和本地的缓存数据快速渲染出一个页面返回。</li><li>因为所有操作都在本地完成，所以速度非常快，性能损耗仅在于渲染 HTML 本身。</li></ul></li><li><p>(3) 数据更新与同步机制（关键）：</p><ul><li>触发更新：当商品信息、店铺信息、广告信息等发生变更时，相关服务会向消息队列（如 RabbitMQ） 发送一个消息。</li><li>数据处理：有一个缓存构建服务会消费这个消息，调用各个服务接口（比如商品信息接口等）获取最新的数据，并整合成前端页面渲染所需的数据格式。</li><li>更新缓存：将整合好的最新数据更新到 Redis 分布式缓存中。</li><li>过期与拉取：Nginx 渲染页面时，若本地的缓存数据过期了，会主动去 Redis 分布式缓存中获取最新的数据来更新本地缓存。</li></ul></li></ul></li><li><p>架构优点</p><ul><li>解决了全量静态化的弊端：HTML 模板文件变更时，无需重新生成亿级页面，只需更新模板文件，下次请求所有用户都会自动使用新模板渲染。</li><li>保证了高性能：大部分请求直接使用本地缓存的数据和模板进行渲染，速度极快。</li><li>保证了数据时效性：通过 “消息队列 + Redis” 的机制，能在秒级或分钟级内将变更的数据同步到整个服务器集群，实现了数据更新与页面渲染的解耦。</li><li>具备高可扩展性：适合海量页面（如亿级）的场景。</li></ul></li></ul><p><img data-src="../../../asset/2025/08/web-page-static-2.png"></p><h4 id="模板文件动态更新"><a href="#模板文件动态更新" class="headerlink" title="模板文件动态更新"></a>模板文件动态更新</h4><div class="admonition warning"><p class="admonition-title">思考</p><p>如果有多个 Nginx 对外提供服务，那如何动态更新多个 Nginx 服务器上的 HTML 模版文件呢？</p></div><blockquote><p>方案一：结合版本控制与配置管理工具（推荐）</p></blockquote><p>这是最常用、最规范的方法，利用自动化工具完成分发和生效。</p><ul><li>流程：<ul><li>存储：将 HTML 模板文件存放在一个版本控制系统（如 Git）中，这便于管理版本、回顾历史、协同工作。</li><li>触发：开发人员将修改后的模板推送（<code>git push</code>）到 Git 仓库（如 GitLab/GitHub）。</li><li>自动分发：通过 CI/CD 工具（如 Jenkins， GitLab CI）监听 Git 仓库的变更。一旦有新的推送，CI/CD 工具自动触发部署脚本。</li><li>执行部署脚本：脚本通过配置管理工具（如 Ansible、SaltStack、Puppet）或简单的 <code>rsync</code> 命令，将新的模板文件同步到所有 Nginx 服务器的指定目录下。</li></ul></li><li>优点：<ul><li>自动化、可追溯、规范性强，非常适合大规模集群。</li></ul></li><li>缺点：<ul><li>需要同时维护和理解一整套工具链（GitLab/GitHub、CI/CD、Ansible/SaltStack 等），对运维和开发团队的技术能力要求较高。</li></ul></li><li>适用场景：<ul><li>几十台到上万台服务器规模的管理，自动化优势能得到极大体现。</li></ul></li></ul><blockquote><p>方案二：利用分布式文件系统</p></blockquote><p>让所有 Nginx 服务器不从本地磁盘，而是从同一个网络位置读取模板文件。</p><ul><li>流程：<ul><li>搭建一个分布式文件系统（如 NFS、GlusterFS）或使用对象存储（如 AWS S3， 阿里云 OSS，但通常需要配合缓存使用）。</li><li>将所有 Nginx 服务器的模板目录挂载到这个共享的网络存储上。</li><li>需要更新模板时，只需更新共享存储上的一份文件即可，所有 Nginx 服务器立即就能看到最新的文件。</li></ul></li><li>优点：<ul><li>管理简单，只需修改一个点。</li></ul></li><li>缺点：<ul><li>单点故障和性能瓶颈：如果网络存储出现故障或网络延迟高，所有网站都会受影响。</li><li>性能：每次请求都可能产生网络 I/O，延迟比本地读取高。</li><li>通常需要配合本地缓存使用，这又引入了缓存一致性问题。</li></ul></li><li>适用场景：<ul><li>中小规模集群或对实时性要求不极端的场景。</li></ul></li></ul><blockquote><p>方案三：使用反向代理层切换</p></blockquote><p>在更复杂的架构中，Nginx 本身可能也分为多级。可以在最前层的反向代理（或负载均衡器）上做文章。</p><ul><li>流程：<ul><li>假设有两组后端 Nginx 服务器：Group A（当前在线）和 Group B（待更新）。</li><li>先更新 Group B 的模板文件，并重启其服务。</li><li>通过前层的负载均衡器（如 LVS、F5，或另一个 Nginx）将流量从 Group A 平滑切换到 Group B。</li><li>确认 Group B 工作正常后，再更新 Group A 的模板，并将其作为新的备用组。</li></ul></li><li>优点：<ul><li>完全无缝更新，对用户无感知，是最高级的更新方式。</li></ul></li><li>缺点：<ul><li>架构复杂，需要额外的机器资源（至少多一整套备用服务器）。</li></ul></li><li>适用场景：<ul><li>超大规模、对可用性要求极高的网站（如淘宝、京东级别）。</li></ul></li></ul><blockquote><p>方案四：容器化部署（云原生方案）</p></blockquote><p>这是现代应用部署的趋势，与方案一紧密结合。</p><ul><li>流程：<ul><li>将 HTML 模板文件存放在一个版本控制系统（如 Git）中，这便于管理版本、回顾历史、协同工作。</li><li>通过 CI/CD 工具（如 Jenkins）监听 Git 仓库的变更。一旦模板文件更新，自动拉取代码，将 Nginx 和最新的模板文件一起构建成一个 Docker 镜像，并推送至镜像仓库。</li><li>CI/CD 工具（如 Jenkins）调用 Kubernetes API，触发 Deployment 的滚动更新（Rolling Update），使用新镜像逐步替换旧 Pod（容器）。</li><li>Kubernetes 的滚动更新（Rolling Update）策略会自动完成流量切换与新老实例更替，实现无缝、零宕机的全集群模板更新。</li></ul></li><li>优点：<ul><li>环境一致，部署流程标准化，是云原生时代的最佳实践。</li></ul></li><li>缺点：<ul><li>技术栈复杂，需要引入容器和编排平台。</li></ul></li><li>技术栈：<ul><li>版本控制系统（VCS）：如 Git，用于存储和管理模板文件、Dockerfile、部署脚本等。</li><li>CI/CD 工具：如 Jenkins、GitLab CI、GitHub Actions，用于自动化构建和部署流程。</li><li>容器镜像仓库：如 Docker Hub、Harbor、AWS ECR，用于存储构建好的 Docker 镜像。</li><li>容器编排平台：如 Kubernetes（K8s），用于最终的应用部署和滚动更新。</li><li>配置管理（融入了镜像）：Dockerfile 和 K8s 的 YAML 文件会替代 Ansible 等工具的角色（功能）。</li></ul></li></ul><hr><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong> CI/CD + 配置管理</strong></td><td>自动化、规范、可靠、无单点瓶颈</td><td>需要搭建和维护一套工具链</td><td><strong>绝大多数场景，最通用推荐</strong></td></tr><tr><td><strong>分布式文件系统</strong></td><td>管理简单，更新即时</td><td>存在单点故障和性能风险</td><td>中小集群，开发测试环境</td></tr><tr><td><strong>反向代理切换</strong></td><td>无缝更新，用户体验最佳</td><td>架构复杂，资源成本高</td><td>超大型网站，金融级应用</td></tr><tr><td><strong>容器化部署</strong></td><td>环境一致，现代化，易于扩展</td><td>技术复杂度最高</td><td>云原生技术栈团队</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">总结</p><p>方案一（CI/CD + Ansible 等工具）是最平衡、最常用的选择。它既能快速响应模板变更，又能可靠地管理成百上千台服务器，完美契合了 "模板变更了，不需要将所有页面全部重新静态化" 的设计初衷。</p></div>]]></content>
    
    
    <summary type="html">本文主要介绍大型电商网站商品详情页系统的架构设计。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="架构设计" scheme="https://www.techgrow.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于 Linux 下 VSCode 搭建 C/C++ 开发环境</title>
    <link href="https://www.techgrow.cn/posts/83b1bb3b.html"/>
    <id>https://www.techgrow.cn/posts/83b1bb3b.html</id>
    <published>2025-05-25T14:25:49.000Z</published>
    <updated>2025-05-25T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将在 Linux 系统中，搭建 VSCode 开发 C/C++ 程序的环境（本地开发），适用于绝大多数的 Linux 发行版，比如 CentOS、Ubuntu、Debian 等。</p><span id="more"></span><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ul><li>(1) 在 Linux 系统中安装 VSCode<ul><li><a href="/posts/d8f0998b.html">Linux 安装 VSCode 的详细教程</a></li></ul></li><li> (2) 在 VSCode 中安装 C/C++ 相关插件，比如：<ul><li><code>C/C++</code>：C/C++ 核心插件，提供 C/C++ 智能感知、调试、导航、语法提示等核心功能。</li><li><code>C/C++ Extension Pack</code>：C/C++ 插件组合包，用于一键安装多个与 C/C++ 开发相关的扩展，方便快速配置。</li><li><code>Code Runner</code>：代码快速运行插件（可选安装），仅支持运行单个源文件，支持多种语言，包括 C/C++、Java、JS、PHP、Python、、Go、Lua 等。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/630b5e44.html">VSCode 搭建远程 Linux 开发环境</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍基于 Linux 下 VSCode 如何搭建 C/C++ 开发环境。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>VSCode 搭建远程 Linux 开发环境</title>
    <link href="https://www.techgrow.cn/posts/630b5e44.html"/>
    <id>https://www.techgrow.cn/posts/630b5e44.html</id>
    <published>2025-05-22T14:25:49.000Z</published>
    <updated>2025-05-22T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 VSCode 如何搭建远程 Linux 开发环境（远程开发），实现的效果相当于在远程 Linux 服务器上直接开发 C/C++ 项目，适用于 Windows 系统。</p><span id="more"></span><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><blockquote><p>VSCode 搭建远程 Linux 开发环境的步骤：</p></blockquote><ul><li>(1) 在远程 Linux 系统中运行 SSH 服务</li><li> (2) 在本地 Windows 系统的 VSCode 中安装 C/C++ 相关插件，比如：<ul><li><code>Remote Development</code>：远程开发插件，支持连接远程 Linux 服务器、Docker 容器、WSL。</li><li><code>C/C++</code>：C/C++ 核心插件，提供 C/C++ 智能感知、调试、导航、语法提示等核心功能。</li><li><code>C/C++ Extension Pack</code>：C/C++ 插件组合包，用于一键安装多个与 C/C++ 开发相关的扩展，方便快速配置。</li><li><code>Code Runner</code>：代码快速运行插件（可选安装），仅支持运行单个源文件，支持多种语言，包括 C/C++、Java、JS、PHP、Python、、Go、Lua 等。</li></ul></li><li>(3) 在本地 Windows 系统的 VSCode 中配置远程 Linux 服务器的信息。</li><li>(4) 在本地 Windows 系统的 VSCode 中连接远程的 Linux 服务器进行开发（即远程开发）。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>VSCode 远程开发的详细搭建教程，可以参考文末给出的 <a href="/posts/630b5e44.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a>，这里不再累述。</p></div><blockquote><p>VSCode 安装 C/C++ 相关插件后的样子如下图所示：</p></blockquote><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-1.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里注意不要安装 <code>C/C++ Runner</code> 这款插件（支持直接运行单个或多个 C/C++ 源文件），因为 <code>C/C++ Runner</code> 插件不会自动安装到远程环境中，也不支持在远程环境中运行，因为它的设计是为了在本地运行程序。</p></div><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="直接运行程序找不到头文件"><a href="#直接运行程序找不到头文件" class="headerlink" title="直接运行程序找不到头文件"></a>直接运行程序找不到头文件</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>当 C/C++ 源文件中引入了自定义的头文件，执行 VSCode 右上角的 <code>运行 C/C++ 文件</code> 按钮运行程序后（如下图所示），会出现找不到头文件的错误。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-2.png"></p><ul><li>这是因为 VSCode 是使用 <code>g++</code> 命令直接编译当前打开的 <code>.cpp</code> 文件，仅执行 <code>g++ file.cpp -o file &amp;&amp; ./file</code> 这种快速编译运行命令，而没有加上自定义头文件所在的目录路径（<code>-I</code> 参数）所导致的。</li></ul><h4 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h4><ul><li>创建或编辑当前项目的 <code>.vscode/c_cpp_properties.json</code> 文件，或者使用 <code>cmd + shift + p</code> 快捷键打开命令面板并输入 <code>C/C++ Edit Configurations (JSON)</code>），然后更改对应的配置内容 </li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Linux"</span>,</span><br><span class="line">            <span class="attr">"includePath"</span>: [</span><br><span class="line">                <span class="string">"${workspaceFolder}/**"</span>       <span class="comment">// 用于 VSCode 的 IntelliSense 引擎（代码提示、跳转、补全等），帮助它找到头文件的位置，不是用于编译代码。编译用的头文件路径是在 tasks.json 或 CMakeLists.txt 中通过 `-I` 参数来指定</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"defines"</span>: [],</span><br><span class="line">            <span class="attr">"compilerPath"</span>: <span class="string">"/usr/bin/g++"</span>,   <span class="comment">// 指定使用的编译器</span></span><br><span class="line">            <span class="attr">"cStandard"</span>: <span class="string">"c11"</span>,               <span class="comment">// 指定 C 版本</span></span><br><span class="line">            <span class="attr">"cppStandard"</span>: <span class="string">"gnu++11"</span>,         <span class="comment">// 指定 C++ 版本</span></span><br><span class="line">            <span class="attr">"intelliSenseMode"</span>: <span class="string">"linux-gcc-x64"</span></span><br><span class="line">        }</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">4</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑当前项目的 <code>.vscode/tasks.json</code> 文件，然后添加 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppbuild"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"C/C++: g++ build active file"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"/usr/bin/g++"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"-fdiagnostics-color=always"</span>,</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"${file}"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"${fileDirname}/${fileBasenameNoExtension}"</span>, <span class="comment">// 指定输出的可执行文件名</span></span><br><span class="line">                <span class="string">"-Iinclude"</span>, <span class="comment">// 指定项目的头文件</span></span><br><span class="line">                <span class="string">"-lpthread"</span> <span class="comment">// 指定链接的静态库或者动态库（必须注意顺序，从上到下链接），可选配置</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"options"</span>: {</span><br><span class="line">                <span class="attr">"cwd"</span>: <span class="string">"${workspaceFolder}"</span></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">"problemMatcher"</span>: [</span><br><span class="line">                <span class="string">"$gcc"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"group"</span>: {</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>然后执行 VSCode 右上角的 <code>运行 C/C++ 文件</code> 按钮运行程序后（如下图所示），就可以正常运行 C/C++ 程序</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-8.png"></p><h4 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h4><ul><li>创建或编辑当前项目的 <code>.vscode/tasks.json</code> 文件，然后添加 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"tasks"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"Run Main with include"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-Iinclude"</span>,       <span class="comment">// 指定头文件路径</span></span><br><span class="line">        <span class="string">"main.cpp"</span>,        <span class="comment">// 指定目标源文件名</span></span><br><span class="line">        <span class="string">"-o"</span>,</span><br><span class="line">        <span class="string">"main"</span>             <span class="comment">// 指定输出的可执行文件名</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"group"</span>: <span class="string">"build"</span>,</span><br><span class="line">      <span class="attr">"problemMatcher"</span>: [],</span><br><span class="line">      <span class="attr">"detail"</span>: <span class="string">"Compile with header path"</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑当前项目的 <code>.vscode/launch.json</code> 文件，然后指定 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Launch main"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"${workspaceFolder}/main"</span>,     <span class="comment">// 指定可执行文件</span></span><br><span class="line">      <span class="attr">"args"</span>: [],</span><br><span class="line">      <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"${workspaceFolder}"</span>,</span><br><span class="line">      <span class="attr">"preLaunchTask"</span>: <span class="string">"Run Main with include"</span>,      <span class="comment">// 指定 Task</span></span><br><span class="line">      <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">      <span class="attr">"miDebuggerPath"</span>: <span class="string">"/usr/bin/gdb"</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>按下快捷键 <code>Ctrl + Shift + D</code>，调出 VSCode 的 <code>运行和调试</code> 面板，然后在顶部选择自定义的配置 <code>Launch main</code>，最后点击左边的 <code>绿色</code> 按钮就可以正常运行程序。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-3.png"></p><ul><li>第一次运行程序后，VSCode 的底部工具栏会新增 <code>Launch main</code> 相关的操作按钮，以后可以直接在底部工具栏运行或调试 C/C++ 程序，还可以使用快捷键 <code>F5</code> 直接运行。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>VSCode 中 <code>运行 C/C++ 文件</code> 按钮的行为非常简单（如下表所示），因此更推荐使用 CMake 管理 C/C++ 项目，并使用 <code>launch.json</code> + <code>task.json</code> 来调用它。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>默认使用 <code>g++</code> 编译当前文件</td><td>忽略项目结构和依赖关系</td></tr><tr><td>不支持多源文件编译</td><td>如果有 <code>main.cpp</code> 和 <code>other.cpp</code>，它不会编译全部源文件</td></tr><tr><td>不自动添加 <code>-I</code>、<code>-L</code> 参数</td><td>所以无法识别头文件或链接库</td></tr><tr><td>不识别 CMake 项目</td><td>所以不适合正式工程</td></tr></tbody></table><h3 id="CMake-项目无法直接运行"><a href="#CMake-项目无法直接运行" class="headerlink" title="CMake 项目无法直接运行"></a>CMake 项目无法直接运行</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>当点击 VSCode 右上角的 <code>运行 C/C++ 文件</code> 按钮时，CMake 项目无法正常运行（如下图所示）。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-4.png"></p><ul><li>这是因为点击 <code>运行 C/C++ 文件</code> 按钮后，其实触发的是 <code>C/C++: Run</code> 快捷命令，这个命令不会走 CMake，而是仅对当前打开的 <code>.cpp</code> 文件执行 <code>g++ file.cpp -o file &amp;&amp; ./file</code> 这种快速编译运行命令。</li></ul><h4 id="解决方案一-1"><a href="#解决方案一-1" class="headerlink" title="解决方案一"></a>解决方案一</h4><ul><li>创建或编辑当前项目的 <code>.vscode/tasks.json</code> 文件，然后添加 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"tasks"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"CMake Build"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"cmake -S . -B build &amp;&amp; cmake --build build"</span>,</span><br><span class="line">      <span class="attr">"problemMatcher"</span>: []</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>创建或编辑当前项目的 <code>.vscode/launch.json</code> 文件，然后指定 Task</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Run CMake Executable"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"${workspaceFolder}/build/main"</span>,   <span class="comment">// 指定 CMake 输出的可执行文件名</span></span><br><span class="line">      <span class="attr">"args"</span>: [],</span><br><span class="line">      <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"${workspaceFolder}"</span>,</span><br><span class="line">      <span class="attr">"preLaunchTask"</span>: <span class="string">"CMake Build"</span>,   <span class="comment">// 指定 Task</span></span><br><span class="line">      <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">      <span class="attr">"miDebuggerPath"</span>: <span class="string">"/usr/bin/gdb"</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>按下快捷键 <code>Ctrl + Shift + D</code>，调出 VSCode 的 <code>运行和调试</code> 面板，然后在顶部选择自定义的配置 <code>Run CMake Executable</code>，最后点击左边的 <code>绿色</code> 按钮就可以正常运行 CMake 项目。</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-5.png"></p><ul><li>第一次运行程序后，VSCode 的底部工具栏会新增 <code>Launch main</code> 相关的操作按钮，以后可以直接在底部工具栏运行或调试 CMake 项目，还可以使用快捷键 <code>F5</code> 直接运行。</li></ul><h4 id="解决方案二-1"><a href="#解决方案二-1" class="headerlink" title="解决方案二"></a>解决方案二</h4><p>在 VSCode 中安装 <code>CMake Tools</code> 插件，打开 CMake 项目后点击左下角状态栏，确认 <code>CMake Tools</code> 插件已经识别 CMake 项目，然后就可以选择生成、调试、运行 CMake 项目了。</p><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-6.png"></p><h3 id="免密码连接远程-Linux-服务器"><a href="#免密码连接远程-Linux-服务器" class="headerlink" title="免密码连接远程 Linux 服务器"></a>免密码连接远程 Linux 服务器</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>VSCode 安装完 <code>Remote Development</code> 插件后，每次连接远程的 Linux 服务器都会提示输入密码，非常不方便。</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>(1) 在本地的 Windows 系统中，安装 Git Bash 工具；然后在 Git Bash 中执行以下命令生成 SSH 公钥，默认保存位置是：<code>~/.ssh/id_rsa</code>（私钥）和 <code>~/.ssh/id_rsa.pub</code>（公钥）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 SSH 秘钥对，一路回车即可（通常无需设置密码）</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 在本地的 Git Bash 中，执行以下命令将公钥拷贝到远程 Linux 服务器中 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝公钥到远程 Linux 服务器（第一次会要求输入远程服务器的密码，之后设置完成即可免密）</span></span><br><span class="line">ssh-copy-id root@192.168.1.100</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 测试 SSH 登录是否免密成功 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.1.100</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 重新运行 VSCode，选择需要连接的 Linux 服务器，观察是否成功免密建立远程连接</li></ul><h3 id="C-C-代码实现格式化"><a href="#C-C-代码实现格式化" class="headerlink" title="C/C++ 代码实现格式化"></a>C/C++ 代码实现格式化</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>VSCode 默认的 C/C++ 代码格式化风格不太习惯，比如每个大括号都是换行显示的，希望更改为自己所需的代码风格。</p><h4 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>(1) 在远程 Linux 服务器上安装 <code>clang-format</code> 代码格式化工具 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y clang-format</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 在本地的 VSCode 中安装 Clang-Format 插件</li></ul><p><img data-src="../../../asset/2025/05/vscode-cxx-remote-7.png"></p><ul><li> (3) 创建或编辑当前项目的 <code>.vscode/settings.json</code> 文件，添加以下配置内容：</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">// C 代码格式化配置</span></span><br><span class="line">    <span class="attr">"[c]"</span>: {</span><br><span class="line">        <span class="attr">"editor.defaultFormatter"</span>: <span class="string">"xaver.clang-format"</span>, <span class="comment">// 指定格式化器，远程服务器必须先安装 clang-format 工具</span></span><br><span class="line">        <span class="attr">"editor.formatOnSave"</span>: <span class="literal">false</span> <span class="comment">// 可选，保存文件时自动格式化</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// C++ 代码格式化配置</span></span><br><span class="line">    <span class="attr">"[cpp]"</span>: {</span><br><span class="line">        <span class="attr">"editor.defaultFormatter"</span>: <span class="string">"xaver.clang-format"</span>, <span class="comment">// 指定格式化器，远程服务器必须先安装 clang-format 工具</span></span><br><span class="line">        <span class="attr">"editor.formatOnSave"</span>: <span class="literal">false</span> <span class="comment">// 可选，保存文件时自动格式化</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 代码格式化规则</span></span><br><span class="line">    <span class="attr">"clang-format.style"</span>: <span class="string">"{ BasedOnStyle: Google, IndentWidth: 4, TabWidth: 4, AccessModifierOffset: -4, UseTab: Never, ColumnLimit: 120, AllowShortFunctionsOnASingleLine: None }"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>提示：推荐将代码格式化规则配置在项目根目录下的 <code>.clang-format</code> 文件中（如下），然后在当前项目的 <code>.vscode/settings.json</code> 文件中添加配置内容 <code>"clang-format.style": "file"</code>，让代码格式化插件去自动读取项目中的 <code>.clang-format</code> 文件。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 基于哪种代码风格，可选：LLVM、Google、Chromium、Mozilla、WebKit 等</span><br><span class="line">BasedOnStyle: Google</span><br><span class="line"></span><br><span class="line"># 每一层缩进使用的空格数（默认 Google 是 2，这里改为 4）</span><br><span class="line">IndentWidth: 4</span><br><span class="line"></span><br><span class="line"># 设置一个制表符（Tab）等价于多少个空格（影响对齐）</span><br><span class="line">TabWidth: 4</span><br><span class="line"></span><br><span class="line"># 使访问修饰符（如 private:）顶格，不缩进</span><br><span class="line">AccessModifierOffset: -4</span><br><span class="line"></span><br><span class="line"># 是否使用 Tab 缩进：</span><br><span class="line">#   - Never: 一律使用空格</span><br><span class="line">#   - Always: 总是使用 Tab</span><br><span class="line">#   - ForIndentation: 缩进用 Tab，对齐用空格</span><br><span class="line">UseTab: Never</span><br><span class="line"></span><br><span class="line"># 每行的最大字符数限制</span><br><span class="line">ColumnLimit: 120</span><br><span class="line"></span><br><span class="line"># 强制所有函数体换行，即使只有一行</span><br><span class="line">AllowShortFunctionsOnASingleLine: None</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 配置 VSCode 的 C/C++ 代码格式化快捷键<ul><li>按 <code>Ctrl + Shift + P</code> 组合建打开命令面板</li><li>输入 <code>Preferences: Open Keyboard Shortcuts (JSON)</code> 并回车</li><li>在打开的 <code>keybindings.json</code> 文件里，添加以下配置内容：<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="comment">// 格式化选中的 C/C++ 代码块</span></span><br><span class="line">    {</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"ctrl+l"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"editor.action.formatSelection"</span>,</span><br><span class="line">        <span class="attr">"when"</span>: <span class="string">"editorTextFocus &amp;&amp; (editorLangId == 'cpp' || editorLangId == 'c') &amp;&amp; editorHasSelection"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 格式化整个 C/C++ 源文件</span></span><br><span class="line">    {</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"ctrl+l"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"editor.action.formatDocument"</span>,</span><br><span class="line">        <span class="attr">"when"</span>: <span class="string">"editorTextFocus &amp;&amp; (editorLangId == 'cpp' || editorLangId == 'c') &amp;&amp; !editorHasSelection"</span></span><br><span class="line">    }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/weixin_51278158/article/details/130186395">VSCode 使用 SSH 进行远程开发</a></li><li><a href="https://cloud.tencent.com/developer/article/2282762">VSCode 远程开发 - SSH 入门保姆级教程</a></li><li><a href="https://blog.csdn.net/qq_41897304/article/details/131282774">Windows 平台下 VSCode 配置远程 Linux 开发环境</a></li><li><a href="https://www.cnblogs.com/lidabo/p/18348376">Windows 平台使用 VSCode 远程连接 Linux 进行 C++ 开发配置教程</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 VSCode 如何搭建远程 Linux 开发环境。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 手写线程池</title>
    <link href="https://www.techgrow.cn/posts/585aa296.html"/>
    <id>https://www.techgrow.cn/posts/585aa296.html</id>
    <published>2025-05-13T13:55:33.000Z</published>
    <updated>2025-05-13T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 手写一个线程池，并分别提供 C++ 11 和 C++ 17 两种版本的线程池实现。线程池作为五大池之一（内存池、连接池、协程池、线程池、进程池），应用非常广泛，不管是客户端程序，还是后台服务程序，都是提高业务处理能力的必备模块。有很多开源的线程池实现，虽然各自接口在使用上稍有区别，但是其核心实现原理都是基本相同的。</p><h3 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h3><p>在基于 C++ 手写线程池之前，应该熟悉并掌握以下技术内容：</p><ul><li>熟练基于 C++ 11 的面向对象编程</li><li>熟悉组合和继承、继承多态、STL 容器、智能指针、函数对象、绑定器、<code>lambda</code> 表达式、可变参数模板编程等。</li><li>熟悉 C++ 11 多线程编程，比如线程互斥、线程同步、原子操作、CAS 等。</li><li>熟悉 <code>thread</code>、<code>mutex</code>、<code>unique_lock</code>、<code>condition_variable</code>、<code>atomic</code> 等。</li><li>熟悉 C++ 17 和 C++ 20 的新特性，比如 C++ 17 的 <code>any</code> 类型和 C++ 20 的 <code>counting_semaphore</code> 信号量类型等。</li></ul><span id="more"></span><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>本文使用以下工具来开发 C++ 线程池项目：</p><ul><li>C++ 11 / C++ 17</li><li>Visual Studio 2019</li><li>CMake 构建编译环境</li><li> GDB 调试分析定位线程死锁问题</li><li> Linux 编译项目生成动态链接库（<code>.so</code>）</li></ul><h3 id="版本特性"><a href="#版本特性" class="headerlink" title="版本特性"></a>版本特性</h3><p>C++ 各版本支持的特性如下：</p><table><thead><tr><th>特性名称</th><th>对应头文件</th><th>最低支持的 C++ 标准版本</th><th>说明</th></tr></thead><tbody><tr><td><code>std::make_unique</code></td><td><code>&lt;memory&gt;</code></td><td>C++ 14</td><td>C++ 14 引入，用于简洁安全地创建 <code>unique_ptr</code> 智能指针。</td></tr><tr><td><code>std::any</code></td><td><code>&lt;any&gt;</code></td><td>C++ 17</td><td> 提供类型安全的类型擦除容器。</td></tr><tr><td><code>std::counting_semaphore</code></td><td><code>&lt;semaphore&gt;</code></td><td>C++ 20</td><td>C++ 20 引入的信号量机制。</td></tr><tr><td><code>std::packaged_task</code></td><td><code>&lt;future&gt;</code></td><td>C++ 11</td><td> 将可调用对象封装起来，并用于异步执行。</td></tr><tr><td><code>std::future</code></td><td><code>&lt;future&gt;</code></td><td>C++ 11</td><td> 异步操作的结果获取机制，可以与 <code>std::async</code>、<code>std::promise</code> 搭配使用。</td></tr><tr><td>可变参数模板</td><td>语言特性</td><td> C++ 11</td><td> 支持模板中参数数量可变，用于构建灵活函数模板，如递归参数展开等。</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><p>如果使用的是 GCC、Clang 或 MSVC 编译器，需确保编译器版本也支持相应的 C++ 标准。若需进一步查询编译器支持的标准或特性情况，可以参考 <a href="https://zh.cppreference.com">C/C++ 参考手册</a>。</p></div><h3 id="兼容平台"><a href="#兼容平台" class="headerlink" title="兼容平台"></a>兼容平台</h3><p>本文提供的所有 C++ 线程池代码都可以兼容 Windows 和 Linux 平台，并分别提供 C++ 11 和 C++ 17 两种版本的线程池实现。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li><p><strong>并发（Concurrency）</strong></p><ul><li>在单核处理器上，多个线程之间通过操作系统的调度机制交替执行，每个线程轮流占用 CPU 的时间片（例如每 10 毫秒切换一次）。由于每个线程执行的时间片非常短，人们在宏观上感受到这些线程像是 “同时” 在执行一样，虽然它们在物理层面上是串行执行的。这种 “看起来同时执行” 的场景被称为并发。</li></ul></li><li><p><strong>并行（Parallelism）</strong></p><ul><li>在多核处理器或多 CPU 系统中，多个线程可以被分配到不同的核心上同时执行，彼此之间互不抢占 CPU 时间资源，是真正意义上的 “同时执行”。这种多个任务在物理层面并行的执行方式称为并行。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>简而言之，并发是 "逻辑上的同时发生"，并行是 "物理上的同时进行"。</p></div><h3 id="多线程的适用场景"><a href="#多线程的适用场景" class="headerlink" title="多线程的适用场景"></a>多线程的适用场景</h3><p>多线程程序的性能就一定好吗？不一定，要看具体的应用场景：</p><ul><li><p><strong>I/O 密集型场景</strong></p><ul><li>对于涉及大量 I/O 操作（如磁盘读写、网络通信、数据库访问等）的程序，这些操作通常会导致线程阻塞，从而释放 CPU 时间片。此时，通过多线程并发处理，可以有效利用 CPU 的空闲时间，提高程序的吞吐量和响应速度。因此，无论是 CPU 单核、CPU 多核、多 CPU，多线程通常都能带来较好的性能提升，因此适合运行多线程程序。</li></ul></li><li><p><strong>CPU 密集型场景</strong></p><ul><li>CPU 单核<ul><li>在 CPU 单核中，多个线程无法真正并行执行，只能通过 CPU 时间片轮转实现 “伪并发”。多线程会导致频繁的线程上下文切换，增加 CPU 调度开销，甚至可能因为线程数量过多而拖慢整体性能。<strong>在这种情况下，使用单线程可能反而更高效，因此不适合运行多线程程序</strong>。</li></ul></li><li>CPU 多核、多 CPU<ul><li> 多个线程可以被调度到多个核心上并行运行，从而充分利用计算资源，提高程序的运行效率。对于 CPU 密集型任务（如图像处理、大规模计算等），多线程可以显著提升性能，尤其是在合理控制线程数量、避免过度竞争的前提下，因此适合运行多线程程序。</li></ul></li></ul></li></ul><h3 id="多线程的协作机制"><a href="#多线程的协作机制" class="headerlink" title="多线程的协作机制"></a>多线程的协作机制</h3><p>在 C++ 中，为了实现多线程之间的正确协作与安全访问共享资源，通常需要使用线程互斥与线程同步机制。</p><h4 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h4><p>线程互斥用于防止多个线程同时访问共享资源，从而避免数据竞争和数据不一致的问题。常用机制包括：</p><ul><li><p><code>mutex</code> 互斥锁</p><ul><li>提供基本的加锁与解锁操作（<code>lock()</code> / <code>unlock()</code> 或 <code>lock_guard</code> / <code>unique_lock</code> 自动管理），确保同一时间只有一个线程能够访问临界区（共享资源）。</li></ul></li><li><p><code>recursive_mutex</code> 递归互斥锁</p><ul><li>支持同一个线程多次对同一个互斥锁加锁，适用于递归函数调用场景。</li></ul></li><li><p><code>atomic</code> 原子类型</p><ul><li>提供无锁的并发访问机制，支持原子操作，如自增、比较交换等，适用于简单共享变量的并发访问，性能较高。</li></ul></li></ul><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>线程同步用于协调多个线程之间的执行顺序，例如一个线程等待另一个线程完成某项任务后再继续执行。常用机制包括：</p><ul><li><p><code>condition_variable</code> 条件变量</p><ul><li>配合互斥锁（<code>mutex</code>）使用，允许线程在满足某个条件之前进入等待状态，并在条件满足后被唤醒。适合用于生产者 - 消费者模型等场景。</li></ul></li><li><p><code>semaphore</code> 信号量（C++ 20 引入）</p><ul><li>用于控制对某个资源的并发访问数量，即限制同一时刻最多有 N 个线程访问某个共享资源（可用作限流器），适用于如电商秒杀、停车场停车等业务场景。</li></ul></li><li><p><code>barrier</code> / <code>latch</code>（C++ 20 引入）</p><ul><li>用于多线程之间的阶段性同步。例如，所有线程都执行到某一步后再一起进入下一阶段。</li></ul></li></ul><h3 id="多线程的额外开销"><a href="#多线程的额外开销" class="headerlink" title="多线程的额外开销"></a>多线程的额外开销</h3><p>为了完成任务，创建很多的线程可以吗？线程真的是越多越好吗？答案是否定的。</p><ul><li>线程的创建和销毁都是非常 “重” 的操作（涉及用户空间和内核空间的切换）；</li><li>线程栈（通常为 8MB）本身占用大量内存空间；</li><li>线程的上下文切换需要占用大量时间；</li><li>大量线程同时唤醒，会导致操作系统经常出现锯齿状负载或者瞬间负载量很大，造成系统宕机。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Linux 平台下，通过 <code>pthread</code> 库默认最多可以创建约 <code>380</code> 个线程。若希望创建更多的线程，可以降低线程栈的大小（比如 8KB），还可以增大 Linux 系统的最大可打开文件描述符数（<code>ulimit -n</code>），或者最大可创建的用户进程数 / 线程数（<code>ulimit -u</code>）。</p></div><h2 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h2><h3 id="线程池的使用优势"><a href="#线程池的使用优势" class="headerlink" title="线程池的使用优势"></a>线程池的使用优势</h3><p>在操作系统中，线程的创建和销毁都是较为 “昂贵” 的操作，不仅耗时，而且会消耗较多的系统资源。如果在服务运行过程中，每当有任务到来就动态创建线程来执行，任务完成后又立即销毁线程，那么在高并发或大流量场景下，频繁的线程创建与销毁会显著降低系统的实时响应能力，增加 CPU 开销，从而影响整体业务的处理效率。线程池的出现正是为了解决这一问题。在线程池机制中，服务进程在启动阶段就会预先创建好一组可复用的线程（即线程池），这些线程会在后台处于等待状态。当业务任务到来时，系统无需重新创建线程，而是直接从线程池中取出一个空闲线程来执行任务（Task）。任务执行完毕后，该线程不会被销毁，而是归还给线程池，等待下一次任务（Task）的分配。</p><ul><li>线程池带来了多种优势：<ul><li>减少线程创建和销毁的开销，提高系统性能；</li><li>避免线程资源耗尽，通过线程池大小限制线程总数，控制系统并发量；</li><li>提升响应速度，线程可立即复用，减少任务启动延迟；</li><li>便于线程管理和监控，统一由线程池控制线程生命周期和运行状态。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>线程池是一种非常重要的并发编程工具，特别适用于高并发、高吞吐、对实时性有要求的业务场景。</p></div><h3 id="线程池的两种模式"><a href="#线程池的两种模式" class="headerlink" title="线程池的两种模式"></a>线程池的两种模式</h3><ul><li><p><strong>Fixed 模式线程池（固定大小线程池）</strong></p><ul><li>在这种模式下，线程池中的线程数量在创建时就被固定，且在整个线程池的生命周期内保持不变。一般在初始化线程池时，会根据当前机器的 CPU 核心数量或业务需求设定一个合理的线程数。</li><li>当有任务到来时，如果线程池中有空闲线程，则立即分配执行；如果线程都处于忙碌状态，则任务会被放入等待队列中，排队等待有空闲的线程。</li><li>Fixed 模式适合任务量较为稳定、对系统资源可控性要求较高的场景，有助于防止线程数量膨胀导致系统负载过高。</li></ul></li><li><p><strong>Cached 模式线程池（缓存线程池）</strong></p><ul><li>在这种模式下，线程池的线程数量不是固定的，而是可以根据实际任务量动态增长。当有新的任务到来时，如果线程池中没有空闲线程，会临时创建新的线程来处理任务，并在任务完成后将其归还到线程池中。</li><li>为了防止线程无限增长，通常会设置一个线程最大数量的阀值。此外，如果某个线程在空闲超过指定时间（如 60 秒）后仍无新任务可执行，它将被自动销毁，从而释放资源。线程池会始终保留初始的核心线程数，用于处理正常业务流量。</li><li>Cached 模式适用于任务处理量波动较大、流量突发性强的场景，可以在短时间内快速扩展线程池以应对高并发流量，但需要注意合理设置线程上限以避免资源耗尽。</li></ul></li></ul><h2 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h2><h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><p><img data-src="../../../asset/2025/05/cxx-thread-pool-1.png"></p><h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><ul><li>(1) 基于 C++ 可变参数模板编程和引用折叠原理，实现线程池 <code>submitTask</code> 接口，支持任意任务函数和任意参数的传递</li><li> (2) 使用 <code>future</code> 类型定制 <code>submitTask</code> 接口提交任务的返回值</li><li> (3) 使用 <code>map</code> 和 <code>queue</code> 容器管理线程对象和任务</li><li> (4) 基于条件变量 <code>condition_variable</code> 和互斥锁 <code>mutex</code> 实现任务提交线程和任务执行线程间的同步通信机制</li><li> (5) 支持 <code>fixed</code> 模式和 <code>cached</code> 模式的线程池定制</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="C-11-版本"><a href="#C-11-版本" class="headerlink" title="C++ 11 版本"></a>C++ 11 版本</h4><p>这里基于 C++ 11 手写一个线程池，并自行实现 <code>make_unique()</code>、<code>any</code> 类型、信号量类型。</p><div class="admonition note"><p class="admonition-title">代码下载</p><p>C++ 11 实现线程池的完整案例代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-thread-pool/c%2B%2B-11-thread-pool">这里</a> 下载得到，所有案例代码都兼容 Windows 和 Linux 平台。</p></div><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><ul><li><code>extend.h</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXTEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// make_unique() /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> extend {</span><br><span class="line">    <span class="comment">// 创建非数组类型对象</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;!std::is_array&lt;T&gt;::value, std::unique_ptr&lt;T&gt;&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">make_unique</span><span class="params">(Args &amp;&amp;... args)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建未知大小的数组（例如 make_unique&lt;T[]&gt;(n)）</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;std::is_array&lt;T&gt;::value &amp;&amp; std::extent&lt;T&gt;::value == <span class="number">0</span>, std::unique_ptr&lt;T&gt;&gt;::type</span><br><span class="line">    <span class="built_in">make_unique</span>(std::<span class="keyword">size_t</span> size) {</span><br><span class="line">        <span class="keyword">using</span> ElementType = <span class="keyword">typename</span> std::remove_extent&lt;T&gt;::type;</span><br><span class="line">        <span class="keyword">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> ElementType[size]());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止使用定长数组（例如 make_unique&lt;int[10]&gt; 是不合法的）</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;(std::extent&lt;T&gt;::value != <span class="number">0</span>), <span class="keyword">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">make_unique</span><span class="params">(Args &amp;&amp;...)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// Any 类型 /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any 类型（可以接收任意数据类型）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Any</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用带左值的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Any</span>(<span class="keyword">const</span> Any &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用带左值的赋值运算符</span></span><br><span class="line">    Any &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Any &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值的拷贝构造函数（移动拷贝构造）</span></span><br><span class="line">    <span class="built_in">Any</span>(Any&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值的赋值运算符（移动赋值运算符）</span></span><br><span class="line">    Any &amp;<span class="keyword">operator</span>=(Any &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用构造函数（让 Any 类型可以接收任意数据类型）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(T&amp;&amp; data)</span> : base_(extend::make_unique&lt;Derive&lt;typename std::decay&lt;T&gt;::type&gt;&gt;(std::forward&lt;T&gt;(data))) {</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换（将 Any 类型存储的数据类型提取出来）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T <span class="title">cast</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (base_ == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"Any is empty"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将基类指针转换为派生类指针（类型向下转换）</span></span><br><span class="line">        Derive &lt;T&gt; *p = <span class="keyword">dynamic_cast</span>&lt;Derive &lt;T&gt; *&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"type is unmatch!"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回真实的数据类型</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;<span class="built_in">getData</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 基类类型</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 虚析构函数</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类类型</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 通用构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">        <span class="title">Derive</span><span class="params">(U &amp;&amp;data)</span> : data_(std::forward&lt;U&gt;(data)) {</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~<span class="built_in">Derive</span>() {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> data_;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T data_;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;    <span class="comment">// 基类指针</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// Semaphore 信号量 /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量类（用于线程通信）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Semaphore</span>(<span class="keyword">int</span> limit = <span class="number">0</span>) : <span class="built_in">limit_</span>(limit), <span class="built_in">isDestroyed</span>(<span class="literal">false</span>) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Semaphore</span>() {</span><br><span class="line">        <span class="comment">// 标记当前对象已经被析构</span></span><br><span class="line">        isDestroyed = <span class="literal">true</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个信号量资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!isDestroyed) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待信号量资源</span></span><br><span class="line">            cond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> limit_ &gt; <span class="number">0</span>; });</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更改资源计数</span></span><br><span class="line">            limit_--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个信号量资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!isDestroyed) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更改资源计数</span></span><br><span class="line">            limit_++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知其他线程获取信号量资源</span></span><br><span class="line">            <span class="comment">// 特别注意，在默认情况下，Linux 平台中 condition_variable 的析构函数什么也没做，会导致这里状态已经失效；一旦外部使用它的对象（比如 Result）提前析构，就会无故阻塞线程，造成线程死锁</span></span><br><span class="line">            cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> limit_;                     <span class="comment">// 资源计数</span></span><br><span class="line">    std::mutex mtx_;                <span class="comment">// 互斥锁</span></span><br><span class="line">    std::condition_variable cond_;  <span class="comment">// 条件变量</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isDestroyed;   <span class="comment">// 是否已经被析构（用于解决Linux平台的兼容问题）</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EXTEND_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>thread_pool.h</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"extend.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池核心参数 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的线程数量（默认是CPU的核心数）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INIT_THREAD_SIZE = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TASK_MAX_THRESHHOLD = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_SIZE_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程允许的最大空闲时间（单位秒）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">PoolMode</span> {</span></span><br><span class="line">    MODE_FIXED,    <span class="comment">// 固定大小线程池</span></span><br><span class="line">    MODE_CACHED    <span class="comment">// 缓存线程池</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务抽象类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务执行结果类的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Task</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Task</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数，实现用户自定义的任务处理逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Result *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Result *result_;    <span class="comment">// 任务执行结果（使用裸指针，避免智能指针循环引用问题）</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务结果类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="keyword">bool</span> isValid = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Result</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    <span class="function">Any <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(Any data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断任务执行结果是否有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断关联的任务是否已完成</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFinished</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Any data_;                        <span class="comment">// 存储任务执行的结果</span></span><br><span class="line">    Semaphore sem_;                   <span class="comment">// 线程通信的信号量</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isValid_;        <span class="comment">// 任务执行结果是否有效</span></span><br><span class="line">    std::shared_ptr&lt;Task&gt; task_;      <span class="comment">// 关联的任务</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isFinished_;     <span class="comment">// 关联的任务是否已执行完成</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数对象的类型</span></span><br><span class="line">    <span class="keyword">using</span> ThreadHandler = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程构造</span></span><br><span class="line">    <span class="built_in">Thread</span>(ThreadHandler handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程析构</span></span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程ID</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> threadId_;                    <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> generateId_;           <span class="comment">// 用于辅助生成全局唯一的线程ID</span></span><br><span class="line">    ThreadHandler threadHandler_;     <span class="comment">// 线程处理函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池析构</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initThreadSize = INIT_THREAD_SIZE)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务给线程池</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Result&gt; <span class="title">submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池的运行状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理已完成的任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanTaskResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;        <span class="comment">// 线程集合</span></span><br><span class="line">    PoolMode poolMode_;                                               <span class="comment">// 线程池的模式</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isPoolRuning_;                                   <span class="comment">// 表示线程池是否正在运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> initThreadSize_;                                           <span class="comment">// 初始的线程数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> idleThreadSize_;                                  <span class="comment">// 空闲线程的数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> curThreadSize_;                                   <span class="comment">// 当前线程池的线程数量</span></span><br><span class="line">    <span class="keyword">int</span> threadSizeMaxThreshHold_;                                     <span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"></span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;Task&gt;&gt; taskQueue_;                     <span class="comment">// 任务队列</span></span><br><span class="line">    std::<span class="keyword">atomic_uint</span> taskSize_;                                       <span class="comment">// 当前任务队列的任务数量</span></span><br><span class="line">    <span class="keyword">size_t</span> taskQueMaxThreshHold_;                                     <span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"></span><br><span class="line">    std::mutex taskQueMtx_;                                           <span class="comment">// 任务队列操作的互斥锁</span></span><br><span class="line">    std::condition_variable notFull_;                                 <span class="comment">// 表示任务队列不满，用于通知用户线程提交任务</span></span><br><span class="line">    std::condition_variable notEmpty_;                                <span class="comment">// 表示任务队列不空，用于通知线程池中的线程执行任务</span></span><br><span class="line">    std::condition_variable allExit_;                                 <span class="comment">// 表示等待线程池回收所有线程</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Result&gt;&gt; taskResults_;                <span class="comment">// 任务执行结果列表，用于避免任务执行结果比任务早被析构</span></span><br><span class="line">    std::mutex taskResultsMtx_;                                       <span class="comment">// 任务执行结果的互斥锁</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// THREAD_POOL_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>thread_pool.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务抽象类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Task::<span class="built_in">Task</span>() : <span class="built_in">result_</span>(<span class="literal">nullptr</span>) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task::exec</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 执行任务处理逻辑（发生多态调用）</span></span><br><span class="line">    Any data = <span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="keyword">if</span> (result_ != <span class="literal">nullptr</span>) {</span><br><span class="line">        result_-&gt;<span class="built_in">setVal</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task::setResult</span><span class="params">(Result *p)</span> </span>{</span><br><span class="line">    result_ = p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务结果类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Result::<span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="keyword">bool</span> isValid) : <span class="built_in">task_</span>(task), <span class="built_in">isValid_</span>(isValid), <span class="built_in">isFinished_</span>(<span class="literal">false</span>) {</span><br><span class="line">    <span class="comment">// 关联任务和任务执行结果</span></span><br><span class="line">    task-&gt;<span class="built_in">setResult</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取任务执行结果</span></span><br><span class="line"><span class="function">Any <span class="title">Result::get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 如果任务执行结果无效，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!isValid_) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待获取一个信号量资源（即让当前线程等待任务执行完成）</span></span><br><span class="line">    sem_.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回任务执行完成的结果</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(data_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Result::setVal</span><span class="params">(Any data)</span> </span>{</span><br><span class="line">    <span class="comment">// 存储任务执行结果</span></span><br><span class="line">    data_ = std::<span class="built_in">move</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联的任务已执行完成</span></span><br><span class="line">    isFinished_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个信号量资源（即通知其他线程获取任务执行结果）</span></span><br><span class="line">    sem_.<span class="built_in">post</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断任务执行结果是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Result::isValid</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isValid_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断关联的任务是否已完成</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Result::isFinished</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isFinished_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程构造</span></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadHandler handler) : <span class="built_in">threadHandler_</span>(handler), <span class="built_in">threadId_</span>(generateId_++) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程析构</span></span><br><span class="line">Thread::~<span class="built_in">Thread</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个线程，并执行线程处理函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadHandler_, threadId_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将子线程设置为分离线程</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread::getId</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> threadId_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于辅助生成全局唯一的线程ID</span></span><br><span class="line"><span class="keyword">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 ////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池构造</span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>() {</span><br><span class="line">    idleThreadSize_ = <span class="number">0</span>;</span><br><span class="line">    curThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">    initThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">    threadSizeMaxThreshHold_ = THREAD_SIZE_MAX_THRESHHOLD;</span><br><span class="line">    taskSize_ = <span class="number">0</span>;</span><br><span class="line">    taskQueMaxThreshHold_ = TASK_MAX_THRESHHOLD;</span><br><span class="line">    poolMode_ = PoolMode::MODE_FIXED;</span><br><span class="line">    isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池析构</span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">    <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">    isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁，用于等待线程池里面所有的线程结束运行（线程有两种状态：阻塞等待获取任务 &amp; 正在执行任务中）</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须先获取互斥锁，然后再唤醒所有正在等待获取任务的线程，避免发生线程死锁问题</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程池里的所有线程回收完成</span></span><br><span class="line">    allExit_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的工作模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setMode</span><span class="params">(PoolMode mode)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        poolMode_ = mode;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; !<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        threadSizeMaxThreshHold_ = threshhold;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查线程池的运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ThreadPool::checkRunningState</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isPoolRuning_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理已完成的任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::cleanTaskResult</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">    <span class="comment">// 将满足条件的元素移动到容器末尾</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = std::<span class="built_in">remove_if</span>(taskResults_.<span class="built_in">begin</span>(), taskResults_.<span class="built_in">end</span>(), [](<span class="keyword">const</span> std::shared_ptr&lt;Result&gt; &amp;res) {</span><br><span class="line">        <span class="keyword">return</span> res-&gt;<span class="built_in">isFinished</span>();</span><br><span class="line">    });</span><br><span class="line">    <span class="comment">// 删除容器末尾那段区域的所有元素</span></span><br><span class="line">    taskResults_.<span class="built_in">erase</span>(new_end, taskResults_.<span class="built_in">end</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="keyword">int</span> initThreadSize)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">    isPoolRuning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录初始的线程数量</span></span><br><span class="line">    initThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前线程池的线程数量</span></span><br><span class="line">    curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">        <span class="comment">// 创建线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">        std::unique_ptr&lt;Thread&gt; thread = extend::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        <span class="comment">// 将线程对象放入线程集合中</span></span><br><span class="line">        threads_.<span class="built_in">emplace</span>(thread-&gt;<span class="built_in">getId</span>(), std::<span class="built_in">move</span>(thread));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动初始的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>();    <span class="comment">// 启动一个线程去执行线程处理函数</span></span><br><span class="line">        idleThreadSize_++;        <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span> </span>{</span><br><span class="line">    <span class="comment">// 记录当前线程首次运行的时间</span></span><br><span class="line">    <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For死循环，为了实现在线程池结束时，所有任务必须执行完成，线程池才可以回收线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 等待获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让当前线程等待获取任务，使用While循环避免虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 如果任务列表为空，且线程池要结束运行，则回收当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">                <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                <span class="comment">// 唤醒等待线程池回收完毕的线程</span></span><br><span class="line">                allExit_.<span class="built_in">notify_all</span>();</span><br><span class="line">                <span class="comment">// 打印日志信息</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">"thread pool destroy, thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 线程池Cached模式的处理,由于Cached模式下有可能已经创建了很多的线程，但是空闲时间超过最大阀值，因此需要将多余的空闲线程回收掉</span></span><br><span class="line">            <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_) {</span><br><span class="line">                std::cv_status waitResult = notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 需要区分超时返回，还是线程正常被唤醒返回</span></span><br><span class="line">                <span class="keyword">if</span> (std::cv_status::timeout == waitResult) {</span><br><span class="line">                    <span class="keyword">auto</span> nowTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">                    <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(nowTime - lastTime);</span><br><span class="line">                    <span class="comment">// 当线程的空闲时间超过最大阀值，且当前线程池的线程数量大于初始线程数量，则开始回收线程池中的空闲线程</span></span><br><span class="line">                    <span class="keyword">if</span> (duration.<span class="built_in">count</span>() &gt; THREAD_MAX_IDLE_TIME &amp;&amp; curThreadSize_ &gt; initThreadSize_) {</span><br><span class="line">                        <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                        threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                        <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">                        idleThreadSize_--;</span><br><span class="line">                        <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">                        curThreadSize_--;</span><br><span class="line">                        <span class="comment">// 打印日志信息</span></span><br><span class="line">                        std::cout &lt;&lt; <span class="string">"idle thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                        <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 线程池Fixed模式的处理</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 等待任务队列不为空</span></span><br><span class="line">                notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新空闲线程数量（在当前线程执行任务之前）</span></span><br><span class="line">        idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从任务队列中获取需要执行的任务</span></span><br><span class="line">        std::shared_ptr&lt;Task&gt; task = taskQueue_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务从任务队列中移除</span></span><br><span class="line">        taskQueue_.<span class="built_in">pop</span>();</span><br><span class="line">        taskSize_--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 成功获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果获取了任务之后，任务队列依旧不为空，则继续通知其他线程执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (taskQueue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">            notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为刚获取了任务，任务队列肯定有空余位置（不满），通知用户提交任务到线程池</span></span><br><span class="line">        notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放互斥锁（在当前线程执行任务之前）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程负责执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">nullptr</span>) {</span><br><span class="line">            task-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新空闲线程数量（在当前线程执行完任务之后）</span></span><br><span class="line">        idleThreadSize_++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理已完成的任务执行结果（在当前线程执行完任务之后）</span></span><br><span class="line">        <span class="built_in">cleanTaskResult</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前线程最后执行完任务的时间</span></span><br><span class="line">        lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务给线程池</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Result&gt; <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务队列有空余位置（不满）</span></span><br><span class="line">    <span class="keyword">bool</span> waitResult = notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [<span class="keyword">this</span>]() { <span class="keyword">return</span> taskQueue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; });</span><br><span class="line">    <span class="comment">// 如果等待超时，则返回无效的任务执行结果</span></span><br><span class="line">    <span class="keyword">if</span> (!waitResult) {</span><br><span class="line">        <span class="comment">// 打印错误信息</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"task queue is full, submit task failed."</span>;</span><br><span class="line">        <span class="comment">// 无效的任务执行结果</span></span><br><span class="line">        std::shared_ptr&lt;Result&gt; result = std::make_shared&lt;Result&gt;(task, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">        <span class="comment">// 将任务执行结果保存起来，防止用户未使用而导致提前析构</span></span><br><span class="line">        taskResults_.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">        <span class="comment">// 返回任务执行结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务队列有空余位置（不满），则将任务放入任务队列中</span></span><br><span class="line">    taskQueue_.<span class="built_in">emplace</span>(task);</span><br><span class="line">    taskSize_++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为刚放入了新任务，任务队列肯定不为空，通知线程池中的线程去执行任务</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池Cached模式的处理，根据任务数量动态增加线程池的线程数量</span></span><br><span class="line">    <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; taskSize_ &gt; idleThreadSize_ &amp;&amp; curThreadSize_ &lt; threadSizeMaxThreshHold_) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"expand and create new thread."</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 创建新线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">        std::unique_ptr&lt;Thread&gt; thread = extend::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        <span class="comment">// 获取线程ID（必须在线程放入线程集合之前获取一次线程ID，否则后续将可能获取到空值）</span></span><br><span class="line">        <span class="keyword">int</span> threadId = thread-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        <span class="comment">// 将新线程对象放入线程集合中</span></span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(thread));</span><br><span class="line">        <span class="comment">// 启动新线程</span></span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">        idleThreadSize_++;</span><br><span class="line">        <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">        curThreadSize_++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有效的任务执行结果</span></span><br><span class="line">    std::shared_ptr&lt;Result&gt; result = std::make_shared&lt;Result&gt;(task);</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">    <span class="comment">// 将任务执行结果保存起来，防止用户未使用而导致提前析构</span></span><br><span class="line">    taskResults_.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">    <span class="comment">// 返回任务执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> ULong = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义任务类（模拟并行计算）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculateTask</span> :</span> <span class="keyword">public</span> Task {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CalculateTask</span>(ULong begin, ULong end) : <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"execute task by thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程执行计算</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ULong i = begin_; i &lt;= end_; ++i) {</span><br><span class="line">            sum += i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前线程的计算结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Any</span>(sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ULong begin_;    <span class="comment">// 开始计算的位置</span></span><br><span class="line">    ULong end_;      <span class="comment">// 结束计算的位置</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 线程池的工作模式</span></span><br><span class="line">    <span class="keyword">int</span> poolMode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 获取用户输入</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"请选择线程池的工作模式，0 - Fixed，1 - Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; poolMode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为非法输入</span></span><br><span class="line">        <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) {</span><br><span class="line">            <span class="comment">// 清除错误标志位</span></span><br><span class="line">            std::cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">// 丢弃错误输入</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"输入无效，请重新输入一个合法的数字！\n"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部作用域开始</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPool pool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// Fixed模式（固定大小线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_FIXED);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Fixed"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Cached模式（缓存线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">            pool.<span class="built_in">setThreadSizeMaxThreshHold</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程池（指定初始的线程数量）</span></span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::shared_ptr&lt;Result&gt;&gt; results;</span><br><span class="line">        ULong begin = <span class="number">0</span>;</span><br><span class="line">        ULong end = <span class="number">0</span>;</span><br><span class="line">        ULong step = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交多个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// 计算区间</span></span><br><span class="line">            begin = end + <span class="number">1</span>;</span><br><span class="line">            end = begin + step - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建任务</span></span><br><span class="line">            std::shared_ptr&lt;Task&gt; task = std::make_shared&lt;CalculateTask&gt;(begin, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            std::shared_ptr&lt;Result&gt; result = pool.<span class="built_in">submitTask</span>(task);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储任务执行结果</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;<span class="built_in">isValid</span>()) {</span><br><span class="line">                results.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计任务执行结果</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取任务执行结果</span></span><br><span class="line">            ULong result = results[i]-&gt;<span class="built_in">get</span>().cast&lt;ULong&gt;();</span><br><span class="line">            sum += result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出并行计算结果</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"==&gt; 计算结果：1 + 2 + ... + "</span> &lt;&lt; end &lt;&lt; <span class="string">" = "</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是Cached模式，则等待一段时间，触发线程池回收空闲线程</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">1</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）..."</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(THREAD_MAX_IDLE_TIME + <span class="number">5</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 局部作用域结束，线程池自动析构，回收线程池中的所有线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞主线程，直到用户按下任意键才结束程序</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 平台编译测试代码，生成并运行可执行测试程序（使用的 <code>g++</code> 版本是 <code>4.8.5</code>）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++ -Iinclude src/thread_pool.cpp src/test.cpp -o thread_pool_test -pthread -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行测试程序</span></span><br><span class="line">./thread_pool_test</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Fixed 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Fixed</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">thread pool destroy, thread 480 exited.</span><br><span class="line">thread pool destroy, thread 11872 exited.</span><br><span class="line">thread pool destroy, thread 2620 exited.</span><br><span class="line">thread pool destroy, thread 9140 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Cached 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Cached</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15144 成功获取任务...</span><br><span class="line">execute task by thread 15144</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 20812 成功获取任务...</span><br><span class="line">execute task by thread 20812</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 3904 成功获取任务...</span><br><span class="line">execute task by thread 3904</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 15616 成功获取任务...</span><br><span class="line">execute task by thread 15616</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 9800 成功获取任务...</span><br><span class="line">execute task by thread 9800</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）...</span><br><span class="line">idle thread 15616 exited.</span><br><span class="line">idle thread 9800 exited.</span><br><span class="line">idle thread 480 exited.</span><br><span class="line">idle thread 15144 exited.</span><br><span class="line">thread pool destroy, thread 20864 exited.</span><br><span class="line">thread pool destroy, thread 11812 exited.</span><br><span class="line">thread pool destroy, thread 20812 exited.</span><br><span class="line">thread pool destroy, thread 3904 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><h5 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h5><p>为了便于将线程池库提供给第三方使用，可以将线程池项目的核心源码编译成动态链接库。下面将以 Linux 平台为例，介绍使用不同的方式将线程池项目编译为动态链接库（<code>.so</code> 文件）。值得一提的是，C++ 线程池项目的目录结构如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c++-11-thread-pool</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│&nbsp;&nbsp; ├── extend.h</span><br><span class="line">│&nbsp;&nbsp; └── thread_pool.h</span><br><span class="line">└── src</span><br><span class="line">    ├── test.cpp</span><br><span class="line">    └── thread_pool.cpp</span><br></pre></td></tr></tbody></table></figure><h6 id="GCC-编译"><a href="#GCC-编译" class="headerlink" title="GCC 编译"></a>GCC 编译</h6><div class="admonition note"><p class="admonition-title">版本说明</p><p>本文使用的 <code>g++</code> 版本是 <code>4.8.5</code>，若版本过低，可能会出现线程池代码编译失败的问题。</p></div><ul><li>项目的编译构建 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成动态链接库</span></span><br><span class="line">g++ -fPIC -Iinclude -shared src/thread_pool.cpp -o libthread_pool.so -pthread -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++ -Iinclude src/thread_pool.cpp src/test.cpp -o thread_pool_test -pthread -std=c++11</span><br></pre></td></tr></tbody></table></figure><ul><li>编译参数的说明</li></ul><table><thead><tr><th>编译参数</th><th></th><th>参数说明</th></tr></thead><tbody><tr><td><code>-fPIC</code></td><td></td><td>生成位置无关代码，<code>.so</code> 文件必须使用</td></tr><tr><td><code>-Iinclude</code></td><td></td><td>指定头文件目录为 <code>include</code></td></tr><tr><td><code>-shared</code></td><td></td><td>指定编译生成共享库（动态链接库）</td></tr><tr><td><code>src/thread_pool.cpp</code></td><td></td><td>指定源文件路径</td></tr><tr><td><code>-o libthread_pool.so</code></td><td></td><td>指定编译输出的文件名</td></tr><tr><td><code>-pthread</code></td><td></td><td>链接 <code>pthread</code> 库</td></tr><tr><td><code>-std=c++11</code></td><td></td><td>指定 C++ 版本</td></tr></tbody></table><ul><li>动态链接库的安装（可选），如果不安装，第三方程序在运行时可能会遇到找不到动态链接库的问题 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将头文件安装到系统中</span></span><br><span class="line">sudo cp ./include/* /usr/<span class="built_in">local</span>/include</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将编译生成的动态链接库安装到系统中</span></span><br><span class="line">sudo cp libthread_pool.so /usr/<span class="built_in">local</span>/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统的动态链接库配置文件</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt; /etc/ld.so.conf.d/custom.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载系统的动态链接库配置</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></tbody></table></figure><h6 id="CMake-编译"><a href="#CMake-编译" class="headerlink" title="CMake 编译"></a>CMake 编译</h6><div class="admonition note"><p class="admonition-title">版本说明</p><p>本文使用的 <code>g++</code> 版本是 <code>4.8.5</code>，CMake 版本是 <code>3.25.1</code>，若版本过低，可能会出现线程池代码编译失败的问题。值得一提的是，CMake 的详细使用教程可以参考 <a href="/posts/b6161f29.html">这里</a>。</p></div><ul><li>项目的 CMake 配置 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line"># 项目名称和语言</span><br><span class="line">project(cxx_11_thread_pool VERSION 1.0 LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"># 设置 C++ 版本</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line"></span><br><span class="line"># 设置构建模式</span><br><span class="line">set(CMAKE_BUILD_TYPE Debug CACHE STRING "" FORCE)</span><br><span class="line"></span><br><span class="line"># 设置头文件目录</span><br><span class="line">include_directories(${CMAKE_SOURCE_DIR}/include)</span><br><span class="line"></span><br><span class="line"># 设置源文件</span><br><span class="line">file(GLOB SRC_FILES src/*.cpp)</span><br><span class="line"></span><br><span class="line"># 编译生成动态链接库</span><br><span class="line">add_library(thread_pool SHARED ${SRC_FILES})</span><br><span class="line"></span><br><span class="line"># 设置动态链接库的文件名称</span><br><span class="line">set_target_properties(thread_pool PROPERTIES</span><br><span class="line">        OUTPUT_NAME "thread_pool"</span><br><span class="line">        PREFIX "lib"</span><br><span class="line">        SUFFIX ".so"</span><br><span class="line">        POSITION_INDEPENDENT_CODE ON</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 设置动态链接库的链接标志</span><br><span class="line">if (CMAKE_SYSTEM_NAME STREQUAL "Linux")</span><br><span class="line">    target_link_libraries(thread_pool PRIVATE pthread)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line"># 编译生成可执行测试程序</span><br><span class="line">add_executable(thread_pool_test ${SRC_FILES})</span><br><span class="line"></span><br><span class="line"># 设置可执行测试程序的链接标志</span><br><span class="line">if (CMAKE_SYSTEM_NAME STREQUAL "Linux")</span><br><span class="line">    target_link_libraries(thread_pool_test PRIVATE pthread)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line"># 设置默认的安装前缀路径</span><br><span class="line">if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)</span><br><span class="line">    set(CMAKE_INSTALL_PREFIX "/usr/local" CACHE PATH "Install path prefix." FORCE)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"># 将头文件和编译生成的动态链接库安装到指定位置（可选）</span><br><span class="line">install(DIRECTORY include/ DESTINATION include)</span><br><span class="line">install(TARGETS thread_pool DESTINATION lib)</span><br></pre></td></tr></tbody></table></figure><ul><li>项目的编译构建 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成动态链接库和可执行测试程序</span></span><br><span class="line">cmake -S . -B build &amp;&amp; cmake --build build</span><br></pre></td></tr></tbody></table></figure><ul><li>编译参数的说明</li></ul><table><thead><tr><th>编译参数</th><th>参数说明</th></tr></thead><tbody><tr><td><code>-S .</code></td><td>指定源码目录为当前目录（包含 <code>CMakeLists.txt</code>）</td></tr><tr><td><code>-B build</code></td><td>指定构建目录为 <code>build</code>，不存在时会自动创建</td></tr><tr><td><code>cmake --build build</code></td><td>执行编译（相当于 <code>make</code>）</td></tr></tbody></table><ul><li>动态链接库的安装（可选），如果不安装，第三方程序在运行时可能会遇到找不到动态链接库的问题 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将头文件和编译生成的动态链接库安装到系统中</span></span><br><span class="line">sudo cmake --install build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统的动态链接库配置文件</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt; /etc/ld.so.conf.d/custom.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载系统的动态链接库配置</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></tbody></table></figure><h4 id="C-17-版本"><a href="#C-17-版本" class="headerlink" title="C++ 17 版本"></a>C++ 17 版本</h4><p>这里基于 C++ 17 手写一个线程池，使用了可变参数模板、<code>make_unique()</code>、<code>packaged_task</code>、<code>future</code> 特性。</p><div class="admonition note"><p class="admonition-title">代码下载</p><p>C++ 17 实现线程池的完整案例代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-thread-pool/c%2B%2B-17-thread-pool">这里</a> 下载得到，所有案例代码都兼容 Windows 和 Linux 平台。</p></div><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><ul><li><code>thread_pool.h</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池核心参数 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的线程数量（默认是CPU的核心数）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INIT_THREAD_SIZE = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TASK_MAX_THRESHHOLD = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_SIZE_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程允许的最大空闲时间（单位秒）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">PoolMode</span> {</span></span><br><span class="line">    MODE_FIXED,    <span class="comment">// 固定大小线程池</span></span><br><span class="line">    MODE_CACHED    <span class="comment">// 缓存线程池</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数对象的类型</span></span><br><span class="line">    <span class="keyword">using</span> ThreadHandler = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程构造</span></span><br><span class="line">    <span class="built_in">Thread</span>(ThreadHandler handler) : <span class="built_in">threadHandler_</span>(handler), <span class="built_in">threadId_</span>(generateId_++) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程析构</span></span><br><span class="line">    ~<span class="built_in">Thread</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个线程，并执行线程处理函数</span></span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">(threadHandler_, threadId_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子线程设置为分离线程</span></span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程ID</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> threadId_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> threadId_;                    <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> generateId_;           <span class="comment">// 用于辅助生成全局唯一的线程ID</span></span><br><span class="line">    ThreadHandler threadHandler_;     <span class="comment">// 线程处理函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于辅助生成全局唯一的线程ID</span></span><br><span class="line"><span class="keyword">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>() {</span><br><span class="line">        idleThreadSize_ = <span class="number">0</span>;</span><br><span class="line">        curThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">        initThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">        threadSizeMaxThreshHold_ = THREAD_SIZE_MAX_THRESHHOLD;</span><br><span class="line">        taskSize_ = <span class="number">0</span>;</span><br><span class="line">        taskQueMaxThreshHold_ = TASK_MAX_THRESHHOLD;</span><br><span class="line">        poolMode_ = PoolMode::MODE_FIXED;</span><br><span class="line">        isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池析构</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">        <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">        isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁，用于等待线程池里面所有的线程结束运行（线程有两种状态：阻塞等待获取任务 &amp; 正在执行任务中）</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须先获取互斥锁，然后再唤醒所有正在等待获取任务的线程，避免发生线程死锁问题</span></span><br><span class="line">        notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程池里的所有线程回收完成</span></span><br><span class="line">        allExit_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            poolMode_ = mode;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; !<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            threadSizeMaxThreshHold_ = threshhold;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initThreadSize)</span> </span>{</span><br><span class="line">        <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">        isPoolRuning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录初始的线程数量</span></span><br><span class="line">        initThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前线程池的线程数量</span></span><br><span class="line">        curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建初始的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">            <span class="comment">// 创建线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">            std::unique_ptr&lt;Thread&gt; thread = std::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">            <span class="comment">// 将线程对象放入线程集合中</span></span><br><span class="line">            threads_.<span class="built_in">emplace</span>(thread-&gt;<span class="built_in">getId</span>(), std::<span class="built_in">move</span>(thread));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动初始的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">            threads_[i]-&gt;<span class="built_in">start</span>();    <span class="comment">// 启动一个线程去执行线程处理函数</span></span><br><span class="line">            idleThreadSize_++;       <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务给线程池（使用可变参数模板 + 引用折叠 + 完美转发）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func &amp;&amp;func, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt; </span>{</span><br><span class="line">        <span class="comment">// 推导任务执行结果的类型（返回值类型）</span></span><br><span class="line">        <span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装一个任意可调用对象（函数、函数对象、Lambda表达式等）为异步任务</span></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">                std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取与异步任务关联的Future，方便用户获取任务执行结果</span></span><br><span class="line">        std::future&lt;RType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待任务队列有空余位置（不满）</span></span><br><span class="line">        <span class="keyword">bool</span> waitResult = notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [<span class="keyword">this</span>]() { <span class="keyword">return</span> taskQueue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; });</span><br><span class="line">        <span class="comment">// 如果等待超时，则直接返回Future</span></span><br><span class="line">        <span class="keyword">if</span> (!waitResult) {</span><br><span class="line">            <span class="comment">// 打印错误信息</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">"task queue is full, submit task failed."</span>;</span><br><span class="line">            <span class="comment">// 封装一个空的任务</span></span><br><span class="line">            <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;([]() -&gt; RType { <span class="keyword">return</span> <span class="built_in">RType</span>(); });</span><br><span class="line">            <span class="comment">// 执行一个空的任务</span></span><br><span class="line">            (*task)();</span><br><span class="line">            <span class="comment">// 返回与任务关联的Future</span></span><br><span class="line">            <span class="keyword">return</span> task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果任务队列有空余位置（不满），则将任务放入任务队列中</span></span><br><span class="line">        taskQueue_.<span class="built_in">emplace</span>([task]() {</span><br><span class="line">            (*task)();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前任务队列的任务数量</span></span><br><span class="line">        taskSize_++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为刚放入了新任务，任务队列肯定不为空，通知线程池中的线程去执行任务</span></span><br><span class="line">        notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池Cached模式的处理，根据任务数量动态增加线程池的线程数量</span></span><br><span class="line">        <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; taskSize_ &gt; idleThreadSize_ &amp;&amp; curThreadSize_ &lt; threadSizeMaxThreshHold_) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"expand and create new thread."</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 创建新线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">            std::unique_ptr&lt;Thread&gt; thread = std::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">            <span class="comment">// 获取线程ID（必须在线程放入线程集合之前获取一次线程ID，否则后续将可能获取到空值）</span></span><br><span class="line">            <span class="keyword">int</span> threadId = thread-&gt;<span class="built_in">getId</span>();</span><br><span class="line">            <span class="comment">// 将新线程对象放入线程集合中</span></span><br><span class="line">            threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(thread));</span><br><span class="line">            <span class="comment">// 启动新线程</span></span><br><span class="line">            threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">            <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">            idleThreadSize_++;</span><br><span class="line">            <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">            curThreadSize_++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回与任务关联的Future</span></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span> </span>{</span><br><span class="line">        <span class="comment">// 记录当前线程首次运行的时间</span></span><br><span class="line">        <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For死循环，为了实现在线程池结束时，所有任务必须执行完成，线程池才可以回收线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 等待获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让当前线程等待获取任务，使用While循环避免虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 如果任务列表为空，且线程池要结束运行，则回收当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">                    <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                    threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                    <span class="comment">// 唤醒等待线程池回收完毕的线程</span></span><br><span class="line">                    allExit_.<span class="built_in">notify_all</span>();</span><br><span class="line">                    <span class="comment">// 打印日志信息</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">"thread pool destroy, thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 线程池Cached模式的处理,由于Cached模式下有可能已经创建了很多的线程，但是空闲时间超过最大阀值，因此需要将多余的空闲线程回收掉</span></span><br><span class="line">                <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_) {</span><br><span class="line">                    std::cv_status waitResult = notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 需要区分超时返回，还是线程正常被唤醒返回</span></span><br><span class="line">                    <span class="keyword">if</span> (std::cv_status::timeout == waitResult) {</span><br><span class="line">                        <span class="keyword">auto</span> nowTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">                        <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(nowTime - lastTime);</span><br><span class="line">                        <span class="comment">// 当线程的空闲时间超过最大阀值，且当前线程池的线程数量大于初始线程数量，则开始回收线程池中的空闲线程</span></span><br><span class="line">                        <span class="keyword">if</span> (duration.<span class="built_in">count</span>() &gt; THREAD_MAX_IDLE_TIME &amp;&amp; curThreadSize_ &gt; initThreadSize_) {</span><br><span class="line">                            <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                            threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                            <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">                            idleThreadSize_--;</span><br><span class="line">                            <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">                            curThreadSize_--;</span><br><span class="line">                            <span class="comment">// 打印日志信息</span></span><br><span class="line">                            std::cout &lt;&lt; <span class="string">"idle thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                            <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 线程池Fixed模式的处理</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 等待任务队列不为空</span></span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新空闲线程数量（在当前线程执行任务之前）</span></span><br><span class="line">            idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从任务队列中获取需要执行的任务</span></span><br><span class="line">            Task task = taskQueue_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务从任务队列中移除</span></span><br><span class="line">            taskQueue_.<span class="built_in">pop</span>();</span><br><span class="line">            taskSize_--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 成功获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果获取了任务之后，任务队列依旧不为空，则继续通知其他线程执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (taskQueue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">                notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为刚获取了任务，任务队列肯定有空余位置（不满），通知用户提交任务到线程池</span></span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放互斥锁（在当前线程执行任务之前）</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前线程负责执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新空闲线程数量（在当前线程执行完任务之后）</span></span><br><span class="line">            idleThreadSize_++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新当前线程最后执行完任务的时间</span></span><br><span class="line">            lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池的运行状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> isPoolRuning_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;        <span class="comment">// 线程集合</span></span><br><span class="line">    PoolMode poolMode_;                                               <span class="comment">// 线程池的模式</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isPoolRuning_;                                   <span class="comment">// 表示线程池是否正在运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> initThreadSize_;                                           <span class="comment">// 初始的线程数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> idleThreadSize_;                                  <span class="comment">// 空闲线程的数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> curThreadSize_;                                   <span class="comment">// 当前线程池的线程数量</span></span><br><span class="line">    <span class="keyword">int</span> threadSizeMaxThreshHold_;                                     <span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;                               <span class="comment">// 类型重定义，使用Function类模板作为任务</span></span><br><span class="line">    std::queue&lt;Task&gt; taskQueue_;                                      <span class="comment">// 任务队列</span></span><br><span class="line">    std::<span class="keyword">atomic_uint</span> taskSize_;                                       <span class="comment">// 当前任务队列的任务数量</span></span><br><span class="line">    <span class="keyword">size_t</span> taskQueMaxThreshHold_;                                     <span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"></span><br><span class="line">    std::mutex taskQueMtx_;                                           <span class="comment">// 任务队列操作的互斥锁</span></span><br><span class="line">    std::condition_variable notFull_;                                 <span class="comment">// 表示任务队列不满，用于通知用户线程提交任务</span></span><br><span class="line">    std::condition_variable notEmpty_;                                <span class="comment">// 表示任务队列不空，用于通知线程池中的线程执行任务</span></span><br><span class="line">    std::condition_variable allExit_;                                 <span class="comment">// 表示等待线程池回收所有线程</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// THREAD_POOL_H</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> ULong = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算逻辑</span></span><br><span class="line"><span class="function">ULong <span class="title">sum</span><span class="params">(ULong begin, ULong end)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"execute task by thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程执行加法计算</span></span><br><span class="line">    ULong sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ULong i = begin; i &lt;= end; ++i) {</span><br><span class="line">        sum += i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回计算结果</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 线程池的工作模式</span></span><br><span class="line">    <span class="keyword">int</span> poolMode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 获取用户输入</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"请选择线程池的工作模式，0 - Fixed，1 - Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; poolMode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为非法输入</span></span><br><span class="line">        <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) {</span><br><span class="line">            <span class="comment">// 清除错误标志位</span></span><br><span class="line">            std::cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">// 丢弃错误输入</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"输入无效，请重新输入一个合法的数字！\n"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部作用域开始</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPool pool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// Fixed模式（固定大小线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_FIXED);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Fixed"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Cached模式（缓存线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">            pool.<span class="built_in">setThreadSizeMaxThreshHold</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程池（指定初始的线程数量）</span></span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储与任务关联的Future</span></span><br><span class="line">        std::vector&lt;std::future&lt;ULong&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">        ULong begin = <span class="number">0</span>;</span><br><span class="line">        ULong end = <span class="number">0</span>;</span><br><span class="line">        ULong step = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交多个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// 计算区间</span></span><br><span class="line">            begin = end + <span class="number">1</span>;</span><br><span class="line">            end = begin + step - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            std::future&lt;ULong&gt; result = pool.<span class="built_in">submitTask</span>(sum, begin, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储与任务关联的Future</span></span><br><span class="line">            results.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(result));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计任务执行结果</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取任务执行结果</span></span><br><span class="line">            ULong result = results[i].<span class="built_in">get</span>();</span><br><span class="line">            sum += result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出并行计算结果</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"==&gt; 计算结果：1 + 2 + ... + "</span> &lt;&lt; end &lt;&lt; <span class="string">" = "</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是Cached模式，则等待一段时间，触发线程池回收空闲线程</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">1</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）..."</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(THREAD_MAX_IDLE_TIME + <span class="number">5</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 局部作用域结束，线程池自动析构，回收线程池中的所有线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞主线程，直到用户按下任意键才结束程序</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 平台编译测试代码，生成并运行可执行测试程序（使用的 <code>g++</code> 版本是 <code>12.2.0</code>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-17-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++<span class="params"> -Iinclude</span> src/<span class="built_in">test</span>.cpp<span class="params"> -o</span> thread_pool_test<span class="params"> -pthread</span><span class="params"> -std</span>=c++17</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行测试程序</span></span><br><span class="line">./thread_pool_test</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Fixed 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Fixed</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">thread pool destroy, thread 480 exited.</span><br><span class="line">thread pool destroy, thread 11872 exited.</span><br><span class="line">thread pool destroy, thread 2620 exited.</span><br><span class="line">thread pool destroy, thread 9140 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Cached 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Cached</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15144 成功获取任务...</span><br><span class="line">execute task by thread 15144</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 20812 成功获取任务...</span><br><span class="line">execute task by thread 20812</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 3904 成功获取任务...</span><br><span class="line">execute task by thread 3904</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 15616 成功获取任务...</span><br><span class="line">execute task by thread 15616</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 9800 成功获取任务...</span><br><span class="line">execute task by thread 9800</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）...</span><br><span class="line">idle thread 15616 exited.</span><br><span class="line">idle thread 9800 exited.</span><br><span class="line">idle thread 480 exited.</span><br><span class="line">idle thread 15144 exited.</span><br><span class="line">thread pool destroy, thread 20864 exited.</span><br><span class="line">thread pool destroy, thread 11812 exited.</span><br><span class="line">thread pool destroy, thread 20812 exited.</span><br><span class="line">thread pool destroy, thread 3904 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><h5 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h5><div class="admonition warning"><p class="admonition-title">动态链接库说明</p><p>由于上面基于 C++ 17 实现的线程池，其核心源码全部都写在头文件中，也就是说 <code>thread_pool.h</code> 是纯 Header-Only（例如类模板 / 函数模板全部实现都在头文件中），因此该线程池项目是无法编译成动态链接库（比如 <code>.so</code>）的。如果一定要编译成动态链接库，可以将线程池的核心代码逻辑移植到 <code>.cpp</code> 源文件，然后再编译成动态链接库。由于篇幅有限，这里不再累述。</p></div><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>(1) 基于 C++ 11 / C++ 17 实现线程池，当线程池准备结束运行（销毁），需要等待线程池中所有线程退出时，发生线程死锁问题，导致应用进程无法正常退出。</li><li>(2) 基于 C++ 11 实现线程池，在 Windows 平台下可以正常运行，但在 Linux 平台下运行时自定义实现的信号量类型 Semaphore 会出现线程死锁问题（原因是 <code>condition_variable</code> 的析构函数为空导致，一旦 Result 对象比 Task 对象早被析构就会出现线程死锁）。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>这里提到的两个线程死锁问题，在上面给出的 C++ 11 / C++ 17 线程池代码中已经解决了。</p></div><h4 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h4><p>定位死锁问题时，通常可以通过 <code>gdb</code> 附加（<code>attach</code>）到正在运行的目标进程，然后使用以下命令进行分析：</p><ul><li>使用 <code>ps</code> 命令查找目标进程的 ID；</li><li>使用 <code>gdb attch &lt;pid&gt;</code> 命令附加到目标进程；</li><li>使用 <code>info threads</code> 命令查看当前进程中所有线程的状态及线程 ID；</li><li>使用 <code>thread &lt;tid&gt;</code> 命令切换到指定的线程；</li><li>使用 <code>bt</code> 命令查看当前线程的调用堆栈信息，判断其是否被阻塞、在等待互斥锁（<code>mutex</code>）、或处于循环等待状态；</li><li>重复以上操作，依次分析所有可疑线程的调用堆栈信息，找出多个线程相互等待资源的典型死锁原因。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看目标进程的 ID</span></span><br><span class="line">ps -aux|grep thread_pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 附加的目标进程</span></span><br><span class="line">$ gdb attach &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（查看目标进程中的所有线程）</span></span><br><span class="line">&gt; (gdb) info threads</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（切换到指定的线程）</span></span><br><span class="line">&gt; (gdb) thread &lt;id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（查看当前线程的调用堆栈信息）</span></span><br><span class="line">&gt; (gdb) bt</span><br></pre></td></tr></tbody></table></figure><p>结合项目源码和线程之间的加锁、解锁逻辑，定位到具体发生死锁的代码片段后，可以进一步分析导致死锁的根本原因，常见的原因包括：</p><ul><li>多个线程交叉持有多个锁，且锁的获取顺序不一致；</li><li>忽略了可能抛异常或提前返回，导致某个线程未能正确释放锁；</li><li>加锁和等待条件变量的时机不当等；</li><li>多个资源需要同时加锁时，未采用统一锁策略（比如没有统一使用 <code>lock()</code> 或 <code>unique_lock</code>）。</li></ul><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>规范加锁顺序，避免循环依赖；</li><li>拆分锁或减少锁的粒度；</li><li>使用 <code>try_lock()</code> 等避免阻塞的锁操作；</li><li>引入超时机制，防止死锁的出现；</li><li>在合适的场景下，可以引入无锁并发编程模型（如基于 CAS 的算法），以提升性能并减少锁竞争带来的开销。</li></ul><h2 id="项目输出总结"><a href="#项目输出总结" class="headerlink" title="项目输出总结"></a>项目输出总结</h2><h3 id="应用到企业项目中"><a href="#应用到企业项目中" class="headerlink" title="应用到企业项目中"></a>应用到企业项目中</h3><ul><li>耗时任务处理</li><li>高并发高性能网络服务器</li><li> Master-Slave 线程模型（可用于并行计算）</li></ul><h3 id="输出到求职简历上"><a href="#输出到求职简历上" class="headerlink" title="输出到求职简历上"></a>输出到求职简历上</h3><ul><li><p><strong>项目名称</strong></p><ul><li>基于可变参数模板实现线程池</li></ul></li><li><p><strong>项目描述</strong></p><ul><li>基于可变参数模板和引用折叠原理，实现线程池 <code>submitTask</code> 接口，支持任意任务函数和任意参数的传递</li><li>使用 <code>future</code> 类型定制 <code>submitTask</code> 接口提交任务的返回值</li><li>使用 <code>map</code> 和 <code>queue</code> 容器管理线程对象和任务</li><li>基于条件变量 <code>condition_variable</code> 和互斥锁 <code>mutex</code> 实现任务提交线程和任务执行线程之间的通信机制</li><li>支持 Fixed 和 Cached 模式的线程池</li><li>……（自由发挥）</li></ul></li><li><p><strong>项目问题</strong></p><ul><li>遇到的问题<ul><li>基于 C++ 11 / C++ 17 实现线程池，当线程池准备结束运行（销毁），需要等待线程池中所有线程退出时，发生线程死锁问题，导致应用进程无法正常退出。</li><li>基于 C++ 11 实现线程池，在 Windows 平台下可以正常运行，但在 Linux 平台下运行时自定义实现的信号量类型会出现线程死锁问题（原因是 <code>condition_variable</code> 的析构函数为空导致，一旦 Result 对象比 Task 对象早被析构就会出现线程死锁）。</li></ul></li><li>问题的定位<ul><li>使用 <code>ps</code> 命令查找目标进程的 ID；</li><li>使用 <code>gdb attch &lt;pid&gt;</code> 命令附加到目标进程；</li><li>使用 <code>info threads</code> 命令查看当前进程中所有线程的状态及线程 ID；</li><li>使用 <code>thread &lt;tid&gt;</code> 命令切换到指定的线程；</li><li>使用 <code>bt</code> 命令查看当前线程的调用堆栈信息，判断其是否被阻塞、在等待互斥锁（<code>mutex</code>）、或处于循环等待状态；</li><li>重复以上操作，依次分析所有可疑线程的调用堆栈信息，找出多个线程相互等待资源的典型死锁原因。</li></ul></li><li>问题的解决<ul><li>结合项目源码和线程之间的加锁、解锁逻辑，定位到具体发生死锁的代码片段后，可以进一步分析导致死锁的根本原因，常见的原因包括：</li><li>(1) 多个线程交叉持有多个锁，且锁的获取顺序不一致。</li><li>(2) 忽略了可能抛异常或提前返回，导致某个线程未能正确释放锁。</li><li>(3) 加锁和等待条件变量的时机不当等。</li><li>(4) 多个资源需要同时加锁时，未采用统一锁策略（比如没有统一使用 <code>lock()</code> 或 <code>unique_lock</code>）。</li></ul></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/a2a7ad9b.html">C++ 多线程编程之一</a></li><li><a href="/posts/832c55b5.html">Java 之线程池使用详解</a></li><li><a href="/posts/17b04dfd.html">Java 线程死锁的定位与分析</a></li><li><a href="/posts/dc8f1477.html">如何估算 Java 线程池的大小与队列长度</a></li><li><a href="/posts/f7fd0987.html">Java 多线程编程之七队列、线程池、线程通信</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何基于 C++ 手写一个线程池，并提供 C++ 11 和 C++ 17 两种版本的实现代码。</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统中缓存雪崩的解决方案</title>
    <link href="https://www.techgrow.cn/posts/77b20c93.html"/>
    <id>https://www.techgrow.cn/posts/77b20c93.html</id>
    <published>2025-05-12T13:43:32.000Z</published>
    <updated>2025-05-12T13:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在中大型项目中经常会使用到 Redis，当 Redis 缓存服务（一主多从 + 哨兵架构或者集群架构）不可用时，所有请求会直接打到 MySQL，瞬间把数据库压垮（即缓存雪崩），导致整个系统不可用。那么如何设计系统架构，即使 Redis 缓存服务完全不可用，整个系统也可以正常运行（不至于完全挂掉）呢？</p><span id="more"></span><h2 id="缓存雪崩的概念"><a href="#缓存雪崩的概念" class="headerlink" title="缓存雪崩的概念"></a>缓存雪崩的概念</h2><ul><li><strong>缓存雪崩是指在设置缓存时采用了相同的过期时间，甚至缓存中间件挂掉，导致大量缓存在某一时刻同时失效，外部请求全部转发到数据库，而数据库由于瞬时压力过重导致雪崩。</strong></li><li>简单的解决方案有以下几种：<ul><li>(1) 可以在原有的缓存过期时间基础上增加一个随机值，比如 1 ~ 5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，进而很难引发缓存集体失效的事件。</li><li>(2) 使用本地缓存（Caffeine）+ Redis 哨兵 / 集群 + Hystrix 熔断 / 降级 / 限流<ul><li>其中本地缓存（Caffeine）作为一级缓存兜底；</li><li>Redis 哨兵 / 集群保证高可用，并设置 Key 错峰过期；</li><li>Hystrix 在 Redis 服务异常时触发熔断，并降级到返回本地缓存（Caffeine）数据或默认数据，从而防止缓存雪崩导致大量请求涌入冲跨数据库。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2025/08/redis-avalanche-1.png"></p><h2 id="缓存雪崩的解决"><a href="#缓存雪崩的解决" class="headerlink" title="缓存雪崩的解决"></a>缓存雪崩的解决</h2><p>不依赖单一防线，而是用「网关限流 → 应用熔断 / 熔断 / 本地缓存 → 请求合并 → 后端拒绝」多层保护，同时提升 Redis 的 HA（高可用）能力，才能有效避免 Redis 故障时的缓存雪崩把 MySQL 打垮。</p><h3 id="整体的防护思路"><a href="#整体的防护思路" class="headerlink" title="整体的防护思路"></a>整体的防护思路</h3><ul><li>事前降级：<ul><li>在缓存不可用时允许返回 “可接受的弱一致性或降级结果”（例如：部分功能只返回缓存数据、或返回静态提示页）。</li></ul></li><li>保护后端（削峰限流）：<ul><li>对外限流、熔断、队列化，防止大量并发请求落到数据库。</li></ul></li><li>多级缓存 + 回退策略：<ul><li>本地缓存（LRU） + 远端 Redis + 数据库回源。</li></ul></li><li>请求合并：<ul><li>避免大量相同 Key 的并发请求回源到数据库。</li></ul></li><li>提高 Redis 可用性：<ul><li>部署多副本、Sentinel/Cluster、跨可用区和异地多活（长期方案）。</li></ul></li><li>可观测性 + 自动化恢复：<ul><li>指标告警（QPS、错误率、数据库连接数、Redis 失败率）、并配合自动限流 / 熔断规则。</li></ul></li></ul><h3 id="具体方案与可选框架"><a href="#具体方案与可选框架" class="headerlink" title="具体方案与可选框架"></a>具体方案与可选框架</h3><ul><li><p>(1) <strong>边缘 / 网关限流（第一道防线）</strong></p><ul><li>目的：<ul><li>在流量激增或缓存不可用时，尽早拒绝 / 排队请求，保护后端。</li></ul></li><li>常用方案：<ul><li>API 网关：Kong、Nginx + Lua（OpenResty）、Envoy、Traefik。</li><li>CDN / 边缘：使用 CDN 缓存静态或部分接口响应结果（可作为快速降级）。</li></ul></li><li>实现：<ul><li>Nginx + Lua（OpenResty）实现令牌桶 / 漏桶限流算法，非常高效，放在 LB（负载均衡）层。</li><li>Envoy 支持熔断机制（Circuit-Breaking） + 全局限流器（Global Rate-Limiter），适合微服务网格。</li></ul></li></ul></li><li><p>(2) <strong>服务端限流与令牌桶（应用层）</strong></p><ul><li>目的：<ul><li>对热点接口进行精细限流，允许重要请求先行。</li></ul></li><li>常用库：<ul><li>Java：Bucket4j、Guava RateLimiter、Resilience4j Rate Limiter、Sentinel Rate Limiter、Spring Cloud Gateway Rate Limiter。</li><li>Go：Ratelimit， Uber/Ratelimit。</li></ul></li><li>要点：<ul><li>支持按用户 / 按 key / 按接口限流。</li><li>与下游熔断器联动：当 Redis 故障探测到上升，网关自动降低阈值。</li></ul></li></ul></li><li><p>(3) <strong>熔断 / 降级（保护数据库）</strong></p><ul><li>目的：<ul><li>当 Redis / 数据库或下游服务错误率（异常、超时等）上升时，自动短路请求并返回降级结果或缓存的旧数据。</li></ul></li><li>常用库：<ul><li>Sentinel（阿里开源）：支持熔断、降级、限流、系统保护，尤其适合高并发微服务场景，可与 Spring Cloud Alibaba 集成。</li><li>Resilience4j（推荐，替代 Hystrix），支持断路器、舱壁隔离、重试、限流等。</li><li>Spring Cloud Circuit Breaker（抽象层，可对接 Resilience4j）。</li><li>Hystrix（已逐步退役 / 不推荐新项目使用）。</li></ul></li><li>策略：<ul><li>熔断器触发条件：比如，10 秒内，请求数达到阈值 20，且错误率 &gt;= 50%。</li><li>熔断后：返回降级结果（例如默认值 / 本地缓存数据 / 静态页面），同时异步收集重试 / 探测请求。</li></ul></li></ul></li><li><p>(4) <strong>多级缓存（本地 + 远端）</strong></p><ul><li>目的：<ul><li>Redis 故障时，使用本地近端缓存（Caffeine）降低数据库回源率；</li><li>利用 TTL + stale-while-revalidate 策略保证可用。<ul><li>stale-while-revalidate 策略允许在缓存过期后，先从本地缓存（Caffeine）返回旧数据保证系统可用性，同时后台异步刷新最新数据写回本地缓存和 Redis，从而避免请求阻塞和缓存雪崩。</li></ul></li></ul></li><li>实现：<ul><li>应用内 LRU（本地缓存）：Caffeine、Guava Cache。</li><li>远端缓存：Redis Cluster（Lettuce / Redisson 客户端）。</li><li>读写策略：<ul><li>读取流程：本地缓存 -&gt; Redis -&gt; DB；</li><li>写入流程：DB -&gt; Redis -&gt; 本地缓存。</li></ul></li></ul></li><li>失效策略：<ul><li>当 Redis 不可用时，从本地缓存（Caffeine）返回 “过期但可接受的旧数据”，并异步刷新最新数据写回本地缓存和 Redis。</li><li>对于强一致性场景需要谨慎考虑，必须有业务允许范围。</li></ul></li></ul></li><li><p>(5) <strong>请求合并（防止大量请求回源数据库）</strong></p><ul><li>目的：<ul><li>对同一 key 的高并发请求只允许一个请求回源到数据库，其余请求等待或返回本地缓存数据。</li></ul></li><li>实现：<ul><li>Java 自行实现，或者借助 Guava 的 <code>LoadingCache</code>、Caffeine 的 <code>AsyncLoadingCache</code> + 互斥锁。</li></ul></li></ul></li><li><p>(6) <strong>后端拒绝（数据库层保护）</strong></p><ul><li>目的：<ul><li>限制数据库的并发连接数 / QPS，保证数据库不会被压垮，必要时拒绝请求或请求排队。</li></ul></li><li>实现：<ul><li>数据库代理中间件：ProxySQL、MySQL Router，用于数据库连接限流、优先级控制。</li><li>应用层的连接池设置：合理设置数据库的最大连接数、超时、最大等待队列。</li><li>在应用层使用熔断 / 限流机制，且当 DB 连接池耗尽时直接快速失败（不阻塞调用线程）。</li></ul></li></ul></li><li><p>(7) <strong>健康检查 + 自动切换（提高 Redis 可用性）</strong></p><ul><li>目的：<ul><li>及时检测 Redis 故障并自动降级到备用逻辑（或使用备用缓存）。</li></ul></li><li>实现：<ul><li>短期方案：Redis Sentinel（一主多从）或者 Redis Cluster（多主多从、分片存储），支持自动故障转移。</li><li>长期方案：跨可用区 / 跨区域多活。</li><li>使用客户端（Lettuce / Redisson）配置连接超时、重试与负载均衡策略。</li></ul></li></ul></li></ul><h3 id="具体可落地的架构与实现"><a href="#具体可落地的架构与实现" class="headerlink" title="具体可落地的架构与实现"></a>具体可落地的架构与实现</h3><div class="admonition note"><p class="admonition-title">提示</p><p>本节将给出一个典型的 Java 微服务防护栈（分层）与核心代码示例。</p></div><blockquote><p>整体业务流程（简化）</p></blockquote><ul><li>Client -&gt; API Gateway（Nginx + Lua、Envoy 限流） -&gt; Service A</li><li>Service A 读取缓存：本地缓存（Caffeine）-&gt; Redis -&gt; DB。</li><li>系统保护组件：Resilience4j（熔断 + 舱壁隔离）、Bucket4j（限流）、Singleflight（请求合并）、异步队列（重建缓存）</li></ul><blockquote><p>边缘 / 网关限流（基于 Nginx + Lua）</p></blockquote><ul><li><p>限流实现方式</p><ul><li>在 Nginx 层使用 <code>lua-resty-limit-traffic</code> 模块</li><li>或者自定义实现令牌桶（Token-Bucket）算法</li></ul></li><li><p>限流粒度</p><ul><li>按 IP 地址</li><li>按用户 ID</li><li> 按 API Key（通常代表不同的调用者或应用）</li></ul></li><li><p>动态调整</p><ul><li>通过健康探测检测后端 Redis 状态</li><li>当 Redis 健康下降时，动态降低令牌桶的速率</li></ul></li><li><p>实现目的</p><ul><li>控制请求流量，防止后端过载</li><li>提高系统可用性和稳定性</li></ul></li></ul><blockquote><p>SpringBoot + Resilience4j + Caffeine + Lettuce（伪代码）</p></blockquote><ul><li>实现要点<ul><li><code>readFromRedisOrDB</code> 的 Redis 读需要设置短超时（比如 50 ~ 200ms），避免阻塞线程池。</li><li>Resilience4j 的 CB 配置要与业务 QPS 级别匹配：最小请求数、错误率阈值、滚动窗口大小等。</li><li>Singleflight（请求合并）可以避免短时间内 N 个相同 Key 的请求并发回源到数据库。</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 本地缓存（Caffeine）</span></span><br><span class="line">Cache&lt;String, Value&gt; localCache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">    .expireAfterWrite(Duration.ofMinutes(<span class="number">5</span>))</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 请求合并（简化实现）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, CompletableFuture&lt;Value&gt;&gt; inFlight = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">getValue</span><span class="params">(String key)</span> </span>{</span><br><span class="line">    <span class="comment">// 1) 先查本地缓存（Caffeine）</span></span><br><span class="line">    Value v = localCache.getIfPresent(key);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 尝试合并请求</span></span><br><span class="line">    CompletableFuture&lt;Value&gt; future = inFlight.computeIfAbsent(key, k -&gt; {</span><br><span class="line">        CompletableFuture&lt;Value&gt; f = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="comment">// 异步去 Redis / 数据库获取数据</span></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Value val = readFromRedisOrDB(k); <span class="comment">// 包含 Redis 超时 / 异常处理</span></span><br><span class="line">                <span class="keyword">if</span> (val != <span class="keyword">null</span>) localCache.put(k, val);</span><br><span class="line">                f.complete(val);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                f.completeExceptionally(ex);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                inFlight.remove(k);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> future.get(<span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 设置等待超时时间</span></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="comment">// 超时或失败：返回降级数据或 Error</span></span><br><span class="line">        <span class="keyword">return</span> getFallbackValue(key);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Resilience4j 的断路器 + 降级（示例）</span></span><br><span class="line"><span class="meta">@CircuitBreaker(name = "redisCB", fallbackMethod = "redisFallback")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">readFromRedisOrDB</span><span class="params">(String key)</span> </span>{</span><br><span class="line">    <span class="comment">// 先读 Redis（配置了短超时），若 Redis 抛出异常，则会触发熔断规则</span></span><br><span class="line">    Value v = redisClient.get(key);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="comment">// Redis 缓存未命中 -&gt; 读取数据库</span></span><br><span class="line">    Value dbv = dbRepository.findByKey(key);</span><br><span class="line">    <span class="comment">// 回写 Redis 和本地缓存（Caffeine）</span></span><br><span class="line">    <span class="keyword">try</span> { redisClient.set(key, dbv, ttl); } <span class="keyword">catch</span>(Exception e) { <span class="comment">/*记录日志*/</span> }</span><br><span class="line">    <span class="keyword">return</span> dbv;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Redis 不可用或熔断时的降级逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">redisFallback</span><span class="params">(String key, Throwable t)</span> </span>{</span><br><span class="line">    <span class="comment">// 优先返回本地缓存的 "过期但可用" 数据</span></span><br><span class="line">    Value v = localCache.getIfPresent(key);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="comment">// 或返回静态默认/错误提示/降级响应</span></span><br><span class="line">    <span class="keyword">return</span> defaultFallbackValue();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最佳实践（落地顺序建议）"><a href="#最佳实践（落地顺序建议）" class="headerlink" title="最佳实践（落地顺序建议）"></a>最佳实践（落地顺序建议）</h3><ul><li><p><strong>短期（1 ~ 2 周）</strong></p><ul><li>在网关层加全局限流（简单的令牌桶），保护数据库。</li><li>在应用内增加本地缓存（Caffeine），并使用 <code>stale-while-revalidate</code> 策略。</li><li>给 Redis 客户端设置短超时 + 快速失败策略。</li><li>在关键读取接口实现 SingleFlight（请求合并）。</li><li>配置 Resilience4j 的熔断与降级（Fallback）机制。</li></ul></li><li><p><strong>中期（1 ~ 3 个月）</strong></p><ul><li>精细化限流（按接口 / 用户 / 业务），使用 Bucket4j 或 Envoy Rate-Limit。</li><li>部署数据库代理中间件（比如 ProxySQL），实现数据库连接限流与优先级控制。</li><li>增加监控 / 告警（Redis 执行命令的错误率、数据库连接数、服务断路器的开启和关闭状态）。</li></ul></li><li><p><strong>长期（3 个月以上）</strong></p><ul><li>优化 Redis 高可用架构（Sentinel 、Cluster + 跨可用区副本、多活 / 读写分离）。</li><li>建立灰度降级策略与用户体验方案（部分用户可以看到降级内容）。</li><li>容灾演练：模拟 Redis 故障，并验证熔断 / 降级 / 降级链路是否按预期工作。</li></ul></li></ul><h3 id="推荐使用技术的组合"><a href="#推荐使用技术的组合" class="headerlink" title="推荐使用技术的组合"></a>推荐使用技术的组合</h3><ul><li><p>边缘 / 网关限流：</p><ul><li>Nginx + Lua（OpenResty）或 Envoy（支持熔断和限流）</li></ul></li><li><p>Spring Cloud 微服务：</p><ul><li>本地缓存：Caffeine</li><li> 熔断 / 降级 / 限流：Resilience4j + Spring Cloud Circuit Breaker</li><li> 请求合并：Caffeine AsyncLoading / 自行实现 SingleFlight</li><li>Redis 客户端：Lettuce / Redisson（配置短超时）</li><li>API 网关：Spring Cloud Gateway + Redis 限流，或者 Envoy（支持熔断和限流）</li><li>精细限流：Bucket4j，或者 Hazelcast / Redis 限流）</li></ul></li><li><p>数据库保护：</p><ul><li>ProxySQL / MySQL Router 做数据库连接管理与慢查询保护</li></ul></li></ul><h3 id="常见误区与注意事项"><a href="#常见误区与注意事项" class="headerlink" title="常见误区与注意事项"></a>常见误区与注意事项</h3><ul><li><p>不要把分布式锁依赖在 Redis 的可用性上：</p><ul><li>当 Redis 不可用时分布式锁会失效，不能用分布式锁作为保护数据库的唯一手段。</li><li>在应用内使用 SingleFlight（请求合并）更可靠，用于热点请求合并。</li></ul></li><li><p>熔断参数太松或太紧都会有问题：</p><ul><li>需结合真实流量做压测与迭代调整。</li></ul></li><li><p>本地缓存生存期太久会造成一致性问题：</p><ul><li>对于强一致性场景，务必权衡本地缓存的有效时间（或在写路径强制失效 / 异步同步）。</li></ul></li><li><p>确保快速失败：</p><ul><li>使用快速失败机制，不等待、不重试、不排队。</li><li>一旦线程池 / 连接池资源耗尽，会导致系统级雪崩，应避免使用无限等待。</li></ul></li></ul><h2 id="多级缓存的读写流程"><a href="#多级缓存的读写流程" class="headerlink" title="多级缓存的读写流程"></a>多级缓存的读写流程</h2><p>在多级缓存（本地缓存 → Redis → 数据库）架构中，读取和更新操作的流程有所不同。下面将简单梳理一下常见模式，包含缓存命中、缓存未命中、缓存更新策略以及缓存异步刷新机制。</p><h3 id="读取流程"><a href="#读取流程" class="headerlink" title="读取流程"></a>读取流程</h3><ul><li><p><strong>读取流程（Read）</strong></p><ul><li>(1) 访问本地缓存（Caffeine）<ul><li>如果缓存命中 → 直接返回数据（延迟最低）。</li><li>如果缓存未命中 → 继续访问 Redis。</li></ul></li><li>(2) 访问 Redis（远程缓存）<ul><li>如果缓存命中 → 写回本地缓存（Caffeine） → 返回数据。</li><li>如果缓存命中 → 继续访问数据库。</li></ul></li><li>(3) 访问数据库<ul><li>获取数据库最新的数据 → 写回 Redis → 写回本地缓存（Caffeine） → 返回数据。</li><li>注意，这里先写 Redis，后写本地缓存（Caffeine）；优先保证全局缓存一致性，最后加速本节点访问。</li></ul></li></ul></li><li><p><strong>可选优化（<code>stale-while-revalidate</code> 策略）</strong></p><ul><li>当本地缓存（Caffeine）或 Redis 缓存的数据已过期：<ul><li>先返回过期数据保证系统可用；</li><li>在后台异步刷新缓存数据，即从数据库加载最新数据，然后写回本地缓存（Caffeine）和 Redis。</li></ul></li></ul></li><li><p><strong>工作流程图</strong><br>  <img data-src="../../../asset/2025/09/multi-cache-read.png"></p></li></ul><h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><p>多级缓存的更新通常有三种策略：写穿（Write-through）、写回（Write-behind）、缓存失效（Cache-Aside）。</p><ul><li><p><strong>写穿策略（Write-through）</strong></p><ul><li>概述：<ul><li>更新数据库的同时立即更新缓存。</li></ul></li><li>流程：<br>  <img data-src="../../../asset/2025/09/multi-cache-write-through.png"></li><li>优点：<ul><li>缓存与数据库保持一致。</li></ul></li><li>缺点：<ul><li>写操作延迟增加。</li></ul></li></ul></li><li><p><strong>写回策略（Write-behind）</strong></p><ul><li>概述：<ul><li>先写缓存，数据库异步刷新。</li></ul></li><li>流程：<br>  <img data-src="../../../asset/2025/09/multi-cache-write-behind.png"></li><li>优点：<ul><li>写入延迟低，适合高吞吐写场景。</li></ul></li><li>缺点：<ul><li>短时间内缓存与数据库可能不一致，需要保证异步刷新数据库的可靠性。</li></ul></li></ul></li><li><p><strong>失效策略（Cache-Aside）</strong></p><ul><li>概述：<ul><li>更新数据库后，主动删除缓存，下一次读取数据时重建缓存。</li></ul></li><li>流程：<br>  <img data-src="../../../asset/2025/09/multi-cache-cache-aside.png"></li><li>优点：简单、保证最终一致性。</li><li>缺点：第一次访问会有缓存未命中，可能带来突发的数据库压力，建议使用分布式锁进行控制。</li></ul></li></ul><h3 id="最佳实践组合"><a href="#最佳实践组合" class="headerlink" title="最佳实践组合"></a>最佳实践组合</h3><ul><li><p><strong>读取操作：</strong></p><ul><li>本地缓存 + Redis + 数据库回源</li><li>可选结合 <code>stale-while-revalidate</code> 策略提升性能和可用性。</li></ul></li><li><p><strong>更新操作：</strong></p><ul><li>读多写少的场景 → 缓存失效策略（Cache-Aside）</li><li>高并发写的场景 → 写回策略（Write-behind）</li><li>对一致性要求高的场景 → 写穿策略（Write-through）</li></ul></li></ul><h3 id="方案总结对比"><a href="#方案总结对比" class="headerlink" title="方案总结对比"></a>方案总结对比</h3><table><thead><tr><th>操作</th><th>流程概述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>读取</td><td>读本地缓存 → 读 Redis → 读数据库</td><td>延迟低，高可用</td><td>复杂性高，需要多级缓存同步</td></tr><tr><td>写穿策略</td><td>写数据库 → 写 Redis → 写本地缓存</td><td>数据一致性高</td><td>写延迟高</td></tr><tr><td>写回策略</td><td>写本地缓存 → 写 Redis → 异步写数据库</td><td>写性能高</td><td>数据短期不一致，需要保证异步写数据库的可靠性</td></tr><tr><td>失效策略</td><td>写数据库 → 删除 Redis → 删除本地缓存</td><td>简单，最终一致性</td><td>大量缓存突发未命中时，数据库压力大</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文主要介绍分布式系统中缓存雪崩的解决方案。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="架构设计" scheme="https://www.techgrow.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="缓存" scheme="https://www.techgrow.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 内存池源码剖析</title>
    <link href="https://www.techgrow.cn/posts/5bc5018f.html"/>
    <id>https://www.techgrow.cn/posts/5bc5018f.html</id>
    <published>2025-04-18T13:55:33.000Z</published>
    <updated>2025-04-18T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/712a574b.html">SGI STL 内存池源码剖析</a></li><li><a href="/posts/5bc5018f.html">Nginx 内存池源码剖析</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将剖析 Nginx 内存池的源码，并介绍内存池的底层设计和工作原理，最后基于 C++ 移植 Nginx 内存池的核心源码。值得一提的是，移植后的 C++ 代码兼容 Windows 和 Linux 平台。</p><div class="admonition note"><p class="admonition-title">C++ 常见的池</p><p>在 C++ 中，常见的池有对象池、内存池、连接池、协程池、线程池、进程池。</p></div><span id="more"></span><h3 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h3><p>内存管理，是指软件运行时对计算机内存资源的分配和使用的技术。<strong>其最主要的目的是如何高效、快速地分配内存，并且在适当的时候释放和回收内存资源。</strong></p><h3 id="源码学习目标"><a href="#源码学习目标" class="headerlink" title="源码学习目标"></a>源码学习目标</h3><p>在剖析 Nginx 内存管理的源码之前，先思考以下几个问题：</p><ul><li>(1) Nginx 为什么要进行内存管理？</li><li>(2) Nginx 如何进行内存管理？</li><li>(3) Nginx 的内存管理解决了哪些问题？</li></ul><h2 id="Nginx-内存池"><a href="#Nginx-内存池" class="headerlink" title="Nginx 内存池"></a>Nginx 内存池</h2><h3 id="内存池的源码剖析"><a href="#内存池的源码剖析" class="headerlink" title="内存池的源码剖析"></a>内存池的源码剖析</h3><p>这里剖析的 Nginx 版本是 <code>1.12.2</code>，Nginx 内存池的核心源码主要位于 <code>ngx_palloc.h</code> 和 <code>ngx_palloc.c</code> 源文件中。</p><h4 id="重要类型和变量的定义"><a href="#重要类型和变量的定义" class="headerlink" title="重要类型和变量的定义"></a>重要类型和变量的定义</h4><ul><li>Nginx 内存池的粒度信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NGX_MAX_ALLOC_FROM_POOL should be (ngx_pagesize - 1), i.e. 4095 on x86. On Windows NT it decreases a number of locked pages in a kernel.</span></span><br><span class="line"><span class="comment">// 小块内存池单次分配的最大内存大小，不能超过 ngx_pagesize - 1，超过这个大小的内存不会从内存池中分配，而是通过 malloc() 之类的方式单独分配内存。</span></span><br><span class="line"><span class="comment">//ngx_pagesize 是系统页面大小（例如 x86 平台是 4096 字节），减 1 是为了确保对齐且不会跨页，最终小块内存池单次分配的最大内存大小为 4095 字节（x86 平台）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池的默认初始大小为 16KB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_DEFAULT_POOL_SIZE (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池分配时的对齐字节数为 16 字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_POOL_ALIGNMENT 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存的最小可接受大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MIN_POOL_SIZE ngx_align ((sizeof (ngx_pool_t) + 2 * sizeof (ngx_pool_large_t)), NGX_POOL_ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存分配时的对齐字节数，通常是 4 字节（32 位系统）或者 8 字节（64 位系统）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_ALIGNMENT sizeof (unsigned long)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Nginx 内存池的主结构体类型 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;         <span class="comment">// 小块内存池的数据头</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;       <span class="comment">// 小块内存分配的最大值</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;   <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;     <span class="comment">// 该指针挂接一个 ngx_chain_t 结构</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;     <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;   <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *log;       <span class="comment">// 内存分配相关的日志记录</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>小块内存的数据头信息 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">   u_char               *last;      <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">   u_char               *end;       <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">   <span class="keyword">ngx_pool_t</span>           *next;      <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">   <span class="keyword">ngx_uint_t</span>            failed;    <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">} <span class="keyword">ngx_pool_data_t</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>大块内存的类型定义 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">   <span class="keyword">ngx_pool_large_t</span>     *next;      <span class="comment">// 下一个大块内存</span></span><br><span class="line">   <span class="keyword">void</span>                 *alloc;     <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>清理操作的类型定义，包括一个清理回调函数、传给回调函数的数据和下一个清理操作的地址 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;    <span class="comment">// 清理回调函数的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>  <span class="title">ngx_pool_cleanup_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> {</span></span><br><span class="line">   ngx_pool_cleanup_pt   handler;   <span class="comment">// 函数指针，指向内存清理操作的回调函数</span></span><br><span class="line">   <span class="keyword">void</span>                 *data;      <span class="comment">// 传递给回调函数的参数</span></span><br><span class="line">   <span class="keyword">ngx_pool_cleanup_t</span>   *next;      <span class="comment">// 指向下一个清理操作</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="重要的内存池函数接口"><a href="#重要的内存池函数接口" class="headerlink" title="重要的内存池函数接口"></a>重要的内存池函数接口</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span> *<span class="title">ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span>;   <span class="comment">// 创建内存池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;    <span class="comment">// 销毁内存池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;      <span class="comment">// 重置内存池</span></span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理核心函数"><a href="#内存池管理核心函数" class="headerlink" title="内存池管理核心函数"></a>内存池管理核心函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> * <span class="title">ngx_palloc_small</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span>   <span class="comment">// 内存池分配小块内存的入口函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">ngx_palloc_block</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span>     <span class="comment">// 内存池分配新小块内存（在小块内存块空间不足时）</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">ngx_palloc_large</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span>     <span class="comment">// 内存池分配大块内存的入口函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">ngx_int_t</span> <span class="title">ngx_pfree</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span>     <span class="comment">// 内存池释放大块内存的入口函数</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="内存池的底层设计"><a href="#内存池的底层设计" class="headerlink" title="内存池的底层设计"></a>内存池的底层设计</h3><p>Nginx 中所有请求都单独对应一个内存池，在这个请求的过程中，所有涉及到内存分配的地方，都到该请求相关的内存池中处理，而中间不会去释放内存，内存池的生命周期与请求一样，请求完毕则直接回收内存。这样的好处在于：统一分配和统一释放，降低了内存泄露问题的出现。Nginx 的内存池设计分为两个部分：</p><ul><li>大块内存：超过 <code>max</code> 大小（默认 4095 字节）的内存分配，走大块内存分配，这部分内存管理由 <code>ngx_pool_large_t</code> 结构体负责。</li><li>小块内存：在 <code>ngx_pool_t</code> 链表中遍历符合要求的 <code>ngx_pool_t</code> 结构体，找到符合要求大小的 <code>pool</code> 直接返回，否则就申请新的小块内存 <code>pool</code>。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>小块内存在分配后不会被单独释放，而是在整个内存池销毁（<code>ngx_destroy_pool()</code>）时，通过 <code>free()</code> 一次性释放。</li><li>大块内存会在整个内存池重置（<code>ngx_reset_pool()</code>）或者整个内存池销毁（<code>ngx_destroy_pool()</code>）时被 <code>free()</code> 释放，但还可以手动调用 <code>ngx_pfree()</code> 单独释放。</li><li>小块内存的重用机制：Nginx 也有机制尝试在链表中查找可用内存块（并非永远只分配不回收），但它不做碎片整理或回收，只是简单地继续分配新的小块内存。</li></ul></div><h4 id="内存池结构设计"><a href="#内存池结构设计" class="headerlink" title="内存池结构设计"></a>内存池结构设计</h4><p>Nginx 采用内存池的结构设计来管理内存，而内存池是由若干固定大小的内存块组成的单向链表（如下图所示）。从图中可以看出来，内存池的头结点维护着内存池的总体信息，从头结点开始，可以访问内存池的小块内存（单向链表，由 <code>ngx_pool_data_t</code> 结构特维护），大块内存（单向链表，由 <code>ngx_pool_large_t</code> 结构特维护），以及抽象内存数据（单向链表，由 <code>ngx_pool_chain_t</code> 结构体维护）。</p><p><img data-src="../../../asset/2025/04/nginx-memory-4.png"></p><h4 id="ngx-pool-data-t"><a href="#ngx-pool-data-t" class="headerlink" title="ngx_pool_data_t"></a>ngx_pool_data_t</h4><p><code>ngx_pool_data_t</code> 结构体负责存储每个 <code>ngx_pool_t</code> 结构体的元数据：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">   u_char               *last;      <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">   u_char               *end;       <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">   <span class="keyword">ngx_pool_t</span>           *next;      <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">   <span class="keyword">ngx_uint_t</span>            failed;    <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">} <span class="keyword">ngx_pool_data_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/04/nginx-memory-pool-1.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p><code>failed</code> 成员的引入是为了避免某个 <code>pool</code> 虽然还有可用的内存空间，但是由于内存空间很小了，导致经常性的分配内存空间失败，当累计失败的次数达到某个阈值时，下一次再次查找内存就直接跳过这个 <code>pool</code>，直接去寻找内存池链表中的下一个 <code>pool</code>。在 <code>ngx_pool_s</code> 结构体中，<code>current</code> 指针会随着 <code>failed</code> 的增加而发生改变，如果 <code>current</code> 指向的内存池的 <code>failed</code> 达到了 <code>4</code> 的话，<code>current</code> 就会指向下一个内存池。</p></div><h4 id="ngx-pool-large-t"><a href="#ngx-pool-large-t" class="headerlink" title="ngx_pool_large_t"></a>ngx_pool_large_t</h4><p><code>ngx_pool_large_t</code> 结构体用于存储大内存块，这一块就比较简单粗暴了，直接调用 <code>malloc()</code> 分配一块大内存来使用，多个大内存块之间也是以链表形式来组织数据。正常情况下，这些大块内存会在整个内存池销毁时统一释放，比如在请求处理完毕后、连接断开后、Worker 进程（子进程）退出后会释放大块内存。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">   <span class="keyword">ngx_pool_large_t</span>     *next;      <span class="comment">// 下一个大块内存</span></span><br><span class="line">   <span class="keyword">void</span>                 *alloc;     <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>大块内存的分配请求不会直接在内存池上分配内存来满足，而是直接向操作系统申请一大块内存（底层直接调用 <code>malloc()</code> 分配内存），然后将这块内存挂到内存池头部的 <code>large</code> 指针下。内存池的作用在于解决小块内存池的频繁申请问题，对于这种大块内存，是可以忍受直接申请的。为什么大块内存分配后是挂在链表头部而不是尾部呢？根据程序局部性原理，最近分配的内存一般经常使用，挂在头部可以提高空闲内存块的查找效率。</p></div><h4 id="ngx-pool-t"><a href="#ngx-pool-t" class="headerlink" title="ngx_pool_t"></a>ngx_pool_t</h4><p><code>ngx_pool_t</code> 结构体用于表示一个内存池，内存池的内部以链表形式来组织数据。如下图：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;         <span class="comment">// 小块内存池的数据头</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;       <span class="comment">// 小块内存分配的最大值</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;   <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;     <span class="comment">// 该指针挂接一个 ngx_chain_t 结构</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;     <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;   <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *log;       <span class="comment">// 内存分配相关的日志记录</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/04/nginx-memory-pool-2.png"></p><p>需要注意的是：</p><ul><li>内存池内部以链表形式组织起来的，完成这个工作的就是前面的 <code>ngx_pool_data_t</code> 结构体的 <code>next</code> 成员。</li><li><code>current</code> 指针，用于表示当前该内存池在使用的 <code>pool</code> 指针。除了内存池链表的头结点之外，内存池链表其他节点的该指针无效。之所以需要这个指针，就是前面提到的，在某个内存池多次失效的情况下，下一次直接跳过该内存池查找内存空间，<code>current</code> 指针保存当前在内存池链表的哪一个内存池上面查找内存空间。</li><li><code>large</code> 指针，指向 <code>ngx_pool_large_t</code> 结构体，用于管理大块内存。</li></ul><h3 id="内存池的工作原理"><a href="#内存池的工作原理" class="headerlink" title="内存池的工作原理"></a>内存池的工作原理</h3><h4 id="内存池的创建"><a href="#内存池的创建" class="headerlink" title="内存池的创建"></a>内存池的创建</h4><ul><li>经过测试，Nginx 会为每个 Http 连接（Connection）创建大小为 <code>256</code> 字节的 <code>pool</code>，为每个请求（Request）创建大小为 <code>4096</code> 的 <code>pool</code>。</li><li>当客户端使用长连接向服务器请求资源时，Nginx 处理完 Request 后会释放 Request 对应的 <code>pool</code>，但不会立即释放 Connection 对应的 <code>pool</code>，而是等连接超时后再释放。</li><li>在一次简单的会话中（比如请求首页），从连接建立到连接关闭，至少有约 30 次的内存分配（调用 <code>ngx_palloc()</code>）。</li></ul><h4 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h4><ul><li><p><strong>小块内存的分配</strong></p><ul><li>对于小块内存的分配，Nginx 会首先尝试在当前小块内存池中查找是否存在足够的空闲内存空间。</li><li>如果当前小块内存池的可用内存不足以满足需求，Nginx 会尝试遍历该小块内存池的链表（即多个小块内存池），寻找可用的内存空间。</li><li>如果仍然找不到可用的内存空间，则会创建一个新的小块内存块，并将其添加到该小块内存池链表的尾部。</li><li><strong>小块内存的分配是按顺序进行的，不会进行回收，因此分配效率很高，适合频繁分配和释放内存的场景（比如 Web 服务器处理大量短连接）。</strong></li></ul></li><li><p><strong>大块内存的分配</strong></p><ul><li>对于大块内存的分配，当分配的内存大小超过小块内存分配的阈值（一般是 <code>4095</code> 字节，根据平台决定），Nginx 会直接调用 <code>malloc()</code> 申请一块大内存，并将该大块内存封装成一个 <code>ngx_pool_large_t</code> 节点，挂载到内存池的大块内存链表的头部。</li><li>这类内存块比较大、分配成本比较高，通常用于缓存大数据或模块中临时需要的较大资源。</li><li>由于<strong>小块内存使用的是顺序分配模型，而大块内存是从系统申请分配的</strong>，因此两者的管理方式不同，但最终都会在内存池销毁时（比如处理完 HTTP 请求、HTTP 连接关闭等）统一释放，确保资源不会泄漏。</li></ul></li></ul><h4 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h4><p>Nginx 从内存池分配内存的流程如下图所示：</p><p><img data-src="../../../asset/2025/04/nginx-memory-pool-3.png"></p><h4 id="内存池的销毁"><a href="#内存池的销毁" class="headerlink" title="内存池的销毁"></a>内存池的销毁</h4><ul><li><p>一个 Web Server 通常会持续不断地接收 Connection 和 Request，因此 Nginx 将内存池划分为不同的层级，包括进程级内存池、Connection 级内存池以及 Request 级内存池。具体来说，当创建一个 Worker 进程时，系统会为该 Worker 分配一个独立的内存池；当有新的 Connection 到来时，又会在该 Worker 的内存池基础上为该 Connection 分配一个新的内存池；当该 Connection 上接收到一个新的 Request 时，再在 Connection 的内存池中为该 Request 创建一个新的内存池。</p></li><li><p>这种分层次的内存池管理方式，使得在处理完一个 Request 后，可以一次性释放该 Request 的整个内存池；当 Connection 关闭时，可以释放该 Connection 对应的内存池；而当 Worker 进程退出时，其对应的内存池也会整体释放。通过这种机制，确保了内存既有分配，也能及时回收，避免了内存泄漏的问题。</p></li><li><p>从内存的分配与释放策略可以看出，Nginx 内存池的核心作用在于将多个小块内存的分配操作集中处理，并在适当的时机统一释放，从而避免频繁的小内存申请，降低内存碎片的产生，提升了系统的内存管理效率和性能。</p></li></ul><h3 id="内存池的源码测试"><a href="#内存池的源码测试" class="headerlink" title="内存池的源码测试"></a>内存池的源码测试</h3><p>这里将介绍如何编写代码测试 Nginx 内存池的 <code>ngx_destroy_pool()</code> 接口，并编译运行自定义的测代码。</p><h4 id="编译-Nginx-源码"><a href="#编译-Nginx-源码" class="headerlink" title="编译 Nginx 源码"></a>编译 Nginx 源码</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://nginx.org/download/nginx-1.12.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf nginx-1.12.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j4</span><br></pre></td></tr></tbody></table></figure><h4 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h4><p>在 Nginx 的源码目录下（比如 <code>nginx-1.12.2</code>），创建 C 源文件 <code>ngx_testpool.c</code>，其测试代码的内容如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nginx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_palloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误日志处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_log_error_core</span> <span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">stData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> {</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc1</span> <span class="params">(<span class="keyword">char</span> *p)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"free ptr mem!\n"</span>);</span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc2</span> <span class="params">(FILE *pf)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"close file!\n"</span>);</span><br><span class="line">    fclose (pf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span> *pool = ngx_create_pool (<span class="number">512</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_create_pool fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小块内存池分配内存</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = ngx_palloc (pool, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_palloc 128 bytes fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大块内存池分配内存</span></span><br><span class="line">    stData *p2 = ngx_palloc (pool, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_palloc 512 bytes fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p2-&gt;ptr = <span class="built_in">malloc</span> (<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (p2-&gt;ptr, <span class="string">"hello world"</span>);</span><br><span class="line">    p2-&gt;pfile = fopen (<span class="string">"data.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span> *c1 = ngx_pool_cleanup_add (pool, <span class="keyword">sizeof</span> (<span class="keyword">char</span> *));</span><br><span class="line">    c1-&gt;handler = cleanFunc1;</span><br><span class="line">    c1-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span> *c2 = ngx_pool_cleanup_add (pool, <span class="keyword">sizeof</span> (FILE *));</span><br><span class="line">    c2-&gt;handler = cleanFunc2;</span><br><span class="line">    c2-&gt;data = p2-&gt;pfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁内存池，步骤：(1) 调用所有的预置的清理函数 (2) 释放所有大块内存 (3) 释放小块内存池所有内存</span></span><br><span class="line">    ngx_destroy_pool (pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="运行测试代码"><a href="#运行测试代码" class="headerlink" title="运行测试代码"></a>运行测试代码</h4><ul><li>编译测试代码 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译测试代码（生成目标文件）</span></span><br><span class="line">gcc -c -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules -o ngx_testpool.o  ngx_testpool.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接测试代码（生成可执行文件）</span></span><br><span class="line">gcc -o ngx_testpool ngx_testpool.o objs/src/core/ngx_palloc.o objs/src/os/unix/ngx_alloc.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行文件</span></span><br><span class="line">./ngx_testpool</span><br></pre></td></tr></tbody></table></figure><ul><li>测试代码运行的输出结果 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close file!</span><br><span class="line">free ptr mem!</span><br></pre></td></tr></tbody></table></figure><h3 id="内存池的源码移植"><a href="#内存池的源码移植" class="headerlink" title="内存池的源码移植"></a>内存池的源码移植</h3><p>这里将介绍如何基于 C++ 11 移植 Nginx 内存池的核心源码，其中移植的代码主要位于 Nginx（版本是 <code>1.12.2</code>）的 <code>ngx_palloc.h</code> 和 <code>ngx_palloc.c</code> 源文件中。</p><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><ul><li><code>ngx_mem_pool.h</code> 头文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值 d 调整为临近数值 a 的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align (d, a) (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值 p 调整为临近数值 a 的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr (p, a) (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的内存全部初始化为 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memzero (buf, n) (void) memset (buf, 0, n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> u_char = <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ngx_uint_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理函数（回调函数）的类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理操作的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> {</span></span><br><span class="line">    ngx_pool_cleanup_pt handler;     <span class="comment">// 函数指针，指向内存清理操作的回调函数</span></span><br><span class="line">    <span class="keyword">void</span> *data;                      <span class="comment">// 传递给回调函数的参数</span></span><br><span class="line">    ngx_pool_cleanup_s *next;        <span class="comment">// 下一个清理函数，最终形成单向链表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大块内存的内存池的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">    ngx_pool_large_s *next;      <span class="comment">// 下一个大块内存，最终形成单向链表</span></span><br><span class="line">    <span class="keyword">void</span> *alloc;                 <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存的内存池的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_data_t</span> {</span></span><br><span class="line">    u_char *last;           <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">    u_char *end;            <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">    ngx_pool_s *next;       <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span> failed;      <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池的主结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span> d;              <span class="comment">// 小块内存池的头部信息</span></span><br><span class="line">    <span class="keyword">size_t</span> max;                     <span class="comment">// 小块内存分配的最大空间</span></span><br><span class="line">    ngx_pool_s *current;            <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    ngx_pool_large_s *large;        <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    ngx_pool_cleanup_s *cleanup;    <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个物理页面的默认大小（4KB）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_PAGESIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// 小块内存可分配的最大空间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MAX_ALLOC_FROM_POOL = NGX_PAGESIZE - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 内存池的默认初始大小（16KB）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_DEFAULT_POOL_SIZE = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// 内存池分配时的对齐字节数（16 字节）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_POOL_ALIGNMENT = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 小块内存的最小可接受大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MIN_POOL_SIZE = <span class="built_in">ngx_align</span> ((<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s) + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_large_s)), NGX_POOL_ALIGNMENT);</span><br><span class="line"><span class="comment">// 小块内存分配时的对齐字节数，通常是 4 字节（32 位系统）或者 8 字节（64 位系统）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_ALIGNMENT = <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ngx_mem_pool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span> (<span class="keyword">int</span> size = NGX_DEFAULT_POOL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ngx_mem_pool</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span> (<span class="keyword">const</span> ngx_mem_pool &amp;pool) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ngx_mem_pool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ngx_mem_pool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 从内存池中申请指定大小的内存，并考虑内存字节对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内存池中申请指定大小的内存，不考虑内存字节对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_pnalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 ngx_palloc 实现内存分配，并将内存初始化为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_pcalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_pfree</span> <span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作（回调）函数</span></span><br><span class="line">    <span class="function">ngx_pool_cleanup_s *<span class="title">ngx_pool_cleanup_add</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 创建指定大小的内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配小块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_small</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配大块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_large</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的小块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_block</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指向内存池的入口指针</span></span><br><span class="line">    ngx_pool_s *_pool;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ngx_mem_pool.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ngx_mem_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ngx_mem_pool::<span class="built_in">ngx_mem_pool</span> (<span class="keyword">int</span> size) {</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">ngx_create_pool</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (_pool == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span> (<span class="string">"create memory pool fail..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ngx_mem_pool::~<span class="built_in">ngx_mem_pool</span> () {</span><br><span class="line">    <span class="comment">// 销毁内存池</span></span><br><span class="line">    <span class="keyword">if</span> (_pool != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">ngx_destroy_pool</span> ();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定大小的内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt; NGX_MIN_POOL_SIZE) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"create memory pool fail, pool size too small"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存空间</span></span><br><span class="line">    _pool = (ngx_pool_s *) <span class="built_in">malloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (_pool == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小块内存池的头部信息</span></span><br><span class="line">    _pool-&gt;d.last = (u_char *) _pool + <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    _pool-&gt;d.end = (u_char *) _pool + size;</span><br><span class="line">    _pool-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    _pool-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小块内存分配的最大空间</span></span><br><span class="line">    size = size - <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    _pool-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    _pool-&gt;current = _pool;</span><br><span class="line">    _pool-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">    _pool-&gt;cleanup = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _pool;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内存池中申请指定大小的内存，并考虑内存字节对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="keyword">this</span>-&gt;_pool-&gt;max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span> (size, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内存池中申请指定大小的内存，不考虑内存字节对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_pnalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="keyword">this</span>-&gt;_pool-&gt;max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span> (size, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ngx_palloc 实现内存分配，并将内存初始化为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_pcalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">ngx_palloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (p) {</span><br><span class="line">        <span class="built_in">ngx_memzero</span> (p, size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配小块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_small</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span> </span>{</span><br><span class="line">    u_char *m;</span><br><span class="line">    ngx_pool_s *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">this</span>-&gt;_pool-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历小块内存池链表，查找有可用空间的小块内存</span></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (align) {</span><br><span class="line">            m = <span class="built_in">ngx_align_ptr</span> (m, NGX_ALIGNMENT);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) {</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当找不到有可用空间的小块内存，则直接分配新的小块内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_block</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配大块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_large</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span> n;</span><br><span class="line">    ngx_pool_large_s *large;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的大块内存</span></span><br><span class="line">    p = <span class="built_in">malloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历大块内存池链表，将新的大块内存添加到链表中</span></span><br><span class="line">    <span class="keyword">for</span> (large = <span class="keyword">this</span>-&gt;_pool-&gt;large; large; large = large-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">nullptr</span>) {</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    large = (ngx_pool_large_s *) <span class="built_in">ngx_palloc_small</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_large_s), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">free</span> (p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = <span class="keyword">this</span>-&gt;_pool-&gt;large;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配新的小块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_block</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    u_char *m;</span><br><span class="line">    <span class="keyword">size_t</span> psize;</span><br><span class="line">    ngx_pool_s *p, *_new;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的小块内存的大小</span></span><br><span class="line">    psize = (<span class="keyword">size_t</span>) (<span class="keyword">this</span>-&gt;_pool-&gt;d.end - (u_char *) <span class="keyword">this</span>-&gt;_pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的小块内存</span></span><br><span class="line">    m = (u_char *) <span class="built_in">malloc</span> (psize);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    _new = (ngx_pool_s *) m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的小块内存的头部信息</span></span><br><span class="line">    _new-&gt;d.end = m + psize;</span><br><span class="line">    _new-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    _new-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = <span class="built_in">ngx_align_ptr</span> (m, NGX_ALIGNMENT);</span><br><span class="line">    _new-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="keyword">this</span>-&gt;_pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) {</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p-&gt;d.next = _new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放大块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_pfree</span> <span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_reset_pool</span> <span class="params">()</span> </span>{</span><br><span class="line">    ngx_pool_s *p;</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置小块内存池链表中的第一块内存，实现后续小块内存的复用</span></span><br><span class="line">    p = <span class="keyword">this</span>-&gt;_pool;</span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置小块内存池链表中的第二块到最后一块内存，实现后续小块内存的复用</span></span><br><span class="line">    <span class="keyword">for</span> (p = p-&gt;d.next; p; p = p-&gt;d.next) {</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;current = <span class="keyword">this</span>-&gt;_pool;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_destroy_pool</span> <span class="params">()</span> </span>{</span><br><span class="line">    ngx_pool_s *p, *n;</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line">    ngx_pool_cleanup_s *c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用所有清理操作（回调）函数</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="keyword">this</span>-&gt;_pool-&gt;cleanup; c; c = c-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) {</span><br><span class="line">            c-&gt;<span class="built_in">handler</span> (c-&gt;data);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放小块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="keyword">this</span>-&gt;_pool, n = <span class="keyword">this</span>-&gt;_pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) {</span><br><span class="line">        <span class="built_in">free</span> (p);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加资源清理操作（回调）函数</span></span><br><span class="line"><span class="function">ngx_pool_cleanup_s *<span class="title">ngx_mem_pool::ngx_pool_cleanup_add</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    ngx_pool_cleanup_s *c;</span><br><span class="line"></span><br><span class="line">    c = (ngx_pool_cleanup_s *) <span class="built_in">ngx_palloc</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_cleanup_s));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) {</span><br><span class="line">        c-&gt;data = <span class="built_in">ngx_palloc</span> (size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        c-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到资源清理操作链表中（头插法）</span></span><br><span class="line">    c-&gt;next = <span class="keyword">this</span>-&gt;_pool-&gt;cleanup;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><ul><li><code>test.cpp</code> 源文件 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ngx_mem_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> {</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc1</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) arg;</span><br><span class="line">    cout &lt;&lt; <span class="string">"free ptr memory!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc2</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">    FILE *p = (FILE *) arg;</span><br><span class="line">    cout &lt;&lt; <span class="string">"close file!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">fclose</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="function">unique_ptr&lt;ngx_mem_pool&gt; <span class="title">pool</span> <span class="params">(<span class="keyword">new</span> ngx_mem_pool (<span class="number">256</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小块内存池分配内存</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = pool-&gt;<span class="built_in">ngx_palloc</span> (<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"ngx_palloc 128 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大块内存池分配内存</span></span><br><span class="line">    Data *p2 = (Data *) pool-&gt;<span class="built_in">ngx_palloc</span> (<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"ngx_palloc 512 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p2-&gt;ptr = (<span class="keyword">char</span> *) <span class="built_in">malloc</span> (<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2-&gt;ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"malloc 12 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span> (p2-&gt;ptr, <span class="string">"hello world"</span>);</span><br><span class="line">    p2-&gt;pfile = <span class="built_in">fopen</span> (<span class="string">"data.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    ngx_pool_cleanup_s *c1 = pool-&gt;<span class="built_in">ngx_pool_cleanup_add</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">char</span> *));</span><br><span class="line">    c1-&gt;handler = cleanFunc1;</span><br><span class="line">    c1-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    ngx_pool_cleanup_s *c2 = pool-&gt;<span class="built_in">ngx_pool_cleanup_add</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (FILE *));</span><br><span class="line">    c2-&gt;handler = cleanFunc2;</span><br><span class="line">    c2-&gt;data = p2-&gt;pfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存池由智能指针管理，程序运行结束后会自动销毁内存池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close file!</span><br><span class="line">free ptr memory!</span><br></pre></td></tr></tbody></table></figure><h4 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h4><p>Nginx 内存池移植后的完整案例代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-nginx-memory-pool">这里</a> 下载得到。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><blockquote><p>Nginx 为什么要进行内存管理？</p></blockquote><ul><li><p>Nginx 作为高性能 Web 服务器，在各个环节都必须考虑如何提高性能的问题，比如使用 <code>malloc()</code> 申请内存是很耗时的，这时候就需要优化内存的分配。</p></li><li><p>在使用系统的 <code>malloc()</code> 和 <code>free()</code> 面临几个问题：Web 服务器对内存的需求有大有小，系统运行久了会产生大量的内存碎片，最终造成内存操作更加耗时直到无可用内存，导致服务器宕机。</p></li></ul><blockquote><p>Nginx 如何进行内存管理？</p></blockquote><ul><li><p>Nginx 首先将内存池进行分级管理：包括进程级、连接级和请求级三个层次；随后再根据内存使用情况的不同，将内存池细分为三类：小块内存、大块内存以及自定义资源内存。</p></li><li><p>进程级内存池在通过 <code>Fork()</code> 创建 Worker 子进程时完成初始化。由于 <code>Fork()</code> 会复制父进程的数据段和堆栈段，因此每个子进程拥有独立的内存空间。根据 Web Server 的运行特点，当客户端建立连接时，会在函数 <code>void ngx_event_accept (ngx_event_t *ev)</code> 中创建连接级的内存池；当客户端发起请求时，会在函数 <code>void ngx_http_init_connection (ngx_connection_t *c)</code> 中创建请求级的内存池。</p></li><li><p>在处理 HTTP 请求的过程中，所有与该请求相关的内存分配操作都在对应连接的内存池中完成。根据实际需要的内存大小及资源类型，Nginx 会采用不同的分配策略：对于较小的内存块，采用顺序分配以提高效率；对于较大的内存块或特殊资源，则使用独立分配方式以便于管理。</p></li><li><p>当请求处理完成后，请求级的内存池会被整体释放；当连接超时或者断开时，连接级的内存池随之释放；当进程退出时，系统会释放进程占用的全部内存池资源。通过这种分级且分类型的内存管理机制，Nginx 有效提升了内存分配效率，降低了内存碎片率，同时确保了资源的可控释放和系统的高性能运行。</p></li></ul><blockquote><p>Nginx 的内存管理解决了哪些问题？</p></blockquote><ul><li><strong>简化了内存操作</strong>：程序员不必担心何时释放内存，当连接释放时，就回收该连接对应的内存池。</li><li><strong>避免了内存碎片</strong>：从外部内存碎片来看，采用一次性申请一个内存页，避免了外部内存碎片；从内部内存碎片来看，对大小内存申请分别管理，提高了内存利用率，避免了内部内存碎片。</li><li><strong>避免了内存泄露</strong>：在同一内存池上进行内存申请和回收，当连接关闭后，不存在没有被回收的内存，即可以避免内存泄漏问题。</li><li><strong>提高了内存访问效率</strong>：充分利用程序局部性原理，结合内存对齐和内存分页机制，有效提高了 CPU 访存的 Cache 命中率。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.kancloud.cn/digest/understandingnginx/202588">Nginx 内存池管理详解</a></li><li><a href="https://www.cnblogs.com/didiaoxiong/p/nginx_memory.html">Nginx 1.4.0 内存管理详解</a></li><li><a href="https://heapdump.cn/article/4444830">Nginx 内存分配与释放 — 堆 (内存池) 源码与原理</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Nginx 内存池的底层源码。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="源码剖析" scheme="https://www.techgrow.cn/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>C++ 算法入门教程之一</title>
    <link href="https://www.techgrow.cn/posts/73b8af5d.html"/>
    <id>https://www.techgrow.cn/posts/73b8af5d.html</id>
    <published>2025-04-07T13:55:33.000Z</published>
    <updated>2025-04-07T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大数的加减法"><a href="#大数的加减法" class="headerlink" title="大数的加减法"></a>大数的加减法</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/mrqiuwen/article/details/127057549">C++ 实现大数加减法</a></li><li><a href="https://zhuanlan.zhihu.com/p/92141234">一文读懂大数加减乘除</a></li><li><a href="https://www.cnblogs.com/hello-nullptr/p/18536106">C++ 大整数相加的实现</a></li><li><a href="https://cloud.tencent.com/developer/article/1818199">大数加减乘除运算总结</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 常用的数据结构与算法。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
</feed>
