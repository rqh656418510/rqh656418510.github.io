<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术空间</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2025-04-30T14:32:18.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C/C++ 面试准备内容整理</title>
    <link href="https://www.techgrow.cn/posts/d069ee67.html"/>
    <id>https://www.techgrow.cn/posts/d069ee67.html</id>
    <published>2025-04-30T14:32:18.000Z</published>
    <updated>2025-04-30T14:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="C-面试准备内容"><a href="#C-面试准备内容" class="headerlink" title="C++ 面试准备内容"></a>C++ 面试准备内容</h2><ul><li>C++ 基础<ul><li>智能指针</li><li> Boost 库</li><li> Libevent 库</li><li> C++ 11 的常用特性</li><li> STL 库中的各种容器，并阅读过底层源码</li><li>熟悉函数调用堆栈过程，<code>ptmalloc</code> 内存管理方式</li></ul></li></ul><span id="more"></span><ul><li><p> C++ 网络编程</p><ul><li>熟悉使用 Muduo 库</li><li>熟悉 TCP/IP 的三次握手和四次挥手过程</li><li>熟悉 ET/LT 模式的特点，理解阻塞 / 非阻塞 I/O、同步 / 异步 I/O</li><li> 熟悉网络编程，以及 I/O 多路复用，包括 <code>select</code> 、<code>poll</code>、<code>epoll</code> 库等</li><li>熟悉网络协议体系，包括 TCP/IP 协议、UDP 协议、HTTP 协议、ARP 协议</li><li>熟悉 TCP/IP 协议栈、可靠传输、快速重传、滑动窗口、流量控制、拥塞控制原理等</li></ul></li><li><p>数据结构与算法</p><ul><li>熟悉常用的数据结构，例如栈、队列、链表、哈希表、二叉树、红黑树、AVL 树、BST 树、大小根堆</li><li>熟悉常用的算法，例如 BF/KMP、分治算法、回溯算法、动态规划算法、最短路径算法、分支定界算法、八大排序算法、二分查找</li><li>熟悉常用的排序算法，包括快速排序、堆排序、归并排序、冒泡排序等</li></ul></li><li><p> Linux 系统编程</p><ul><li>Linux 下的编译和链接过程</li><li>熟悉 gcc、g++、gdb、vim、git 等开发工具</li><li>熟悉 Linux 进程间通信（管道、共享内存、Socket 等），以及多进程和多线程编程</li><li>熟悉 Linux 的虚拟内存管理、虚拟地址映射机制、进程 / 线程的调度、线程的互斥和同步通信</li></ul></li><li><p>数据库</p><ul><li>熟悉 MySQL 常用的 SQL 语法、索引以及优化、索引的底层实现、事务处理（ACID 和隔离级别）</li></ul></li><li><p>中间件</p><ul><li>MySQL</li><li>Redis</li><li>Kafka</li><li>ZooKeeper</li></ul></li><li><p> 设计模式</p><ul><li>比如：单例模式、工厂模式、观察者模式、代理模式、策略模式、适配器模式等</li></ul></li><li><p>开源源码</p><ul><li>Redis</li><li>Memcached</li><li>Muduo 库</li><li> Boost 库</li><li> Libevent 库</li><li> Nginx 内存池</li><li> SGI STL 空间配置器</li><li> Linux 内核源码</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要记录 C 语言与 C++ 面试准备内容。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 算法入门教程之一</title>
    <link href="https://www.techgrow.cn/posts/73b8af5d.html"/>
    <id>https://www.techgrow.cn/posts/73b8af5d.html</id>
    <published>2025-04-07T13:55:33.000Z</published>
    <updated>2025-04-07T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大数的加减法"><a href="#大数的加减法" class="headerlink" title="大数的加减法"></a>大数的加减法</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/mrqiuwen/article/details/127057549">C++ 实现大数加减法</a></li><li><a href="https://zhuanlan.zhihu.com/p/92141234">一文读懂大数加减乘除</a></li><li><a href="https://www.cnblogs.com/hello-nullptr/p/18536106">C++ 大整数相加的实现</a></li><li><a href="https://cloud.tencent.com/developer/article/1818199">大数加减乘除运算总结</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 常用的数据结构与算法。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="数据结构与算法" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Debian 12 搭建 IPSec VPN 实现内网互连</title>
    <link href="https://www.techgrow.cn/posts/ec9b99f7.html"/>
    <id>https://www.techgrow.cn/posts/ec9b99f7.html</id>
    <published>2025-03-16T13:48:23.000Z</published>
    <updated>2025-03-16T13:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 Debian 12 如何基于 StrongSwan‌ 搭建 IPSec VPN，以此在多台 Linux 服务器（处于不同的数据中心 - IDC）之间实现内网通信。</p><h2 id="内网互连方案介绍"><a href="#内网互连方案介绍" class="headerlink" title="内网互连方案介绍"></a>内网互连方案介绍</h2><p>在多台 Linux 服务器（处于不同的数据中心 - IDC）之间实现内网互连，有以下几种方案：</p><ul><li><p>虚拟专用网络（Virtual Private Network - VPN）</p><ul><li>通过建立虚拟专用网络连接，将服务器与内网之间建立起安全的通信隧道，实现互通。可以使用软件或硬件设备来实现虚拟专用网络连接。</li></ul></li><li><p>隧道技术（Tunneling）</p><ul><li>使用隧道技术，将服务器的网络流量封装在内网的流量中传输，从而实现互通。常见的隧道技术有 SSH 隧道、GRE 隧道、IPSec 隧道等。</li></ul></li><li><p>NAT（Network Address Translation，网络地址转换）</p><ul><li>在内网中配置 NAT 设备，将服务器的私有 IP 地址映射为内网的公共 IP 地址，从而实现互通。</li></ul></li><li><p>配置防火墙规则</p><ul><li>在内网的防火墙中配置相应的规则，允许服务器与内网之间的通信。可以通过指定源 IP 地址、目标 IP 地址、端口等来限制通信。</li></ul></li></ul><span id="more"></span><h2 id="IPSec-VPN-的简单介绍"><a href="#IPSec-VPN-的简单介绍" class="headerlink" title="IPSec VPN 的简单介绍"></a>IPSec VPN 的简单介绍</h2><h3 id="IPSec-是什么"><a href="#IPSec-是什么" class="headerlink" title="IPSec 是什么"></a>IPSec 是什么</h3><p>IPSec 是虚拟私有网络（VPN）的一种连接协议，用于在服务器和客户端之间建立加密隧道，并传输敏感数据。它由两个阶段组成，第一阶段（Phrase 1， ph1），交换密钥建立连接，使用互联网密钥交换协议（ike）；ike 密钥交换协议有两个版本，分别是 IKEV1、IKEV2；第二阶段（Phrase 2， ph2），连接建立后对数据进行加密传输，使用封装安全载荷（ESP）协议。</p><h3 id="IKEV1-与-IKEV2"><a href="#IKEV1-与-IKEV2" class="headerlink" title="IKEV1 与 IKEV2"></a>IKEV1 与 IKEV2</h3><p>IKE 属于一种混合型协议，由 Internet 安全关联和密钥管理协议（ISAKMP）和两种密钥交换协议 OAKLEY 与 SKEME 组成。IKE 创建在由 ISAKMP 定义的框架上，沿用了 OAKLEY 的密钥交换模式以及 SKEME 的共享和密钥更新技术，还定义了它自己的两种密钥交换方式：主模式和积极模式（IKEV1 才有）。IKE 有两个版本，分别是 IKEV1 与 IKEV2。值得一提的是，IKEV2 不兼容 IKEV1，IKEV1 不支持认证，IKEV2 支持认证。IKEV2 支持 EAP 认证，支持 NAT 穿透，支持私密性、完整性、源认证。工作在 UDP 的 500 /4500 端口。NAT-T 用的是 UDP 4500 端口。</p><h3 id="OpenSwan-与-StrongSwan"><a href="#OpenSwan-与-StrongSwan" class="headerlink" title="OpenSwan 与 StrongSwan"></a>OpenSwan 与 StrongSwan</h3><p>Linux 系统有两种比较常见的 IPSec 实现，分别是 OpenSwan 与 StrongSwan，两者的主要区别如下：</p><ul><li><p>协议支持</p><ul><li>OpenSwan‌<ul><li>主要支持 ‌IKEV1‌ 协议，兼容旧版设备‌。</li><li>默认使用 ‌KLIPS‌ 内核模块实现 IPSec（需手动为旧内核打补丁），对 Linux <code>2.6.9+</code> 内核支持 NETKEY‌。</li></ul></li><li>StrongSwan‌<ul><li>专注 ‌IKEV2‌ 协议，安全性更高且简化配置流程‌。</li><li>原生支持 NETKEY 内核模块（无需额外补丁），对现代 Linux 内核（如 <code>4.x+</code>）兼容性更佳‌。</li></ul></li></ul></li><li><p>配置复杂度‌</p><ul><li>‌OpenSwan‌<ul><li>依赖 <code>ipsec.conf</code> 配置文件，需手动管理多参数（如 <code>protostack=netkey</code> 需显式声明）‌。</li><li>对 NAT 穿透支持较弱（旧内核需额外补丁）‌。</li></ul></li><li>‌StrongSwan‌<ul><li>使用模块化配置（如 <code>strongswan.conf</code>），支持动态加载插件（如 <code>charon</code> 进程管理 IKE）‌。</li><li>内置 ‌NAT-Traversal‌ 功能，适配复杂网络环境更便捷‌。</li></ul></li></ul></li><li><p>维护与扩展性‌</p><ul><li>‌OpenSwan‌<ul><li>社区维护停滞，新版 Linux 发行版（如 Debian 12、Ubuntu <code>22.04+</code>）默认移除了 ‌OpenSwan‌ 的支持‌。</li><li>适合需兼容老旧设备的场景‌。</li></ul></li><li>‌StrongSwan‌<ul><li>项目持续更新，支持 ‌X.509 证书认证‌、‌EAP 扩展认证‌等现代安全机制‌。</li><li>使用 C 语言编写，提供线程池优化，大大提升多连接场景下的协商效率‌。</li></ul></li></ul></li><li><p>性能表现‌</p><ul><li>OpenSwan‌<ul><li>在低带宽场景下性能稳定，但加密转发带宽受限（实测最高约 700 Mbps）‌。</li></ul></li><li>StrongSwan‌<ul><li>通过优化加密算法（如 AES-NI 加速）和线程池技术，转发性能更高（实测带宽可达 1 Gbps+）‌。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">适用场景总结</p><ul><li>‌OpenSwan‌：需兼容旧版设备（如 Linux <code>2.4</code> 内核）、使用 IKEV1 协议的场景‌。</li><li>StrongSwan‌：现代网络环境、需要 IKEV2 协议、高安全认证及性能优化的场景‌。</li></ul></div><h2 id="IPSec-VPN-实现内网互连"><a href="#IPSec-VPN-实现内网互连" class="headerlink" title="IPSec VPN 实现内网互连"></a>IPSec VPN 实现内网互连</h2><p>由于 Debian 12 的 Linux 内核版本是 <code>6.x</code>，因此这里选择基于 StrongSwan‌ 搭建 IPSec VPN，以此在多台 Linux 服务器（处于不同的数据中心 - IDC）之间实现内网通信。各服务器的网络信息如下所示：</p><table><thead><tr><th>服务器</th><th>公网 IP</th><th> 内网 IP</th><th> 备注</th></tr></thead><tbody><tr><td>服务器一</td><td> 101.53.225.204</td><td>10.0.8.9</td><td> 云服务器</td></tr><tr><td>服务器二</td><td> 49.135.225.57</td><td>10.0.20.6</td><td> 云服务器</td></tr></tbody></table><h3 id="准备工作执行"><a href="#准备工作执行" class="headerlink" title="准备工作执行"></a>准备工作执行</h3><p>在两台 Debian 服务器上，分别执行以下操作，为后续安装和配置 IPSec VPN 做准备。</p><ul><li>安装工具软件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新软件索引</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装工具软件</span></span><br><span class="line">sudo apt install -y wget curl telnet tcpdump net-tools vim -y</span><br></pre></td></tr></tbody></table></figure><ul><li>更改系统配置 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑系统配置文件，更改或添加以下配置内容</span></span><br><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 允许转发，默认值是 0</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.ipv6.conf.all.forwarding = 1</span><br><span class="line"></span><br><span class="line"># 关闭重定向，防止恶意用户可以使用 IP 重定向来修改远程主机中的路由表</span><br><span class="line">net.ipv4.conf.all.accept_redirects = 0</span><br><span class="line">net.ipv4.conf.all.send_redirects = 0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用系统配置更改生效</span></span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></tbody></table></figure><ul><li>防火墙开放端口 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 UFW　防火墙</span></span><br><span class="line">sudo apt install -y ufw</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 TCP 22 端口（SSH）</span></span><br><span class="line">sudo ufw allow 22/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 UDP 500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 500/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 UDP 4500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 4500/udp</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用 UFW 防火墙</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙所有已开放的端口</span></span><br><span class="line">sudo ufw verbose</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加路由表规则（可选操作），通过 iptables 修改出站流量的源 IP，匹配云服务器 NAT 映射规则，否则服务器之间的网络可能会不通</span></span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由表规则添加后，若希望删除掉它，可以执行以下命令</span></span><br><span class="line">sudo iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>为了方便后续配置 IPSec VPN 和排查问题，可以先暂时不配置防火墙，也就是可以等 IPSec VPN 正常工作后再配置防火墙。</li><li>IPSec VPN 默认监听在 UDP 的 <code>500</code> 和 <code>4500</code> 两个端口，其中 UDP <code>500</code> 是用于 IKE 密钥交换协商，UDP <code>4500</code> 是用于 NAT 穿透。</li></ul></div><h3 id="服务器一配置"><a href="#服务器一配置" class="headerlink" title="服务器一配置"></a>服务器一配置</h3><h4 id="安装-StrongSwan"><a href="#安装-StrongSwan" class="headerlink" title="安装 StrongSwan"></a>安装 StrongSwan</h4><ul><li>安装 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 StrongSwan 服务</span></span><br><span class="line">sudo apt install -y strongswan strongswan-charon strongswan-libcharon libstrongswan libcharon-extra-plugins</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启 StrongSwan 服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>备份 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/ipsec.conf /etc/ipsec.conf.bak</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">        charondebug="all"</span><br><span class="line"></span><br><span class="line">conn %default                             # 配置ike默认参数</span><br><span class="line">        ikelifetime=1440m                 # ike协议的SA生命周期</span><br><span class="line">        keylife=60m                       # IPSec连接的密钥生命周期为60分钟</span><br><span class="line">        rekeymargin=3m                    # 3分钟过后密钥生命周期结束后重新生成密钥</span><br><span class="line">        keyingtries=0                     # 密钥交换期间允许最大的重试次数为0次</span><br><span class="line">        keyexchange=ikev1                 # IPSec连接使用IKE协议的版本</span><br><span class="line">        authby=secret                     # 使用预共享密钥认证方式</span><br><span class="line">    </span><br><span class="line">conn ipsecvpn                             # 创建ipsecvpn</span><br><span class="line">        leftid=101.53.225.204             # 本地网关设备的标识</span><br><span class="line">        left=101.53.225.204               # 本地网关设备的公网IP地址，如果使用本地网关的私网IP地址建立IPSec-VPN连接，则本项需配置为本地网关设备的私网IP地址</span><br><span class="line">        leftsubnet=10.0.8.0/22            # 本地设备的内网网段</span><br><span class="line">        right=49.135.225.57               # 远端设备的出口网关的公网IP地址</span><br><span class="line">        rightsubnet=10.0.20.0/22          # 远端设备的内网网段</span><br><span class="line">        auto=start                        # 主模式</span><br><span class="line">        type=tunnel                       # 隧道模式</span><br><span class="line">        ike=3des-md5-modp1024             # IKE使用3des-md5-modp1024加密套件</span><br><span class="line">        esp=3des-md5                      # esp使用3des-md5加密套件</span><br><span class="line">        forceencaps=yes                   # 强制使用NAT-T封装，即使NAT-T不是必需的</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>强烈建议加上配置 <code>forceencaps=yes</code>，因为这在云服务器（如阿里云、腾讯云）场景下特别重要，因为它们的公网 IP 可能是 NAT 映射的地址。为了适配 NAT 场景，还可以添加 <code>nat-ikev1-method=natd</code> 配置。</li></ul></div><ul><li>配置 IPSec 预共享密钥 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.secrets</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">101.53.225.204 49.135.225.57 : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">%any : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><h4 id="启动-StrongSwan"><a href="#启动-StrongSwan" class="headerlink" title="启动 StrongSwan"></a>启动 StrongSwan</h4><ul><li>启动 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启 StrongSwan 服务</span></span><br><span class="line">systemctl restart strongswan-starter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 StrongSwan 服务的运行状态</span></span><br><span class="line">systemctl status strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>启动 IPSec 服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新加载 IPSec 配置文件</span></span><br><span class="line">ipsec reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 IPSec 服务</span></span><br><span class="line">ipsec restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动名称为 ipsecvpn 的 IPSec 连接（这里暂时不会启动成功，因为另一台服务器还没有配置 IPSec）</span></span><br><span class="line">ipsec up ipsecvpn </span><br></pre></td></tr></tbody></table></figure><h4 id="关闭-StrongSwan"><a href="#关闭-StrongSwan" class="headerlink" title="关闭 StrongSwan"></a>关闭 StrongSwan</h4><ul><li>若 StrongSwan 服务无法正常启动，可以使用以下命令先关闭 IPSec 和 StrongSwan 服务，然后再重新启动服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭名称为 ipsecvpn 的 IPSec 连接</span></span><br><span class="line">sudo ipsec down ipsecvpn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 IPSec 服务</span></span><br><span class="line">sudo ipsec stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 StrongSwan 服务</span></span><br><span class="line">sudo systemctl stop strongswan-starter</span><br></pre></td></tr></tbody></table></figure><h3 id="服务器二配置"><a href="#服务器二配置" class="headerlink" title="服务器二配置"></a>服务器二配置</h3><h4 id="安装-StrongSwan-1"><a href="#安装-StrongSwan-1" class="headerlink" title="安装 StrongSwan"></a>安装 StrongSwan</h4><ul><li>安装 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 StrongSwan 服务</span></span><br><span class="line">sudo apt install -y strongswan strongswan-charon strongswan-libcharon libstrongswan libcharon-extra-plugins</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启 StrongSwan 服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>备份 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/ipsec.conf /etc/ipsec.conf.bak</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 IPSec 主配置文件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.conf</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">        charondebug="all"</span><br><span class="line"></span><br><span class="line">conn %default                             # 配置ike默认参数</span><br><span class="line">        ikelifetime=1440m                 # ike协议的SA生命周期</span><br><span class="line">        keylife=60m                       # IPSec连接的密钥生命周期为60分钟</span><br><span class="line">        rekeymargin=3m                    # 3分钟过后密钥生命周期结束后重新生成密钥</span><br><span class="line">        keyingtries=0                     # 密钥交换期间允许最大的重试次数为0次</span><br><span class="line">        keyexchange=ikev1                 # IPSec连接使用IKE协议的版本</span><br><span class="line">        authby=secret                     # 使用预共享密钥认证方式</span><br><span class="line">    </span><br><span class="line">conn ipsecvpn                             # 创建ipsecvpn</span><br><span class="line">        leftid=49.135.225.57              # 本地网关设备的标识</span><br><span class="line">        left=49.135.225.57                # 本地网关设备的公网IP地址，如果使用本地网关的私网IP地址建立IPSec-VPN连接，则本项需配置为本地网关设备的私网IP地址</span><br><span class="line">        leftsubnet=10.0.8.0/22            # 本地设备的内网网段</span><br><span class="line">        right=101.53.225.204              # 远端设备的出口网关的公网IP地址</span><br><span class="line">        rightsubnet=10.0.20.0/22          # 远端设备的内网网段</span><br><span class="line">        auto=start                        # 主模式</span><br><span class="line">        type=tunnel                       # 隧道模式</span><br><span class="line">        ike=3des-md5-modp1024             # IKE使用3des-md5-modp1024加密套件</span><br><span class="line">        esp=3des-md5                      # esp使用3des-md5加密套件</span><br><span class="line">        forceencaps=yes                   # 强制使用NAT-T封装，即使NAT-T不是必需的</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>强烈建议加上配置 <code>forceencaps=yes</code>，因为这在云服务器（如阿里云、腾讯云）场景下特别重要，因为它们的公网 IP 可能是 NAT 映射的地址。为了适配 NAT 场景，还可以添加 <code>nat-ikev1-method=natd</code> 配置。</li></ul></div><ul><li>配置 IPSec 预共享密钥 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件，添加以下内容</span></span><br><span class="line">sudo vim /etc/ipsec.secrets</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">49.135.225.57 101.53.225.204 : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 秘钥需要使用双引号包裹</span><br><span class="line">%any : PSK "mysecret"</span><br></pre></td></tr></tbody></table></figure><h4 id="启动-StrongSwan-1"><a href="#启动-StrongSwan-1" class="headerlink" title="启动 StrongSwan"></a>启动 StrongSwan</h4><ul><li>启动 StrongSwan</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启 StrongSwan 服务</span></span><br><span class="line">systemctl restart strongswan-starter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 StrongSwan 服务的运行状态</span></span><br><span class="line">systemctl status strongswan-starter</span><br></pre></td></tr></tbody></table></figure><ul><li>启动 IPSec 服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新加载 IPSec 配置文件</span></span><br><span class="line">ipsec reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 IPSec 服务</span></span><br><span class="line">ipsec restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动名称为 ipsecvpn 的 IPSec 连接</span></span><br><span class="line">ipsec up ipsecvpn </span><br></pre></td></tr></tbody></table></figure><p>当两台服务器都执行 <code>ipsec up ipsecvpn</code> 命令后，就会一直检测对方服务器是否正常启动 IPSec，如果正常启动，它们自己会互相连接成功，如下图所示（<strong>图片来源自网络，仅供参考</strong>）：</p><p><img data-src="../../../asset/2025/03/ipsec-vpn-1.png"></p><h4 id="关闭-StrongSwan-1"><a href="#关闭-StrongSwan-1" class="headerlink" title="关闭 StrongSwan"></a>关闭 StrongSwan</h4><ul><li>若 StrongSwan 服务无法正常启动，可以使用以下命令先关闭 IPSec 和 StrongSwan 服务，然后再重新启动服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭名称为 ipsecvpn 的 IPSec 连接</span></span><br><span class="line">sudo ipsec down ipsecvpn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 IPSec 服务</span></span><br><span class="line">sudo ipsec stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 StrongSwan 服务</span></span><br><span class="line">sudo systemctl stop strongswan-starter</span><br></pre></td></tr></tbody></table></figure><h3 id="验证-VPN-连接"><a href="#验证-VPN-连接" class="headerlink" title="验证 VPN 连接"></a>验证 VPN 连接</h3><ul><li>在服务一查看 IPSec 的运行状态，如下图所示（<strong>图片来源自网络，仅供参考</strong>）：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 IPSec 的运行状态</span></span><br><span class="line">sudo ipsec statusall</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/03/ipsec-vpn-3.png"></p><ul><li>在服务二查看 IPSec 的运行状态，如下图所示（<strong>图片来源自网络，仅供参考</strong>）：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 IPSec 的运行状态</span></span><br><span class="line">sudo ipsec statusall</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/03/ipsec-vpn-2.png"></p><h2 id="IPSec-VPN-常见配置问题"><a href="#IPSec-VPN-常见配置问题" class="headerlink" title="IPSec VPN 常见配置问题"></a>IPSec VPN 常见配置问题</h2><h3 id="UDP-500-端口无法正常通信"><a href="#UDP-500-端口无法正常通信" class="headerlink" title="UDP 500 端口无法正常通信"></a>UDP 500 端口无法正常通信</h3><blockquote><p>问题描述</p></blockquote><p>在服务器一（<code>101.53.225.204</code>）中，执行 <code>systemctl status strongswan-starter</code> 命令查看 StrongSwan 服务的运行状态，出现以下错误信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mar 25 21:38:49 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br><span class="line">Mar 25 21:39:02 debian charon[274510]: 11[IKE] sending retransmit 3 of request message ID 0, seq 1</span><br><span class="line">Mar 25 21:39:02 debian charon[274510]: 11[NET] sending packet: from 101.53.225.204[500] to 49.135.225.57[500] (248 bytes)</span><br><span class="line">Mar 25 21:39:02 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br><span class="line">Mar 25 21:39:26 debian charon[274510]: 12[IKE] sending retransmit 4 of request message ID 0, seq 1</span><br><span class="line">Mar 25 21:39:26 debian charon[274510]: 12[NET] sending packet: from 101.53.225.204[500] to 49.135.225.57[500] (248 bytes)</span><br><span class="line">Mar 25 21:39:26 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br><span class="line">Mar 25 21:40:08 debian charon[274510]: 13[IKE] sending retransmit 5 of request message ID 0, seq 1</span><br><span class="line">Mar 25 21:40:08 debian charon[274510]: 13[NET] sending packet: from 101.53.225.204[500] to 49.135.225.57[500] (248 bytes)</span><br><span class="line">Mar 25 21:40:08 debian charon[274510]: 04[NET] error writing to socket: Network is unreachable</span><br></pre></td></tr></tbody></table></figure><blockquote><p>问题分析</p></blockquote><p>分析错误信息可得知，可能是服务器二（<code>49.135.225.57</code>）的 UDP <code>500</code> 端口不能正常访问导致。</p><blockquote><p>问题解决</p></blockquote><ul><li><strong>(1)</strong> 在服务器二中，检查 IPSec VPN 是否有正常监听 UDP <code>500</code> 和 UDP <code>4500</code> 端口。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查端口监听</span></span><br><span class="line">netstat -ulnp | grep -E <span class="string">'500|4500'</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(2)</strong> 在服务器二中，若 Debian 系统有启用 UFW 防火墙，则需要开放 UDP <code>500</code> 和 UDP <code>4500</code> 端口。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 UDP 500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 500/udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 UDP 4500 端口（IPSec VPN）</span></span><br><span class="line">sudo ufw allow 4500/udp</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(3)</strong> 在服务器二中，使用 <code>tcpdump</code> 工具检测 UDP <code>500</code> 和 UDP <code>4500</code> 端口是否有接收到进站的流量。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any -nn udp port 500 or udp port 4500</span><br></pre></td></tr></tbody></table></figure><ul><li>若 <code>tcpdump</code> 工具没有检测到进站的流量，那么在服务器一中，可以执行以下命令手动发送数据包，以此检测服务器二 UDP <code>500</code> 端口的可达性。当提示 “Connection refused” 或 “Network is unreachable”，则说明 UDP <code>500</code> 端口未开放，需要检查防火墙配置。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -u -z -v 49.135.225.57 500</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(4)</strong> 在服务器一中，检查网络接口是否绑定了公网 IP。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show eth0</span><br></pre></td></tr></tbody></table></figure><ul><li>若在上述命令的输出中，‌没有显示公网 IP <code>101.53.225.204</code>，则可能需要通过云服务商控制台将该 IP 绑定到服务器的弹性网卡（如 <code>eth0</code>）‌。若公网 IP 是通过 NAT 映射（如云服务器弹性 IP），则需要确保 NAT 规则正确配置。</li><li>若公网流量需要通过特定网关（非默认内网网关），则需要在服务器一中添加静态路由，其中 <code>&lt;公网网关IP&gt;</code> 需替换为云服务商提供的公网网关地址（例如 <a href="../../../asset/2025/03/ipsec-vpn-4.png">VPN 网关</a>），详细教程请看 <a href="https://cloud.tencent.com/developer/article/1505715">这里</a>。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加静态路由</span></span><br><span class="line">ip route add 49.135.225.57/32 via &lt;公网网关IP&gt; dev eth0</span><br></pre></td></tr></tbody></table></figure><ul><li>验证路由是否生效，在服务器一中执行以下命令后，预期输出应该包含公网接口（如 <code>dev eth0</code>）和正确网关。若仍指向内网网关，则需要调整路由优先级或联系云服务商检查底层网络配置‌。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取路由表记录</span></span><br><span class="line">ip route get 49.135.225.57</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(5)</strong> 两台服务器分别调整 StrongSwan 配置，尝试显式指定源 IP（公网 IP），避免自动选择内网 IP。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conn ipsecvpn                             # 创建ipsecvpn</span><br><span class="line">        leftid=101.53.225.204             # 本地网关设备的标识</span><br><span class="line">        left=101.53.225.204               # 本地网关设备的公网IP地址，如果使用本地网关的私网IP地址建立IPSec-VPN连接，则本项需配置为本地网关设备的私网IP地址</span><br><span class="line">        leftsubnet=10.0.8.0/22            # 本地设备的内网网段</span><br><span class="line">        leftsourceip=101.53.225.204       # 本地设备的源IP（公网IP）</span><br><span class="line">        ......</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>(6)</strong> 若上述步骤都无法定位或者解决问题，那么可以查看 IPSec 的运行状态和 StrongSwan 的日志信息来进一步定位问题。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 IPSec 的运行状态</span></span><br><span class="line">sudo ipsec statusall</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 StrongSwan 的所有日志信息</span></span><br><span class="line">journalctl -u strongswan-starter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者只查看 StrongSwan 的最新日志信息</span></span><br><span class="line">journalctl -u strongswan-starter --no-pager | tail -n 30</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="IPSec-VPN-技术科普"><a href="#IPSec-VPN-技术科普" class="headerlink" title="IPSec VPN 技术科普"></a>IPSec VPN 技术科普</h3><ul><li><a href="https://www.cnblogs.com/longlyseul/p/16966471.html">IPSec 技术详解</a></li><li><a href="https://developer.jdcloud.com/article/2535">IPSec VPN 原理介绍</a></li></ul><h3 id="IPSec-VPN-网络性能测试"><a href="#IPSec-VPN-网络性能测试" class="headerlink" title="IPSec VPN 网络性能测试"></a>IPSec VPN 网络性能测试</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/27363937370">StrongSwan 配置 IPSec VPN 的性能测试</a></li></ul><h3 id="OpenSwan-搭建-IPSec-VPN"><a href="#OpenSwan-搭建-IPSec-VPN" class="headerlink" title="OpenSwan 搭建 IPSec VPN"></a>OpenSwan 搭建 IPSec VPN</h3><ul><li><a href="https://blog.csdn.net/qq_36833548/article/details/130375242">OpenSwan 安装和简单配置</a></li><li><a href="https://blog.csdn.net/weixin_49816179/article/details/133150477">CentOS VPN 隧道技术实战</a></li><li><a href="https://bbs.sangfor.com.cn/forum.php?mod=viewthread&amp;tid=96195">OpenSwan 实现 IPSec VPN 野蛮模式对接</a></li><li><a href="https://www.liuchunhua.me/post/network/03sitetositevpn/site2sitevpn/">基于 OpenSwan 在 AWS 上构建高可用 VPN</a></li><li><a href="https://github.com/LCTT/TranslateProject/blob/master/published/201411/How%20to%20create%20a%20site-to-site%20IPsec%20VPN%20tunnel%20using%20Openswan%20in%20Linux.md">Openswan 搭建站点到站点的 IPsec VPN 隧道</a></li><li><a href="https://apple4us.com/2010/setting-up-l2tp-vpn-on-debian-ubuntu">如何在 Debian / Ubuntu 服务器上架设 L2TP / IPSec VPN</a></li></ul><h3 id="StrongSwan-搭建-IPSec-VPN"><a href="#StrongSwan-搭建-IPSec-VPN" class="headerlink" title="StrongSwan 搭建 IPSec VPN"></a>StrongSwan 搭建 IPSec VPN</h3><ul><li><a href="https://blog.csdn.net/qq_54100121/article/details/137450215">Debian 配置 IPSec VPN</a></li><li><a href="https://juejin.cn/post/7216604612404707386">Debian L2TP IPSec 服务器搭建</a></li><li><a href="https://blog.51cto.com/niubdada/5037222">CentOS 7.9 使用 StrongSwan 搭建 IPSec VPN</a></li><li><a href="https://cloud.tencent.com/developer/article/1505715">在 CentOS 上使用 StrongSwan 搭建 IPSec VPN 服务</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要记录 Debian 12 如何搭建 IPSec VPN 来实现多台服务器之间的内网通信。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
    <category term="网络安全" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器网络性能测试</title>
    <link href="https://www.techgrow.cn/posts/97085038.html"/>
    <id>https://www.techgrow.cn/posts/97085038.html</id>
    <published>2025-03-16T13:48:23.000Z</published>
    <updated>2025-03-16T13:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍 Linux 服务器的网络性能测试方法，可以根据测试后的数据判断网络性能。服务器的网络性能受多种因素的影响，例如：实例的物理距离、服务器的性能、操作系统参数等，请结合实际情况判断。</p><span id="more"></span><h2 id="安装测试工具"><a href="#安装测试工具" class="headerlink" title="安装测试工具"></a>安装测试工具</h2><p>分别登录服务器、客户端，按以下步骤在服务器和客户端上安装 iperf3 工具。</p><div class="admonition warning"><p class="admonition-title">注意</p><p>在测试环境搭建和测试时都需要保证自己拥有系统的 <code>root</code> 用户权限。</p></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.jdcloud.com/cn/virtual-private-cloud/vpc-performance-test">Linux 服务器网络性能测试</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要记录 Linux 服务器如何进行网络测试。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="网络安全" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 一键搭建 OpenVPN 服务器</title>
    <link href="https://www.techgrow.cn/posts/86c906bc.html"/>
    <id>https://www.techgrow.cn/posts/86c906bc.html</id>
    <published>2025-03-14T12:43:29.000Z</published>
    <updated>2025-03-14T12:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着工作的多样化，办公场地也不局限于公司，有些时候往往需要在家或者公共场所（远程办公）访问公司的内网服务器资源，出于网络安全考虑，互联网不能直接访问公司的内网资源，常见解决方案就是部署 VPN 服务器。本文基于 OpenVPN 搭建 VPN 服务器，搭建好之后可以使用 OpenVPN 客户端连接 VPN 服务器，这样就可以安全地访问 VPN 服务器的内网资源。</p><span id="more"></span><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><ul><li><a href="https://github.com/hwdsl2/setup-ipsec-vpn">hwdsl2/setup-ipsec-vpn</a></li><li><a href="https://github.com/hwdsl2/openvpn-install/tree/master">hwdsl2/openvpn-install</a></li></ul><h3 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h3><blockquote><p>运维面板的高权限风险  </p></blockquote><p>运维面板通常拥有极高的权限，一旦被非法访问，攻击者几乎可以完全控制服务器，安全风险极高。以下是几种常见的 Web 面板及其权限范围：  </p><ul><li><code>宝塔面板</code>：拥有服务器 <code>root</code> 权限，可对系统进行完全控制。  </li><li><code>Portainer</code>：掌管 Docker 的管理权限，能够管理所有容器和镜像。  </li><li><code>Proxmox VE</code>：具备对服务器的完整控制权，包括虚拟机和存储管理。  </li><li><code>phpMyAdmin</code>：负责 MySQL 数据库的管理，拥有数据库的完全操作权限。  </li></ul><blockquote><p>运维面板的安全脆弱性  </p></blockquote><ul><li>一些 Web 面板需要开放公网访问，例如宝塔面板，它引入了多种鉴权和防护机制，能够在一定程度上抵御攻击。然而，历史上仍然发生过多次严重安全漏洞事件。  </li><li>大多数 Web 面板的鉴权方式较为简单，通常只是一个 Web 登录框，防护强度较低。甚至部分面板并未考虑公网访问的安全性，例如 Portainer 官方明确表示其内置鉴权机制不适用于生产环境，并强烈不建议将其直接暴露在公网。</li><li>因此，如果这些鉴权机制较弱的 Web 面板直接开放到公网，将存在极大的安全隐患。  </li></ul><blockquote><p>基于 VPN 的安全防护  </p></blockquote><ul><li>VPN 是一种企业级的成熟加密通信技术，本文推荐使用 开源的 OpenVPN，其代码公开透明，安全性经过长期验证。通过在 Web 面板外层套一层 VPN，不论服务本身的安全性如何，整体访问环境都能得到有效保护。</li><li>使用 VPN 保护 Web 面板的访问是最便捷且安全的方案。其原理十分简单：对于不希望暴露在公网的服务（如高权限管理面板、私人 Web 服务），可以使用防火墙或安全组阻止外网访问。然后，部署一个 VPN 服务器，使管理者在连接 VPN 后，仿佛置身于服务器的内网环境，从而安全访问这些服务。  </li></ul><div class="admonition note"><p class="admonition-title">OpenVPN 的应用场景</p><ul><li>个人出差办公需要访问公司内网的服务器。</li><li>公司不同地区之间建立安全的网络通信（比如 IDC 与 IDC 之间安全通信）。</li></ul></div><h2 id="OpenVPN-服务器部署"><a href="#OpenVPN-服务器部署" class="headerlink" title="OpenVPN 服务器部署"></a>OpenVPN 服务器部署</h2><p>这里使用的是 <a href="https://github.com/hwdsl2/openvpn-install">OpenVPN 自动安装脚本</a>，大家可能认为脚本安装并不能保证安全性。但实际上，OpenVPN 的安全性是由 RSA 技术提供的，安装脚本每次安装都会现场生成 RSA 密钥，安全性是有保障的。使用脚本只是方便部署操作，对于个人应用场景，脚本提供的默认设置已经足够使用。该脚本支持 Ubuntu、Debian、AlmaLinux、Rocky Linux、CentOS、Fedora 系统。特别注意，如果使用的是虚拟化容器，则需要给容器开启 TUN/TAP。</p><h3 id="下载安装脚本"><a href="#下载安装脚本" class="headerlink" title="下载安装脚本"></a>下载安装脚本</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/hwdsl2/openvpn-install/master/openvpn-install.sh -O openvpn.sh</span><br></pre></td></tr></tbody></table></figure><h3 id="运行安装脚本"><a href="#运行安装脚本" class="headerlink" title="运行安装脚本"></a>运行安装脚本</h3><ul><li>使用 <code>root</code> 权限运行脚本，并使用默认选项自动安装（<strong>不推荐</strong>）OpenVPN 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --auto</span><br></pre></td></tr></tbody></table></figure><ul><li>或者使用自定义选项进行交互式安装（<strong>强烈推荐</strong>），自定义选项包括：VPN 服务器的域名、协议（TCP/UDP）和端口、VPN 客户端的 DNS 服务器以及第一个客户端的名称 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>当安装脚本执行成功后，会在运行目录下自动生成一个 <code>客户端名.ovpn</code> 的文件（默认是 <code>client.ovpn</code>），该文件就是 OpenVPN 客户端的连接配置文件，将其下载到本地，然后导入到 OpenVPN 客户端就可以连接 OpenVPN 服务器。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>执行 <code>openvpn.sh</code> 安装脚本后，会从 GitHub 下载相应的文件资源；如果安装脚本执行失败，可能是网络访问 GitHub 较慢导致的，建议再次尝试执行安装脚本。</p></div><h3 id="防火墙开放端口"><a href="#防火墙开放端口" class="headerlink" title="防火墙开放端口"></a>防火墙开放端口</h3><ul><li>当云服务器有外部防火墙（比如安全组），则需要手动调整安全组的配置，也就是开放安全组对应的协议和对应的端口，具体的协议和端口请根据上面的安装选项来配置。</li><li>当 Linux 服务器内有防火墙（比如 <code>UFW</code>），则需要手动调整安全组的配置，也就是开放安全组对应的协议和对应的端口，具体的协议和端口请根据上面的安装选项来配置。</li><li>比如，使用 <code>openvpn.sh --auto</code> 命令自动安装 OpenVPN 服务器后（基于默认安装选项），云服务器的安全组或者 Linux 服务器的防火墙都需要开放 UDP 协议的 <code>1194</code> 端口。<ul><li>Debian 开放 OpenVPN 端口：<code>sudo ufw allow 1194/udp</code></li><li>CentOS 开放 OpenVPN 端口：<code>sudo firewall-cmd --zone=public --permanent --add-port=1194/udp</code></li></ul></li></ul><h2 id="OpenVPN-的日常管理"><a href="#OpenVPN-的日常管理" class="headerlink" title="OpenVPN 的日常管理"></a>OpenVPN 的日常管理</h2><ul><li>安装脚本提供了以下命令行参数，可以用于管理 OpenVPN 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看脚本的参数</span></span><br><span class="line">sudo bash openvpn.sh --<span class="built_in">help</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Usage: bash openvpn.sh [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">  --addclient [client name]      add a new client</span><br><span class="line">  --exportclient [client name]   export configuration for an existing client</span><br><span class="line">  --listclients                  list the names of existing clients</span><br><span class="line">  --revokeclient [client name]   revoke an existing client</span><br><span class="line">  --uninstall                    remove OpenVPN and delete all configuration</span><br><span class="line">  -y, --yes                      assume "yes" as answer to prompts when revoking a client or removing OpenVPN</span><br><span class="line">  -h, --help                     show this help message and exit</span><br><span class="line"></span><br><span class="line">Install options (optional):</span><br><span class="line"></span><br><span class="line">  --auto                         auto install OpenVPN using default or custom options</span><br><span class="line">  --listenaddr [IPv4 address]    IPv4 address that OpenVPN should listen on for requests</span><br><span class="line">  --serveraddr [DNS name or IP]  server address, must be a fully qualified domain name (FQDN) or an IPv4 address</span><br><span class="line">  --proto [TCP or UDP]           protocol for OpenVPN (TCP or UDP, default: UDP)</span><br><span class="line">  --port [number]                port for OpenVPN (1-65535, default: 1194)</span><br><span class="line">  --clientname [client name]     name for the first OpenVPN client (default: client)</span><br><span class="line">  --dns1 [DNS server IP]         primary DNS server for clients (default: Google Public DNS)</span><br><span class="line">  --dns2 [DNS server IP]         secondary DNS server for clients</span><br><span class="line"></span><br><span class="line">To customize options, you may also run this script without arguments.</span><br></pre></td></tr></tbody></table></figure><ul><li>查看所有 OpenVPN 客户端 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --listclients</span><br></pre></td></tr></tbody></table></figure><ul><li>移除指定的 OpenVPN 客户端 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --revokeclient client_name</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 OpenVPN 客户端 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --addclient client_name</span><br></pre></td></tr></tbody></table></figure><ul><li>卸载 OpenVPN 服务器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash openvpn.sh --uninstall</span><br></pre></td></tr></tbody></table></figure><blockquote><p>为了日后更方便地执行安装脚本来管理 OpenVPN 服务器，可以将安装脚本移动到 Linux 系统的 <code>bin</code> 目录下，如下所示：</p></blockquote><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移动脚本文件</span></span><br><span class="line">sudo mv openvpn.sh /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权脚本文件</span></span><br><span class="line">sudo chmod 744 /usr/<span class="built_in">local</span>/bin/openvpn.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以后可以在任意目录下执行脚本</span></span><br><span class="line">sudo openvpn.sh --<span class="built_in">help</span></span><br></pre></td></tr></tbody></table></figure><h2 id="OpenVPN-客户端安装"><a href="#OpenVPN-客户端安装" class="headerlink" title="OpenVPN 客户端安装"></a>OpenVPN 客户端安装</h2><h3 id="各平台安装-GUI-客户端"><a href="#各平台安装-GUI-客户端" class="headerlink" title="各平台安装 GUI 客户端"></a>各平台安装 GUI 客户端</h3><ul><li>(1) <a href="https://openvpn.net/client/">OpenVPN 客户端</a> 在 Windows、macOS、iOS、Android 和 Linux 上均可用，macOS 用户还可以使用 Tunnelblick 作为 OpenVPN 客户端。</li><li>(2) OpenVPN 客户端要连接 OpenVPN 服务器，首先将生成的 <code>客户端名.ovpn</code> 文件安全地下载到本地设备，然后打开 OpenVPN 客户端程序，并导入 OpenVPN 客户端的配置文件（比如 <code>client.ovpn</code>）。</li><li>(3) 当 OpenVPN 服务器需要管理 OpenVPN 客户端时，可以再次运行安装脚本，比如，查看所有 OpenVPN 客户端：<code>sudo bash openvpn.sh --listclients</code>。</li></ul><h3 id="CentOS-7-安装-GUI-客户端"><a href="#CentOS-7-安装-GUI-客户端" class="headerlink" title="CentOS 7 安装 GUI 客户端"></a>CentOS 7 安装 GUI 客户端</h3><p>值得一提的是，如果 Centos 7 不需要使用 GUI 客户端，那么可以直接官方提供的 OpenVPN 3，也就是基于命令行的方式连接 OpenVPN 服务器。</p><ul><li>关闭 SELINUX</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一（临时关闭）</span></span><br><span class="line">sudo setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二（永久关闭，需要重启系统）</span></span><br><span class="line">sudo vi /etc/selinux/config</span><br><span class="line">SELINUX=disabled             <span class="comment"># 找到 SELINUX 这一行，并将其值改为 disabled</span></span><br></pre></td></tr></tbody></table></figure><ul><li>安装客户端（GUI）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install NetworkManager-openvpn</span><br><span class="line">sudo yum install NetworkManager-openvpn-gnome</span><br></pre></td></tr></tbody></table></figure><ul><li>导入 <code>.ovpn</code> 文件 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) 系统菜单栏导航到 settings -&gt; network -&gt; 点击 VPN 旁边的 + 号 -&gt; Import form file</span><br><span class="line">(2) 选择本地的 .ovpn 配置文件，NetworkManager 会自动识别 VPN 客户端的连接方式（比如使用 OpenVPN）</span><br><span class="line">(3) 如果有用户密码，需要在 User key password 输入框中填写用户密码</span><br><span class="line">(4) 如果有用户密码，密码保存方式选择：Store the password for all users（点击选择用户密码输入框右边那两个小人图标），否则容易出现某种奇怪的密码读取问题</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>一键安装 OpenVPN 服务器</p><ul><li><a href="https://blog.csdn.net/weixin_53391173/article/details/134180734">轻松搭建 OpenVPN 服务器</a></li><li><a href="https://blog.csdn.net/lemon_TT/article/details/136375983">OpenVPN 服务器的安装与使用</a></li><li><a href="https://www.zouht.com/3573.html">通过 OpenVPN 安全地进行服务器运维</a></li></ul></li><li><p>手动安装 OpenVPN 服务器</p><ul><li><a href="https://blog.csdn.net/qq_37510195/article/details/130777785">CentOS 搭建 OpenVPN 服务器</a></li><li><a href="https://www.cnblogs.com/cheyunhua/p/17516732.html">CentOS 7 安装 OpenVPN - 超详细</a></li></ul></li><li><p> Docker 安装 OpenVPN 服务器</p><ul><li><a href="https://cloud.tencent.com/developer/article/1953132">Docker 搭建虚拟专用网（VPN）</a></li></ul></li><li><p>CentOS 7 安装 OpenVPN 客户端</p><ul><li><a href="https://developer.baidu.com/article/details/3282576">CentOS 7 安装 OpenVPN 客户端</a></li><li><a href="https://zhuanlan.zhihu.com/p/637668940">Centos 7 安装 OpenVPN 客户端（GUI）</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Linux 系统一键搭建 OpenVPN 服务器。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="网络安全" scheme="https://www.techgrow.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装 Sentinel Dashboard 单机</title>
    <link href="https://www.techgrow.cn/posts/592ca43f.html"/>
    <id>https://www.techgrow.cn/posts/592ca43f.html</id>
    <published>2025-03-13T12:05:42.000Z</published>
    <updated>2025-03-13T12:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍如何使用 Docker 和 Docker-Compose 安装 Sentinel Dashboard（单机）。</p><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li><a href="https://github.com/alibaba/Sentinel">Sentinel 官方项目</a></li><li><a href="https://github.com/alibaba/Sentinel/wiki">Sentinel 官方文档</a></li><li><a href="https://hub.docker.com/r/herodotus/sentinel-dashboard">Sentinel Dashboard 镜像（支持持久化）</a></li><li><a href="https://hub.docker.com/r/bladex/sentinel-dashboard">Sentinel Dashboard 镜像（不支持持久化）</a></li></ul><span id="more"></span><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><ul><li>拉取镜像 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bladex/sentinel-dashboard:1.8.8</span><br></pre></td></tr></tbody></table></figure><ul><li>启动容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name sentinel -d -p 8858:8858  bladex/sentinel-dashboard:1.8.8</span><br></pre></td></tr></tbody></table></figure><h3 id="Docker-Compose-安装"><a href="#Docker-Compose-安装" class="headerlink" title="Docker-Compose 安装"></a>Docker-Compose 安装</h3><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sentinel-dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bladex/sentinel-dashboard:1.8.8</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sentinel-dashboard</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8858</span><span class="string">:8858</span></span><br></pre></td></tr></tbody></table></figure><h3 id="测试-Sentinel-Dashboard"><a href="#测试-Sentinel-Dashboard" class="headerlink" title="测试 Sentinel Dashboard"></a>测试 Sentinel Dashboard</h3><p>启动 Sentinel Dashboard 容器后，浏览器通过 <code>http://127.0.0.1:8858/</code> 可以访问控制台管理页面，默认登录用户和密码分别是 <code>sentinel /sentinel</code>。</p><h3 id="Sentinel-Dashboard-持久化"><a href="#Sentinel-Dashboard-持久化" class="headerlink" title="Sentinel Dashboard 持久化"></a>Sentinel Dashboard 持久化</h3><p>Sentinel Dashboard 的流量控制规则默认存储在内存中，重启后会丢失配置规则。若希望通过 Sentinel Dashboard 界面将流量控制规则存储到 Nacos，或者将微服务的流量监控数据持久化存储到 Influxdb 时序数据库，可以使用 Dante Cloud 发布的 <a href="https://hub.docker.com/r/herodotus/sentinel-dashboard">Sentinel Dashboard 镜像</a>。</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sentinel-dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">herodotus/sentinel-dashboard:1.8.8</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sentinel-dashboard</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SENTINEL_ADMIN_USERNAME:</span> <span class="string">sentinel</span></span><br><span class="line">      <span class="attr">SENTINEL_ADMIN_PASSWORD:</span> <span class="string">sentinel</span></span><br><span class="line">      <span class="attr">INFLUXDB_URL:</span> <span class="string">http://127.0.0.1:8086</span></span><br><span class="line">      <span class="attr">INFLUXDB_USERNAME:</span> <span class="string">influx</span></span><br><span class="line">      <span class="attr">INFLUXDB_PASSWORD:</span> <span class="string">influx</span></span><br><span class="line">      <span class="attr">INFLUXDB_DATABASE:</span> <span class="string">sentinel</span></span><br><span class="line">      <span class="attr">NACOS_SERVER_ADDRESS:</span> <span class="string">http://127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">NACOS_CONFIG_DATA_ID_SUFFIX:</span> <span class="string">flow-rules</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8858:8858"</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Dante Cloud 发布的 Sentinel Dashboard 镜像，时序数据存储支持 Influxdb <code>v1.x</code> 版本，Nacos 目前仅支持 <code>v2.x</code> 版本。默认使用 Sentinel Dashboard 原有内存方式存储，可通过配置参数动态开启或者关闭 Influxdb 和 Nacos 存储机制。</p></div>]]></content>
    
    
    <summary type="html">本文主要介绍如何使用 Docker 安装 Sentinel Dashboard 单机。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>UFW 导致 Docker 容器无法使用 IP 访问宿主机</title>
    <link href="https://www.techgrow.cn/posts/9fc5e76e.html"/>
    <id>https://www.techgrow.cn/posts/9fc5e76e.html</id>
    <published>2025-03-13T12:05:42.000Z</published>
    <updated>2025-03-13T12:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>Debian 服务器的内网 IP（宿主机 IP） 是 <code>192.16.1.5</code>，启用了 UFW 防火墙，并且服务器上运行着两个 Docker 容器。</li><li>假设用 <code>-p 8080:80</code> 参数启动了容器 A 内的服务，在容器 B 内的服务通过宿主机 IP（<code>192.16.1.5:8080</code>）访问容器 A 的服务，发现无法正常访问。</li></ul><span id="more"></span><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>Debian 启用 UFW 防火墙后，Docker 容器可能无法使用宿主机的 IP 地址相互通信。这是因为 Docker 默认会直接修改 <code>iptables</code> 规则，而这些规则可能与 UFW 的配置产生冲突，导致通信受阻。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>关闭 UFW 防火墙，这是最简单的方案，但也是最危险的方案。因为服务器将失去 UFW 防火墙的保护，容易受到恶意攻击。</p><h3 id="解决方法二"><a href="#解决方法二" class="headerlink" title="解决方法二"></a>解决方法二</h3><p>自定义 Docker 桥接网络，并添加 UFW 防火墙规则允许 Docker 桥接网络与宿主机互相通信。</p><ul><li>定义 Docker 桥接网络，同时指定自定义网络的子网范围 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">user-biz:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">clay/user-biz:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">user-biz</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">cloud_default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">173.18</span><span class="number">.0</span><span class="number">.05</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">order-biz:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">clay/order-biz:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">order-biz</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9090</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">cloud_default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">173.18</span><span class="number">.0</span><span class="number">.06</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">cloud_default:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud_default</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">173.18</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br></pre></td></tr></tbody></table></figure><ul><li>或者手动创建 Docker 桥接网络，同时指定自定义网络的子网范围，并在容器启动时指定桥接网络 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker network create --driver bridge --subnet 173.18.0.0/16 cloud_default</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name user-biz -p 8080:80 --network cloud_default --ip 173.18.0.05 clay/user-biz:latest</span><br><span class="line">sudo docker run -d --name order-biz -p 9090:80 --network cloud_default --ip 173.18.0.06 clay/order-biz:latest</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Docker 桥接网络的 IP 分配情况 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect network cloud_default</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">"d268549f1335d1078c3692e1208a0376eb403a920a176642983f2eb0f64f4b61": {</span><br><span class="line">    "Name": "user-biz",</span><br><span class="line">    "EndpointID": "8d5cba4fe76a69b4169e6266ca2d3a5cbd9be84fdcf0e7f4f3ab6a05c2825a1f",</span><br><span class="line">    "MacAddress": "8e:40:19:99:af:49",</span><br><span class="line">    "IPv4Address": "173.18.0.05/16",</span><br><span class="line">    "IPv6Address": ""</span><br><span class="line">},</span><br><span class="line">"f83453e8d515e58a1c5a68c7957835ed82cece7104129dba1fcb604bb1215d8a": {</span><br><span class="line">    "Name": "order-biz",</span><br><span class="line">    "EndpointID": "8899737f0c54cfb3f4fac0f9effaeaf318eb12e8d0d4988fff399a2d94e9be0b",</span><br><span class="line">    "MacAddress": "72:6e:1b:a8:15:26",</span><br><span class="line">    "IPv4Address": "173.18.0.06/16",</span><br><span class="line">    "IPv6Address": ""</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 UFW 防火墙规则（使用 CIDR 表示法），允许 Docker 桥接网络与宿主机互相通信。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow from 173.18.0.0/16</span><br><span class="line">sudo ufw allow out to 173.18.0.0/16</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/shihan175/article/details/131058696">Docker 容器无法使用 IP 访问宿主机</a></li><li><a href="https://www.cnblogs.com/codedingzhen/p/18371798">解决 Docker 和 UFW 的网络冲突问题</a></li><li><a href="https://juejin.cn/post/7307857575507836966">解决 UFW 和 Docker 的冲突问题</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何解决 Docker 容器无法使用 IP 访问宿主机的问题。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    <category term="Linux运维" scheme="https://www.techgrow.cn/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固进阶之四</title>
    <link href="https://www.techgrow.cn/posts/6e5acd18.html"/>
    <id>https://www.techgrow.cn/posts/6e5acd18.html</id>
    <published>2025-03-07T13:55:33.000Z</published>
    <updated>2025-03-07T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-的智能指针"><a href="#C-的智能指针" class="headerlink" title="C++ 的智能指针"></a>C++ 的智能指针</h2><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="/posts/dbff2af9.html#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">C++ 智能指针使用教程</a></li></ul></div><h3 id="智能指针的几种常见类型"><a href="#智能指针的几种常见类型" class="headerlink" title="智能指针的几种常见类型"></a>智能指针的几种常见类型</h3><p>在 C++ 中，智能指针的类型有以下几种：</p><ul><li>(1) 带引用计数的智能指针：<code>shared_ptr</code></li><li>(2) 不带引用计数的智能指针：<code>auto_ptr</code>、<code>scoped_ptr</code>、<code>unique_ptr</code></li><li>(3) 特殊的智能指针：<code>weak_ptr</code>（不增加引用计数，可以用于避免 <code>shared_ptr</code> 发生循环引用）</li></ul><table><thead><tr><th>智能指针</th><th>所有权</th><th>带引用计数</th><th>适用场景</th><th>核心特性</th></tr></thead><tbody><tr><td><code>auto_ptr</code></td><td>独占（拷贝时转移）</td><td>否</td><td>⚠ 已废弃，建议改用 <code>unique_ptr</code></td><td>独占所有权，在复制或赋值时会转移所有权，导致原指针变为空（<code>nullptr</code>）</td></tr><tr><td><code>scoped_ptr</code></td><td>独占</td><td>否</td><td>生命周期受限于作用域，适用于简单的场景，避免资源泄漏</td><td>独占所有权，不可复制或赋值，不支持移动语义，即不可以使用 <code>std::move()</code> 函数转移所有权</td></tr><tr><td><code>unique_ptr</code></td><td>独占</td><td>否</td><td>资源独占，生命周期明确</td><td>独占所有权，不可复制（拷贝构造和赋值），但可以移动（移动构造和移动赋值），即支持使用 <code>std::move()</code> 函数转移所有权</td></tr><tr><td><code>shared_ptr</code></td><td>共享</td><td>是</td><td>资源共享，生命周期不固定</td><td>共享所有权（允许多个智能指针管理同一个资源）</td></tr><tr><td><code>weak_ptr</code></td><td>观察 <code>shared_ptr</code></td><td>否</td><td>避免 <code>shared_ptr</code> 发生循环引用</td><td>不增加引用计数，用于避免 <code>shared_ptr</code> 发生循环引用，可以通过 <code>lock()</code> 函数转换为 <code>shared_ptr</code></td></tr></tbody></table><h3 id="不带引用计数的智能指针"><a href="#不带引用计数的智能指针" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h3><h4 id="auto-ptr-智能指针"><a href="#auto-ptr-智能指针" class="headerlink" title="auto_ptr 智能指针"></a>auto_ptr 智能指针</h4><h5 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h5><p><code>auto_ptr</code> 是 C++ 98 引入的智能指针，具有独占所有权，在复制或赋值时会转移所有权，导致原指针变为空（<code>nullptr</code>）。它可以自动释放资源，但由于容易导致空指针问题，在 C++ 11 被弃用，推荐使用 <code>unique_ptr</code> 或 <code>shared_ptr</code> 代替。<code>auto_ptr</code> 的核心特性如下：</p><ul><li><p>独占所有权（所有权转移）：  </p><ul><li>不能有多个 <code>auto_ptr</code> 共享同一资源。</li><li>复制或赋值时，所有权会从原指针转移到新指针，原指针会变为空（<code>nullptr</code>）。</li></ul></li><li><p>自动释放资源：  </p><ul><li>在 <code>auto_ptr</code> 离开作用域时，会自动调用 <code>delete</code> 释放资源，防止内存泄漏。</li></ul></li><li><p>已被 C++ 11 弃用：  </p><ul><li>由于所有权转移容易导致空指针问题，<code>auto_ptr</code> 在 C++ 11 中已经被 <code>unique_ptr</code> 或者 <code>shared_ptr</code> 取代。</li></ul></li></ul><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>))</span></span>;   <span class="comment">// ptr1 拥有这个动态分配的 int(20)</span></span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;          <span class="comment">// 可复制，ptr1 的所有权被 ptr2 接管，ptr1 变为空</span></span><br><span class="line">    *ptr2 = <span class="number">10</span>;                        <span class="comment">// 通过 ptr2 修改资源的值</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;          // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;             <span class="comment">// 正常输出 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>))</span></span>;   <span class="comment">// ptr1 拥有这个动态分配的 int(20)</span></span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;   <span class="comment">// 可赋值，ptr2 拥有这个动态分配的 int(30)</span></span><br><span class="line">    ptr2 = ptr1;                       <span class="comment">// ptr1 的所有权被 ptr2 接管，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;          // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;             <span class="comment">// 正常输出 20</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="scoped-ptr-智能指针"><a href="#scoped-ptr-智能指针" class="headerlink" title="scoped_ptr 智能指针"></a>scoped_ptr 智能指针</h4><h5 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h5><p><code>scoped_ptr</code> 是 Boost 库提供的一种简单智能指针，独占所有权，不可复制或赋值，不支持移动语义，即不可以使用 <code>std::move()</code> 函数转移所有权，在离开作用域时自动释放资源。类似于 <code>unique_ptr</code>，但不支持移动语义，适用于 RAII（资源管理即初始化） 场景。在 C++ 11 之后，推荐使用 <code>unique_ptr</code> 代替。<code>scoped_ptr</code> 的核心特性如下：</p><ul><li><p>独占所有权：</p><ul><li>只能有一个 <code>scoped_ptr</code> 拥有资源，不可复制或赋值。</li></ul></li><li><p>自动释放资源：  </p><ul><li>离开作用域时自动调用 <code>delete</code> 释放资源，防止内存泄漏。</li></ul></li><li><p>不支持移动语义：  </p><ul><li>不能使用 <code>std::move()</code> 函数转移所有权（但相比 <code>unique_ptr</code>，功能更简单）。</li></ul></li><li><p>适用于 RAII（资源管理即初始化）：  </p><ul><li>适合管理动态分配的对象，确保作用域结束时资源被释放。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>阅读 <code>scoped_ptr</code> 的底层源码，可以发现它的拷贝构造函数和赋值运算符重载函数都被 <code>delete</code> 掉，所以它才不支持复制或赋值（转移）。</p></div><h5 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// boost::scoped_ptr&lt;int&gt; ptr2(ptr1);       // 编译出错，不可复制</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = ptr1;     // 编译出错，不可赋值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// boost::scoped_ptr&lt;int&gt; ptr2(move(ptr1));       // 编译出错，不支持移动构造</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = move(ptr1);      // 编译出错，不支持移动赋值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="unique-ptr-智能指针"><a href="#unique-ptr-智能指针" class="headerlink" title="unique_ptr 智能指针"></a>unique_ptr 智能指针</h4><h5 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h5><p><code>unique_ptr</code> 是 C++ 11 引入的智能指针，独占所有权，不可复制（拷贝构造和赋值），但可以移动（移动构造和移动赋值），即支持使用 <code>std::move()</code> 函数转移所有权。它在离开作用域时自动释放资源，适用于 RAII（资源管理即初始化），是 <code>auto_ptr</code> 和 <code>scoped_ptr</code> 的现代替代方案。<code>unique_ptr</code> 的核心特性如下：</p><ul><li><p>独占所有权：  </p><ul><li>只能有一个 <code>unique_ptr</code> 拥有同一资源，不可复制。</li></ul></li><li><p>支持移动语义：  </p><ul><li>可通过 <code>std::move()</code> 函数转移所有权。</li></ul></li><li><p>自动释放资源：</p><ul><li>离开作用域时自动调用 <code>delete</code> 释放资源，防止内存泄漏。</li></ul></li><li><p>支持自定义删除器：  </p><ul><li>可指定自定义删除器，如 <code>std::default_delete</code> 或 Lambda。</li></ul></li><li><p>轻量且性能优越：  </p><ul><li>不会有额外的引用计数（相比 <code>shared_ptr</code> 而言），适用于 RAII 管理单一对象。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>阅读 <code>unique_ptr</code> 的底层源码，可以发现它使用了带右值引用参数的拷贝构造函数和赋值运算符重载函数，所以它才可以通过 <code>std::move()</code> 函数转移所有权。</li></ul></div><h5 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;int&gt; ptr2(ptr1);         // 编译出错，不可复制</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = ptr1;                         // 编译出错，不可赋值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(move(ptr1))</span></span>;      <span class="comment">// 支持移动构造，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    ptr2 = <span class="built_in">move</span>(ptr1);                     <span class="comment">// 支持移动赋值，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="带引用计数的智能指针"><a href="#带引用计数的智能指针" class="headerlink" title="带引用计数的智能指针"></a>带引用计数的智能指针</h3><p>C++ 11 带引用计数的智能指针允许多个指针共享同一个资源。当最后一个指向资源的智能指针被销毁时，资源才会被释放。它通过引用计数来跟踪有多少个智能指针指向同一资源，确保资源在不再使用时自动释放，避免内存泄漏。</p><ul><li>C++ 11 带引用计数的智能指针有两种，分别是：<ul><li><code>shared_ptr</code>：强引用智能指针，可以改变资源的引用计数</li><li><code>weak_ptr</code>：弱引用智能指针，不会改变资源的引用计数，主要用于避免 <code>shared_ptr</code> 智能指针的循环引用</li></ul></li></ul><h4 id="shared-ptr-智能指针"><a href="#shared-ptr-智能指针" class="headerlink" title="shared_ptr 智能指针"></a>shared_ptr 智能指针</h4><h5 id="概念介绍-3"><a href="#概念介绍-3" class="headerlink" title="概念介绍"></a>概念介绍</h5><p><code>shared_ptr</code> 是 C++ 11 引入的智能指针，允许多个指针共享同一资源。它通过引用计数来跟踪有多少个指针指向同一对象，当最后一个指向该资源的 <code>shared_ptr</code> 被销毁时，资源会自动释放。适用于需要多个所有者共享同一资源的场景，即需要多个智能指针管理同一个资源。<code>shared_ptr</code> 的核心特性如下：</p><ul><li>共享所有权<ul><li>多个 <code>shared_ptr</code> 可以同时指向同一对象，共享资源的所有权。</li></ul></li><li>引用计数<ul><li>每个 <code>shared_ptr</code> 内部维护一个引用计数，表示当前有多少个指针引用该资源。</li></ul></li><li>自动管理内存<ul><li>当引用计数归零时，资源被自动释放。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>shared_ptr</code> 的引用计数是和对象是分开存储在堆上的。引用计数并不是存在被管理对象中，而是存储在由 <code>shared_ptr</code> 内部管理的一个独立控制块（Control Block）中（<a href="../../../asset/2025/04/cxx-interview-1.jpeg">如图所示</a>）。</li><li>这种设计可以支持多个指针共享对象的同时，又能独立于对象本体跟踪引用和生命周期。</li></ul></div><h5 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h5><ul><li><code>shared_ptr</code> 的引用计数是和对象默认是分开存储在堆上的。引用计数并不是存在被管理对象中，而是存储在由 <code>shared_ptr</code> 内部管理的一个独立控制块（Control Block）中。</li><li>这种设计可以支持多个指针共享对象的同时，又能独立于对象本体跟踪引用和生命周期，如下图所示：</li></ul><p><img data-src="../../../asset/2025/04/cxx-make-shared.png"></p><p>在创建 <code>shared_ptr</code> 智能指针时，建议使用 <code>make_shared()</code> 函数来创建，而不是直接 <code>new</code>，其原因如下：</p><ul><li><p>使用 <code>make_shared()</code> 函数</p><ul><li>写法：<code>shared_ptr&lt;Person&gt; sp1 = make_shared&lt;Person&gt;();</code></li><li>只进行一次内存分配（对象和控制块在同一块内存中），可以减少开销。</li><li>资源的内存分配和 <code>shared_ptr</code> 创建是原子操作，可以避免内存泄漏和异常安全问题。</li></ul></li><li><p>使用 <code>new</code> 关键字</p><ul><li>写法：<code>shared_ptr&lt;Person&gt; sp1(new Person());</code></li><li>需要进行两次内存分配（一次是给对象，另一次是给 <code>shared_ptr</code> 的控制块），性能稍低。</li><li><code>new</code> 和 <code>shared_ptr</code> 绑定是分离的，如果 <code>shared_ptr</code> 还没成功创建，但 <code>new</code> 已经分配内存，这可能会导致内存泄漏。</li></ul></li></ul><h5 id="使用案例-3"><a href="#使用案例-3" class="headerlink" title="使用案例"></a>使用案例</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Using Person"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr sp1，并管理 Person 对象</span></span><br><span class="line">    shared_ptr&lt;Person&gt; sp1 = make_shared&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不建议这样写</span></span><br><span class="line">    <span class="comment">// shared_ptr&lt;Person&gt; sp1(new Person());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印引用计数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Reference count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建一个 shared_ptr sp2，共享 sp1 的资源</span></span><br><span class="line">        shared_ptr&lt;Person&gt; sp2 = sp1;</span><br><span class="line">        <span class="comment">// 打印引用计数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"Reference count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 访问资源</span></span><br><span class="line">        sp2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    } <span class="comment">// 作用域结束后，sp2 自动析构，引用计数减少</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印引用计数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Reference count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person()</span><br><span class="line">Reference count: 1</span><br><span class="line">Reference count: 2</span><br><span class="line">Using Person</span><br><span class="line">Reference count: 1</span><br><span class="line">~Person()</span><br></pre></td></tr></tbody></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>在 C++ 中使用 <code>shared_ptr</code> 时，推荐使用 <code>make_shared()</code> 直接代替使用 <code>new</code> 操作符，主要原因如下：</p><ul><li><p><strong>异常安全</strong></p><ul><li>当使用 <code>new</code> 创建对象并传递给 <code>shared_ptr</code> 构造函数时，若函数参数的求值顺序不确定，可能导致内存泄漏。例如：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(shared_ptr&lt;T&gt;(<span class="keyword">new</span> T), <span class="built_in">some_function</span>());</span><br></pre></td></tr></tbody></table></figure></li><li>在上述代码中，若 <code>new T</code> 先执行，接着 <code>some_function()</code> 抛出异常，此时 <code>new T</code> 分配的内存尚未被 <code>shared_ptr</code> 接管，会导致内存泄漏。而 <code>make_shared()</code> 会将对象的构造与控制块的内存分配合并为原子操作，避免了这一问题。</li></ul></li><li><p><strong>性能优化</strong></p><ul><li><code>make_shared()</code> 会一次性分配内存，同时存储对象和控制块（包含引用计数、弱引用计数等）。而通过 <code>new</code> 构造 <code>shared_ptr</code> 时，需要进行两次内存分配（对象和控制块各一次），增加了额外开销。</li><li><code>make_shared()</code> 可以减少内存分配次数，提升了性能，尤其在频繁创建 <code>shared_ptr</code> 时效果显著。</li></ul></li><li><p><strong>内存碎片</strong></p><ul><li>对象和控制块连续存储在同一内存块中，提高了缓存局部性，可能减少内存碎片，尤其对小对象更有利。</li></ul></li><li><p><strong>代码简洁</strong></p><ul><li><code>make_shared()</code> 语法更简洁，无需显式使用 <code>new</code>，避免了手动管理裸指针的风险。例如：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = make_shared&lt;T&gt;();       <span class="comment">// 清晰且安全</span></span><br><span class="line"><span class="keyword">auto</span> ptr = shared_ptr&lt;T&gt;(<span class="keyword">new</span> T);   <span class="comment">// 需要显式处理new</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>尽管 <code>make_shared()</code> 的优势非常明显，但在以下场景仍需直接使用 <code>new</code>：</li><li><strong>(1) 自定义删除器</strong>：<code>make_shared()</code> 不支持指定自定义删除器。</li><li><strong>(2) 对象和控制块的内存分离存储</strong>：若希望对象内存（而非控制块）在引用计数归零时立即释放（而不需要等待所有 <code>weak_ptr</code> 释放），需使用 <code>new</code> 并手动构造 <code>shared_ptr</code>。</li></ul></div><h3 id="较为特殊的智能指针"><a href="#较为特殊的智能指针" class="headerlink" title="较为特殊的智能指针"></a>较为特殊的智能指针</h3><h4 id="weak-ptr-智能指针"><a href="#weak-ptr-智能指针" class="headerlink" title="weak_ptr 智能指针"></a>weak_ptr 智能指针</h4><h5 id="weak-ptr-的概念介绍"><a href="#weak-ptr-的概念介绍" class="headerlink" title="weak_ptr 的概念介绍"></a>weak_ptr 的概念介绍</h5><p><code>weak_ptr</code> 是 C++ 11 的智能指针之一，主要用于避免 <code>shared_ptr</code> 智能指针之间的循环引用问题。它是 <code>shared_ptr</code> 智能指针的弱引用，不会增加引用计数，不能直接访问资源，但可以通过 <code>lock()</code> 函数将其转换为 <code>shared_ptr</code> 智能指针来访问资源。当资源已被释放时，<code>lock()</code> 函数会返回空指针，可用于判断对象是否仍然存在。<code>weak_ptr</code> 的核心特性如下：</p><ul><li>不增加引用计数<ul><li>只持有 <code>shared_ptr</code> 智能指针的弱引用，不影响对象生命周期。  </li></ul></li><li>防止循环引用<ul><li>可以解决 <code>shared_ptr</code> 智能指针循环引用导致的内存泄漏问题。</li></ul></li><li>检查资源状态<ul><li>可以通过 <code>expired()</code> 函数判断资源是否仍然存在。</li></ul></li><li>访问资源<ul><li>可以通过 <code>lock()</code> 函数转换为 <code>shared_ptr</code> 智能指针，若资源已释放，则返回空指针。</li></ul></li><li>可重置与交换<ul><li>支持使用 <code>reset()</code> 函数释放关联，还支持使用 <code>swap()</code> 函数交换指针内容。</li></ul></li></ul><h5 id="模拟-shared-ptr-循环引用问题"><a href="#模拟-shared-ptr-循环引用问题" class="headerlink" title="模拟 shared_ptr 循环引用问题"></a>模拟 shared_ptr 循环引用问题</h5><p>本节将演示在使用 <code>shared_ptr</code> 智能指针时，怎样才会发生循环引用的问题。在下述代码中，会发生智能指针循环引用的问题，最终导致堆上的对象 A 和 对象 B 无法正常析构（释放内存资源），最终导致内存泄漏，详细的分析图解请看 <a href="../../../asset/2025/02/cxx_shared_pointer_1.png">这里</a>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟 shared_ptr 智能指针发生循环引用的问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;B&gt; _ptrB;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;A&gt; _ptrA;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">ptrA</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">ptrB</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会造成智能指针的循环引用，导致程序结束运行后资源无法正常被析构（释放内存空间）</span></span><br><span class="line">    ptrA-&gt;_ptrB = ptrB;</span><br><span class="line">    ptrB-&gt;_ptrA = ptrA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印智能指针的引用计数</span></span><br><span class="line">    cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ptrB.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h5 id="解决-shared-ptr-循环引用问题"><a href="#解决-shared-ptr-循环引用问题" class="headerlink" title="解决 shared_ptr 循环引用问题"></a>解决 shared_ptr 循环引用问题</h5><p>为了解决 <code>shared_ptr</code> 智能指针使用不当导致的循环引用问题，可以在定义对象的时候，使用强引用智能指针（<code>shared_ptr</code>）；而在引用对象的时候，使用弱引用智能指针（<code>weak_ptr</code>）。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解決 shared_ptr 智能指针的循环引用问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 B 的存在，但未定义 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">A</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用对象时，使用弱引用智能指针 (weak_ptr)</span></span><br><span class="line">weak_ptr&lt;B&gt; _ptrB;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">B</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用对象时，使用弱引用智能指针 (weak_ptr)</span></span><br><span class="line">weak_ptr&lt;A&gt; _ptrA;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 定义对象时，使用强引用智能指针 (shared_ptr)</span></span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">ptrA</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;B&gt; <span class="title">ptrB</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不会造成智能指针循环引用的问题</span></span><br><span class="line">ptrA-&gt;_ptrB = ptrB;</span><br><span class="line">ptrB-&gt;_ptrA = ptrA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印智能指针的引用计数</span></span><br><span class="line">cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ptrB.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></tbody></table></figure><h5 id="weak-ptr-访问对象资源"><a href="#weak-ptr-访问对象资源" class="headerlink" title="weak_ptr 访问对象资源"></a>weak_ptr 访问对象资源</h5><p><code>weak_ptr</code> 智能指针是 <code>shared_ptr</code> 智能指针的弱引用，不会增加引用计数，不能直接访问资源，但可以通过 <code>lock()</code> 函数转换为 <code>shared_ptr</code> 智能指针来访问资源。当资源已被释放时，<code>lock()</code> 函数会返回空指针，可用于判断对象是否仍然存在。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weak_ptr 通过 lock() 函数访问对象资源</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 B 的存在，但未定义 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 func 方法的存在，但未定义 func 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用对象时，使用弱引用智能指针</span></span><br><span class="line">    weak_ptr&lt;B&gt; _ptrB;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 func 方法的存在，但未定义 func 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用对象时，使用弱引用智能指针</span></span><br><span class="line">    weak_ptr&lt;A&gt; _ptrA;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::func</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"A::func()"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 必须将弱引用智能指针转换为强引用智能指针，这样才能访问被管理对象的资源</span></span><br><span class="line">    shared_ptr&lt;B&gt; ptrB = _ptrB.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (ptrB != <span class="literal">nullptr</span>) {</span><br><span class="line">        ptrB-&gt;<span class="built_in">func</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::func</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"B::func()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义对象时，使用强引用智能指针</span></span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">ptrA</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">ptrB</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里不会造成智能指针循环引用的问题</span></span><br><span class="line">    ptrA-&gt;_ptrB = ptrB;</span><br><span class="line">    ptrA-&gt;<span class="built_in">func</span>();</span><br><span class="line">    ptrB-&gt;_ptrA = ptrA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印智能指针的引用计数</span></span><br><span class="line">    cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ptrB.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">A::func()</span><br><span class="line">B::func()</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></tbody></table></figure><h3 id="自定义智能指针的删除器"><a href="#自定义智能指针的删除器" class="headerlink" title="自定义智能指针的删除器"></a>自定义智能指针的删除器</h3><h4 id="删除器的概念介绍"><a href="#删除器的概念介绍" class="headerlink" title="删除器的概念介绍"></a>删除器的概念介绍</h4><p>C++ 智能指针的删除器（Deleter）是一个可自定义的回调函数，用于在智能指针释放资源时自动执行自定义的删除操作。</p><ul><li><code>unique_ptr</code> 智能指针的删除器可以是函数指针或仿函数（函数对象），允许自定义释放方式，例如调用 <code>delete[]</code> 代替 <code>delete</code>。  </li><li><code>shared_ptr</code> 智能指针的删除器可以确保所有引用计数归零后执行自定义删除操作。  </li></ul><h4 id="删除器的使用场景"><a href="#删除器的使用场景" class="headerlink" title="删除器的使用场景"></a>删除器的使用场景</h4><p>在以下使用情况下，C++ 需要自定义智能指针的删除器。</p><ul><li>(1) 使用非 <code>new</code> 分配的资源。当对象的创建方式不是 <code>new</code>，不能用默认 <code>delete</code> 释放时，需要自定义删除器。例如，使用 <code>malloc()</code> 分配的内存必须用 <code>free()</code> 释放。  </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>, <span class="title">decltype</span><span class="params">(&amp;free)</span>&gt; <span class="title">ptr</span><span class="params">((<span class="keyword">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)), free)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 管理文件、网络、数据库等系统资源。智能指针默认用 <code>delete</code> 释放资源，但某些系统资源（如文件、数据库连接、网络套接字）需要调用特定 API 释放资源。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(&amp;fclose)</span>&gt; <span class="title">file</span><span class="params">(fopen(<span class="string">"data.txt"</span>, <span class="string">"w"</span>), fclose)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 数组（<code>new[]</code>）资源的正确释放。默认的 <code>unique_ptr</code> 只调用 <code>delete</code>，而不是 <code>delete[]</code>，所以管理动态数组时，需要自定义删除器。  </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>[], <span class="title">void</span><span class="params">(*)</span><span class="params">(<span class="keyword">int</span>*)</span>&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span>* p) { <span class="keyword">delete</span>[] p; })</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>; <span class="comment">// C++ 11 允许直接用 unique_ptr&lt;int[]&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 需要额外的清理操作。对象释放时，需要额外的清理步骤，比如日志记录、计数等。  </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customDeleter</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Deleting pointer: "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>, <span class="title">decltype</span><span class="params">(&amp;customDeleter)</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>), customDeleter)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(5) 使用 <code>shared_ptr</code> 时需要优化删除器大小。<code>shared_ptr</code> 允许自定义删除器，但它需要存储删除器对象，因此通常使用函数对象（仿函数）或 Lambda 来优化删除器大小。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDeleter</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>* p)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Deleting shared ptr: "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>), CustomDeleter())</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> deleter = [](<span class="keyword">int</span>* p) { <span class="keyword">delete</span> p; };</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>), deleter)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除器的使用案例"><a href="#删除器的使用案例" class="headerlink" title="删除器的使用案例"></a>删除器的使用案例</h4><h5 id="删除器的案例代码一"><a href="#删除器的案例代码一" class="headerlink" title="删除器的案例代码一"></a>删除器的案例代码一</h5><p>通过模板类单独定义了两个函数对象（仿函数），来实现 <code>unique_ptr</code> 智能指针的删除器。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数组的删除器（函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayDeleter</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * arrayPtr)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"Deleting array pointer"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (arrayPtr != <span class="literal">nullptr</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] arrayPtr;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义文件的删除器（函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileDeleter</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* filePtr)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"Deleting file pointer"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (filePtr != <span class="literal">nullptr</span>) {</span><br><span class="line"><span class="built_in">fclose</span>(filePtr);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 创建一个智能指针管理整型数组，并指定删除器</span></span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>, ArrayDeleter&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个智能指针管理文件，并指定删除器</span></span><br><span class="line">unique_ptr&lt;FILE, FileDeleter&lt;FILE&gt;&gt; <span class="built_in">ptr2</span>(<span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deleting file pointer</span><br><span class="line">Deleting array pointer</span><br></pre></td></tr></tbody></table></figure><h5 id="删除器的案例代码二"><a href="#删除器的案例代码二" class="headerlink" title="删除器的案例代码二"></a>删除器的案例代码二</h5><p>在上述的案例代码一中，通过模板类单独定义了两个函数对象（仿函数）来实现智能指针的删除器，这略显得冗余，因为删除器在定义之后只使用了一次。为了使代码更简洁，可以使用 Lambda 表达式来定义智能指针的删除器。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 创建一个智能指针管理整型数组，并通过Lambda表达指定删除器</span></span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>, function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>*)&gt;&gt; <span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>], [](<span class="keyword">int</span>* p) {</span><br><span class="line">cout &lt;&lt; <span class="string">"Deleting array pointer by lambda"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个智能指针管理文件，并通过Lambda表达指定删除器</span></span><br><span class="line">unique_ptr&lt;FILE, function&lt;<span class="built_in"><span class="keyword">void</span></span>(FILE*)&gt;&gt; <span class="built_in">ptr2</span>(<span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>), [](FILE* p) {</span><br><span class="line">cout &lt;&lt; <span class="string">"Deleting file pointer by lambda"</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">fclose</span>(p);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deleting file pointer by lambda</span><br><span class="line">Deleting array pointer by lambda</span><br></pre></td></tr></tbody></table></figure><h5 id="删除器的案例代码三"><a href="#删除器的案例代码三" class="headerlink" title="删除器的案例代码三"></a>删除器的案例代码三</h5><p>除了上面介绍的删除器定义方式之外，还可以使用函数指针作为 <code>unique_ptr</code> 智能指针的删除器。通过 <code>std::decltype()</code> 来获取 <code>arrayDeleter()</code> 函数的类型，并将其作为 <code>unique_ptr</code> 智能指针的删除器类型。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayDeleter</span><span class="params">(<span class="keyword">int</span>* ptr)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Deleting array pointer: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个智能指针管理文件，并通过函数指针指定删除器</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>, <span class="title">decltype</span><span class="params">(&amp;arrayDeleter)</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], arrayDeleter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效写法之一</span></span><br><span class="line">    <span class="comment">// using DeleterType = void(*)(int*);  // 明确指定删除器类型</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int, DeleterType&gt; ptr(new int[100], arrayDeleter);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效写法之二</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int(10), arrayDeleter);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deleting array pointer: 000001B05684F800</span><br></pre></td></tr></tbody></table></figure><h3 id="多线程访问共享对象的问题"><a href="#多线程访问共享对象的问题" class="headerlink" title="多线程访问共享对象的问题"></a>多线程访问共享对象的问题</h3><p>在多个线程同时访问同一个对象（共享对象）时，往往会产生线程安全问题，下面将介绍如何使用 C++ 11 的 <code>shared_ptr</code> 与 <code>weak_ptr</code> 智能指针来解决线程安全问题。</p><h4 id="thread-detach-介绍"><a href="#thread-detach-介绍" class="headerlink" title="thread::detach() 介绍"></a>thread::detach () 介绍</h4><p>这里先简单介绍一下 <code>thread::detach()</code> 函数，有助于理解后面给出的多线程案例代码。</p><ul><li><p><code>thread::detach()</code> 函数的作用</p><ul><li><code>detach()</code> 提供了一种非阻塞方式来运行线程</li><li>线程一旦 <code>detach()</code>，就会变成守护线程（Daemon Thread），独立于 <code>thread</code> 对象运行。</li><li><code>thread</code> 对象与底层线程资源分离，<code>thread</code> 对象销毁时不会影响已分离的线程。</li><li>适用于不需要等待线程结束的场景，例如后台任务或日志记录等。</li></ul></li><li><p><code>thread::detach()</code> 函数的注意事项</p><ul><li><code>不要访问已销毁的资源</code>：调用 <code>detach()</code> 后，线程对象的生命周期由操作系统管理，后续不能再通过 <code>thread</code> 访问它，否则会导致未定义行为。</li><li><code>避免主线程提前退出</code>：<code>main()</code> 退出时，所有仍在运行的分离线程会被终止，这可能导致任务未完成或资源泄漏。</li><li><code>不能 detach() 两次</code>：如果 <code>thread</code> 已经 <code>detach()</code>，再次调用 <code>detach()</code> 会导致错误。</li></ul></li><li><p><code>thread::detach()</code> 与 <code>thread::join()</code> 的区别</p><ul><li><code>join()</code>：阻塞主线程，直到子线程执行完毕，适用于必须等待子线程完成的任务（如并行计算）。</li><li><code>detach()</code>：让子线程独立运行，主线程不会等待它执行完毕，适用于不关心子线程何时完成的任务（如日志记录、异步 I/O 任务）。</li></ul></li></ul><h4 id="线程安全问题的产生"><a href="#线程安全问题的产生" class="headerlink" title="线程安全问题的产生"></a>线程安全问题的产生</h4><p>下述这段 C++ 代码会产生线程安全问题，因为主线程和子线程同时访问共享对象 Task，但是主线程在子线程访问共享对象 Task 之前，将共享对象析构掉，这会导致子线程在后续访问共享对象时产生不可预知的行为。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全问题的产生</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"invoke Task::run()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executTask</span><span class="params">(Task *task)</span> </span>{</span><br><span class="line">    <span class="comment">// 子线程等待 5 秒</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="comment">// 执行任务方法</span></span><br><span class="line">    task-&gt;<span class="built_in">run</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Task *task = <span class="keyword">new</span> <span class="built_in">Task</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(executTask, task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将子线程与 thread 对象分离，使其在后台独立运行，直到子线程执行完毕</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程在子线程调用 Task::run() 函数之前析构 Task 对象（共享对象），这样就会产生线程安全问题</span></span><br><span class="line">    <span class="keyword">delete</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待子线程执行完成</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="线程安全问题的解决"><a href="#线程安全问题的解决" class="headerlink" title="线程安全问题的解决"></a>线程安全问题的解决</h4><p>这里利用 <code>weak_ptr</code> 智能指针可以观察 <code>shared_ptr</code> 智能指针状态的特性，来解决多线程访问共享对象的线程安全问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全问题的解决</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"invoke Task::run()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executTask</span><span class="params">(weak_ptr&lt;Task&gt; wp)</span> </span>{</span><br><span class="line">    <span class="comment">// 子线程等待 5 秒</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子线程访问共享对象时，先检查共享对象是否存活</span></span><br><span class="line">    shared_ptr&lt;Task&gt; sp = wp.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (sp != <span class="literal">nullptr</span>) {</span><br><span class="line">        sp-&gt;<span class="built_in">run</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Failed to invoke Task:run()"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建强引用智能指针</span></span><br><span class="line">        shared_ptr&lt;Task&gt; task = make_shared&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(executTask, weak_ptr&lt;Task&gt;(task))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子线程与 thread 对象分离，使其在后台独立运行，直到子线程执行完毕</span></span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 共享对象 task 出了作用域后会自动释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待子线程执行完成</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task()</span><br><span class="line">~Task()</span><br><span class="line">Failed to invoke Task:run()</span><br></pre></td></tr></tbody></table></figure><h3 id="智能指针的模拟实现"><a href="#智能指针的模拟实现" class="headerlink" title="智能指针的模拟实现"></a>智能指针的模拟实现</h3><p>本节将使用 C++ 的类模板来简单模拟实现智能指针。</p><div class="admonition note"><p class="admonition-title">提示</p><p>智能指针的本质是利用栈上的对象出了作用域（比如函数作用域）后自动析构的特性，以此来实现资源的自动释放。</p></div><h4 id="不带引用计数的智能指针-1"><a href="#不带引用计数的智能指针-1" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h4><p>本节将使用类模板、右值引用、移动语义（<code>move</code> ）来简单模拟实现 C++ 11 中的 <code>unique_ptr</code> 智能指针。</p><div class="admonition note"><p class="admonition-title">扩展阅读</p><p>更多关于 C++ 11 右值引用和移动语义（<code>move</code> ）的介绍请看 <a href="/posts/e302ad63.html">这里</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现不带引用计数的智能指针，类似 unique_ptr 智能指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSmartPtr</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(T *ptr)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~CSmartPtr()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式删除带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式删除带左值引用参数的赋值运算符重载函数</span></span><br><span class="line">    CSmartPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数，支持移动构造（即支持 move 移动语义）</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(CSmartPtr&lt;T&gt; &amp;&amp;src) <span class="keyword">noexcept</span> : _ptr(src._ptr) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(CSmartPtr&lt;T&gt; &amp;&amp;src)"</span> &lt;&lt; endl;</span><br><span class="line">        src._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载函数，支持移动赋值（即支持 move 移动语义）</span></span><br><span class="line">    CSmartPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(CSmartPtr&lt;T&gt; &amp;&amp;src) <span class="keyword">noexcept</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr&lt;T&gt; &amp;operator=(CSmartPtr&lt;T&gt; &amp;&amp;src)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 避免自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先存储当前的指针，避免删除自己后 src._ptr 变为 nullptr</span></span><br><span class="line">        T *old_ptr = _ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转移所有权</span></span><br><span class="line">        _ptr = src._ptr;</span><br><span class="line">        src._ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放旧资源</span></span><br><span class="line">        <span class="keyword">delete</span> old_ptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// * 运算符重载函数</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() {</span><br><span class="line">        <span class="keyword">if</span> (!_ptr) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"Dereferencing a null pointer!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -&gt; 运算符重载函数</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() {</span><br><span class="line">        <span class="keyword">if</span> (!_ptr) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"Accessing member of a null pointer!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有权，不删除对象</span></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">        T *temp = _ptr;</span><br><span class="line">        _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">        <span class="comment">// 避免 delete 自己的对象</span></span><br><span class="line">        <span class="keyword">if</span> (_ptr == ptr) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">        _ptr = ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始指针</span></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// CSmartPtr&lt;int&gt; ptr2(ptr1);         // 编译出错，不可复制</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = ptr1;                         // 编译出错，不可赋值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(move(ptr1))</span></span>;      <span class="comment">// 支持移动构造，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    ptr2 = <span class="built_in">move</span>(ptr1);                     <span class="comment">// 支持移动赋值，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 30</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> *rawPtr = p1.<span class="built_in">release</span>();             <span class="comment">// p1 不再管理该资源</span></span><br><span class="line">    <span class="keyword">delete</span> rawPtr;                          <span class="comment">// 需要手动释放</span></span><br><span class="line"></span><br><span class="line">    CSmartPtr&lt;<span class="keyword">int</span>&gt; p2;</span><br><span class="line">    p2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>));                 <span class="comment">// 重新分配资源</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="built_in">test05</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">C++ 11 及更高版本中的特殊成员函数行为</p><ul><li>如果用户通过右值引用参数声明了移动构造函数或移动赋值运算符重载函数，而没有显式声明拷贝构造函数或赋值运算符重载函数（带左值引用参数），则：</li><li>(1) 拷贝构造函数（带左值引用参数）会被隐式删除（<code>= delete</code>）。</li><li>(2) 赋值运算符重载函数（带左值引用参数）会被隐式删除（<code>= delete</code>）。</li></ul></div><table><thead><tr><th><strong>是否定义了用户自定义的…</strong></th><th><strong> 默认拷贝构造</strong></th><th><strong>默认拷贝赋值</strong></th><th><strong>默认移动构造</strong></th><th><strong>默认移动赋值</strong></th></tr></thead><tbody><tr><td>没有移动构造和移动赋值</td><td>✅ 自动生成</td><td>✅ 自动生成</td><td>❌ <strong>不会自动生成</strong></td><td>❌ <strong>不会自动生成</strong></td></tr><tr><td><strong>定义了移动构造或移动赋值</strong></td><td>❌ <strong>隐式删除</strong></td><td>❌ <strong>隐式删除</strong></td><td>✅ 存在</td><td>✅ 存在</td></tr></tbody></table><h4 id="带引用计数的智能指针-1"><a href="#带引用计数的智能指针-1" class="headerlink" title="带引用计数的智能指针"></a>带引用计数的智能指针</h4><p>本节将使用类模板来简单模拟实现 C++ 11 中的 <code>shared_ptr</code> 智能指针，暂时不考虑线程安全问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现带引用计数的智能指针（不考虑线程安全问题），类似 shared_ptr 智能指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefCount</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RefCount</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr) {</span><br><span class="line">        <span class="comment">// 在堆上初始化引用计数，为了让智能指针在复制或赋值时共享同一个引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RefCount</span>() {</span><br><span class="line">        <span class="comment">// 释放堆上的引用计数</span></span><br><span class="line">        <span class="keyword">delete</span> _count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数自增</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increDef</span><span class="params">()</span> </span>{</span><br><span class="line">        ++(*_count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数自减</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decreRef</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (*_count &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> --(*_count);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前引用计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> *_count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;        <span class="comment">// 指向资源的指针</span></span><br><span class="line">    <span class="keyword">int</span> *_count;    <span class="comment">// 指向堆上存储的引用计数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSmartPtr</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(T* ptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 初始化引用计数对象</span></span><br><span class="line">        _refCount = <span class="keyword">new</span> RefCount&lt;T&gt;(_ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~CSmartPtr()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 减少引用计数，并且当引用计数为零时，才释放智能指针管理的资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _refCount-&gt;<span class="built_in">decreRef</span>()) {</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _refCount;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;src) : _ptr(src._ptr), _refCount(src._refCount) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(const CSmartPtr&lt;T&gt;&amp; src)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 增加引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (_ptr != <span class="literal">nullptr</span>) {</span><br><span class="line">            _refCount-&gt;<span class="built_in">increDef</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载函数</span></span><br><span class="line">    CSmartPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;src) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr&lt;T&gt; operator=(const CSmartPtr&lt;T&gt;&amp; src)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 避免自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放旧的资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _refCount-&gt;<span class="built_in">decreRef</span>()) {</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _refCount;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共享新的资源</span></span><br><span class="line">        _ptr = src._ptr;</span><br><span class="line">        _refCount = src._refCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加引用计数</span></span><br><span class="line">        _refCount-&gt;<span class="built_in">increDef</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// * 运算符重载函数</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() {</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -&gt; 运算符重载函数</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() {</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;                   <span class="comment">// 指向资源的指针</span></span><br><span class="line">    RefCount&lt;T&gt; *_refCount;    <span class="comment">// 指向资源引用计数对象的指针</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age = <span class="number">0</span>) : _age(age) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person(int age)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"age: "</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 测试多个智能指针管理同一个对象资源</span></span><br><span class="line">    <span class="function">CSmartPtr&lt;Person&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">20</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="function">CSmartPtr&lt;Person&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;   <span class="comment">// 可复制</span></span><br><span class="line">        ptr2-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">        CSmartPtr&lt;Person&gt; ptr3;</span><br><span class="line">        ptr3 = ptr2;                    <span class="comment">// 可赋值</span></span><br><span class="line">        ptr3-&gt;<span class="built_in">print</span>();</span><br><span class="line">    } <span class="comment">// 出了作用域后，ptr2、ptr3 析构，但不影响 ptr1，也不影响对象资源的析构</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"Leaving inner scope..."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ptr1-&gt;<span class="built_in">print</span>();  <span class="comment">// 仍然有效</span></span><br><span class="line"></span><br><span class="line">} <span class="comment">// 出了作用域后，ptr1 析构，并析构对象资源</span></span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Person(int age)</span><br><span class="line">CSmartPtr(T* ptr)</span><br><span class="line">CSmartPtr(const CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">age: 20</span><br><span class="line">CSmartPtr(T* ptr)</span><br><span class="line">CSmartPtr&lt;T&gt; operator=(const CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">age: 20</span><br><span class="line">~CSmartPtr()</span><br><span class="line">~CSmartPtr()</span><br><span class="line">Leaving inner scope...</span><br><span class="line">age: 20</span><br><span class="line">~CSmartPtr()</span><br><span class="line">~Person()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固进阶之三</title>
    <link href="https://www.techgrow.cn/posts/bd9d2710.html"/>
    <id>https://www.techgrow.cn/posts/bd9d2710.html</id>
    <published>2025-03-02T13:55:33.000Z</published>
    <updated>2025-03-02T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-11-的-function-类模板"><a href="#C-11-的-function-类模板" class="headerlink" title="C++ 11 的 function 类模板"></a>C++ 11 的 function 类模板</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p><code>function</code> 是 C++ 11 引入的一个类模板，用于存储任何可以调用的目标（如普通函数、函数指针、函数对象、Lambda 表达式等），并通过统一的接口进行调用。它能够封装和管理函数，允许将函数作为对象传递和存储，位于 <code>&lt;functional&gt;</code> 头文件中，常用于回调和高阶函数。</p><ul><li><p>使用说明</p><ul><li>用函数类型实例化 <code>function</code> 类模板</li><li>通过 <code>function</code> 类模板调用 <code>operator()</code> 函数的时候，需要根据函数类型传入相应的参数</li></ul></li><li><p>使用特点</p><ul><li>通过类型擦除技术存储任意可调用对象（普通函数、Lambda 表达式、仿函数、成员函数指针等），无需关心具体类型，仅需关注调用签名‌</li><li>编译时会检查参数和返回类型是否匹配，避免了传统函数指针的类型不安全问题‌</li></ul></li><li><p>使用场景</p><ul><li>事件回调</li><li>作为函数参数传递可调用对象</li><li>存储 Lambda 表达式</li></ul></li></ul><h3 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h3><p>C 语言中的函数指针与 C++ 的 <code>function</code> 类模板的对比如下：</p><table><thead><tr><th>特性</th><th>函数指针 (C 语言)</th><th><code>function</code> 类模板 (C++)</th></tr></thead><tbody><tr><td> 灵活性</td><td>只能指向具有匹配签名的函数</td><td>可以封装多种类型的可调用对象 (函数、Lambda、函数对象)</td></tr><tr><td> 状态管理</td><td>不支持状态封装</td><td>支持状态封装（如 Lambda 表达式和函数对象）</td></tr><tr><td>类型安全</td><td>不提供额外的类型安全</td><td>提供类型安全检查</td></tr><tr><td>性能开销</td><td>较低</td><td>可能有较高的内存和性能开销</td></tr><tr><td>多态性</td><td>不支持多态</td><td>支持多态</td></tr></tbody></table><p>C 语言中的函数指针与 C++ 的 <code>function</code> 类模板的区别如下：</p><ul><li><p>基本概念</p><ul><li>函数指针（C 语言）<ul><li>函数指针是一个变量，用于存储函数的地址。通过该指针，可以间接调用对应的函数。</li><li>C 语言中的函数指针需要显式指定函数签名（返回值类型和参数类型）。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 是 C++ 11 引入的类模板，提供了一种通用的、类型安全的方式来存储、传递和调用可调用对象（如普通函数、函数指针、Lambda 表达式、函数对象等）。</li><li>它可以封装多种不同类型的可调用对象，并且允许它们通过统一的接口被调用。</li></ul></li></ul></li><li><p>灵活性和类型支持</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针只能指向具有相同函数签名（参数类型和返回类型）的函数。</li><li>不支持封装函数对象、Lambda 表达式等其他类型的可调用对象。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 支持多种类型的可调用对象，包括普通函数、函数指针、Lambda 表达式、函数对象等。</li><li>它的模板参数可以适配任意函数签名，支持更加灵活的调用。</li><li>还支持捕获外部状态的 Lambda 表达式，或者包含状态的函数对象。</li></ul></li></ul></li><li><p>状态管理</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针无法封装额外的状态信息，指向的仅仅是一个函数。</li><li>如果需要管理状态（如在函数调用前后执行某些操作），必须依赖外部的代码来实现。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 可以封装状态信息。例如，Lambda 表达式和函数对象可以拥有成员变量和成员函数，允许在调用时使用封装的状态。</li><li>这种能力使得 <code>function</code> 在处理回调和事件处理时更具优势。</li></ul></li></ul></li><li><p>类型安全</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针本身类型是静态的，编译时要求函数签名必须匹配，但它不提供额外的类型安全检查，错误的使用可能导致未定义行为。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 是类型安全的，编译时会检查存储的可调用对象是否与声明的函数签名一致。</li><li>C++ 编译器提供了类型安全的保证，避免了函数签名不匹配带来的错误。</li></ul></li></ul></li><li><p>内存管理和性能</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针直接存储函数的地址，不涉及额外的内存分配，因此它的性能开销较小。</li><li>由于没有额外的封装，也没有多态或状态的管理，性能上较为高效。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 需要进行额外的内存分配和类型擦除（Type Erasure）。对于 Lambda 表达式和函数对象，它会封装一个通用的接口，这可能带来额外的性能开销。</li><li>但是，它的灵活性和类型安全是 <code>function</code> 的优势。</li></ul></li></ul></li><li><p>多态和扩展性</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针没有多态性。它们只是简单地指向某个函数，无法支持运行时多态。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 支持通过函数对象、Lambda 表达式和虚拟函数等方式实现运行时多态，提供了更大的灵活性。</li><li>它可以封装复杂的行为，例如结合面向对象编程中的继承和多态来实现不同的回调机制。</li></ul></li></ul></li></ul><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello1</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello2</span><span class="params">(string str)</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// function 函数对象类型</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; function1 = hello1;</span><br><span class="line">    <span class="built_in">function1</span>();</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; function2 = hello2;</span><br><span class="line">    <span class="built_in">function2</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; function3 = sum;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="built_in">function3</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"total = "</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function 函数对象类型 + Lambda 表达式</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; function4 = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) {<span class="keyword">return</span> a + b; };</span><br><span class="line">    <span class="keyword">int</span> total2 = <span class="built_in">function4</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"total2 = "</span> &lt;&lt; total2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello peter</span><br><span class="line">total = 3</span><br><span class="line">total2 = 8</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 通过 function 函数对象类型，调用类的成员函数</span></span><br><span class="line">    Test t;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(Test*, string)&gt; function1 = &amp;Test::hello;</span><br><span class="line">    <span class="built_in">function1</span>(&amp;t, <span class="string">"peter"</span>);</span><br><span class="line">    <span class="built_in">function1</span>(&amp;<span class="built_in">Test</span>(), <span class="string">"peter"</span>);    <span class="comment">// 或者使用临时变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br><span class="line">hello peter</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码三"><a href="#案例代码三" class="headerlink" title="案例代码三"></a>案例代码三</h4><p>使用 <code>function</code> 函数对象类型来实现图书管理系统的菜单列表选择功能。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doShowAllBooks</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"查看所有书籍"</span> &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBorrowBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"借书"</span> &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBackBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"还书"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doQueryBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"查询书籍"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoginOut</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"注销"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="keyword">int</span>, function&lt;<span class="keyword">void</span>()&gt;&gt; actionMap;</span><br><span class="line">actionMap.<span class="built_in">insert</span>({ <span class="number">1</span>, doShowAllBooks });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">2</span>, doBorrowBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">3</span>, doBackBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">4</span>, doQueryBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">5</span>, doLoginOut });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"\n-------------------"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"1. 查看所有书籍"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"2. 借书"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"3. 还书"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"4. 查询书籍"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"5. 注销"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"-------------------"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"请选择: "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测输入是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (!(cin &gt;&gt; choice)) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入数字无效，请重新输入!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 清除错误状态</span></span><br><span class="line">            cin.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">// 丢弃错误输入</span></span><br><span class="line">            cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = actionMap.<span class="built_in">find</span>(choice);</span><br><span class="line">        <span class="keyword">if</span> (it == actionMap.<span class="built_in">end</span>()) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入数字无效，请重新输入!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        it-&gt;<span class="built_in">second</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="案例代码一-1"><a href="#案例代码一-1" class="headerlink" title="案例代码一"></a>案例代码一</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有一个参数且不带返回值的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 模板类的特化，支持特定的函数签名 R(ARG)</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG 代表参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ARG&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg 传递给存储函数的参数</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG arg)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 hello 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = hello;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 hello</span></span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二-1"><a href="#案例代码二-1" class="headerlink" title="案例代码二"></a>案例代码二</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有两个参数且带返回值的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG1, ARG2)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 模板类的特化，支持特定的函数签名 R(ARG1, ARG2)</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG1 代表第一个参数类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG2 代表第二个参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ARG1, <span class="keyword">typename</span> ARG2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG1, ARG2)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG1, ARG2) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG1, ARG2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line"><span class="comment">     * @param pfunc 指向函数的指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg1 传递给存储函数的第一个参数</span></span><br><span class="line"><span class="comment">     * @param arg2 传递给存储函数的第二个参数</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG1 arg1, ARG2 arg2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg1, arg2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 sum 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func1 = sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 sum</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">func1</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result: "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: 8</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码三-1"><a href="#案例代码三-1" class="headerlink" title="案例代码三"></a>案例代码三</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有不同数量参数（可变参数列表）的函数，避免编写多个模板类的特例化。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG...)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief myfunction 模板类的特化，支持可变长参数列表</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG 代表参数列表（可以是任意数量的参数类型）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ... ARG&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG...)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG...) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line"><span class="comment">     * @param pfunc 指向函数的指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg 传递给存储函数的参数列表</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG... arg)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg...);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 hello 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = hello;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 hello</span></span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 sum函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func2 = sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func2 调用 sum</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">func2</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result: "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br><span class="line">result: 7</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的-bind-绑定器"><a href="#C-11-的-bind-绑定器" class="headerlink" title="C++ 11 的 bind 绑定器"></a>C++ 11 的 bind 绑定器</h2><h3 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h3><h4 id="bind-的概念"><a href="#bind-的概念" class="headerlink" title="bind 的概念"></a>bind 的概念</h4><p><code>bind</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的一个工具，用于创建可调用对象（Callable Object），它可以将函数与部分参数进行绑定，并返回一个新的可调用对象，方便后续调用。</p><ul><li><p>主要作用</p><ul><li>固定部分参数：可以预先绑定部分参数，简化后续调用的接口。</li><li>调整参数顺序：可以自定义参数的传递顺序，使函数调用更加灵活。</li><li>与标准库配合：可以与 <code>function</code>、<code>thread</code>、STL 算法等一起使用，提高程序的灵活性。</li></ul></li><li><p>关键点</p><ul><li><code>bind</code> 返回一个可调用对象（函数对象），类似于 Lambda 表达式。</li><li><code>placeholders::_1, placeholders::_2, ...</code> 代表占位符（最多可以有 20 个），表示绑定器调用时需要提供的参数。</li><li>适用于普通函数、类成员函数、仿函数（函数对象）等。</li></ul></li><li><p>使用场景</p><ul><li>配合 <code>function</code> 类模板使用，用于回调管理。</li><li>与 <code>thread</code> 配合，用于传递类成员函数。</li><li>在 STL 算法中自定义比较或筛选规则。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>尽管 <code>bind</code> 功能强大，但在 C++ 11 之后，Lambda 表达式在大多数情况下更加直观，建议优先使用 Lambda 表达式。</p></div><h4 id="bind1st-与-bind2nd-的概念"><a href="#bind1st-与-bind2nd-的概念" class="headerlink" title="bind1st 与 bind2nd 的概念"></a>bind1st 与 bind2nd 的概念</h4><p><code>bind1st</code> 和 <code>bind2nd</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的函数适配器，用于对二元（两个参数）函数对象进行绑定，使其成为一元（单参数）函数对象。这两个函数适配器用于旧版 C++（C++ 98 / C++ 03），在 C++ 11 及更新版本中已被 <code>bind</code> 取代。</p><ul><li><code>bind1st</code>：绑定二元（两个参数）函数对象的第一个参数，生成一个新的一元函数对象，该函数对象接收原函数的第二个参数作为输入。</li><li><code>bind2nd</code>：绑定二元（两个参数）函数对象的第二个参数，生成一个新的一元函数对象，该函数对象接收原函数的第一个参数作为输入。</li></ul><h3 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="bind-与-function-基础使用"><a href="#bind-与-function-基础使用" class="headerlink" title="bind 与 function 基础使用"></a><code>bind</code> 与 <code>function</code> 基础使用</h4><p>这里主要演示如何使用 C++ 11 中的 <code>bind</code> 和 <code>function</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 例子一，绑定拥有一个参数的普通函数</span></span><br><span class="line">    <span class="built_in">bind</span>(hello, <span class="string">"Hello Bind!"</span>)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子二，绑定拥有两个参数的普通函数</span></span><br><span class="line">    <span class="keyword">int</span> result1 = <span class="built_in">bind</span>(sum, <span class="number">3</span>, <span class="number">5</span>)();</span><br><span class="line">    cout &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子三，绑定类成员函数</span></span><br><span class="line">    <span class="keyword">int</span> result2 = <span class="built_in">bind</span>(&amp;Test::sum, <span class="built_in">Test</span>(), <span class="number">5</span>, <span class="number">9</span>)();</span><br><span class="line">    cout &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子四，使用参数占位符绑定（最多可以有20个参数占位符）</span></span><br><span class="line">    <span class="built_in">bind</span>(hello, placeholders::_1)(<span class="string">"Hello Rust!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子五，使用 function 类模板实现 bind 绑定器的复用</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = <span class="built_in">bind</span>(hello, placeholders::_1);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"Hello Python"</span>);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"Hello Golang"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子六，使用参数占位符 + function 类模板进行绑定</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; func2 = <span class="built_in">bind</span>(sum, <span class="number">6</span>, placeholders::_1);    <span class="comment">// 绑定 6 作为第一个参数，第二个参数则手动传入</span></span><br><span class="line">    <span class="keyword">int</span> result3 = <span class="built_in">func2</span>(<span class="number">5</span>);     <span class="comment">// 输出 11，相当于 sum(6, 5)</span></span><br><span class="line">    cout &lt;&lt; result3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hello Bind!</span><br><span class="line">8</span><br><span class="line">14</span><br><span class="line">Hello Rust!</span><br><span class="line">Hello Python</span><br><span class="line">Hello Golang</span><br><span class="line">11</span><br></pre></td></tr></tbody></table></figure><h4 id="bind-与-function-实现线程池"><a href="#bind-与-function-实现线程池" class="headerlink" title="bind 与 function 实现线程池"></a><code>bind</code> 与 <code>function</code> 实现线程池</h4><p>这里简单使用 C++ 11 的 <code>bind</code> 和 <code>function</code> 来模拟实现线程池。特别注意，下述代码中的 <code>ThreadPool::startPool()</code> 会调用 <code>join()</code> 来阻塞等待所有子线程执行完成，即线程池运行一次后就会结束，不能重复使用，而且也没有使用到任务队列来优化线程池。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Thread</span>(function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; func, <span class="keyword">int</span> id) : _func(func), _id(id) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(_func, _id)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; _func;</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程池</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">        <span class="comment">// 释放堆上的资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _pool.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">delete</span> _pool[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建自定义的线程对象，并放入容器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="comment">// 使用 bind 绑定器</span></span><br><span class="line">            _pool.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="keyword">this</span>, placeholders::_1), i));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _handler.<span class="built_in">push_back</span>(_pool[i]-&gt;<span class="built_in">start</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子线程执行完成</span></span><br><span class="line">        <span class="keyword">for</span> (thread &amp;t : _handler) {</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Thread *&gt; _pool;</span><br><span class="line">    vector&lt;thread&gt; _handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runInThread() 成员函数充当线程函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runInThread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call runInThread! id: "</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">startPool</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call runInThread! id: 0</span><br><span class="line">call runInThread! id: 2</span><br><span class="line">call runInThread! id: 5</span><br><span class="line">call runInThread! id: 9</span><br><span class="line">call runInThread! id: 6</span><br><span class="line">call runInThread! id: 8</span><br><span class="line">call runInThread! id: 1</span><br><span class="line">call runInThread! id: 7</span><br><span class="line">call runInThread! id: 4</span><br><span class="line">call runInThread! id: 3</span><br></pre></td></tr></tbody></table></figure><h4 id="bind1st-与-bind2nd-基础使用"><a href="#bind1st-与-bind2nd-基础使用" class="headerlink" title="bind1st 与 bind2nd 基础使用"></a><code>bind1st</code> 与 <code>bind2nd</code> 基础使用</h4><p>这里主要演示如何使用旧版 C++ 提供的 <code>bind1st</code> 与 <code>bind2nd</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showContainer</span><span class="params">(Container &amp;con)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历容器并打印元素</span></span><br><span class="line">    <span class="keyword">typename</span> Container::iterator it = con.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; it != con.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序，greater 是二元函数对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 70 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind1st 绑定 greater 的第一个参数，使其始终为 70，让 greater(70, x) 变成一元函数对象，等价于 f(x) = (70 &gt; x)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind2nd 绑定 less 的第二个参数，使其始终为 70，让 less(x, 70) 变成一元函数对象，等价于 f(x) = (x &lt; 70)</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator it = find_if(vec.begin(), vec.end(), bind2nd(less&lt;int&gt;(), 70));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 70 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"================================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">20 67 35 49 100 43 28 63 71 46 </span><br><span class="line">20 28 35 43 46 49 63 67 71 100 </span><br><span class="line">100 71 67 63 49 46 43 35 28 20 </span><br><span class="line">================================</span><br><span class="line">76 88 70 53 82 84 42 38 91 64 </span><br><span class="line">91 88 84 82 76 70 64 53 42 38 </span><br><span class="line">找到小于 70 的第一个元素：64</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 C++ 11 及更新版本中，<code>bind1st</code> 和 <code>bind2nd</code> 已被 <code>bind</code> 取代，示例代码如下：</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 3 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind 绑定 greater 的第一个参数，等价于 f(x) = (3 &gt; x)</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>)&gt; predicate = <span class="built_in">bind</span>(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">3</span>, placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind 绑定 less 的第二个参数，等价于 f(x) = (x &lt; 3)</span></span><br><span class="line">    <span class="comment">// function&lt;bool(int)&gt; predicate = bind(less&lt;int&gt;(), placeholders::_1, 3);</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), predicate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 3 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 3 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 C++ 11 及更新版本中，可以使用 Lambda 表达式（更现代的 C++ 方式）来实现，示例代码如下：</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 3 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x) { <span class="keyword">return</span> x &lt; <span class="number">3</span>; });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 3 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 3 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><h4 id="bind1st-与-bind2nd-底层原理"><a href="#bind1st-与-bind2nd-底层原理" class="headerlink" title="bind1st 与 bind2nd 底层原理"></a><code>bind1st</code> 与 <code>bind2nd</code> 底层原理</h4><h5 id="模拟实现-bind1st-的功能"><a href="#模拟实现-bind1st-的功能" class="headerlink" title="模拟实现 bind1st 的功能"></a>模拟实现 bind1st 的功能</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象（一元函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">my_bind1st</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，比如：my_bind1st(greater&lt;int&gt;(), 5)</span></span><br><span class="line">    _my_bind1st(Compare comp, <span class="keyword">const</span> T &amp;first) : _comp(comp), _first(first) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;second)</span> </span>{</span><br><span class="line">        <span class="comment">// 底层调用的仍然是二元（两个参数）函数对象</span></span><br><span class="line">        <span class="keyword">return</span> _comp(_first, second);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _comp;</span><br><span class="line">    T _first;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定器（模拟 bind1st 的实现）</span></span><br><span class="line"><span class="comment">// 绑定二元（两个参数）函数对象的第一个参数，生成一个新的一元函数对象，该函数对象接收原函数的第二个参数作为输入</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_my_bind1st&lt;Compare, T&gt; <span class="title">my_bind1st</span><span class="params">(Compare comp, <span class="keyword">const</span> T &amp;first)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> _my_bind1st&lt;Compare, T&gt;(comp, first);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*first)) {</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">9</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 5 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 my_bind1st 绑定 greater 的第一个参数，使其始终为 5，让 greater(5, x) 变成一元函数对象，等价于 f(x) = (5 &gt; x)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">my_bind1st</span>(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 5 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 5 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><h5 id="模拟实现-bind2nd-的功能"><a href="#模拟实现-bind2nd-的功能" class="headerlink" title="模拟实现 bind2nd 的功能"></a>模拟实现 bind2nd 的功能</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象（一元函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">my_bind2nd</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，比如：my_bind2nd(less&lt;int&gt;(), 5)</span></span><br><span class="line">    _my_bind2nd(Compare comp, <span class="keyword">const</span> T &amp;second) : _comp(comp), _second(second) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;first)</span> </span>{</span><br><span class="line">        <span class="comment">// 底层调用的仍然是二元（两个参数）函数对象</span></span><br><span class="line">        <span class="keyword">return</span> _comp(first, _second);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _comp;</span><br><span class="line">    T _second;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定器（模拟 bind2nd 的实现）</span></span><br><span class="line"><span class="comment">// 绑定二元（两个参数）函数对象的第二个参数，生成一个新的一元函数对象，该函数对象接收原函数的第一个参数作为输入</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_my_bind2nd&lt;Compare, T&gt; <span class="title">my_bind2nd</span><span class="params">(Compare comp, <span class="keyword">const</span> T &amp;second)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> _my_bind2nd&lt;Compare, T&gt;(comp, second);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*first)) {</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">9</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 5 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 my_bind2nd 绑定 less 的第二个参数，使其始终为 5，让 less(x, 5) 变成一元函数对象，等价于 f(x) = (x &lt; 5)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">my_bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 5 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 5 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的-Lambda-表达式"><a href="#C-11-的-Lambda-表达式" class="headerlink" title="C++ 11 的 Lambda 表达式"></a>C++ 11 的 Lambda 表达式</h2><h3 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>C++ 11 的 Lambda 表达式（Lambda Expressions）是一种用于定义匿名函数对象的简洁语法，使得代码更加简洁、灵活。其强大的变量捕获、类型推导和灵活性，使其在现代 C++ 开发中被广泛使用。</p><ul><li><p>Lambda 表达式的语法</p><ul><li><code>[capture](parameter_list) -&gt; return_type {function_body}</code>，即 <code>[捕获外部变量](形参列表) -&gt; 返回类型 {操作代码}</code></li><li><code>capture</code>（捕获列表）：定义 Lambda 访问外部变量的方式（比如：按值或按引用）。<ul><li><code>[]</code>：表示不捕获任何外部变量</li><li><code>[this]</code>：表示捕获外部的 <code>this</code> 指针。</li><li><code>[=]</code>：表示以传值的方式捕获外部的所有变量。</li><li><code>[&amp;]</code>：表示以传引用的方式捕获外部的所有变量。</li><li><code>[=, &amp;a]</code>：表示以传值的方式捕获外部的所有变量，但是 <code>a</code> 变量以传引用的方式捕获。</li><li><code>[a, b]</code>：表示以传值的方式捕获外部的 <code>a</code> 和 <code>b</code> 变量。</li><li><code>[a, &amp;b]</code>：表示以传值的方式捕获外部的 <code>a</code> 变量，以传引用的方式捕获外部的 <code>b</code> 变量。</li></ul></li><li><code>parameter_list</code>（形参列表）：类似普通函数的参数。</li><li><code>return_type</code>（返回类型）：可省略，通常编译器可自动推导。</li><li><code>function_body</code>（函数体）：Lambda 实现的具体逻辑。</li></ul></li><li><p>Lambda 表达式的适用场景</p><ul><li>STL 算法的回调（如 <code>std::for_each</code>）</li><li>多线程编程（如 <code>std::thread</code>）</li><li>回调函数（如事件处理）</li><li>临时函数对象（避免定义冗长的 <code>struct</code>）</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Lambda 表达式的本质</p><p>C++ Lambda 表达式的本质是匿名的函数对象（Functor），即 没有名字的类的实例。C++ 编译器在编译 Lambda 时，会自动生成一个匿名类，并在其中重载 operator () 函数，从而使其行为类似于函数。值得一提的是，C++ Lambda 不是单纯的 “匿名函数”，而是一个匿名类的实例，即匿名的函数对象。</p></div><h3 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="Lambda-的核心特性"><a href="#Lambda-的核心特性" class="headerlink" title="Lambda 的核心特性"></a>Lambda 的核心特性</h4><ul><li>变量捕获（按值或按引用）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda1 = [x, &amp;y]() -&gt; <span class="keyword">void</span> { y = x + y; }; <span class="comment">// x 按值捕获，y 按引用捕获</span></span><br><span class="line"><span class="built_in">lambda1</span>();</span><br><span class="line">cout &lt;&lt; y;  <span class="comment">// 输出 30</span></span><br></pre></td></tr></tbody></table></figure><ul><li>省略返回类型 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);  <span class="comment">// 输出 8</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>mutable</code> 关键字修改按值捕获的变量 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> modify = [a]() <span class="keyword">mutable</span> -&gt; <span class="keyword">int</span> { a *= <span class="number">2</span>; <span class="keyword">return</span> a; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">modify</span>() &lt;&lt; endl; <span class="comment">// 输出 10</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 原变量 a 仍然是 5</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>function</code> 进行存储 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 输出 5</span></span><br></pre></td></tr></tbody></table></figure><ul><li>作为 STL 算法的回调 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">void</span> { cout &lt;&lt; item * <span class="number">2</span> &lt;&lt; <span class="string">" "</span>; }); <span class="comment">// 输出 2 4 6 8 10</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>若希望在 Lambda 表达式中不指定返回类型，那么可以省略 <code>-&gt; return_type</code>，比如：<code>auto add = [](int a, int b) { return a + b; };</code></p></div><h4 id="Lambda-的基础使用"><a href="#Lambda-的基础使用" class="headerlink" title="Lambda 的基础使用"></a>Lambda 的基础使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印容器</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">void</span> { cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>; });</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> { <span class="keyword">return</span> a &gt; b; });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印容器</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">void</span> { cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>; });</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 5 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">bool</span> { <span class="keyword">return</span> item &lt; <span class="number">50</span>; });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者简写</span></span><br><span class="line">    <span class="comment">// auto it = find_if(vec.begin(), vec.end(), [](int item) { return item &lt; 50; });</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 50 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">91 18 37 28 55 86 50 47 66 52 </span><br><span class="line">91 86 66 55 52 50 47 37 28 18 </span><br><span class="line">找到小于 50 的第一个元素：47</span><br></pre></td></tr></tbody></table></figure><h4 id="Lambda-的应用实践"><a href="#Lambda-的应用实践" class="headerlink" title="Lambda 的应用实践"></a>Lambda 的应用实践</h4><p>这里主要介绍 Lambda 表达式的各种应用实战场景。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : _a(a), _b(b) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用 function 存储 Lambda 表达式</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    map[<span class="number">0</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">    map[<span class="number">1</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a - b; };</span><br><span class="line">    map[<span class="number">2</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a * b; };</span><br><span class="line">    map[<span class="number">3</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a / b; };</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"30 + 15 = "</span> &lt;&lt; map[<span class="number">0</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"30 - 15 = "</span> &lt;&lt; map[<span class="number">1</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"30 * 15 = "</span> &lt;&lt; map[<span class="number">2</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"30 / 15 = "</span> &lt;&lt; map[<span class="number">3</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 智能指针自定义删除器</span></span><br><span class="line">    unique_ptr&lt;FILE, function&lt;<span class="built_in"><span class="keyword">void</span></span>(FILE *)&gt;&gt; <span class="built_in">ptr1</span>(<span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>), [](FILE *p) -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="built_in">fclose</span>(p);</span><br><span class="line">        cout &lt;&lt; <span class="string">"Closed File"</span> &lt;&lt; endl;</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 优先级队列自定义元素排序规则</span></span><br><span class="line">    <span class="keyword">using</span> FUNC = function&lt;<span class="built_in"><span class="keyword">bool</span></span>(Data &amp;, Data &amp;)&gt;;</span><br><span class="line">    priority_queue&lt;Data, vector&lt;Data&gt;, FUNC&gt; <span class="built_in">queue</span>([](Data &amp;data1, Data &amp;data2) {</span><br><span class="line">        <span class="keyword">return</span> data1.<span class="built_in">getA</span>() &lt; data2.<span class="built_in">getA</span>();</span><br><span class="line">    });</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">18</span>, <span class="number">25</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">15</span>, <span class="number">23</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">19</span>, <span class="number">28</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) {</span><br><span class="line">        Data data = queue.<span class="built_in">top</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; data.<span class="built_in">getA</span>() &lt;&lt; <span class="string">", b = "</span> &lt;&lt; data.<span class="built_in">getB</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">30 + 15 = 45</span><br><span class="line">30 - 15 = 15</span><br><span class="line">30 * 15 = 450</span><br><span class="line">30 / 15 = 2</span><br><span class="line">----------------</span><br><span class="line">Closed File</span><br><span class="line">----------------</span><br><span class="line">a = 19, b = 28</span><br><span class="line">a = 18, b = 25</span><br><span class="line">a = 15, b = 23</span><br><span class="line">a = 10, b = 20</span><br><span class="line">----------------</span><br></pre></td></tr></tbody></table></figure><h4 id="Lambda-的底层原理"><a href="#Lambda-的底层原理" class="headerlink" title="Lambda 的底层原理"></a>Lambda 的底层原理</h4><p>C++ Lambda 表达式的本质是匿名的函数对象（Functor），即 没有名字的类的实例。C++ 编译器在编译 Lambda 时，会自动生成一个匿名类，并在其中重载 <code>operator()</code> 函数，从而使其行为类似于函数。值得一提的是，C++ Lambda 不是单纯的 “匿名函数”，而是一个匿名类的实例，即匿名的函数对象。</p><ul><li><p>Lambda 是一个匿名类的实例</p><ul><li>编译器会为 Lambda 生成一个 匿名类，该类重载了 <code>operator()</code> 以实现调用操作。</li><li>这个匿名类的实例（匿名函数对象）即 Lambda 本身。</li></ul></li><li><p>Lambda 具有函数对象的性质</p><ul><li>Lambda 可以像普通函数一样被调用。</li><li>如果 Lambda 捕获了外部变量（如 <code>auto func = [x](int y) -&gt; int { return x + y; };</code>），那么编译器会为该匿名类生成成员变量来存储 <code>x</code>，并在 <code>operator()</code> 函数中使用这些成员变量。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">void</span>&gt;</span><br><span class="line">class MyLambda1 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda1</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T <span class="built_in"><span class="keyword">operator</span></span>()() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> func1 = []() -&gt; <span class="keyword">void</span> { cout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl; };</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    MyLambda1&lt;&gt; t1;</span><br><span class="line">    <span class="built_in">t1</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLambda2</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda2</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> fun2 = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun2</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    MyLambda2&lt;<span class="keyword">int</span>&gt; t2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">t2</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">void</span>&gt;</span><br><span class="line">class MyLambda3 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : _a(a), _b(b) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="built_in"><span class="keyword">operator</span></span>()() <span class="keyword">const</span> {</span><br><span class="line">        <span class="comment">// 交换两个变量的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = _a;</span><br><span class="line">        _a = _b;</span><br><span class="line">        _b = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值传递，并没有真正交换两个变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> func3 = [a, b]() <span class="keyword">mutable</span> -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">func3</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    <span class="function">MyLambda3&lt;<span class="keyword">int</span>&gt; <span class="title">t3</span><span class="params">(a, b)</span></span>;    <span class="comment">// 按值传递，并没有真正交换两个变量的值</span></span><br><span class="line">    <span class="built_in">t3</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">void</span>&gt;</span><br><span class="line">class MyLambda4 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda4</span>(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b) : _a(a), _b(b) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="built_in"><span class="keyword">operator</span></span>()() <span class="keyword">const</span> {</span><br><span class="line">        <span class="comment">// 交换两个变量的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = _a;</span><br><span class="line">        _a = _b;</span><br><span class="line">        _b = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> &amp;_a;</span><br><span class="line">    <span class="keyword">int</span> &amp;_b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按引用传递，可以真正交换两个变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> func4 = [&amp;a, &amp;b]() <span class="keyword">mutable</span> -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">func4</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    <span class="function">MyLambda4&lt;<span class="keyword">int</span>&gt; <span class="title">t4</span><span class="params">(a, b)</span></span>;    <span class="comment">// 按引用传递，可以真正交换两个变量的值</span></span><br><span class="line">    <span class="built_in">t4</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">----------------</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">----------------</span><br><span class="line">a = 10, b = 30</span><br><span class="line">a = 10, b = 30</span><br><span class="line">----------------</span><br><span class="line">a = 30, b = 10</span><br><span class="line">a = 10, b = 30</span><br><span class="line">----------------</span><br></pre></td></tr></tbody></table></figure><blockquote><p>验证 Lambda 表达式是函数对象</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> lambda = [](<span class="keyword">int</span> x) { <span class="keyword">return</span> x * <span class="number">2</span>; };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 是一个匿名类的实例</span></span><br><span class="line">    cout &lt;&lt; std::boolalpha;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Lambda 是对象吗？ "</span> &lt;&lt; boolalpha &lt;&lt; is_object&lt;<span class="keyword">decltype</span>(lambda)&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 具有 operator() 函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Lambda(5) = "</span> &lt;&lt; <span class="built_in">lambda</span>(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lambda 是对象吗？ true</span><br><span class="line">Lambda(5) = 10</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固进阶之二</title>
    <link href="https://www.techgrow.cn/posts/2288a106.html"/>
    <id>https://www.techgrow.cn/posts/2288a106.html</id>
    <published>2025-02-19T13:55:33.000Z</published>
    <updated>2025-02-19T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-11-的核心特性"><a href="#C-11-的核心特性" class="headerlink" title="C++ 11 的核心特性"></a>C++ 11 的核心特性</h2><ul><li><p>关键字和语法</p><ul><li><code>auto</code>：可以根据右值推导出右值的类型，然后左边变量的类型就可以知道了。</li><li><code>nullptr</code>：空指针，给指针专用（能够和整数进行区别）。</li><li><code>foreach</code>：通过 <code>for (int num : arr) { }</code> 语法可以遍历数组、容器等。</li><li>右值引用（<code>T &amp;&amp;</code>），还有 <code>move()</code> 移动语义函数和 <code>forward()</code> 完美转发函数。</li><li>模板新特性：<code>type... A</code> 表示可变参数模板。</li></ul></li><li><p>绑定器和函数对象</p><ul><li><code>function</code>：函数类模板，用于存储任何可以调用的目标（如普通函数、函数指针、函数对象、Lambda 表达式等），并通过统一的接口进行调用。</li><li><code>bind</code>：绑定器，用于创建可调用对象，可以将函数与部分参数进行绑定，并返回一个新的可调用对象，方便后续调用。</li><li>Lambda 表达式：用于定义匿名函数对象的简洁语法，拥有强大的变量捕获、类型推导和灵活性，可以使得代码更加简洁、灵活。</li></ul></li><li><p>智能指针</p><ul><li><code>shared_ptr</code>：带引用计数的智能指针，允许多个指针共享同一资源。</li><li><code>weak_ptr</code>：通常用于避免 <code>shared_ptr</code> 智能指针之间的循环引用问题。</li></ul></li><li><p>容器</p><ul><li><code>array</code>：一个固定大小的数组封装，比原生 C 语言数组更安全，支持 STL 的特性，如迭代器、<code>size()</code> 等。</li><li><code>unordered_map</code>：基于哈希表的键值对存储，比 <code>map（基于红黑树）</code> 的查找速度更快，平均时间复杂度是 <code>O(1)</code>。</li><li><code>unordered_set</code>：基于哈希表的集合，插入、查找速度更快。</li><li><code>forward_list</code>：单向链表，比 <code>list（基于双向链表）</code> 更节省内存。</li></ul></li></ul><h2 id="C-11-的右值引用"><a href="#C-11-的右值引用" class="headerlink" title="C++ 11 的右值引用"></a>C++ 11 的右值引用</h2><h3 id="重现模拟实现字符串类的问题"><a href="#重现模拟实现字符串类的问题" class="headerlink" title="重现模拟实现字符串类的问题"></a>重现模拟实现字符串类的问题</h3><p>下述代码模拟实现了 C++ 中的 <code>string</code> 类，但是 <code>main()</code> 函数调用 <code>getString()</code> 函数的效率会非常低。第一个原因是，<code>getString()</code> 函数在调用结束时，返回了一个 MyString 对象，这会调用一次拷贝构造函数来拷贝 <code>tmpStr</code> 对象。第二个原因是，在 <code>main()</code> 函数中，将 <code>getStriing()</code> 函数的返回值赋值了给 <code>str2</code> 对象，这会调用赋值运算符重载函数，也就是又拷贝了一次数据。<a href="../../../asset/2025/02/cxx-custom-string-1.png">点击</a> 查看完整分析图解。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">getString</span><span class="params">(MyString &amp;str)</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tmpStr</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"aaaaaaa"</span>)</span></span>;</span><br><span class="line">    MyString str2;</span><br><span class="line">    str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">    cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str1 对象</span><br><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str2 对象</span><br><span class="line">MyString(const char *p = nullptr)       // getString() 函数中构造 tmpStr 对象</span><br><span class="line">MyString(const MyString &amp;str)           // getString() 函数返回执行结果值时，调用拷贝构造函数来拷贝 tmpStr 对象给 main() 函数栈帧上的临时对象</span><br><span class="line">~MyString()                             // 析构 getString() 函数中的 tmpStr 对象</span><br><span class="line">operator=(const MyString &amp;str)          // main() 函数中，执行赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数栈帧上的临时对象，临时对象的生存周期是所在语句</span><br><span class="line">aaaaaaa             </span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str1 对象</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">operator=(const MyString &amp;str)</span><br><span class="line">~MyString()</span><br><span class="line">aaaaaaa</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="解决模拟实现字符串类的问题"><a href="#解决模拟实现字符串类的问题" class="headerlink" title="解决模拟实现字符串类的问题"></a>解决模拟实现字符串类的问题</h3><p>为了解决上述模拟实现字符串类时，多次拷贝内存数据导致运行效率低的问题，可以使用带右值引用参数的拷贝构造函数和赋值运算符重载函数来解决。</p><h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h4><h5 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h5><ul><li><p>左值引用与右值引用的介绍</p><ul><li><code>左值</code>：有名称、有内存</li><li><code>右值</code>：没名称（临时量）、没内存</li></ul></li><li><p>左值引用与右值引用的区别</p><ul><li>左值引用和右值引用的主要区别在于它们可以绑定的值类别，左值引用只能绑定到左值，而右值引用只能绑定到右值。</li><li>右值引用引入了 <code>move</code> 移动语义，使得 C++ 可以更高效地处理临时对象。</li><li>在泛型编程中，可以通过函数模板的类型推导来同时处理左值引用和右值引用，从而实现参数的 <code>forward</code> 完美转发。</li></ul></li></ul><h5 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ......(省略)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;        <span class="comment">// 左值：有名称、有内存，右值：没名称（临时量）、没内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp; b = a;        <span class="comment">// 可以将左值绑定到左值引用上</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; c = a;    // 无法将左值绑定到右值引用上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; d = <span class="number">20</span>;      <span class="comment">// 可以将右值绑定到右值引用上</span></span><br><span class="line">    <span class="comment">// int&amp; c = 20;    // 无法将右值绑定到左值引用上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int&amp;&amp; f = d;    // 无法将左值绑定到右值引用上，因为右值引用变量本身就是左值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyString&amp; s = MyString("aaa");   // 错误写法</span></span><br><span class="line">    MyString&amp;&amp; s = <span class="built_in">MyString</span>(<span class="string">"aaa"</span>);     <span class="comment">// 正确写法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用右值引用解决问题"><a href="#使用右值引用解决问题" class="headerlink" title="使用右值引用解决问题"></a>使用右值引用解决问题</h4><div class="admonition note"><p class="admonition-title">提示</p><ul><li>(1) 右值引用参数常用于减少内存数据的拷贝，比如在带右值引用参数的拷贝构造函数和赋值运算符重载函数中使用。</li><li>(2) 在带右值引用参数的拷贝构造函数和赋值运算符重载函数中，该右值引用参数接收的都是临时对象。</li></ul></div><h5 id="案例代码-1"><a href="#案例代码-1" class="headerlink" title="案例代码"></a>案例代码</h5><p>这里使用带右值引用参数的拷贝构造函数和赋值运算符重载函数，来解决在模拟实现 C++ 字符串类时，多次拷贝内存数据导致运行效率低的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">getString</span><span class="params">(MyString&amp; str)</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tmpStr</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码一"><a href="#测试代码一" class="headerlink" title="测试代码一"></a>测试代码一</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"aaaaaaa"</span>)</span></span>;</span><br><span class="line">    MyString str2;</span><br><span class="line">    str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">    cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str1 对象</span><br><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str2 对象</span><br><span class="line">MyString(const char *p = nullptr)       // getString() 函数中构造 tmpStr 对象</span><br><span class="line">MyString(MyString&amp;&amp; str)                // getString() 函数返回执行结果值时，调用带右值引用参数的拷贝构造函数来拷贝 tmpStr 对象给 main() 函数栈帧上的临时对象（使用浅拷贝提高运行效率）</span><br><span class="line">~MyString()                             // 析构 getString() 函数中的 tmpStr 对象</span><br><span class="line">operator=(MyString&amp;&amp; str)               // main() 函数中，执行带右值引用参数的赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 str2 对象（使用浅拷贝提高运行效率）</span><br><span class="line">~MyString()                             // 析构 main() 函数栈帧上的临时对象</span><br><span class="line">aaaaaaa             </span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str1 对象</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">================ test01() ================</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">operator=(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">aaaaaaa</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码二"><a href="#测试代码二" class="headerlink" title="测试代码二"></a>测试代码二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"Hello "</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">str2</span><span class="params">(<span class="string">"World!"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    MyString str3 = str1 + str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">---------------------------------</span><br><span class="line">Hello World!</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">Hello World!</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码三"><a href="#测试代码三" class="headerlink" title="测试代码三"></a>测试代码三</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    MyString str1 = <span class="string">"aaa"</span>;</span><br><span class="line">    vector&lt;MyString&gt; v1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(str1); <span class="comment">// 调用的是带左值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是带右值引用参数的拷贝构造函数 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 中，无论是 Debug 模式，还是 Release 模式，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">----------------------------------</span><br><span class="line">MyString(const MyString &amp;str)</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的移动语义与完美转发"><a href="#C-11-的移动语义与完美转发" class="headerlink" title="C++ 11 的移动语义与完美转发"></a>C++ 11 的移动语义与完美转发</h2><h3 id="基础案例代码"><a href="#基础案例代码" class="headerlink" title="基础案例代码"></a>基础案例代码</h3><h4 id="自定义字符串类"><a href="#自定义字符串类" class="headerlink" title="自定义字符串类"></a>自定义字符串类</h4><p>自定义一个 MyString 字符串类，模拟实现　C++ 的 <code>string</code> 字符串类，主要使用带右值引用参数的拷贝构造函数和赋值运算符重载函数来减少内存数据的拷贝次数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义-Vector-容器类"><a href="#自定义-Vector-容器类" class="headerlink" title="自定义 Vector 容器类"></a>自定义 Vector 容器类</h4><p>自定义一个 Vector 容器类，模拟实现　C++ 的 <code>vector</code> 容器，主要实现了 <code>vector</code>　容器的空间分配器、迭代器。值得一提的是，由于篇幅有限，这里虽然解决迭代器失效的问题，但是并没有解决容器扩容（执行插入操作）后导致迭代器失效的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt; *pvec = <span class="literal">nullptr</span>, T *p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base *itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt; *_pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T *p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T *p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator *cur = <span class="literal">nullptr</span>, Iterator_Base *next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator *_cur;</span><br><span class="line">        Iterator_Base *_next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T *start, T *end)</span> </span>{</span><br><span class="line">        Iterator_Base *cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base *next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义-Vector-类存在的问题"><a href="#自定义-Vector-类存在的问题" class="headerlink" title="自定义 Vector 类存在的问题"></a>自定义 Vector 类存在的问题</h4><p>使用上面自定义的 Vecotr 容器类执行以下测试代码后，发现执行 <code>vector.push_back(MyString("bbb"));</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，这会导致多拷贝一份内存数据，从而影响程序的执行效率。值得一提的是，这里希望调用的是 MyString 类带右值引用参数的拷贝构造函数，因为该带右值引用参数的拷贝构造函数使用的是浅拷贝，可以减少内存数据的拷贝次数。至于具体的解决方案，可以使用下面介绍的 C++ 移动语义（<code>move</code>）来实现。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const MyString &amp;str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="move-移动语义"><a href="#move-移动语义" class="headerlink" title="move 移动语义"></a>move 移动语义</h3><h4 id="move-移动语义的概念"><a href="#move-移动语义的概念" class="headerlink" title="move 移动语义的概念"></a>move 移动语义的概念</h4><p>C++ 中的移动语义是引入于 C++ 11 的一种特性，它通过引入移动构造函数和移动赋值运算符，允许程序以更高效的方式管理资源，尤其是在避免不必要的拷贝操作时。移动语义的核心是利用右值引用（<code>T&amp;&amp;</code>）和标准库中的 <code>std::move</code>，使对象的资源从一个对象转移到另一个对象（比如将左值类型强转为右值类型），而不是拷贝，从而提高程序性能。</p><ul><li><p>移动语义的主要作用</p><ul><li>高效资源转移：避免资源分配和释放的重复工作。</li><li>减少拷贝：通过转移所有权来减少对象的拷贝。</li><li>提高程序性能：尤其适用于内存密集型和资源管理复杂的程序。</li></ul></li><li><p>移动语义的使用场景</p><ul><li>减少临时对象的开销（如函数返回大对象）。</li><li>避免深拷贝（如容器中的数据转移）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="https://blog.csdn.net/chenmi123321/article/details/144334601">C++ 的 移动语义 move</a></li><li><a href="https://zhuanlan.zhihu.com/p/602543410">理解现代 C++ 中的移动语义</a></li></ul></div><h4 id="move-移动语义的使用"><a href="#move-移动语义的使用" class="headerlink" title="move 移动语义的使用"></a>move 移动语义的使用</h4><p>在<a href="/posts/e302ad63.html#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E5%AE%B9%E5%99%A8%E7%B1%BB">上面</a>自定义的 Vector 容器类中，为了解决执行 <code>vector.push_back(MyString("bbb"))</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，从而导致多拷贝一份内存数据的问题，可以使用 C++ 中的 <code>move</code> 移动语义来解决。</p><ul><li>更改的核心代码<ul><li>重载 <code>Allocator::construct()</code> 函数，分别用于接收左值引用参数和右值引用参数，并使用 <code>move</code> 移动语义将左值类型强转为右值类型</li><li>重载 <code>Vector::push_back()</code> 函数，分别用于接收左值引用参数和右值引用参数，并使用 <code>move</code> 移动语义将左值类型强转为右值类型 </li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收左值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收右值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, T&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="comment">// move 是移动语义，可以将左值类型强转为右值类型</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(<span class="built_in">move</span>(val));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收左值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收右值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="comment">// move 是移动语义，可以将左值类型强转为右值类型</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, <span class="built_in">move</span>(val));</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt;* pvec = <span class="literal">nullptr</span>, T* p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base* itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* _ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt;* _pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T* p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T* p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T* _last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* cur = <span class="literal">nullptr</span>, Iterator_Base* next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T* _ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* start, T* end)</span> </span>{</span><br><span class="line">        Iterator_Base* cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base* next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="forward-完美转发"><a href="#forward-完美转发" class="headerlink" title="forward 完美转发"></a>forward 完美转发</h3><p>虽然使用 C++ 11 提供的 <code>move</code> 移动语义，可以解决在执行 <code>vector.push_back(MyString("bbb"));</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，从而导致多拷贝一份内存数据的问题。但是，这样每次都需要定义两个重载函数来分别接收左值引用参数和右值引用参数，这就显得比较繁琐。为了使 C++ 代码更简洁，可以使用 C++ 11 提供的 <code>forward</code> 完美转发来实现同样的功能。</p><h4 id="forward-完美转发的概念"><a href="#forward-完美转发的概念" class="headerlink" title="forward 完美转发的概念"></a>forward 完美转发的概念</h4><p>完美转发（Perfect Forwarding）是 C++ 11 中引入的一种编程技巧，其目的是在编写泛型函数时能够保留参数的类型和值类别（左值或右值），从而实现更为高效且准确地传递参数。通过使用右值引用和模板类型推导，完美转发允许在函数中以原始参数的形式将参数传递给其他函数，而不会发生不必要的拷贝操作，从而提高性能。完美转发在很多场合都非常有用，尤其是在设计泛型库和需要高效参数传递的场景。以下是一些常见的完美转发应用场景：</p><ul><li>(1) 委托构造函数：完美转发可以在构造函数之间传递参数，避免不必要的拷贝操作，从而提高性能。</li><li>(2) 可变参数模板函数：完美转发可以用于实现可接受任意数量和类型参数的函数，如实现一个通用的元组或 <code>bind()</code> 函数。</li><li>(3) 智能指针：完美转发在智能指针的实现中也有重要作用，例如 <code>unique_ptr</code> 和 <code>shared_ptr</code> 中的构造函数和 <code>make()</code> 函数等。</li><li>(4) 函数包装器：完美转发可以用于实现函数包装器，使包装后的函数能够正确处理所有类型的参数，包括右值引用。例如 <code>function</code> 的实现。</li><li>(5) 资源管理类：通过完美转发，可以使资源管理类（如锁管理类、线程池等）能够更方便地处理各种资源。</li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="https://blog.csdn.net/haokan123456789/article/details/134980411">C++ 之 forward 完美转发</a></li><li><a href="https://www.cnblogs.com/5iedu/p/11324772.html">C++ 的 forward 完美转发</a></li><li><a href="https://zhuanlan.zhihu.com/p/710953400">深度解析 C++ 完美转发的实现原理与应用</a></li></ul></div><h4 id="forward-完美转发的使用"><a href="#forward-完美转发的使用" class="headerlink" title="forward 完美转发的使用"></a>forward 完美转发的使用</h4><ul><li>在<a href="/posts/e302ad63.html#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E5%AE%B9%E5%99%A8%E7%B1%BB">上面</a>自定义的 Vector 容器类中，更改以下地方：<ul><li>更改 <code>Allocator::construct()</code> 函数，接收右值引用参数，并使用函数模板的类型推导 + 引用折叠 + <code>forward</code> 完美转发来识别左值类型和右值类型。</li><li>重载 <code>Vector::push_back()</code> 函数，接收右值引用参数，并使用函数模板的类型推导 + 引用折叠 + <code>forward</code> 完美转发来识别左值类型和右值类型。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收右值引用参数）</span></span><br><span class="line">    <span class="comment">// 基于函数模板的类型推导 + 引用折叠</span></span><br><span class="line">    <span class="comment">// T &amp; + Ty &amp;&amp;  = T &amp;</span></span><br><span class="line">    <span class="comment">// T &amp;&amp; + Ty &amp;&amp;  = T &amp;&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, Ty&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="comment">// forward 是完美转发，可以识别左值类型和右值类型</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(forward&lt;Ty&gt;(val));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收右值引用参数）</span></span><br><span class="line">    <span class="comment">// 基于函数模板的类型推导 + 引用折叠</span></span><br><span class="line">    <span class="comment">// T &amp; + Ty &amp;&amp;  = T &amp;</span></span><br><span class="line">    <span class="comment">// T &amp;&amp; + Ty &amp;&amp;  = T &amp;&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="comment">// forward 是完美转发，可以识别左值类型和右值类型</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, forward&lt;Ty&gt;(val));</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt;* pvec = <span class="literal">nullptr</span>, T* p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base* itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* _ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt;* _pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T* p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T* p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T* _last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* cur = <span class="literal">nullptr</span>, Iterator_Base* next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T* _ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* start, T* end)</span> </span>{</span><br><span class="line">        Iterator_Base* cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base* next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Debian 12 安装 Docker 与 Docker-Compose</title>
    <link href="https://www.techgrow.cn/posts/a19ep68d.html"/>
    <id>https://www.techgrow.cn/posts/a19ep68d.html</id>
    <published>2025-02-11T13:18:02.000Z</published>
    <updated>2025-02-11T13:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://www.docker.com/">Docker 官网</a></li><li><a href="https://hub.docker.com/">Docker Hub 官网</a></li><li><a href="https://docs.docker.com/">Docker 官方文档</a></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="卸载已有软件"><a href="#卸载已有软件" class="headerlink" title="卸载已有软件"></a>卸载已有软件</h3><p>卸载已安装的 Docker，避免对后续的安装步骤产生影响。</p><span id="more"></span><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载旧版本，包括有关的配置文件</span></span><br><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保证卸载干净</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">sudo rm -rf /etc/docker</span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /usr/libexec/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br><span class="line">sudo rm -rf /etc/apt/keyrings</span><br></pre></td></tr></tbody></table></figure><h3 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></tbody></table></figure><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><h3 id="添加存储库"><a href="#添加存储库" class="headerlink" title="添加存储库"></a>添加存储库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥</span></span><br><span class="line">sudo curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Docker 的 APT 存储库</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian <span class="subst">$(lsb_release -cs)</span> stable"</span> | tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 APT 索引</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></tbody></table></figure><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装最新版本的 Docker</span></span><br><span class="line">sudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>Docker Buildx 是 Docker 官方推出的一款增强型构建工具，旨在简化和优化多架构容器映像的构建流程。它整合了 QEMU 模拟器和多平台构建能力，使得开发者可以在单一的构建过程中同时为多个平台（如 x86、ARM 等）构建容器映像，极大地提高了构建效率和开发体验。</p></div><h3 id="Docker-启动"><a href="#Docker-启动" class="headerlink" title="Docker 启动"></a>Docker 启动</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启动 Docker</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Docker 的运行状态</span></span><br><span class="line">sudo systemctl status docker</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">普通用户使用 Docker 命令</p><p>如果希望让非 <code>root</code> 用户也能使用 Docker 命令，可以将该用户添加到 <code>docker</code> 用户组，比如 <code>sudo usermod -aG docker your-user-name</code>。</p></div><h3 id="Docker-配置源"><a href="#Docker-配置源" class="headerlink" title="Docker 配置源"></a>Docker 配置源</h3><p>由于 Docker Hub 存在不可抗拒因素，导致在国内无法访问，因此需要配置 Docker 使用国内镜像源。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建配置目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">{</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">     <span class="string">"https://ustc-edu-cn.mirror.aliyuncs.com"</span>,</span><br><span class="line">     <span class="string">"https://mirror.iscas.ac.cn"</span>,</span><br><span class="line">     <span class="string">"https://docker.nju.edu.cn"</span>,</span><br><span class="line">     <span class="string">"https://docker.m.daocloud.io"</span>,</span><br><span class="line">     <span class="string">"https://ccr.ccs.tencentyun.com"</span>,</span><br><span class="line">     <span class="string">"https://dockerhub.timeweb.cloud"</span></span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使配置文件生效</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 Docker</span></span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Docker 的运行状态</span></span><br><span class="line">sudo systemctl status docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Docker 的运行信息</span></span><br><span class="line">sudo docker info</span><br></pre></td></tr></tbody></table></figure><h3 id="Docker-验证安裝"><a href="#Docker-验证安裝" class="headerlink" title="Docker 验证安裝"></a>Docker 验证安裝</h3><p>验证是否正确安装了 Docker，以下命令将下载一个测试镜像并在容器中运行它，容器在运行时将输出一条参考消息并退出</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></tbody></table></figure><h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker-Compose"></a>安装 Docker-Compose</h2><div class="admonition note"><p class="admonition-title">提示</p><p>推荐使用第二种方式（基于 <code>curl</code> 命令）进行安装，因为可以指定具体安装哪个版本的 Docker-Compose，而且后期升级维护也更方便。</p></div><h3 id="第一种安装方式"><a href="#第一种安装方式" class="headerlink" title="第一种安装方式"></a>第一种安装方式</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Docker-Compose 插件</span></span><br><span class="line">sudo apt install -y docker-compose-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 Docker-Compose 插件</span></span><br><span class="line">sudo docker compose version</span><br></pre></td></tr></tbody></table></figure><h3 id="第二种安装方式"><a href="#第二种安装方式" class="headerlink" title="第二种安装方式"></a>第二种安装方式</h3><p>这里除了可以使用 <code>curl</code> 命令来下载 Docker-Compose 的二进制包，还可以在 <a href="https://github.com/docker/compose/releases">GitHub Releases</a> 上面手动下载对应的文件，然后上传到目标服务器。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.29.1/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件授权</span></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证下载</span></span><br><span class="line">sudo docker-compose -v</span><br></pre></td></tr></tbody></table></figure><h2 id="常见安装问题"><a href="#常见安装问题" class="headerlink" title="常见安装问题"></a>常见安装问题</h2><h3 id="info-命令输出警告信息"><a href="#info-命令输出警告信息" class="headerlink" title="info 命令输出警告信息"></a>info 命令输出警告信息</h3><ul><li>问题描述：当 Docker 安装完成之后，执行 <code>docker info</code> 命令，发现有以下警告信息存在：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WARNING: No cpu cfs quota support</span><br><span class="line">WARNING: No cpu cfs period support</span><br><span class="line">WARNING: No cpu shares support</span><br><span class="line">WARNING: No cpuset support</span><br><span class="line">WARNING: No io.weight support</span><br><span class="line">WARNING: No io.weight (per device) support</span><br><span class="line">WARNING: No io.max (rbps) support</span><br><span class="line">WARNING: No io.max (wbps) support</span><br><span class="line">WARNING: No io.max (riops) support</span><br><span class="line">WARNING: No io.max (wiops) support</span><br></pre></td></tr></tbody></table></figure><ul><li>解决办法：重启 Debian 服务器，让系统重新加载 <code>cgroup</code> 规则</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="/posts/57bca56f.html">Docker 介绍与安装</a></li><li><a href="/posts/b31f4d18.html">Docker-Compose 安装与使用</a></li><li><a href="https://blog.csdn.net/weixin_49187218/article/details/136935982">Debian 11 上安装 Docker</a></li><li><a href="https://blog.csdn.net/qq_30818545/article/details/124514016">Debian11 之 Docker 稳定版本安装</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Debian 12 如何安装 Docker 与 Docker-Compose。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固进阶之一</title>
    <link href="https://www.techgrow.cn/posts/e302ad63.html"/>
    <id>https://www.techgrow.cn/posts/e302ad63.html</id>
    <published>2025-02-08T13:55:33.000Z</published>
    <updated>2025-02-08T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-对象深入探索"><a href="#C-对象深入探索" class="headerlink" title="C++ 对象深入探索"></a>C++ 对象深入探索</h2><h3 id="对象的构造与析构"><a href="#对象的构造与析构" class="headerlink" title="对象的构造与析构"></a>对象的构造与析构</h3><h4 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">10</span>) : _a(a) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(int)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;t) : _a(t._a) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = t._a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    Test t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Test t3 = t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `Test t4(30);`</span></span><br><span class="line">    <span class="comment">// Test(30) 通常会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 但是，如果用临时对象去拷贝构造新对象，那么临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化</span></span><br><span class="line">    Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 1 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用赋值运算符重载函数</span></span><br><span class="line">    t4 = t2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// Test(20) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    t4 = <span class="built_in">Test</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 2 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// (Test)20 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t4 = Test(20);`，这里要求 Test 类拥有 int 类型的构造函数</span></span><br><span class="line">    t4 = (Test) <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 3 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// 会隐式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t4 = Test(20);`，这里要求 Test 类拥有 int 类型的构造函数</span></span><br><span class="line">    t4 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 4 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// (Test)20 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 当临时对象出了所在语句，会立刻被析构，同时指针 p 会成为野指针</span></span><br><span class="line">    <span class="comment">// 结论：使用指针变量指向临时对象是不安全的</span></span><br><span class="line">    Test *p = &amp;<span class="built_in">Test</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// (Test)20 会显式生成临时对象，临时对象的生存周期是所在函数</span></span><br><span class="line">    <span class="comment">// 但是，这里的临时对象出了所在语句，不会立刻被析构，而是直到出了函数作用域才会被析构</span></span><br><span class="line">    <span class="comment">// 在函数作用域内，ref 引用会一直有效</span></span><br><span class="line">    <span class="comment">// 结论：使用引用变量指向临时对象是安全的</span></span><br><span class="line">    Test &amp;ref = <span class="built_in">Test</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 1 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--------- 1 ---------</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">Test(int)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test()</span><br><span class="line">--------- 2 ---------</span><br><span class="line">Test(int)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test()</span><br><span class="line">--------- 3 ---------</span><br><span class="line">Test(int)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test()</span><br><span class="line">--------- 4 ---------</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">Test(int)</span><br><span class="line">~Test()</span><br><span class="line">Test(int)</span><br><span class="line">--------- 1 ---------</span><br><span class="line">~Test()</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h4><div class="admonition note"><p class="admonition-title">提示</p><p>在 C++ 中，最先析构的对象，往往都是最后析构的，即符合 "先构造后析构" 的规则（类似栈的 "先进后出"），这规则同样适用于类成员属性的构造和析构。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">5</span>, <span class="keyword">int</span> b = <span class="number">5</span>) : _a(a), _b(b) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test("</span> &lt;&lt; a &lt;&lt; <span class="string">", "</span> &lt;&lt; b &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test("</span> &lt;&lt; <span class="keyword">this</span>-&gt;_a &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="keyword">this</span>-&gt;_b &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;t) : _a(t._a), _b(t._b) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = t._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = t._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Test t3 = t2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 1 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `Test t4(30, 30);`</span></span><br><span class="line">    <span class="comment">// Test(30, 30) 通常会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 但是，如果用临时对象去拷贝构造新对象，那么临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化</span></span><br><span class="line">    <span class="comment">// 这里定义的局部静态变量，只在程序结束的时候才会被析构</span></span><br><span class="line">    <span class="keyword">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 2 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// Test(40, 40) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// (Test)(50, 50) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t2 = Test(50);`，这里要求 Test 类拥有对应的构造函数</span></span><br><span class="line">    t2 = (Test) (<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// 60 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t2 = Test(60);`，这里要求 Test 类拥有对应的构造函数</span></span><br><span class="line">    t2 = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 3 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    Test *p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用（两次）普通构造函数</span></span><br><span class="line">    Test *p2 = <span class="keyword">new</span> Test[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 4 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// Test(80, 80) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 当临时对象出了所在语句，会立刻被析构，同时指针 p 会成为野指针</span></span><br><span class="line">    <span class="comment">// 结论：使用指针变量指向临时对象是不安全的</span></span><br><span class="line">    Test *p3 = &amp;<span class="built_in">Test</span>(<span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// Test(90, 90) 会显式生成临时对象，临时对象的生存周期是所在函数</span></span><br><span class="line">    <span class="comment">// 但是，这里的临时对象出了所在语句，不会立刻被析构，而是直到出了函数作用域才会被析构</span></span><br><span class="line">    <span class="comment">// 在函数作用域内，ref 引用会一直有效</span></span><br><span class="line">    <span class="comment">// 结论：使用引用变量指向临时对象是安全的</span></span><br><span class="line">    Test &amp;p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 5 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用析构函数</span></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用（两次）析构函数</span></span><br><span class="line">    <span class="keyword">delete</span>[] p2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 6 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个执行（t1 是最先构造的，而且又是最后析构）</span></span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个执行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ start main()============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ end main()============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个执行</span></span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Test(10, 10)</span><br><span class="line">Test(100, 100)</span><br><span class="line"></span><br><span class="line">============ start main()============</span><br><span class="line"></span><br><span class="line">============ test01() ============</span><br><span class="line">Test(20, 20)</span><br><span class="line">Test(const Test&amp; t)</span><br><span class="line">--------- 1 ---------</span><br><span class="line">Test(30, 30)</span><br><span class="line">--------- 2 ---------</span><br><span class="line">Test(40, 40)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test(40, 40)</span><br><span class="line">Test(50, 5)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test(50, 5)</span><br><span class="line">Test(60, 5)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test(60, 5)</span><br><span class="line">--------- 3 ---------</span><br><span class="line">~Test(20, 20)</span><br><span class="line">~Test(60, 5)</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">Test(70, 70)</span><br><span class="line">Test(5, 5)</span><br><span class="line">Test(5, 5)</span><br><span class="line">--------- 4 ---------</span><br><span class="line">Test(80, 80)</span><br><span class="line">~Test(80, 80)</span><br><span class="line">Test(90, 90)</span><br><span class="line">--------- 5 ---------</span><br><span class="line">~Test(70, 70)</span><br><span class="line">~Test(5, 5)</span><br><span class="line">~Test(5, 5)</span><br><span class="line">--------- 6 ---------</span><br><span class="line">~Test(90, 90)</span><br><span class="line"></span><br><span class="line">============ end main()============</span><br><span class="line">~Test(30, 30)</span><br><span class="line">~Test(100, 100)</span><br><span class="line">~Test(10, 10)</span><br></pre></td></tr></tbody></table></figure><h2 id="C-函数调用深入探索"><a href="#C-函数调用深入探索" class="headerlink" title="C++ 函数调用深入探索"></a>C++ 函数调用深入探索</h2><h3 id="案例代码一-1"><a href="#案例代码一-1" class="headerlink" title="案例代码一"></a>案例代码一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">10</span>) : _ma(a) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(int a)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ma = t._ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ma = t._ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _ma;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObject</span><span class="params">(Test t)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> value = t.<span class="built_in">getData</span>();</span><br><span class="line">    <span class="function">Test <span class="title">tmp</span><span class="params">(value)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Test t1;</span><br><span class="line">    Test t2;</span><br><span class="line">    t2 = <span class="built_in">getObject</span>(t1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下（详细分析图解请看<a href="../../../asset/2025/02/cxx-method-invoke.png">这里</a>）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Test(int a)                 // main() 函数中构造 t1 对象</span><br><span class="line">Test(int a)                 // main() 函数中构造 t2 对象</span><br><span class="line">Test(const Test&amp; t)         // getObject() 函数中拷贝构造 t 对象</span><br><span class="line">Test(int a)                 // getObject() 函数中构造 tmp 对象</span><br><span class="line">Test(const Test&amp; t)         // getObject() 函数返回执行结果值时，调用拷贝构造函数来拷贝 tmp 对象给 main() 函数栈帧上的临时对象</span><br><span class="line">~Test()                     // 析构 getObject() 函数中的 tmp 对象</span><br><span class="line">~Test()                     // 析构 getObject() 函数中的 t 对象</span><br><span class="line">operator=(const Test&amp; t)    // main() 函数中，执行赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 t2 对象</span><br><span class="line">~Test()                     // 析构 main() 函数栈帧上的临时对象，临时对象的生存周期是所在语句</span><br><span class="line">~Test()                     // 析构 main() 函数中的 t2 对象</span><br><span class="line">~Test()                     // 析构 main() 函数中的 t1 对象</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码二-1"><a href="#案例代码二-1" class="headerlink" title="案例代码二"></a>案例代码二</h3><ul><li><p>上述 <a href="/posts/bd9d2710.html#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80-1">案例一</a> 的代码执行效率比较低，主要原因有以下几个：</p><ul><li>第一个原因：<code>getObject()</code> 函数的参数是按值传递，而不是按引用传递，这会多调用一次拷贝构造函数。</li><li>第二个原因：在 <code>getObject()</code> 函数中先构造了一个 <code>tmp</code> 对象，然后再作为函数的返回值，这会多调用一次构造函数。</li><li>第三个原因：在 <code>main()</code> 函数中，将临时对象赋值给 <code>t2</code> 对象，这会多调用一次赋值运算符重载函数。</li></ul></li><li><p>C++ 对象的优化原则</p><ul><li>(1) 函数参数传递的过程中，对象应该优先按引用传递，而不是按值传递。</li><li>(2) 函数调用结果返回对象的时候，应该优先返回一个临时对象，而不要返回一个定义过的对象。</li><li>(3) 当函数返回值是对象的时候，优先按初始化的方式来接收返回值，而不是按赋值的方式来接收返回值。<ul><li>换言之，尽量使用临时对象去拷贝构造新对象，因为这样临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化。</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">10</span>) : _ma(a) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(int a)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ma = t._ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Test &amp;t) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ma = t._ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ma;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _ma;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObject</span><span class="params">(Test &amp;t)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> value = t.<span class="built_in">getData</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>(value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Test t1;</span><br><span class="line">    Test t2 = <span class="built_in">getObject</span>(t1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test(int a)                 // main() 函数中构造 t1 对象</span><br><span class="line">Test(int a)                 // main() 函数中构造 t2 对象（使用临时对象去拷贝构造新对象时，临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化）</span><br><span class="line">~Test()                     // 析构 main() 函数中的 t2 对象</span><br><span class="line">~Test()                     // 析构 main() 函数中的 t1 对象</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 多线程编程之一</title>
    <link href="https://www.techgrow.cn/posts/a2a7ad9b.html"/>
    <id>https://www.techgrow.cn/posts/a2a7ad9b.html</id>
    <published>2025-02-07T13:55:33.000Z</published>
    <updated>2025-02-07T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="C-核心概念"><a href="#C-核心概念" class="headerlink" title="C++ 核心概念"></a>C++ 核心概念</h2><h3 id="互斥锁的介绍"><a href="#互斥锁的介绍" class="headerlink" title="互斥锁的介绍"></a>互斥锁的介绍</h3><ul><li><code>mutex</code><ul><li>使用语法（<code>mtx.lock();</code>、<code>mtx.unlock();</code>）。</li><li>最基础的互斥量类型（原始锁），用于保护共享资源，防止多个线程并发访问共享资源。</li><li>如果在某个程序分支或异常路径中忘了执行 <code>mtx.unlock()</code>，就容易导致线程死锁。</li><li><code>mutex</code> 不支持同一个线程重复对其加锁，即无法用于实现递归锁（可重入锁）。</li><li>如果希望实现递归锁（可重入锁），可以使用 <code>recursive_mutex</code> 来替代。<code>recursive_mutex</code> 支持同一个线程对 <code>mutex</code> 重复加锁，每次加锁都需要对应的解锁。</li></ul></li></ul><span id="more"></span><ul><li><p><code>lock_guard</code></p><ul><li>使用语法（<code>lock_guard&lt;mutex&gt; lock(_mutex);</code>）。</li><li>一种轻量级的锁管理类，它在构造时自动加锁，在析构时自动释放锁（RAII 技术），适合在指定作用域内自动管理锁。</li><li>作用域结束时自动解锁，不可以手动解锁（无法提前释放锁）。</li><li><code>lock_guard</code> 和 <code>recursive_mutex</code> 搭配使用，可以实现递归锁（可重入锁）。</li><li>比 <code>unique_lock</code> 更轻量级，性能更好（因为没有 <code>unlock ()</code> 之类的额外操作）。</li><li><code>lock_guard</code> 不能作为函数参数的类型或者函数返回值的类型，只能用在简单的临界区代码段的互斥操作中。</li></ul></li><li><p><code>unique_lock</code></p><ul><li>使用语法（<code>unique_lock&lt;mutex&gt; lock(_mutex);</code>）。</li><li>一种更灵活的锁管理类，它在构造时自动加锁，在析构时自动释放锁（RAII 技术）。</li><li>可以手动解锁（<code>lock.unlock()</code>）。</li><li>可以延迟加锁（<code>unique_lock&lt;mutex&gt; lock(_mutex, defer_lock);</code>）。</li><li>可以移动赋值（<code>unique_lock</code> 可被转移，但 <code>lock_guard</code> 不能被转移）。</li><li><code>unique_lock</code> 和 <code>recursive_mutex</code> 搭配使用，可以实现递归锁（可重入锁）。</li><li>通常与 <code>condition_variable</code> 一起配合使用，因为 <code>condition_variable::wait()</code> 函数需要传入 <code>unique_lock</code> 参数（不能使用 <code>lock_guard</code>）。</li></ul></li></ul><blockquote><p>对比表格</p></blockquote><table><thead><tr><th>特性</th><th><code>mutex</code></th><th><code>lock_guard</code></th><th><code>unique_lock</code></th></tr></thead><tbody><tr><td>是否自动管理锁</td><td>❌ 否</td><td>✅ 是（RAII）</td><td>✅ 是（RAII）</td></tr><tr><td>是否可解锁再加锁</td><td>✅ 是</td><td>❌ 否</td><td>✅ 是</td></tr><tr><td>是否可延迟加锁</td><td>❌ 否</td><td>❌ 否</td><td>✅ 是</td></tr><tr><td>支持条件变量（CV）</td><td>❌ 否</td><td>❌ 否</td><td>✅ 是（推荐配合使用）</td></tr><tr><td>资源占用</td><td>最低</td><td>低</td><td>略高（但更灵活）</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">总结</p><ul><li>如果需要手动控制解锁，建议使用 <code>unique_lock</code>。</li><li>如果只需要简单加锁 / 解锁，建议使用 <code>lock_guard</code>，效率更高。</li></ul></div><h3 id="unique-lock-的作用"><a href="#unique-lock-的作用" class="headerlink" title="unique_lock 的作用"></a>unique_lock 的作用</h3><p><code>unique_lock</code> 是 C++ 标准库 <code>mutex</code> 的 RAII（资源获取即初始化）封装，用于自动管理互斥锁。当执行 <code>unique_lock&lt;mutex&gt; lock(_mutex);</code> 时：</p><ul><li>当前线程尝试获取 <code>mutex</code> 锁（如果其他线程已经持有锁，则当前线程会阻塞等待，直到锁被释放）。</li><li>一旦成功获取锁，在 <code>lock</code> 对象的生命周期内，当前线程独占访问受保护的资源。</li><li>当 <code>lock</code> 对象销毁时（如作用域结束），<code>mutex</code> 会自动解锁，从而可以避免死锁或资源泄露。</li></ul><h3 id="condition-variable-的作用"><a href="#condition-variable-的作用" class="headerlink" title="condition_variable 的作用"></a>condition_variable 的作用</h3><ul><li><p>核心概念</p><ul><li><code>condition_variable</code> 是 C++ 11 提供的一种线程间同步工具，用于线程等待某个条件满足，并在条件满足时被其他线程唤醒。</li><li><code>condition_variable</code> 常与 <code>mutex</code> 和 <code>unique_lock</code> 一起搭配使用，可用于实现线程间等待通知机制，类似 Java 中的 <code>wait / notify</code>。</li></ul></li><li><p>注意事项</p><ul><li>等待时必须传入一把锁（如 <code>mutex</code>），否则 <code>wait()</code> 会报错。</li><li><strong>执行 <code>wait()</code> 后，线程会挂起等待，同时释放锁，被唤醒后重新获取锁。</strong></li><li>推荐使用带 <code>Predicate（断言）</code> 的 <code>wait()</code>，防止虚假唤醒。</li><li><code>notify_one()</code> 要在修改共享状态之后再调用，否则会错过通知。</li><li>常配合 <code>unique_lock</code> 一起使用，因为 <code>unique_lock</code> 比 <code>lock_guard</code> 更灵活（支持手动解锁、延迟加锁等）。</li></ul></li><li><p>适用场景</p><ul><li>生产者 / 消费者模型</li><li>线程间通知与协作</li><li>线程等待某种条件成立（如队列不为空）</li></ul></li><li><p>基本操作</p></li></ul><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td><code>wait(lock)</code></td><td>线程挂起等待，同时释放锁，被唤醒后重新获取锁。</td></tr><tr><td><code>wait(lock, predicate)</code></td><td>等待直到条件成立，否则继续阻塞，可以防止虚假唤醒。等待期间释放锁，被唤醒后重新获取锁。</td></tr><tr><td><code>notify_one()</code></td><td>唤醒一个等待中的线程。</td></tr><tr><td><code>notify_all()</code></td><td>唤醒所有等待中的线程。</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">什么是虚假唤醒</p><ul><li>虚假唤醒是指线程在没有收到 Notify（通知）或没有满足条件的情况下意外醒来。</li><li>换言之，线程在 <code>wait()</code> 处本应该阻塞，但它自己突然 "醒了"，而并没有任何线程调用 <code>notify_one()</code> 或 <code>notify_all()</code> 触发它醒来，也没有任何共享条件真正发生变化。</li><li>虚假唤醒不是 Bug，它是操作系统 / CPU 实现层面允许的行为。主要原因有：(1) 出于性能或调度策略考虑，某些系统可能让线程偶尔 "意外醒来"；(2) 多线程调度可能出现不可预知的唤醒；(3) 这在 POSIX 线程规范（pthread）和 C++ 标准中都是被允许的。</li></ul></div><h2 id="C-多线程编程"><a href="#C-多线程编程" class="headerlink" title="C++ 多线程编程"></a>C++ 多线程编程</h2><p>这里介绍的是 C++ 语言级别的多线程编程，支持跨平台编译与运行。值得一提的是，现代 C++ 语言层面的多线程编程使用的是 <code>thread</code>，而其底层的实现依旧是区分不同平台的，比如：Windows 平台使用的是 <code>createThread</code>，Linux 平台使用的是 <code>pthread_create</code>。</p><div class="admonition note"><p class="admonition-title">C++ 多线程编程的核心技术</p><ul><li>thread / mutex / condition_variable</li><li>unique_lock / lock_guard</li><li>atomic（基于 CAS 的原则类型）</li><li>sleep_for</li></ul></div><h3 id="thread-的使用"><a href="#thread-的使用" class="headerlink" title="thread 的使用"></a>thread 的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadHandler1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 线程睡眠5秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"run thread handler 1"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadHandler2</span><span class="params">(<span class="keyword">int</span> seconds)</span> </span>{</span><br><span class="line">    <span class="comment">// 线程睡眠</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(seconds));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"run thread handler 2"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个线程对象，参数传入一个线程函数，线程会自动启动</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadHandler1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者指定线程函数的参数</span></span><br><span class="line">    <span class="comment">// std::thread t1(threadHandler2, 5);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待子线程结束，然后再继续往下执行</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者将子线程设置为分离线程，这样主线程就不需要等待子线程结束；当主线程结束，所有子线程都自动结束（终止运行）</span></span><br><span class="line">    <span class="comment">// t1.detach();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run thread handler 1</span><br></pre></td></tr></tbody></table></figure><h3 id="实现线程间的互斥"><a href="#实现线程间的互斥" class="headerlink" title="实现线程间的互斥"></a>实现线程间的互斥</h3><p>这里将使用 <code>std::mutex</code> 与 <code>std::lock_guard</code> 来模拟车站三个售票窗口同时售票，要求每张票只能卖一次。</p><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>std::lock_guard</code> 与 <code>std::unique_lock</code> 都是 C++ 标准库 <code>std::mutex</code> 的 RAII（资源获取即初始化）封装，用于自动管理互斥锁（如自动解锁）。</li><li><code>std::lock_guard</code> 支持在作用域结束时自动解锁，但不可以手动解锁，比 <code>std::unique_lock</code> 更轻量级，性能更好。</li><li><code>std::unique_lock</code> 支持自动 / 手动解锁、延迟加锁、移动赋值等，通常与 <code>std::condition_variable</code> 搭配使用。</li></ul></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line">std::mutex _mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 车站一共有 100 张车票</span></span><br><span class="line"><span class="keyword">int</span> ticketCount = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 获取互斥锁（支持在作用域结束时自动解锁）</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双重检测</span></span><br><span class="line">        <span class="keyword">if</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 执行业务逻辑</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"售票窗口 "</span> &lt;&lt; id &lt;&lt; <span class="string">" 卖出第 "</span> &lt;&lt; ticketCount &lt;&lt; <span class="string">" 张车票"</span> &lt;&lt; std::endl;</span><br><span class="line">            ticketCount--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> threadCount = <span class="number">3</span>;</span><br><span class="line">    std::list&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动三个售票子线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) {</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(sellTicket, i));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待三个售票子线程执行结束</span></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; t : threads) {</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"所有售票窗口已经结束售票"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">售票窗口 0 卖出第 100 张车票</span><br><span class="line">售票窗口 0 卖出第 99 张车票</span><br><span class="line">售票窗口 0 卖出第 98 张车票</span><br><span class="line">售票窗口 0 卖出第 97 张车票</span><br><span class="line">......</span><br><span class="line">售票窗口 1 卖出第 4 张车票</span><br><span class="line">售票窗口 1 卖出第 3 张车票</span><br><span class="line">售票窗口 2 卖出第 2 张车票</span><br><span class="line">售票窗口 2 卖出第 1 张车票</span><br><span class="line">所有售票窗口已经结束售票</span><br></pre></td></tr></tbody></table></figure><h3 id="实现线程间的同步通信"><a href="#实现线程间的同步通信" class="headerlink" title="实现线程间的同步通信"></a>实现线程间的同步通信</h3><p>这里实现生产者 / 消费者线程模型，使用了 <code>std::thread</code>、<code>std::mutex</code>、<code>std::unique_lock</code>、<code>std::condition_variable</code>。主要模拟实现生产者线程生产一条数据，消费者线程就立刻消费一条数据，两个线程一直交替执行。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex _mutex;                <span class="comment">// 互斥锁</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; _queue;           <span class="comment">// 共享数据队列</span></span><br><span class="line">condition_variable _cv;      <span class="comment">// 条件变量</span></span><br><span class="line"><span class="keyword">atomic_bool</span> _finish(<span class="literal">false</span>);  <span class="comment">// 控制标志（用于终止程序）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!_finish) {</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到满足条件才继续往下执行（可以避免虚假唤醒）</span></span><br><span class="line">        _cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> _queue.<span class="built_in">empty</span>(); });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟生产时间</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">rand</span>() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        _queue.<span class="built_in">push</span>(item);</span><br><span class="line">        cout &lt;&lt; <span class="string">"生产: "</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者</span></span><br><span class="line">        _cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!_finish) {</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到满足条件才继续往下执行（可以避免虚假唤醒）</span></span><br><span class="line">        _cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> !_queue.<span class="built_in">empty</span>(); });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟消费时间</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> item = _queue.<span class="built_in">front</span>();</span><br><span class="line">        _queue.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"消费: "</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知生产者</span></span><br><span class="line">        _cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动生产者和消费者线程</span></span><br><span class="line">    <span class="function">thread <span class="title">producer</span><span class="params">(produce)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">consumer</span><span class="params">(consume)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程运行 60 秒</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">60</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置终止标志</span></span><br><span class="line">    _finish = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有线程，确保它们能结束</span></span><br><span class="line">    _cv.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待生产者和消费者线程结束</span></span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">生产: 98</span><br><span class="line">消费: 98</span><br><span class="line">生产: 635</span><br><span class="line">消费: 635</span><br><span class="line">生产: 318</span><br><span class="line">消费: 318</span><br><span class="line">生产: 513</span><br><span class="line">消费: 513</span><br><span class="line">生产: 413</span><br><span class="line">消费: 413</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><h2 id="C-原子类型"><a href="#C-原子类型" class="headerlink" title="C++ 原子类型"></a>C++ 原子类型</h2><div class="admonition note"><p class="admonition-title">提示</p><p>CAS（比较与交换）是一种轻量级、不需要加锁的线程同步机制，可用于防止多个线程同时读写共享变量时发生数据竞争。值得一提的是，C++ 原子类型的底层都是基于 CAS 实现的。</p></div><h3 id="atomic-原子类型的概念"><a href="#atomic-原子类型的概念" class="headerlink" title="atomic 原子类型的概念"></a>atomic 原子类型的概念</h3><ul><li><p>核心概念</p><ul><li><code>std::atomic&lt;T&gt;</code> 是 C++ 11 引入的一个模板类，用于实现线程安全的原子操作。它的本质是：对变量的读写不可被中断，不需要加锁（基于 CAS），但又是线程安全的。</li><li>在多线程编程中，如果两个线程同时读写一个普通变量（如 <code>int</code>），就可能产生竞态条件。使用 <code>std::atomic</code> 可以避免这种问题，而不需要显式使用 <code>mutex</code> 互斥锁。</li><li><code>std::atomic</code> 本身就已经保证了原子性、内存可见性和有序性（默认情况下），不需要也不应该再搭配 <code>volatile</code> 一起使用。</li><li>为了使用方便，C++ 标准库为常用的原始类型提供了特定的类型别名，例如：<ul><li><code>std::atomic_int</code> 是 <code>std::atomic&lt;int&gt;</code> 的类型别名。</li><li><code>std::atomic_bool</code> 是 <code>std::atomic&lt;bool&gt;</code> 的类型别名。</li><li>其他类似的别名还有 <code>std::atomic_char</code>、<code>std::atomic_long</code> 等。</li></ul></li></ul></li><li><p>支持的类型</p><ul><li>基本类型：<code>int</code>、<code>bool</code>、<code>char</code>、<code>float</code> 等。</li><li>用户自定义的类型，但该类型必须是平凡可复制的（Trivially Copyable）。这意味着该类型的对象可以通过简单的内存复制进行复制，比如通过 <code>memcpy</code> 这样的操作进行复制，而无需调用构造函数或者赋值运算符。</li></ul></li><li><p>支持的操作</p><ul><li>原子读写：<code>load()</code> / <code>store()</code></li><li>自增自减：<code>++</code>、<code>--</code>、<code>fetch_add()</code>、<code>fetch_sub()</code></li><li>比较并交换（CAS）：<code>compare_exchange_strong()</code> / <code>compare_exchange_weak()</code></li></ul></li><li><p>使用注意事项</p><ul><li><code>std::atomic</code> 不支持拷贝赋值（复制是被禁用的）。</li><li>默认是顺序一致性（<code>memory_order_seq_cst</code>），内存可见性是有保障的。</li><li>支持内存顺序优化（高级用法），包括 <code>memory_order_relaxed</code>、<code>acquire</code>、<code>release</code> 等。</li></ul></li></ul><blockquote><p>volatile 能干什么？它和 atomic 是一回事吗？</p></blockquote><p><strong>特别注意，<code>volatile</code> 与 <code>std::atomic</code> 不是一回事！<code>volatile</code> 在 C++ 里的作用和你想的不太一样。</strong></p><table><thead><tr><th>功能</th><th><code>std::atomic</code></th><th><code>volatile</code></th></tr></thead><tbody><tr><td>保证原子性？</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>保证内存可见性？</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>保证编译器不优化读写？</td><td>✅是（控制更强）</td><td>✅是（仅编译器层面）</td></tr><tr><td>多线程同步安全？</td><td>✅ 是</td><td>❌ 否</td></tr></tbody></table><ul><li>结论：<ul><li><code>volatile</code> 只告诉编译器 “不要优化这个变量的访问”。</li><li><code>volatile</code> 不会保证线程间同步，不会保证缓存刷新，不会保证乱序执行的控制。</li><li>所以，在 C++ 多线程编程里，<code>volatile</code> 基本没用（少数平台 / 驱动除外）。</li></ul></li></ul><h3 id="atomic-原子类型的使用"><a href="#atomic-原子类型的使用" class="headerlink" title="atomic 原子类型的使用"></a>atomic 原子类型的使用</h3><p>这里将演示如何使用基于 CAS 操作的 <code>atomic</code> 原子类型，比如 <code>atomic_int</code> 和 <code>atomic_bool</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="keyword">atomic_int</span> _count(<span class="number">0</span>);</span><br><span class="line">std::<span class="keyword">atomic_bool</span> _isReady(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">taskHandler</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!_isReady) {</span><br><span class="line">        <span class="comment">// 线程出让当前的 CPU 时间片，等待下一次调度的执行</span></span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">        _count++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::list&lt;std::thread&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个子线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        list.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(taskHandler));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待几秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    _isReady = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有子线程执行结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        (*it).<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"_count = "</span> &lt;&lt; _count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_count = 1000</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的多线程编程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 实现 MySQL 数据库连接池</title>
    <link href="https://www.techgrow.cn/posts/993ae2e0.html"/>
    <id>https://www.techgrow.cn/posts/993ae2e0.html</id>
    <published>2025-01-28T13:55:33.000Z</published>
    <updated>2025-01-28T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/c942e1de.html">C++ 使用 API 连接 MySQL 数据库</a></li><li><a href="/posts/993ae2e0.html">基于 C++ 实现 MySQL 数据库连接池</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了在 C/C++ 项目中，提高 MySQL Server 的访问效率，基于 C++ 11 实现数据库连接池。</p><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>为了提高 MySQL 数据库 (基于 C/S 设计) 的访问瓶颈，除了在服务器端增加缓存服务器缓存常用的数据之外（例如 Redis），还可以增加连接池，来提高 MySQL Server 的访问效率。在高并发情况下，大量的 TCP 三次握手、MySQL Server 连接认证、MySQL Server 关闭连接回收资源和 TCP 四次挥手所耗费的性能时间也是很明显的，增加连接池就是为了减少这一部分的性能损耗。在市场上比较流行的连接池包括 C3P0、Apache DBCP、HikariCP、阿里巴巴的 Druid 连接池，它们对于短时间内大量的数据库增删改查操作性能的提升是很明显的，但是它们有一个共同点就是，全部都是由 Java 实现的。</p><span id="more"></span><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><ul><li>单例模式</li><li> Lambda 表达式</li><li>队列容器 <code>queue</code></li><li>智能指针 <code>shared_ptr</code></li><li>基于 CAS 的原子基础类型</li><li> MySQL 数据库编程（基于 MySQL Connector/C++）</li><li>C++ 11 的多线程编程，包括线程互斥、线程同步通信等</li><li>生产者 - 消费者线程模型的实现，基于 <code>mutex</code>、<code>unique_lock</code>、<code>condition_variable</code></li></ul><h2 id="开发平台的选型"><a href="#开发平台的选型" class="headerlink" title="开发平台的选型"></a>开发平台的选型</h2><p>有关 MySQL 数据库编程、多线程编程、线程互斥和同步通信操作、智能指针、设计模式、容器等等这些技术在 C++ 语言层面都可以直接实现，因此该项目选择直接在 Windows 平台上进行开发，当然项目代码在 Linux 平台下用 <code>g++</code> 也可以直接编译运行。</p><h3 id="Linux-平台开发"><a href="#Linux-平台开发" class="headerlink" title="Linux 平台开发"></a>Linux 平台开发</h3><p>由于 MySQL Connector/C++ 依赖了 <code>boost</code>，因此本地操作系统需要安装 <code>boost</code>。建议从 <a href="https://www.boost.org/users/download/">boost 官网</a> 下载 <code>boost</code> 的源码压缩包，然后使用 <code>root</code> 用户手动编译安装 <code>boost</code>，此方式适用于大多数 Linux 系统，如下所示：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">$ wget https://boostorg.jfrog.io/artifactory/main/release/1.78.0/<span class="built_in">source</span>/boost_1_78_0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压文件</span></span><br><span class="line">$ tar -xvf boost_1_78_0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line">$ <span class="built_in">cd</span> boost_1_78_0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建</span></span><br><span class="line">$ sudo ./bootstrap.sh --prefix=/usr/<span class="built_in">local</span>/boost</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装（耗时非常长）</span></span><br><span class="line">$ sudo ./b2 install --prefix=/usr/<span class="built_in">local</span>/boost --with=all</span><br></pre></td></tr></tbody></table></figure><p>然后进入数据库连接池项目的根目录，通过 CMake 命令直接编译项目即可，比如：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置项目，生成构建文件（例如 Makefile 或 Ninja 文件）</span></span><br><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译项目，生成可执行文件</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></tbody></table></figure><h3 id="Windows-平台开发"><a href="#Windows-平台开发" class="headerlink" title="Windows 平台开发"></a>Windows 平台开发</h3><p>由于 MySQL Connector/C++ 依赖了 <code>boost</code>，因此本地操作系统需要先安装 <code>boost</code>，安装步骤如下：</p><ul><li>(1) 在 <a href="https://www.boost.org/users/download/">Boost 官网</a> 下载最新版本的 <code>Boost</code>，并解压到本地磁盘，例如解压路径为：<code>C:\Program Files\boost_1_77_0</code></li><li>(2) 在 Visual Studio 中右键项目，选择 <code>属性</code>，导航到 <code>配置属性</code> -&gt; <code>C/C++</code> -&gt; <code>常规</code> -&gt; <code>附加包含目录</code>，添加 <code>Boost</code> 的安装路径（如 <code>C:\Program Files\boost_1_77_0</code>），如下图所示</li></ul><p><img data-src="../../../asset/2025/02/cxx-mysql-connection-pool-boost.png"></p><p>然后进入数据库连接池项目的根目录，通过 CMake 命令直接编译项目即可，比如：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置项目，生成构建文件（例如 Makefile 或 Ninja 文件）</span></span><br><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译项目，生成可执行文件</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></tbody></table></figure><h2 id="连接池的功能介绍"><a href="#连接池的功能介绍" class="headerlink" title="连接池的功能介绍"></a>连接池的功能介绍</h2><p>连接池一般包含了数据库连接所用的 IP 地址、Port 端口号、用户名和密码以及其它的性能参数，例如初始连接数、最大连接数、最大空闲时间、连接超时时间等。本项目是基于 C++ 语言实现的连接池，主要也是实现以上几个所有连接池都支持的通用基础功能，其余连接池更多的扩展功能，可以自行实现。</p><ul><li><p>初始连接数（initSize）：</p><ul><li>表示连接池事先会和 MySQL Server 创建 initSize 个数的 connection 连接，当应用发起 MySQL 访问时，不用再创建和 MySQL Server 新的连接，直接从连接池中获取一个可用的连接就可以，使用完成后，并不去释放 connection，而是把当前 connection 再归还到连接池当中。</li></ul></li><li><p>最大连接数（maxSize）:</p><ul><li>当并发访问 MySQL Server 的请求增多时，初始连接数已经不够使用了，此时会根据新的请求数量去创建更多的连接给应用去使用，但是新创建的连接数量上限是 maxSize，不能无限制地创建连接，因为每一个连接都会占用一个 socket 资源。一般连接池和服务器程序是部署在一台主机上的，如果连接池占用过多的 socket 资源，那么服务器就不能接收太多的客户端请求了。当这些连接使用完成后，再次归还到连接池当中来维护。</li></ul></li><li><p>最大空闲时间（maxIdleTime）：</p><ul><li>当访问 MySQL 的并发请求多了以后，连接池里面的连接数量会动态增加，上限是 maxSize 个，当这些连接用完再次归还到连接池当中。如果在指定的 maxIdleTime 里面，这些新增加的连接都没有被再次使用过，那么新增加的这些连接资源就要被回收掉，只需要保持初始连接数 initSize 个连接就可以了。</li></ul></li><li><p>连接超时时间（connectionTimeout）:</p><ul><li>当 MySQL 的并发请求量过大，连接池中的连接数量已经到达 maxSize 了，而此时没有空闲的连接可供使用，那么此时应用无法从连接池获取连接，它通过阻塞的方式获取连接的等待时间如果超过 connectionTimeout 时间，则获取连接失败，无法访问数据库。</li></ul></li></ul><h2 id="连接池的功能设计"><a href="#连接池的功能设计" class="headerlink" title="连接池的功能设计"></a>连接池的功能设计</h2><ul><li><p>C++ 源文件的功能划分</p><ul><li><code>MysqlConnection.h</code> 和 <code>MysqlConnection.cpp</code>：数据库增删改查的代码实现</li><li><code>MysqlConnectionPool.h</code> 和 <code>MysqlConnectionPool.cpp</code>：连接池的代码实现</li></ul></li><li><p>连接池的实现主要包含了以下功能</p><ul><li>(1) 连接池只需要一个实例，所以 ConnectionPool 以单例模式进行设计。</li><li>(2) 应用可以从 ConnectionPool 中获取 MySQL 的连接 Connection。</li><li>(3) 空闲连接 Connection 全部存储在一个线程安全的 Connection 队列中，使用互斥锁来保证队列的线程安全。</li><li>(4) 如果 Connection 队列为空，应用还需要再获取连接，此时需要动态创建连接，最大的连接数量是 maxSize。</li><li>(5) 当队列中空闲连接的存活时间超过 maxIdleTime 后，连接就要被释放掉，只保留初始的 initSize 个连接就可以，这个功能需要放在独立的线程中去完成（定时扫描连接）。</li><li>(6) 如果 Connection 队列为空，而且当前已创建的连接的数量已达到上限 maxSize，则应用需要等待 connectionTimeout 时间。如果应用还是获取不到空闲的连接，则获取连接失败；此处从 Connection 队列获取空闲连接时，可以使用带超时时间的 <code>mutex</code> 互斥锁来实现连接超时时间。</li><li>(7) 应用获取的连接用 <code>shared_ptr</code> 智能指针来管理，并用 Lambda 表达式定制连接释放的功能（不真正释放连接，而是将连接归还到 Connection 队列中）。</li><li>(8) 连接的生产和连接的消费采用生产者 - 消费者线程模型来设计，使用了线程间的同步通信机制、条件变量和互斥锁。</li></ul></li></ul><h2 id="连接池的代码实现"><a href="#连接池的代码实现" class="headerlink" title="连接池的代码实现"></a>连接池的代码实现</h2><h3 id="连接池的项目结构"><a href="#连接池的项目结构" class="headerlink" title="连接池的项目结构"></a>连接池的项目结构</h3><p><img data-src="../../../asset/2025/02/cxx-mysql-connection-pool-arch.png"></p><ul><li><code>config</code>：存放数据库连接池的配置文件</li><li><code>src</code> 目录：存放数据库连接池的 C++ 源文件</li><li><code>include</code> 目录：存放数据库连接池的 C++ 头文件</li><li><code>script</code> 目录：存放 Linux 平台自动编译构建项目的 Shell 脚本</li><li><code>mysql-connector</code> 目录：存放 MySQL Connector/C++ 的头文件和动态链接库，如下所示：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql-connector</span><br><span class="line">├── include</span><br><span class="line">│&nbsp;&nbsp; ├── cppconn</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── build_config.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── config.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── connection.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── datatype.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── driver.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── exception.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── metadata.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── parameter_metadata.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── prepared_statement.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── resultset.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── resultset_metadata.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── sqlstring.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── statement.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── variant.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── version_info.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── warning.h</span><br><span class="line">│&nbsp;&nbsp; ├── mysql_connection.h</span><br><span class="line">│&nbsp;&nbsp; ├── mysql_driver.h</span><br><span class="line">│&nbsp;&nbsp; └── mysql_error.h</span><br><span class="line">└── lib</span><br><span class="line">    ├── libcrypto.so -&gt; libcrypto.so.1.1</span><br><span class="line">    ├── libcrypto.so.1.1</span><br><span class="line">    ├── libmysqlcppconn.so -&gt; libmysqlcppconn.so.7</span><br><span class="line">    ├── libmysqlcppconn.so.7 -&gt; libmysqlcppconn.so.7.1.1.13</span><br><span class="line">    ├── libmysqlcppconn.so.7.1.1.13</span><br><span class="line">    ├── libssl.so -&gt; libssl.so.1.1</span><br><span class="line">    └── libssl.so.1.1</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>MySQL Connector/C++ 库的使用教程请看 <a href="/posts/c942e1de.html">这里</a>。</li></ul></div><h3 id="连接池的配置参数"><a href="#连接池的配置参数" class="headerlink" title="连接池的配置参数"></a>连接池的配置参数</h3><p>数据库连接池的配置参数格式是 <code>key=value</code>，默认存放在 <code>config</code> 目录下的 <code>mysql.ini</code> 文件中，其配置内容如下所示：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接地址</span></span><br><span class="line"><span class="attr">host</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">3306</span></span><br><span class="line"><span class="comment"># 用户名</span></span><br><span class="line"><span class="attr">username</span>=root</span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line"><span class="attr">password</span>=<span class="number">123456</span></span><br><span class="line"><span class="comment"># 数据库</span></span><br><span class="line"><span class="attr">dbname</span>=cxx_study</span><br><span class="line"><span class="comment"># 初始连接数</span></span><br><span class="line"><span class="attr">initSize</span>=<span class="number">10</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maxSize</span>=<span class="number">100</span></span><br><span class="line"><span class="comment"># 最大空闲时间（单位秒）</span></span><br><span class="line"><span class="attr">maxIdleTime</span>=<span class="number">5</span></span><br><span class="line"><span class="comment"># 连接超时时间（单位毫秒）</span></span><br><span class="line"><span class="attr">connectionTimeout</span>=<span class="number">500</span></span><br></pre></td></tr></tbody></table></figure><h3 id="连接池的-CMake-配置"><a href="#连接池的-CMake-配置" class="headerlink" title="连接池的 CMake 配置"></a>连接池的 CMake 配置</h3><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 CMake 的版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第三方库的目录路径</span></span><br><span class="line"><span class="keyword">set</span>(PATH_TO_BOOST /usr/local/boost)</span><br><span class="line"><span class="keyword">set</span>(PATH_TO_MYSQL_CONNECTOR ./libs/mysql-connector)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目信息</span></span><br><span class="line"><span class="keyword">project</span>(db_connection_pool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 C++ 的版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定构建输出的目录</span></span><br><span class="line"><span class="keyword">set</span>(PROJECT_BINARY_DIR <span class="variable">${PROJECT_SOURCE_DIR}</span>/build)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">${PROJECT_SOURCE_DIR}</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义目标，每次编译之前清理可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(clean_bin ALL</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_COMMAND}</span> -E remove_directory <span class="variable">${EXECUTABLE_OUTPUT_PATH}</span></span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_COMMAND}</span> -E <span class="keyword">make_directory</span> <span class="variable">${EXECUTABLE_OUTPUT_PATH}</span></span><br><span class="line">        COMMENT <span class="string">"Cleaning bin directory before build"</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义命令，每次编译之前拷贝 MySQL 配置文件到可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">        <span class="keyword">TARGET</span> clean_bin</span><br><span class="line">        POST_BUILD</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_COMMAND}</span> -E copy_if_different</span><br><span class="line">        <span class="variable">${CMAKE_SOURCE_DIR}</span>/config/mysql.ini</span><br><span class="line">        <span class="variable">${EXECUTABLE_OUTPUT_PATH}</span>/mysql.ini</span><br><span class="line">        COMMENT <span class="string">"Copying mysql.ini to bin directory before build"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入项目里的头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${PROJECT_SOURCE_DIR}</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索项目里的源文件，并将文件名保存到 MAIN_SOURCES 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">${PROJECT_SOURCE_DIR}</span>/src MAIN_SOURCES)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入第三方库的头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${PATH_TO_BOOST}</span>/<span class="keyword">include</span> <span class="variable">${PATH_TO_MYSQL_CONNECTOR}</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定项目里静态库和动态链接库的目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">${PATH_TO_BOOST}</span>/lib <span class="variable">${PATH_TO_MYSQL_CONNECTOR}</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的名称和项目里的所有源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${MAIN_SOURCES}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译参数，比如包括链接库文件：pthread、ssl、crypto、boost</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"-lpthread -lssl -lcrypto -lboost_system -lboost_filesystem"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接项目里的静态库和动态链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">${PROJECT_NAME}</span> ssl.so crypto.so mysqlcppconn.so)</span><br></pre></td></tr></tbody></table></figure><h3 id="连接池的-C-头文件"><a href="#连接池的-C-头文件" class="headerlink" title="连接池的 C++ 头文件"></a>连接池的 C++ 头文件</h3><ul><li><code>public.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LOG(format, ...) printf(format, __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LOG(format, ...) printf(format, ##__VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>MysqlConnection.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MySQL 增删改查操作的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql_connection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/driver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/exception.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/resultset.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/statement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/prepared_statement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> chrono::system_clock::time_point time_point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 数据库操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlConnection</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MysqlConnection</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MysqlConnection</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;ResultSet&gt; <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *query, <span class="keyword">const</span> vector&lt;string&gt; parameters)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">const</span> string host, <span class="keyword">const</span> string username, <span class="keyword">const</span> string password, <span class="keyword">const</span> string dbname)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refreshAliveTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getAliveTime</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _host;                           <span class="comment">// MySQL 连接地址</span></span><br><span class="line">    string _username;                       <span class="comment">// MySQL 用户名</span></span><br><span class="line">    string _password;                       <span class="comment">// MySQL 密码</span></span><br><span class="line">    string _dbname;                         <span class="comment">// MySQL 数据库</span></span><br><span class="line">    Driver *_driver;                        <span class="comment">// MySQL 驱动</span></span><br><span class="line">    Connection *_connection;                <span class="comment">// MySQL 连接</span></span><br><span class="line">    time_point _aliveTime;                  <span class="comment">// 记录连接进入空闲状态后的起始存活时间点</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>MysqlConnectionPool.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MySQL 连接池的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnection.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 连接池类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlConnectionPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MysqlConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断连接池是否已关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isClosed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接池中的连接数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接池单例</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MysqlConnectionPool *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 MySQL 连接</span></span><br><span class="line">    <span class="function">shared_ptr&lt;MysqlConnection&gt; <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数私有化</span></span><br><span class="line">    <span class="built_in">MysqlConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝造函数私有化</span></span><br><span class="line">    <span class="built_in">MysqlConnectionPool</span>(<span class="keyword">const</span> MysqlConnectionPool &amp;pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">loadConfigFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产 MySQL 连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描多余的空闲连接，并释放连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scanIdleConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">static</span> MysqlConnectionPool *INSTANCE;</span><br><span class="line"></span><br><span class="line">    string _host;             <span class="comment">// MySQL 连接地址</span></span><br><span class="line">    string _username;         <span class="comment">// MySQL 用户名</span></span><br><span class="line">    string _password;         <span class="comment">// MySQL 密码</span></span><br><span class="line">    string _dbname;           <span class="comment">// MySQL 数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _initSize;            <span class="comment">// 初始连接数</span></span><br><span class="line">    <span class="keyword">int</span> _maxSize;             <span class="comment">// 最大连接数</span></span><br><span class="line">    <span class="keyword">int</span> _maxIdleTime;         <span class="comment">// 最大空闲时间（单位秒）</span></span><br><span class="line">    <span class="keyword">int</span> _connectionTimeout;   <span class="comment">// 连接超时时间（单位毫秒）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">atomic_int</span> _connectionCount;                 <span class="comment">// MySQL 连接的总数量</span></span><br><span class="line">    queue&lt;MysqlConnection *&gt; _connectionQueue;   <span class="comment">// 存储 MySQL 连接的队列</span></span><br><span class="line">    mutex _queueMutex;                           <span class="comment">// 维护 MySQL 连接队列线程安全的互斥锁</span></span><br><span class="line">    condition_variable _cv;                      <span class="comment">// 条件变量，用于连接生产者线程和连接消费者线程之间的通信</span></span><br><span class="line">    <span class="keyword">atomic_bool</span> _closed;                         <span class="comment">// 连接池是否已关闭</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="连接池的-C-源文件"><a href="#连接池的-C-源文件" class="headerlink" title="连接池的 C++ 源文件"></a>连接池的 C++ 源文件</h3><ul><li><code>MysqlConnection.cpp</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnection.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">MysqlConnection::<span class="built_in">MysqlConnection</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MysqlConnection::~<span class="built_in">MysqlConnection</span>() {</span><br><span class="line">    <span class="comment">// 关闭数据连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection &amp;&amp; !<span class="keyword">this</span>-&gt;_connection-&gt;<span class="built_in">isClosed</span>()) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;_connection-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// LOG("# DE<span class="doctag">BUG:</span> %s\n", "Closed mysql connection");</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行任何 SQL 语句，返回一个 bool 值，表明执行该 SQL 语句是否返回了 ResultSet</span></span><br><span class="line"><span class="comment">// 如果执行后第一个结果是 ResultSet，则返回 true，否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnection::execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="function">unique_ptr&lt;Statement&gt; <span class="title">statement</span><span class="params">(<span class="keyword">this</span>-&gt;_connection-&gt;createStatement())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (statement) {</span><br><span class="line">                <span class="keyword">return</span> statement-&gt;<span class="built_in">execute</span>(sql);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE</span></span><br><span class="line"><span class="comment">// 函数的返回值是一个整数，指示受影响的行数，对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，返回值总为零</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MysqlConnection::executeUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="function">unique_ptr&lt;Statement&gt; <span class="title">statement</span><span class="params">(<span class="keyword">this</span>-&gt;_connection-&gt;createStatement())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (statement) {</span><br><span class="line">                <span class="keyword">return</span> statement-&gt;<span class="built_in">executeUpdate</span>(sql);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 SQL 的预编译机制，执行查询单个结果集（ResultSet）的 SQL 语句，例如 SELECT 语句</span></span><br><span class="line"><span class="function">unique_ptr&lt;ResultSet&gt; <span class="title">MysqlConnection::query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql, <span class="keyword">const</span> vector&lt;string&gt; parameters)</span> </span>{</span><br><span class="line">    unique_ptr&lt;ResultSet&gt; resultSet = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="function">unique_ptr&lt;PreparedStatement&gt; <span class="title">statement</span><span class="params">(<span class="keyword">this</span>-&gt;_connection-&gt;prepareStatement(sql))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (statement) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> iterator = parameters.<span class="built_in">cbegin</span>(); iterator != parameters.<span class="built_in">cend</span>(); iterator++) {</span><br><span class="line">                    index++;</span><br><span class="line">                    statement-&gt;<span class="built_in">setString</span>(index, (*iterator).<span class="built_in">c_str</span>());</span><br><span class="line">                }</span><br><span class="line">                resultSet.<span class="built_in">reset</span>(statement-&gt;<span class="built_in">executeQuery</span>());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> resultSet;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接 MySQL 数据库</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnection::connect</span><span class="params">(<span class="keyword">const</span> string host, <span class="keyword">const</span> string username, <span class="keyword">const</span> string password, <span class="keyword">const</span> string dbname)</span> </span>{</span><br><span class="line">    <span class="comment">// 初始化MySQL的连接信息</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_host = <span class="string">"tcp://"</span> + host;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_username = username;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_password = password;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_dbname = dbname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 加载MySQL驱动</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_driver = <span class="built_in">get_driver_instance</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;_driver) {</span><br><span class="line">            <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to load mysql _driver"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接MySQL实例</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_connection = _driver-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;_host.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;_username.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;_password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to connect mysql server"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 设置默认数据库</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_connection-&gt;<span class="built_in">setSchema</span>(<span class="keyword">this</span>-&gt;_dbname.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="comment">// LOG("# DE<span class="doctag">BUG:</span> %s\n", "Inited mysql connection");</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnection::refreshAliveTime</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;_aliveTime = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取连接的空闲存活时间（单位毫秒）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">MysqlConnection::getAliveTime</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    chrono::milliseconds active_timestamp_ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(<span class="keyword">this</span>-&gt;_aliveTime.<span class="built_in">time_since_epoch</span>());</span><br><span class="line">    chrono::milliseconds now_timestamp_ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>());</span><br><span class="line">    <span class="keyword">return</span> now_timestamp_ms.<span class="built_in">count</span>() - active_timestamp_ms.<span class="built_in">count</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>MysqlConnectionPool.cpp</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnectionPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = boost::filesystem;</span><br><span class="line"></span><br><span class="line">MysqlConnectionPool::<span class="built_in">MysqlConnectionPool</span>() : _connectionCount(<span class="number">0</span>), _closed(<span class="literal">false</span>) {</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">loadConfigFile</span>()) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to load config file mysql.ini"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始化数量的 MySQL 连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;_initSize; i++) {</span><br><span class="line">        MysqlConnection *connection = <span class="keyword">new</span> <span class="built_in">MysqlConnection</span>();</span><br><span class="line">        <span class="comment">// 连接数据库</span></span><br><span class="line">        <span class="keyword">bool</span> connected = connection-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;_host, <span class="keyword">this</span>-&gt;_username, <span class="keyword">this</span>-&gt;_password, <span class="keyword">this</span>-&gt;_dbname);</span><br><span class="line">        <span class="comment">// 判断是否连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (connected) {</span><br><span class="line">            <span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span><br><span class="line">            connection-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line">            <span class="comment">// 入队操作</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">push</span>(connection);</span><br><span class="line">            <span class="comment">// 计数器加一</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_connectionCount++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后台启动 MySQL 连接的生产者线程</span></span><br><span class="line">    <span class="function">thread <span class="title">produce</span><span class="params">(bind(&amp;MysqlConnectionPool::produceConnection, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">    produce.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后台启动一个扫描线程，定时扫描多余的空闲连接，并释放连接</span></span><br><span class="line">    <span class="function">thread <span class="title">scan</span><span class="params">(bind(&amp;MysqlConnectionPool::scanIdleConnection, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">    scan.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">MysqlConnectionPool::<span class="built_in">MysqlConnectionPool</span>(<span class="keyword">const</span> MysqlConnectionPool &amp;pool) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Not support copy constructor"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">MysqlConnectionPool::~<span class="built_in">MysqlConnectionPool</span>() {</span><br><span class="line">    <span class="comment">// 关闭连接池，释放所有连接</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MysqlConnectionPool *<span class="title">MysqlConnectionPool::getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnectionPool::loadConfigFile</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 配置文件的路径</span></span><br><span class="line">    fs::path configPath = fs::<span class="built_in">current_path</span>().<span class="built_in">concat</span>(<span class="string">"/mysql.ini"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    FILE *file = <span class="built_in">fopen</span>(configPath.<span class="built_in">c_str</span>(), <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s %s\n"</span>, configPath.<span class="built_in">c_str</span>(), <span class="string">"file is not exist"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">"======== mysql.ini ========\n"</span>)</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">feof</span>(file)) {</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">fgets</span>(buffer, <span class="number">1024</span>, file);</span><br><span class="line">        string line = buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置格式：username=root</span></span><br><span class="line">        <span class="keyword">int</span> index = line.<span class="built_in">find</span>(<span class="string">'='</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无效配置项</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> endIndex = line.<span class="built_in">find</span>(<span class="string">'\n'</span>, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理配置项</span></span><br><span class="line">        string key = line.<span class="built_in">substr</span>(<span class="number">0</span>, index);</span><br><span class="line">        string value = line.<span class="built_in">substr</span>(index + <span class="number">1</span>, endIndex - index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="string">"host"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_host = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"username"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_username = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"password"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_password = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"dbname"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_dbname = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"initSize"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_initSize = <span class="built_in">stoi</span>(value);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"maxSize"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_maxSize = <span class="built_in">stoi</span>(value);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"maxIdleTime"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_maxIdleTime = <span class="built_in">stoi</span>(value);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"connectionTimeout"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_connectionTimeout = <span class="built_in">stoi</span>(value);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"%s=%s\n"</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">"======== mysql.ini ========\n\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnectionPool::close</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 判断连接池是否已关闭</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关闭状态</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>())) {</span><br><span class="line">        <span class="comment">// 获取队头的连接</span></span><br><span class="line">        MysqlConnection *phead = <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 出队操作</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 计数器减一</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_connectionCount--;</span><br><span class="line">        <span class="comment">// 释放连接占用的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span> phead;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnectionPool::isClosed</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_closed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MysqlConnectionPool::getSize</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_connectionCount;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;MysqlConnection&gt; <span class="title">MysqlConnectionPool::getConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Connection pool has closed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 While 循环来避免线程虚假唤醒</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 如果连接队列为空，则等待指定的时间</span></span><br><span class="line">        cv_status status = <span class="keyword">this</span>-&gt;_cv.<span class="built_in">wait_for</span>(lock, chrono::<span class="built_in">milliseconds</span>(<span class="keyword">this</span>-&gt;_connectionTimeout));</span><br><span class="line">        <span class="keyword">if</span> (cv_status::timeout == status) {</span><br><span class="line">            <span class="comment">// 如果等待超时，再次判断连接队列是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to get connection, queue is empty"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队头的连接，并返回智能指针，同时自定义智能指针释放资源的方式，将连接归还到队列中</span></span><br><span class="line">    <span class="function">shared_ptr&lt;MysqlConnection&gt; <span class="title">sp</span><span class="params">(<span class="keyword">this</span>-&gt;_connectionQueue.front(), [&amp;](MysqlConnection *pcon) -&gt; <span class="keyword">void</span> {</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 获取互斥锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        unique_lock&lt;mutex&gt; lock(<span class="keyword">this</span>-&gt;_queueMutex);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span></span></span><br><span class="line"><span class="params"><span class="function">        pcon-&gt;refreshAliveTime();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 入队操作（将连接归还到队列中）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span>-&gt;_connectionQueue.push(pcon);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 计数器加一</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span>-&gt;_connectionCount++;</span></span></span><br><span class="line"><span class="params"><span class="function">    })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器减一</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_connectionCount--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 如果连接队列为空，则通知生产线程生产连接</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnectionPool::produceConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 While 循环来避免线程虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (!(<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>())) {</span><br><span class="line">            <span class="comment">// 如果连接队列不为空，生产者线程进入等待状态</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当连接数量没有达到上限，继续创建新的连接</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connectionCount &lt; <span class="keyword">this</span>-&gt;_maxSize) {</span><br><span class="line">            MysqlConnection *connection = <span class="keyword">new</span> <span class="built_in">MysqlConnection</span>();</span><br><span class="line">            <span class="comment">// 连接数据库</span></span><br><span class="line">            <span class="keyword">bool</span> connected = connection-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;_host, <span class="keyword">this</span>-&gt;_username, <span class="keyword">this</span>-&gt;_password, <span class="keyword">this</span>-&gt;_dbname);</span><br><span class="line">            <span class="comment">// 判断是否连接成功</span></span><br><span class="line">            <span class="keyword">if</span> (connected) {</span><br><span class="line">                <span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span><br><span class="line">                connection-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line">                <span class="comment">// 入队操作</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">push</span>(connection);</span><br><span class="line">                <span class="comment">// 计数器加一</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionCount++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者线程可以消费连接了</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnectionPool::scanIdleConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="comment">// 模拟定时扫描连接的效果</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="keyword">this</span>-&gt;_maxIdleTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 While 循环来避免线程虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;_connectionCount &lt;= <span class="keyword">this</span>-&gt;_initSize) {</span><br><span class="line">            <span class="comment">// 如果当前的连接总数量小于等于初始连接数量，扫描线程进入等待状态</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前的连接总数量是否大于初始连接数量</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;_connectionCount &gt; <span class="keyword">this</span>-&gt;_initSize) {</span><br><span class="line">            <span class="comment">// 扫描队头的连接是否超过最大空闲时间</span></span><br><span class="line">            MysqlConnection *phead = <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (phead-&gt;<span class="built_in">getAliveTime</span>() &gt;= <span class="keyword">this</span>-&gt;_maxIdleTime) {</span><br><span class="line">                <span class="comment">// 出队操作</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 计数器减一</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionCount--;</span><br><span class="line">                <span class="comment">// 释放连接占用的内存空间</span></span><br><span class="line">                <span class="keyword">delete</span> phead;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 如果队头的连接没有超过最大空闲时间，那么其他连接肯定也没有超过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化单例对象</span></span><br><span class="line">MysqlConnectionPool *MysqlConnectionPool::INSTANCE = <span class="keyword">new</span> <span class="built_in">MysqlConnectionPool</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="连接池的代码测试"><a href="#连接池的代码测试" class="headerlink" title="连接池的代码测试"></a>连接池的代码测试</h2><div class="admonition note"><p class="admonition-title">提示</p><p>本文的所有 C++ 代码都已经在 Linux 平台下编译并测试通过（基于 Clion 与 G++ 编译器），由于笔者的技术水平有限，暂时无法保证代码没有潜在的 Bug，因此所有 C++ 代码仅供学习参考。</p></div><ul><li>用于创建测试数据库的 SQL 语句 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `cxx_study`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `cxx_study` <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> UTF8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line">USE `cxx_study`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 创建数据库表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `properties`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `properties` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `KEY` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `<span class="keyword">VALUE</span>` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `REMARK` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">27</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 往数据库表插入数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_number'</span>, <span class="string">'430'</span>, <span class="string">'Limit Number'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_balance'</span>, <span class="string">'929.32'</span>, <span class="string">'Limit Balance'</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>用于测试的 C++ 代码（<code>main.cpp</code>）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnection.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnectionPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSqlQuery</span><span class="params">()</span> </span>{</span><br><span class="line">    MysqlConnection *connection = <span class="keyword">new</span> <span class="built_in">MysqlConnection</span>();</span><br><span class="line">    connection-&gt;<span class="built_in">connect</span>(<span class="string">"127.0.0.1:3306"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>, <span class="string">"cxx_study"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> string querySql = <span class="string">"select * from properties where `KEY` = ?"</span>;</span><br><span class="line">    unique_ptr&lt;ResultSet&gt; result = connection-&gt;<span class="built_in">query</span>(querySql.<span class="built_in">c_str</span>(), {<span class="string">"test_limit_number"</span>});</span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Query: "</span> &lt;&lt; querySql &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span> (result-&gt;<span class="built_in">next</span>()) {</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getInt</span>(<span class="string">"ID"</span>) &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"KEY"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"VALUE"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"REMARK"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> connection;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testConnectionPoolSingleThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> string insertSql = <span class="string">"INSERT INTO `properties` (`KEY`, `VALUE`, `REMARK`) VALUES ('test_limit_price', '30.5', 'Limit Price')"</span>;</span><br><span class="line">    MysqlConnectionPool *pool = MysqlConnectionPool::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个线程插入多条记录</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1500</span>; i++) {</span><br><span class="line">        shared_ptr&lt;MysqlConnection&gt; connection = pool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">executeUpdate</span>(insertSql.<span class="built_in">c_str</span>());</span><br><span class="line">        cout &lt;&lt; <span class="string">"Insert "</span> &lt;&lt; i &lt;&lt; <span class="string">" record, current pool size: "</span> &lt;&lt; pool-&gt;<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>, milli&gt; elapsed_time = end_time - start_time;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Times: "</span> &lt;&lt; elapsed_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pool;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testConnectionPoolMultiThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num_threads = <span class="number">15</span>;</span><br><span class="line">    thread threads[num_threads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> string insertSql = <span class="string">"INSERT INTO `properties` (`KEY`, `VALUE`, `REMARK`) VALUES ('test_limit_price', '30.5', 'Limit Price')"</span>;</span><br><span class="line">    MysqlConnectionPool *pool = MysqlConnectionPool::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程插入多条记录</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) {</span><br><span class="line">        threads[i] = <span class="built_in">thread</span>([&amp;, i]() {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">100</span>; n++) {</span><br><span class="line">                shared_ptr&lt;MysqlConnection&gt; connection = pool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">                connection-&gt;<span class="built_in">executeUpdate</span>(insertSql.<span class="built_in">c_str</span>());</span><br><span class="line">                cout &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; i &lt;&lt; <span class="string">", current pool size: "</span> &lt;&lt; pool-&gt;<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) {</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>, milli&gt; elapsed_time = end_time - start_time;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Times: "</span> &lt;&lt; elapsed_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"Pool size: "</span> &lt;&lt; pool-&gt;<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pool;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// testSqlQuery();</span></span><br><span class="line">    <span class="comment">// testConnectionPoolSingleThread();</span></span><br><span class="line">    <span class="built_in">testConnectionPoolMultiThread</span>();</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3600</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="MySQL-编程调试技巧"><a href="#MySQL-编程调试技巧" class="headerlink" title="MySQL 编程调试技巧"></a>MySQL 编程调试技巧</h2><p>在开发数据库连接池项目的时候，会经常出现问题，也就是 MySQL API 调用出错，提示 Insert、Delete、Update 等操作执行失败，或者连接 MySQL Server 失败等，很多人不知道遇到这个问题该怎么办？</p><h3 id="MySQL-C-API-调试"><a href="#MySQL-C-API-调试" class="headerlink" title="MySQL C API 调试"></a>MySQL C API 调试</h3><p>当使用的是 MySQL C API（Connector/C）库，可以使用以下两个函数打印出错时的提示信息：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>int mysql_errno(MYSQL *)</code></td><td>返回上次调用的 MySQL 函数的错误编号。</td></tr><tr><td><code>const char* mysql_error(MYSQL *)</code></td><td>返回上次调用的 MySQL 函数的错误消息。</td></tr></tbody></table><p>无论是 Insert 错误还是其它错误，都可以在代码上通过添加 <code>mysql_error</code> 函数打印错误提示信息（如下所示）。一般通过查看提示就可以知道是什么错误了，例如权限问题，但大部分都是细节错误，比如字段不对、类型不对、表名不对等。</p><p><img data-src="../../../asset/2025/02/cxx-mysql-debug.png"></p><h3 id="MySQL-Connector-C-调试"><a href="#MySQL-Connector-C-调试" class="headerlink" title="MySQL Connector/C++ 调试"></a>MySQL Connector/C++ 调试</h3><p>当使用的是 MySQL Connector/C++（JDBC-Style API）库，可以通过异常来获取错误信息：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="function">unique_ptr&lt;sql::Connection&gt; <span class="title">conn</span><span class="params">(driver-&gt;connect(<span class="string">"tcp://127.0.0.1:3306"</span>, <span class="string">"user"</span>, <span class="string">"password"</span>))</span></span>;</span><br><span class="line">    conn-&gt;<span class="built_in">setSchema</span>(<span class="string">"test_db"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;sql::Statement&gt; <span class="title">stmt</span><span class="params">(conn-&gt;createStatement())</span></span>;</span><br><span class="line">    stmt-&gt;<span class="built_in">execute</span>(<span class="string">"INVALID SQL STATEMENT"</span>); <span class="comment">// 故意执行错误的 SQL</span></span><br><span class="line">} <span class="built_in"><span class="keyword">catch</span></span> (sql::SQLException &amp;e) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"Error Code: "</span> &lt;&lt; e.<span class="built_in">getErrorCode</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"SQL State: "</span> &lt;&lt; e.<span class="built_in">getSQLState</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Message: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过 <code>e.getErrorCode()</code> 获取错误码，<code>e.getSQLState()</code> 获取 SQL 状态码，而 <code>e.what()</code> 获取详细的错误信息。</p><div class="admonition note"><p class="admonition-title">提示</p><p>如果使用的是 MySQL X DevAPI，错误提示信息同样可以通过异常处理来获取得到。</p></div><h2 id="MySQL-的参数调整"><a href="#MySQL-的参数调整" class="headerlink" title="MySQL 的参数调整"></a>MySQL 的参数调整</h2><p>以下命令可以查看 MySQL Server 所支持的最大连接数，当超过 <code>max_connections</code> 数量的连接，MySQL Server 会直接拒绝。因此，在使用连接池增加 MySQL 连接数量的时候，MySQL Server 的 <code>max_connections</code> 参数也要适当地进行调整，以适配连接池的最大连接数（<code>maxSize</code>），否则会大大影响连接池的运行效果。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'max_connections'</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="连接池的压力测试"><a href="#连接池的压力测试" class="headerlink" title="连接池的压力测试"></a>连接池的压力测试</h2><p>验证数据库的插入操作所花费的时间，第一次测试使用普通的数据库访问操作，第二次测试使用带连接池的数据库访问操作，对比两次操作同样数据量所花费的时间，性能压力测试结果如下：</p><table><thead><tr><th>数据量</th><th>未使用连接池所花费时间</th><th>使用连接池所花费时间</th></tr></thead><tbody><tr><td> 1000</td><td> 单线程：1891ms 四线程：497ms</td><td> 单线程：1079ms 四线程：408ms</td></tr><tr><td>5000</td><td> 单线程：10033ms 四线程：2361ms</td><td> 单线程: 5380ms 四线程：2041ms</td></tr><tr><td>10000</td><td> 单线程：19403ms 四线程：4589ms</td><td> 单线程：10522ms 四线程：4034ms</td></tr></tbody></table><h2 id="连接池的代码下载"><a href="#连接池的代码下载" class="headerlink" title="连接池的代码下载"></a>连接池的代码下载</h2><ul><li>数据库连接池项目的完整代码（包括 MySQL Connector/C++ 的头文件和动态链接库）可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-project-db-connection-pool">这里</a> 下载得到，由于笔者的技术水平有限，暂时无法保证代码没有潜在的 Bug，因此所有 C++ 代码仅供学习参考。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/a2a7ad9b.html">C++ 多线程编程之一</a></li><li><a href="/posts/841eca80.html">Linux 系统编程之四多线程编程</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 如何实现 MySQL 数据库连接池</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装 Dubbo Admin 单机教程</title>
    <link href="https://www.techgrow.cn/posts/380adca4.html"/>
    <id>https://www.techgrow.cn/posts/380adca4.html</id>
    <published>2025-01-07T13:12:19.000Z</published>
    <updated>2025-01-07T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/d70c90c.html">Dubbo 管理与监控中心的安装部署</a></li><li><a href="/posts/380adca4.html">Docker 安装 Dubbo Admin 单机教程</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍如何使用 Docker + Docker Compose 安装 Dubbo Admin 单实例，包括 ZooKeeper 与 MySQL 的安装。</p><h3 id="官方资源"><a href="#官方资源" class="headerlink" title="官方资源"></a>官方资源</h3><ul><li><a href="https://github.com/apache/dubbo-admin/wiki">Dubbo Admin 的 Wiki 文档</a></li><li><a href="https://github.com/apache/dubbo-admin">Dubbo Admin 的 GitHub 项目</a></li><li><a href="https://github.com/apache/dubbo-admin/tree/develop/docker">Dubbo Admin 的 Docker 项目</a></li></ul><h3 id="Docker-资源"><a href="#Docker-资源" class="headerlink" title="Docker 资源"></a>Docker 资源</h3><ul><li><a href="https://hub.docker.com/_/mysql">MySQL 镜像地址</a></li><li><a href="https://hub.docker.com/_/zookeeper">ZooKeeper 镜像地址</a></li><li><a href="https://hub.docker.com/r/apache/dubbo-admin">Dubbo Admin 镜像地址</a></li></ul><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="ZooKeeper-安装"><a href="#ZooKeeper-安装" class="headerlink" title="ZooKeeper 安装"></a>ZooKeeper 安装</h3><p>这里使用 ZooKeeper 作为注册中心，Dubbo Admin 会从 ZooKeeper 中获取需要监控的 Dubbo 服务列表。</p><ul><li>创建数据目录，用于存放 ZooKeeper 的数据 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据目录</span></span><br><span class="line">$ sudo mkdir -p /data/zookeeper/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志目录</span></span><br><span class="line">$ sudo mkdir -p /data/zookeeper/datalog</span><br></pre></td></tr></tbody></table></figure><ul><li>创建 Docker Compose 的配置文件，并加入以下 ZooKeeper 容器的配置内容 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi docker-compose.yml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper:2888:3888;2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>核心配置</th><th>配置说明</th></tr></thead><tbody><tr><td><code>ZOO_MY_ID: 1</code></td><td>节点 ID，单机模式下可以固定为 1，如果是集群模式，必须全局唯一。</td></tr><tr><td><code>ZOO_SERVERS: server.1=zookeeper:2888:3888;2181</code></td><td>- 单机模式下的服务地址，如果是集群模式，可以指定多个服务地址（使用空格分隔开）。<br> - 这里的 <code>zookeeper</code> 是在 Docker Compose 中定义的 ZooKeeper 服务的名称，用作其他服务（如 Dubbo Admin）访问 ZooKeeper 的主机名，Docker Compose 会自动将这个名称解析为 ZooKeeper 容器的 IP 地址。</td></tr></tbody></table><ul><li>创建并启动 ZooKeeper 容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker compose up -d</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 ZooKeeper 容器的启动日志 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs zookeeper</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">参考教程</p><ul><li><a href="/posts/1b27acd0.html">Docker 安装 ZooKeeper 单机教程</a></li></ul></div><h2 id="Dubbo-Admin-开始安装"><a href="#Dubbo-Admin-开始安装" class="headerlink" title="Dubbo Admin 开始安装"></a>Dubbo Admin 开始安装</h2><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><ul><li>在宿主机内创建 Dubbo Admin 的 <code>application.properties</code> 配置文件，并根据 Dubbo Admin 镜像的版本，从 <a href="https://github.com/apache/dubbo-admin/tree/develop/docker">这里</a> 获取 <code>application.properties</code> 配置文件对应的内容，比如 <a href="https://github.com/apache/dubbo-admin/blob/develop/docker/0.6.0/application.properties">0.6.0 版本</a></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建配置目录</span></span><br><span class="line">$ sudo mkdir -p /data/dubbo-admin/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件</span></span><br><span class="line">$ sudo touch /data/dubbo-admin/conf/application.properties</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 Dubbo Admin 的 <code>application.properties</code> 配置文件，并写入相应的配置内容，以下配置内容对应是 Dubbo Admin 镜像的 <code>0.6.0</code> 版本 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /data/dubbo-admin/conf/application.properties</span><br></pre></td></tr></tbody></table></figure><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">38080</span></span><br><span class="line"><span class="meta">dubbo.protocol.port</span>=<span class="string">30880</span></span><br><span class="line"><span class="meta">dubbo.application.qos-port</span>=<span class="string">32222</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># centers in dubbo, if you want to add parameters, please add them to the url</span></span><br><span class="line"><span class="meta">admin.registry.address</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br><span class="line"><span class="meta">admin.config-center</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br><span class="line"><span class="meta">admin.metadata-report.address</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># nacos config, add parameters to url like username=nacos&amp;password=nacos</span></span><br><span class="line"><span class="comment">#admin.registry.address=nacos://zookeeper:8848?group=DEFAULT_GROUP&amp;namespace=public</span></span><br><span class="line"><span class="comment">#admin.config-center=nacos://zookeeper:8848?group=dubbo</span></span><br><span class="line"><span class="comment">#admin.metadata-report.address=nacos://zookeeper:8848?group=dubbo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#group (Deprecated it is recommended to use URL to add parameters,will be removed in the future)</span></span><br><span class="line"><span class="comment">#admin.registry.group=dubbo</span></span><br><span class="line"><span class="comment">#admin.config-center.group=dubbo</span></span><br><span class="line"><span class="comment">#admin.metadata-report.group=dubbo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#namespace used by nacos. (Deprecated it is recommended to use URL to add parameters,will be removed in the future)</span></span><br><span class="line"><span class="comment">#admin.registry.namespace=public</span></span><br><span class="line"><span class="comment">#admin.config-center.namespace=public</span></span><br><span class="line"><span class="comment">#admin.metadata-report.namespace=public</span></span><br><span class="line"></span><br><span class="line"><span class="meta">admin.root.user.name</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">admin.root.user.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#session timeout, default is one hour</span></span><br><span class="line"><span class="meta">admin.check.sessionTimeoutMilli</span>=<span class="string">3600000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># apollo config</span></span><br><span class="line"><span class="comment"># admin.config-center = apollo://localhost:8070?token=e16e5cd903fd0c97a116c873b448544b9d086de9&amp;app.id=test&amp;env=dev&amp;cluster=default&amp;namespace=dubbo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># (Deprecated it is recommended to use URL to add parameters,will be removed in the future)</span></span><br><span class="line"><span class="comment">#admin.apollo.token=e16e5cd903fd0c97a116c873b448544b9d086de9</span></span><br><span class="line"><span class="comment">#admin.apollo.appId=test</span></span><br><span class="line"><span class="comment">#admin.apollo.env=dev</span></span><br><span class="line"><span class="comment">#admin.apollo.cluster=default</span></span><br><span class="line"><span class="comment">#admin.apollo.namespace=dubbo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#compress</span></span><br><span class="line"><span class="meta">server.compression.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">server.compression.mime-types</span>=<span class="string">text/css,text/javascript,application/javascript</span></span><br><span class="line"><span class="meta">server.compression.min-response-size</span>=<span class="string">10240</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#token timeout, default is one hour</span></span><br><span class="line"><span class="meta">admin.check.tokenTimeoutMilli</span>=<span class="string">3600000</span></span><br><span class="line"><span class="comment">#Jwt signingKey</span></span><br><span class="line"><span class="meta">admin.check.signSecret</span>=<span class="string">86295dd0c4ef69a1036b0b0c15158d77</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#dubbo config</span></span><br><span class="line"><span class="meta">dubbo.application.name</span>=<span class="string">dubbo-admin</span></span><br><span class="line"><span class="meta">dubbo.registry.address</span>=<span class="string">${admin.registry.address}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># mysql</span></span><br><span class="line"><span class="comment">#spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#spring.datasource.url=jdbc:mysql://localhost:3306/dubbo-admin?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=10000&amp;autoReconnect=true</span></span><br><span class="line"><span class="comment">#spring.datasource.username=root</span></span><br><span class="line"><span class="comment">#spring.datasource.password=mysql</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># h2</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:h2:mem:~/dubbo-admin;MODE=MYSQL;</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># id generate type</span></span><br><span class="line"><span class="meta">mybatis-plus.global-config.db-config.id-type</span>=<span class="string">none</span></span><br><span class="line"></span><br><span class="line"><span class="meta">dubbo.application.logger</span>=<span class="string">slf4j</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>核心配置</th><th>配置说明</th></tr></thead><tbody><tr><td><code>server.port=38080</code></td><td>Dubbo Admin 的 Web 服务端口</td></tr><tr><td><code>dubbo.protocol.port=30880</code></td><td>Dubbo 协议的端口</td></tr><tr><td><code>dubbo.application.qos-port=32222</code></td><td>Dubbo QOS 服务的端口</td></tr><tr><td><code>admin.root.user.name=root</code></td><td>Dubbo Admin 中 <code>root</code> 用户的名称，用于登录 Dubbo Admin 控制台</td></tr><tr><td><code>admin.root.user.password=root</code></td><td>Dubbo Admin 中 <code>root</code> 用户的密码，用于登录 Dubbo Admin 控制台</td></tr><tr><td><code>admin.registry.address</code></td><td>注册中心地址，当使用 ZooKeeper 作为注册中心，则必须指定为 <code>zookeeper://zookeeper:2181</code>。如果连接的是 ZooKeeper 集群，那么 <code>zookeeper://</code> 后面使用逗号分隔开多个集群节点的地址。</td></tr><tr><td><code>admin.config-center</code></td><td>配置中心地址，当使用 ZooKeeper 作为配置中心，则必须指定为 <code>zookeeper://zookeeper:2181</code>。如果连接的是 ZooKeeper 集群，那么 <code>zookeeper://</code> 后面使用逗号分隔开多个集群节点的地址。</td></tr><tr><td><code>admin.metadata-report.address</code></td><td>元数据中心地址，当使用 ZooKeeper 作为元数据中心，则必须指定为 <code>zookeeper://zookeeper:2181</code>。如果连接的是 ZooKeeper 集群，那么 <code>zookeeper://</code> 后面使用逗号分隔开多个集群节点的地址。</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">Dubbo Admin 官方文档</p><ul><li><a href="https://github.com/apache/dubbo-admin/wiki/Dubbo-Admin%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E">Dubbo Admin 官方配置说明</a></li></ul></div><h3 id="创建-Docker-容器"><a href="#创建-Docker-容器" class="headerlink" title="创建 Docker 容器"></a>创建 Docker 容器</h3><ul><li>编辑 Docker Compose 的配置文件，并加入以下 Dubbo Admin 容器的配置内容 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi docker-compose.yml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper:2888:3888;2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/dubbo-admin/conf:/config</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建并启动 Dubbo Admin 容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker compose up -d</span><br></pre></td></tr></tbody></table></figure><blockquote><p>若不希望指定 Dubbo Admin 的 <code>application.properties</code> 配置文件，而是想让 Docker Compose 通过环境变量来配置 Dubbo Admin，可以参考 <a href="https://github.com/apache/dubbo-admin/blob/develop/docker/stack.yml">这里</a> 的 YML 配置内容，配置示例如下：</p></blockquote><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line"></span><br><span class="line">  <span class="string">......</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.registry.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.config-center=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.metadata-report.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.application.name=dubbo-admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.registry.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.url=jdbc:h2:mem:~/dubbo-admin;MODE=MYSQL;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.username=sa</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><h3 id="验证-Docker-容器"><a href="#验证-Docker-容器" class="headerlink" title="验证 Docker 容器"></a>验证 Docker 容器</h3><p>浏览器通过 <code>http://192.168.1.235:38080</code> 访问 Dubbo Admin 的控制台页面，请自行将 IP 地址 <code>192.168.1.235</code> 更改为 Dubbo Admin 容器的真实 IP 地址，默认的登录用户名和密码是 <code>root /root</code>。</p><p><img data-src="../../../asset/2025/01/dubbo-admin-1.png"></p><h2 id="Dubbo-Admin-数据持久化"><a href="#Dubbo-Admin-数据持久化" class="headerlink" title="Dubbo Admin 数据持久化"></a>Dubbo Admin 数据持久化</h2><p>在默认情况下，Dubbo Admin 使用的是 H2 嵌入式数据库（内存模式），应用重启后会丢失监控数据，建议使用 MySQL 来存储 Dubbo Admin 的监控数据。</p><h3 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h3><ul><li>创建数据目录，用于存放 MySQL 的数据 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p /data/mysql</span><br></pre></td></tr></tbody></table></figure><ul><li>创建 Jar 包目录，并下载 MySQL 的驱动包 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Jar 包目录</span></span><br><span class="line">$ sudo mkdir -p /data/dubbo-admin/opt-libs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 MySQL 驱动包</span></span><br><span class="line">$ sudo wget -P /data/dubbo-admin/opt-libs https://repo1.maven.org/maven2/com/mysql/mysql-connector-j/8.2.0/mysql-connector-j-8.2.0.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件授权访问</span></span><br><span class="line">$ sudo chmod -R 777 /data/dubbo-admin/opt-libs</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 Docker Compose 的配置文件，并加入以下 MySQL 容器的配置内容 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi docker-compose.yml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.4.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"mysqld"</span>, <span class="string">"--mysql-native-password=ON"</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_HOST:</span> <span class="string">'%'</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/mysql:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper:2888:3888;2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/dubbo-admin/conf:/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/dubbo-admin/opt-libs:/opt-libs</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>核心配置</th><th>配置说明</th></tr></thead><tbody><tr><td><code>MYSQL_ROOT_HOST: '%'</code></td><td>允许 root 用户远程访问</td></tr><tr><td><code>MYSQL_ROOT_PASSWORD: root</code></td><td>设置 root 用户的密码</td></tr><tr><td><code>MYSQL_DATABASE: dubbo-admin</code></td><td>容器启动时自动创建指定的数据库</td></tr><tr><td><code>command: ["mysqld", "--mysql-native-password=ON"]</code></td><td>启用 MySQL 传统的身份认证插件</td></tr></tbody></table><ul><li>编辑 Dubbo Admin 的 <code>application.properties</code> 配置文件，添加 MySQL 数据库的配置，并注释掉 H2 数据库的配置。<strong>特别注意，MySQL 8 的驱动类是 <code>com.mysql.cj.jdbc.Driver</code>，而不是 <code>com.mysql.jdbc.Driver</code>。</strong></li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://mysql:3306/dubbo-admin?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;rewriteBatchedStatements=true&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># h2</span></span><br><span class="line"><span class="comment"># spring.datasource.url=jdbc:h2:mem:~/dubbo-admin;MODE=MYSQL;</span></span><br><span class="line"><span class="comment"># spring.datasource.username=sa</span></span><br><span class="line"><span class="comment"># spring.datasource.password=</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>若不希望指定 Dubbo Admin 的 <code>application.properties</code> 配置文件，而是想让 Docker Compose 通过环境变量来配置 Dubbo Admin，可以参考 <a href="https://github.com/apache/dubbo-admin/blob/develop/docker/stack.yml">这里</a> 的 YML 配置内容，配置示例如下：</p></blockquote><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line"></span><br><span class="line">  <span class="string">......</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.registry.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.config-center=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.metadata-report.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.application.name=dubbo-admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.registry.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.url=jdbc:mysql://mysql:3306/dubbo-admin?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;rewriteBatchedStatements=true&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.username=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.password=root</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/dubbo-admin/opt-libs:/opt-libs</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建并启动 MySQL 容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker compose up -d</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 MySQL 容器的启动日志 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs mysql</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Dubbo Admin 容器的启动日志 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs dubbo-admin</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">参考教程</p><ul><li><a href="/posts/2669f243.html">Docker 安装 MySQL 8 教程</a></li></ul></div><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="连接-ZooKeeer-集群"><a href="#连接-ZooKeeer-集群" class="headerlink" title="连接 ZooKeeer 集群"></a>连接 ZooKeeer 集群</h3><p>若 Dubbo Admin 连接的是 ZooKeeper 集群，那么可以参考以下的 Docker Compose 配置内容：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper01</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">ruok</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper01/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper01/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper02</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper02</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">ruok</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper02/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper02/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper03</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper03</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">ruok</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper03/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper03/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.registry.address=zookeeper://zookeeper01:2181,zookeeper02:2181,zookeeper03:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.config-center=zookeeper://zookeeper01:2181,zookeeper02:2181,zookeeper03:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.metadata-report.address=zookeeper://zookeeper01:2181,zookeeper02:2181,zookeeper03:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.application.name=dubbo-admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.registry.address=zookeeper://zookeeper01:2181,zookeeper02:2181,zookeeper03:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.url=jdbc:h2:mem:~/dubbo-admin;MODE=MYSQL;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.username=sa</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">zookeeper01:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper02:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper03:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">参考教程</p><ul><li><a href="/posts/496af1ce.html">Docker 搭建 ZooKeeper 集群教程</a></li></ul></div><h3 id="使用-Nacos-注册中心"><a href="#使用-Nacos-注册中心" class="headerlink" title="使用 Nacos 注册中心"></a>使用 Nacos 注册中心</h3><ul><li><p>(1) 首先通过 Docker Compose 安装 Nacos，详细教程请看<a href="/posts/1326ecd9.html">《Docker 安装单机版的 Nacos 与 MySQL 8》</a></p></li><li><p>(2) 然后更改上面的 Docker Compose 配置文件，通过环境变量指定 Nacos 的连接地址（比如 <code>nacos://nacos:8848</code>）</p></li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line"></span><br><span class="line">  <span class="string">......</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.registry.address=nacos://nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.config-center=nacos://nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.metadata-report.address=nacos://nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.application.name=dubbo-admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.registry.address=nacos://nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.url=jdbc:h2:mem:~/dubbo-admin;MODE=MYSQL;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.username=sa</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><h3 id="无法加载-MySQL-驱动类"><a href="#无法加载-MySQL-驱动类" class="headerlink" title="无法加载 MySQL 驱动类"></a>无法加载 MySQL 驱动类</h3><p>Dubbo Admin 容器在启动时，抛出 <code>Cannot load driver class: com.mysql.cj.jdbc.Driver</code> 异常。解决方法如下：</p><ul><li>(1) 在宿主机中下载 MySQL 的驱动包，并将其挂载到 Dubbo Admin 容器内的 <code>/opt-libs</code> 目录下</li><li> (2) 如果还是加载不到 MySQL 的驱动类，只能更改 Dubbo Admin 项目源码中的 <code>dubbo-admin-server</code> 模块的 <a href="https://github.com/apache/dubbo-admin/blob/develop/dubbo-admin-server/pom.xml#L205">Maven 配置文件</a>，加入 MySQL 驱动的 Maven 依赖，然后通过 Dubbo Admin 项目的源码手动构建 Docker 镜像（构建步骤可以参考<a href="https://github.com/apache/dubbo-admin/tree/develop/docker">这里</a>）。</li></ul><h3 id="无法查看服务的元数据信息"><a href="#无法查看服务的元数据信息" class="headerlink" title="无法查看服务的元数据信息"></a>无法查看服务的元数据信息</h3><p>在 Dubbo Admin 控制台中，无法查看服务提供者的元数据信息，如下图所示：</p><p><img data-src="../../../asset/2025/01/dubbo-admin-metadata-error.png"></p><ul><li>(1) 首先确保 Dubbo Admin 配置了以下几个属性：</li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">admin.registry.address</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br><span class="line"><span class="meta">admin.config-center</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br><span class="line"><span class="meta">admin.metadata-report.address</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 在服务提供者的代码中，添加元数据中心的配置（<code>&lt;dubbo:metadata-report/&gt;</code>），完整的配置示例如下：</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置服务应用名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-provider-application"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.enable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.port"</span> <span class="attr">value</span>=<span class="string">"22222"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.accept.foreign.ip"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 注册中心配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://192.168.2.235:2181"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 元数据中心配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:metadata-report</span> <span class="attr">address</span>=<span class="string">"zookeeper://192.168.2.235:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置服务协议 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启 Dubbo 的注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.clay.dubbo.producer"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://dubbo.apache.org/zh-cn/overview/tasks/deploy/deploy-on-docker/">Dubbo 官方文档</a></li><li><a href="https://blog.csdn.net/qq_43135259/article/details/130007208">Docker 安装 Dubbo Admin 与 Zookeeper</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Docker 如何安装 Dubbo Admin，包括 ZooKeeper 与 MySQL 的安装。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之六</title>
    <link href="https://www.techgrow.cn/posts/a4fe8225.html"/>
    <id>https://www.techgrow.cn/posts/a4fe8225.html</id>
    <published>2024-12-25T13:55:33.000Z</published>
    <updated>2024-12-25T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><span id="more"></span><h2 id="近容器"><a href="#近容器" class="headerlink" title="近容器"></a>近容器</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>在 C++ 中，常见的近容器有以下几种：</p><ul><li>数组</li><li> string</li><li>bitset</li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>在 C++ 中，常见的迭代器有以下几种：</p><ul><li><code>iterator</code> 和 <code>const_iterator</code></li><li><code>reverse_iterator</code> 和 <code>const_reverse_iterator</code></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>在 C++ 中，<code>iterator</code> 迭代器是从 <code>const_iterator</code> 迭代器继承而来的。</p></div><h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++) {</span><br><span class="line">        v1.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span>  + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>(); it!= v1.<span class="built_in">end</span>(); ++it){</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> ==<span class="number">0</span> ){</span><br><span class="line">            <span class="comment">// 可以赋值</span></span><br><span class="line">            *it = *it + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量的正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::const_iterator it = v1.<span class="built_in">begin</span>(); it!= v1.<span class="built_in">end</span>(); ++it){</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> ==<span class="number">0</span> ){</span><br><span class="line">            <span class="comment">// 错误写法，不可以赋值</span></span><br><span class="line">            <span class="comment">// *it = *it + 1;</span></span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = v1.<span class="built_in">rbegin</span>(); it!= v1.<span class="built_in">rend</span>(); ++it){</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> ==<span class="number">0</span> ){</span><br><span class="line">            <span class="comment">// 可以赋值</span></span><br><span class="line">            *it = *it + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量的反向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator it = v1.<span class="built_in">rbegin</span>(); it!= v1.<span class="built_in">rend</span>(); ++it){</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> ==<span class="number">0</span> ){</span><br><span class="line">            <span class="comment">// 错误写法，不可以赋值</span></span><br><span class="line">            <span class="comment">// *it = *it + 1;</span></span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">25 93 69 85 75 19 79 39 13 19</span><br><span class="line">25 93 69 85 75 19 79 39 13 19</span><br><span class="line">19 13 39 79 19 75 85 69 93 25</span><br><span class="line">19 13 39 79 19 75 85 69 93 25</span><br></pre></td></tr></tbody></table></figure><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><h3 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h3><ul><li>C++ 中的函数对象，其作用类似 C 语言中的函数指针。</li><li>在 C++ 中，将拥有 <code>operator()</code> 小括号运算符重载函数的对象称作 “函数对象”，或者称作 “仿函数”。</li><li>通过函数对象调用 <code>operator ()</code>，会产生内联的效果，其执行效率比较高，因为没有函数调用的开销。</li><li>由于函数对象是使用类生成的，因此函数对象可以拥有相关的成员变量，比如可以通过成员变量来记录函数对象的使用次数。</li><li>在 C++ 中，常见的函数对象有：<code>less</code>、<code>greater</code>。</li></ul><h3 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h3><p>这里主要演示 C++ 中函数指针的使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">my_greater</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">my_less</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compare 是 C++ 的库函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b, Compare func)</span> </span>{</span><br><span class="line">    <span class="comment">// 这里通过函数指针调用函数，是没办法实现内联的（即使通过 inline 关键字将目标函数声明为内联函数），执行效率较低，因为有函数调用的开销</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">3</span>, my_greater&lt;<span class="keyword">int</span>&gt;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">3</span>, my_less&lt;<span class="keyword">int</span>&gt;) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h3><p>这里主要演示 C++ 中函数对象的使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mygreater</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myless</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compare 是 C++ 的库函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b, Compare func)</span> </span>{</span><br><span class="line">    <span class="comment">// 这里调用函数对象，会产生内联，执行效率比较高，没有函数调用的开销</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">3</span>, mygreater&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">3</span>, myless&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码三"><a href="#案例代码三" class="headerlink" title="案例代码三"></a>案例代码三</h3><p>这里主要演示如何在 C++ 的 STL 中使用函数对象。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象，让优先级队列里的元素从小到大排序（默认从大到小排序）</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        q1.<span class="built_in">push</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; q1.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象，让有序集合里的元素从大到小排序（默认从小到大排序）</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; s1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        s1.<span class="built_in">insert</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">4 64 45 55 2 82 62 84 51 74 </span><br><span class="line">2 4 45 51 55 62 64 74 82 84 </span><br><span class="line">============ test02() ============</span><br><span class="line">40 8 50 65 100 26 48 34 43 43 </span><br><span class="line">100 65 50 48 43 40 34 26 8 </span><br></pre></td></tr></tbody></table></figure><h2 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h2><h3 id="概念介绍-3"><a href="#概念介绍-3" class="headerlink" title="概念介绍"></a>概念介绍</h3><ul><li>C++ 泛型算法 = 模板（Template） + 迭代器 + 函数对象。</li><li>C++ 泛型算法的参数接收的都是迭代器，而且还可以接收函数对象。</li><li>C++ 常见的泛型算法有以下几种：<ul><li><code>sort</code>：排序算法</li><li><code>find</code>：查找算法</li><li><code>find_if</code>：条件查找算法</li><li><code>binary_search</code>：二分查找算法</li><li><code>for_each</code>：遍历算法</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>二分查找算法（<code>binary_search</code>）并不适用于降序排序（从大到小）的容器，只适用于升序排序（从小到大）的容器，因为它默认是按照升序排序来查找元素的。</p></div><h3 id="案例代码一-1"><a href="#案例代码一-1" class="headerlink" title="案例代码一"></a>案例代码一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> arr[] = {<span class="number">12</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">39</span>, <span class="number">25</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">58</span>};</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : v1) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序算法（默认升序排序，即从小到大排序）</span></span><br><span class="line">    <span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者降序排序（从大到小）</span></span><br><span class="line">    <span class="comment">// sort(v1.begin(), v1.end(), greater&lt;int&gt;());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : v1) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找算法（不要求容器按顺序存储元素）</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it1 = <span class="built_in">find</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span> (it1 != v1.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"found number 48"</span> &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not found 48"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找算法，只适用于升序排序（从小到大）的容器，如果容器的元素是按降序排序（从大到小），否则二分查找算法无法正常工作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">binary_search</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="number">25</span>)) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"found number 25"</span> &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not found 25"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12 23 7 11 39 25 45 48 58 </span><br><span class="line">7 11 12 23 25 39 45 48 58 </span><br><span class="line">found number 48</span><br><span class="line">found number 25</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码二-1"><a href="#案例代码二-1" class="headerlink" title="案例代码二"></a>案例代码二</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> arr[] = {<span class="number">22</span>, <span class="number">33</span>, <span class="number">8</span>, <span class="number">21</span>, <span class="number">59</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">63</span>, <span class="number">70</span>};</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序算法（默认升序排序，即从小到大排序）</span></span><br><span class="line">    <span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : v1) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件查找算法，将 48 按顺序插入到 vector 容器中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用绑定器（已过时的写法）</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it2 = <span class="built_in">find_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">48</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用绑定器（现代 C++ 的写法）</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator it2 = find_if(v1.begin(), v1.end(), bind(greater&lt;int&gt;(), placeholders::_1, 48));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用绑定器（Lambda 表达式的写法）</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator it2 = find_if(v1.begin(), v1.end(), [](int val) -&gt; bool { return val &gt; 48; });</span></span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">insert</span>(it2, <span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : v1) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 21 22 33 35 55 59 63 70 </span><br><span class="line">8 21 22 33 35 48 55 59 63 70 </span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码三-1"><a href="#案例代码三-1" class="headerlink" title="案例代码三"></a>案例代码三</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        v1.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : v1) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历算法</span></span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), [](<span class="keyword">int</span> val) -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="comment">// 打印所有偶数</span></span><br><span class="line">        <span class="keyword">if</span> (val % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">46 81 98 43 35 60 61 68 77 96 </span><br><span class="line">46 98 60 68 96 </span><br></pre></td></tr></tbody></table></figure><h2 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h2><div class="admonition note"><p class="admonition-title">提示</p><ul><li>下述面试题都来自 "商汤科技" 的一面，难度属于是简单级别。</li></ul></div><ul><li><p>(1) 程序的内存布局</p><ul><li>从下往上分别是：<code>.text</code> 、<code>.rodata</code>、<code>.data</code>、<code>.bss</code>、堆、栈、内核空间，<a href="../../../asset/2024/11/process-address.png">如图所示</a></li></ul></li><li><p> (2) 堆和栈的区别</p><ul><li>堆内存由用户分配（<code>new</code>），而栈内存由系统分配（函数调用时）</li><li>堆内存的数据结构通常是二叉堆、大根堆、小根堆，而栈内存的数据结构是栈</li></ul></li><li><p> (3) 函数调用的参数是怎样传递的</p><ul><li>通过汇编代码的分析，可以知道底层是通过压栈的方式来传递参数</li></ul></li><li><p> (4) 函数调用的参数是按什么顺序传递的</p><ul><li>函数调用是从右往左传递参数</li></ul></li><li><p> (5) 为什么函数调用的参数要从右往左压栈</p><ul><li>因为 C/C++ 需要支持可变参函数（即函数的参数数量不确定）</li><li>C 语言的可变参数函数，缺乏类型安全 <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统 C 语言风格的可变参数函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> num, ...)</span> </span>{</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, num); <span class="comment">// 初始化 args，num 是可变参数的第一个参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) {</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">va_arg</span>(args, <span class="keyword">int</span>); <span class="comment">// 获取下一个参数</span></span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">va_end</span>(args); <span class="comment">// 清理</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">3</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);     <span class="comment">// 输出：10 20 30</span></span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C++ 可变模板参数函数，提供了类型安全，并且能更灵活地处理不同类型的参数 <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变模板参数函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(Args... args)</span> </span>{</span><br><span class="line">    <span class="comment">// 使用折叠表达式打印参数</span></span><br><span class="line">    ((cout &lt;&lt; args &lt;&lt; <span class="string">" "</span>), ...);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);       <span class="comment">// 输出：10 20 30</span></span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);    <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>(6) 有以下一个函数 <code>func</code></p><ul><li>主函数里面通过 <code>string s = func(s1, s2);</code> 调用该函数，说一下调用了什么构造函数和调用顺序，以及析构函数的调用顺序<ul><li>关键考点：如果用临时对象去拷贝构造新对象，那么临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化，<a href="../../../asset/2025/02/cxx-interview-string.png">如图所示</a></li></ul></li><li>如果在 <code>func</code> 函数内写成 <code>return s1 + s2;</code>，这与原来的写法有什么区别<ul><li>省略了原来字符串对象 <code>tmp</code> 的构造函数和析构函数的调用 <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">func</span><span class="params">(string s1, string s2)</span> </span>{</span><br><span class="line">    string tmp = s1 + s2;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>(7) 在一个结构体里面定义一个 <code>char</code> 和 <code>double</code> 变量，它的内存布局是怎样的</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> {</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Data) &lt;&lt; endl;  <span class="comment">// 输出 16</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>char a</code> 占 1 字节</li><li><code>double b</code> 占 8 字节，并且通常需要 8 字节对齐。</li><li>由于 <code>char a</code> 只有 1 字节，而 <code>double b</code> 需要 8 字节对齐，因此编译器会在 <code>a</code> 之后填充 7 个字节，使 <code>b</code> 在 8 字节边界对齐，最终 <code>sizeof(Data) = 16</code>。</li></ul></li><li><p>(8) 空结构体占用多少个字节</p><ul><li>C++ 中，空结构体占用 1 个字节</li><li> C 语言中，空结构体占用 0 个字节</li></ul></li><li><p> (9) 如何防止指针使用带来的内存泄漏</p><ul><li>使用带引用计数的智能指针：<code>share_ptr</code></li><li>使用不带引用计数的智能指针：<code>unique_ptr</code>、<code>scoped_ptr</code>、<code>auto_ptr</code></li><li>使用特殊的智能指针：<code>weak_ptr</code>（不增加引用计数，但可用于观察 <code>shared_ptr</code> 管理的资源）</li></ul></li></ul><table><thead><tr><th>智能指针</th><th>所有权</th><th>带引用计数</th><th>适用场景</th></tr></thead><tbody><tr><td><code>unique_ptr</code></td><td>独占</td><td>否</td><td>资源独占，生命周期明确</td></tr><tr><td><code>shared_ptr</code></td><td>共享</td><td>是</td><td>资源共享，生命周期不固定</td></tr><tr><td><code>scoped_ptr</code></td><td>独占</td><td>否</td><td>生命周期受限于作用域，适用于简单的场景，避免资源泄漏</td></tr><tr><td><code>weak_ptr</code></td><td>观察 <code>shared_ptr</code></td><td>否</td><td>避免 <code>shared_ptr</code> 循环引用</td></tr><tr><td><code>auto_ptr</code></td><td>独占（拷贝时转移）</td><td>否</td><td>⚠ 已废弃，建议改用 <code>unique_ptr</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之五</title>
    <link href="https://www.techgrow.cn/posts/52e74a26.html"/>
    <id>https://www.techgrow.cn/posts/52e74a26.html</id>
    <published>2024-12-21T13:55:33.000Z</published>
    <updated>2024-12-21T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="STL-中的容器汇总"><a href="#STL-中的容器汇总" class="headerlink" title="STL 中的容器汇总"></a>STL 中的容器汇总</h3><ul><li><strong>顺序容器</strong></li></ul><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构</th></tr></thead><tbody><tr><td><code>vector</code></td><td>动态数组容器，支持快速随机访问，尾部插入删除效率高</td><td>连续线性数组</td></tr><tr><td><code>deque</code></td><td>双端队列容器，支持头尾快速插入删除</td><td>支持动态扩展的二维数组结构（分段连续空间）</td></tr><tr><td><code>list</code></td><td>双向链表容器，插入 / 删除效率高，不支持随机访问</td><td>双向链表</td></tr></tbody></table><ul><li><strong>有序关联容器（底层为红黑树）</strong></li></ul><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构</th></tr></thead><tbody><tr><td><code>set</code></td><td>不可重复集合，自动按 key 排序</td><td>红黑树</td></tr><tr><td><code>map</code></td><td>键值对映射表，key 唯一，自动按 key 排序</td><td>红黑树</td></tr><tr><td><code>multiset</code></td><td>可重复元素集合，自动按 key 排序</td><td>红黑树</td></tr><tr><td><code>multimap</code></td><td>可重复键的映射表，自动按 key 排序</td><td>红黑树</td></tr></tbody></table><ul><li><strong>无序关联容器（底层为哈希表）</strong></li></ul><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构</th></tr></thead><tbody><tr><td><code>unordered_set</code></td><td>无序集合，key 唯一，查找效率高</td><td>哈希表（开链法）</td></tr><tr><td><code>unordered_map</code></td><td>无序映射表，key 唯一，存储 <code>&lt;key, value&gt;</code> 键值对</td><td>哈希表（开链法）</td></tr><tr><td><code>unordered_multiset</code></td><td>无序集合，元素可重复</td><td>哈希表（开链法）</td></tr><tr><td><code>unordered_multimap</code></td><td>无序映射表，key 可重复</td><td>哈希表（开链法）</td></tr></tbody></table><ul><li><strong>容器适配器</strong></li></ul><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构（默认）</th></tr></thead><tbody><tr><td><code>stack</code></td><td>后进先出（LIFO）栈结构</td><td><code>deque</code></td></tr><tr><td><code>queue</code></td><td>先进先出（FIFO）队列</td><td><code>deque</code></td></tr><tr><td><code>priority_queue</code></td><td>优先队列，自动排序</td><td>堆（默认最大堆，用 <code>vector</code> + <code>make_heap</code> 实现）</td></tr></tbody></table><ul><li><strong>近容器</strong></li></ul><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构</th></tr></thead><tbody><tr><td><code>array</code></td><td>固定大小的数组容器，编译期确定大小</td><td>静态数组（连续内存）</td></tr><tr><td><code>string</code></td><td>字符串容器，支持动态扩展与字符串操作</td><td>动态字符数组</td></tr><tr><td><code>bitset</code></td><td>定长位集容器，适合二进制标志管理</td><td>位数组（每个位单独存储）</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><p>STL 中的哈希表采用开链法（Separate Chaining）解决哈希冲突，桶结构的底层可能是链表或更优化的数据结构（如 C++ 17 后可用链表 + 跳表等）。</p></div><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h4><p>vector 底层所采用的数据结构是线性连续空间（单向开口的连续内存空间），可以理解为支持动态开辟内存空间的数组。vector 往尾部添加或移除元素的效率非常高，但是往头部或者中部插入元素或移除元素则比较耗时。<strong>特别注意，vector 一旦需要执行扩容操作，那么每次都会以原来空间大小的 2 倍进行扩容。</strong></p><p><img data-src="../../../asset/2025/01/cplusplus-vector-1.png"></p><ul><li><p>声明</p><ul><li><code>vector&lt;int&gt; vec;</code></li></ul></li><li><p>插入</p><ul><li><code>vec.push_back(20)</code>，往容器尾部插入元素，会导致容器扩容</li><li><code>vec.insert(iterator, 30)</code>，往迭代器指向的位置插入元素，会导致容器扩容</li></ul></li><li><p>删除</p><ul><li><code>vec.pop_back()</code>，删除容器尾部的元素</li><li><code>vec.erase(iterator)</code>，删除迭代器指向的元素</li></ul></li><li><p>查询</p><ul><li><code>vec[5]</code>，基于下标的随机访问</li><li><code>iterator</code>，迭代器遍历</li><li><code>for_each</code>，循环遍历</li><li><code>find</code>，查找元素</li></ul></li><li><p>其他</p><ul><li><code>vec.size()</code>，获取容器中元素数量</li><li><code>vec.empty()</code>，判断容器是否为空</li><li><code>vec.swap(vec2)</code>，交换两个容器的元素</li><li><code>vec.reserve(size)</code>，预留容器空间，只会给容器的底层开辟指定大小的内存空间，并不会添加新的元素，主要用于减少频繁扩容的次数</li><li><code>vec.resize(size)</code>，重新指定容器的大小，不仅会给容器的底层开辟指定大小的内存空间，还会以默认值填充新的位置</li><li><code>vec.resize(size, item)</code>，重新指定容器的大小，不仅会给容器的底层开辟指定大小的内存空间，还会以指定值填充新的位置</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>对 vector 容器进行连续的插入（<code>insert</code>）或者删除（<code>erase</code>）操作时，一定要更新迭代器；否则第一次插入或删除操作完成后，迭代器就会失效。</p></div><h4 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="comment">// 往容器尾部插入元素</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中元素数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于下标访问元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"vec[3] = "</span> &lt;&lt; vec[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"================================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中所有的偶数元素全部删除</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 连续删除元素后必须更新迭代器，否则迭代器会失效</span></span><br><span class="line">            it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        cout &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"================================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器中所有的奇数元素前面都添加一个偶数</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 连续插入元素后必须更新迭代器，否则迭代器会失效</span></span><br><span class="line">            it = vec.<span class="built_in">insert</span>(it, *it - <span class="number">1</span>);</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        cout &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size: 10</span><br><span class="line">94 80 7 45 20 57 74 73 16 19 </span><br><span class="line">vec[3] = 45</span><br><span class="line">================================</span><br><span class="line">7 45 57 73 19 </span><br><span class="line">================================</span><br><span class="line">6 7 44 45 56 57 72 73 18 19 </span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器的默认大小是 0，当插入元素时，容器大小会按照 0 1 2 4 8 16 ... 来扩容</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预留空间，只会给容器的底层开辟指定大小的内存空间，并不会添加新的元素，主要用于减少频繁扩容的次数</span></span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"================================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器的默认大小是 0，当插入元素时，容器大小会按照 0 1 2 4 8 16 ... 来扩容</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec2;</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec2.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定容器的大小，不仅会给容器的底层开辟指定大小的内存空间，还会填充新的位置</span></span><br><span class="line">    <span class="comment">// 若容器变大，则以默认值（0）填充新位置。如果容器变小，则末尾超出容器大小的元素会被删除</span></span><br><span class="line">    vec2.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec2.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        vec2.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec2.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">size: 0</span><br><span class="line">empty: true</span><br><span class="line">size: 0</span><br><span class="line">empty: true</span><br><span class="line">size: 10</span><br><span class="line">empty: false</span><br><span class="line">================================</span><br><span class="line">size: 0</span><br><span class="line">empty: true</span><br><span class="line">size: 10</span><br><span class="line">empty: false</span><br><span class="line">size: 20</span><br><span class="line">empty: false</span><br></pre></td></tr></tbody></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><h4 id="容器介绍-1"><a href="#容器介绍-1" class="headerlink" title="容器介绍"></a>容器介绍</h4><p><strong>deque 一种双向开口的连续线性空间（双端队列容器），底层的数据结构是支持动态开辟内存空间的二维数组。</strong>所谓双向开口，意思是可以在头尾两端分别进行元素的插入和移除操作。虽然 vector 也可以在头尾两端进行操作，但是其头部操作的效率非常低，无法被接受。deque 和 vector 的最大差异，一在于 deque 允许于常数项时间内对头端进行元素的插入或移除操作，二在于 <strong>deque 没有所谓容量 <code>capacity</code> 的观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</strong>换句话说，像 vector 那样因旧空间不足而重新配置一块更大的空间，然后拷贝元素，再释放旧空间这样的事情不会发生在 deque 身上，也因此 deque 没有必要提供所谓的空间保留（reserve）功能。虽然 deque 也提供了随机迭代器（Random Access Iterator），但是它的迭代器并不是普通的指针，其复杂度和 vector 不是一个量级，这会影响各个层面的运算效率。因此，除非有必要，应该尽可能的使用 vector，而不是 deque。对 deque 进行的排序操作，为了提高效率，可将 deque 先完整的复制到一个 vector 中，然后对 vector 容器进行排序，再复制回 deque。</p><p><img data-src="../../../asset/2025/01/cplusplus-deque-1.png"></p><p><strong>deque 本质上是由一段一段的定量连续空间（分段连续内存空间）构造而成，一旦有必要在 deque 的头端或尾端增加新空间，便会配置一段新的定量连续空间，然后串接在整个 deque 的头端或尾端。</strong>deque 最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口；这避开了重新配置空间、复制数据、释放空间的轮回，代价就是复杂的迭代器架构。既然 deque 使用的是分段连续内存空间，那么就必须有中央控制器，维持其整体连续的假象，这样也导致了数据结构的设计及迭代器的前进后退操作颇为繁琐，deque 底层实现的代码远比 vector 或 list 都多得多。</p><p><img data-src="../../../asset/2025/01/cplusplus-deque-2.png"></p><p><strong>deque 内部的中控器维护的是每个缓冲区的地址，而缓冲区则存放着真实的数据，目的是让 deque 使用起来像是一片连续的内存空间。</strong>deque 采取一块所谓的 <code>map</code>（注意，不是 STL 的 map 容器）作为主控，这里所谓的 <code>map</code> 是一小块连续的内存空间，其中每一个元素（节点）都是一个指针，指向另一段连续性内存空间，称作缓冲区，缓冲区才是 deque 的存储空间的主体。</p><ul><li><p>声明</p><ul><li><code>deque&lt;int&gt; deq;</code></li></ul></li><li><p>插入</p><ul><li><code>deq.push_back(20)</code>，往尾部插入元素</li><li><code>deq.push_front(20)</code>，往头部插入元素</li><li><code>deq.insert(iterator, 20)</code>，往迭代器指向的位置插入元素</li></ul></li><li><p>删除</p><ul><li><code>deq.pop_back()</code>，往尾部删除元素</li><li><code>deq.pop_front()</code>，往头部删除元素</li><li><code>deq.erase(it)</code>，删除迭代器指向的元素</li></ul></li><li><p>查询</p><ul><li><code>iterator</code>：迭代器遍历</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">deque 与 vector 的区别</p><ul><li>deque 对头部的元素插入与删除，其速度比 vector 快。</li><li>deque 对中间的元素插入与删除，其速度比 vector 慢。</li><li>vector 对于头部的插入与删除效率极低，数据量越大，效率越低。</li><li>vector 访问元素的速度会比 deque 快，这和两者的内部实现有关。</li></ul></div><h4 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"------ deque 大小操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    d1.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断容器是否为空</span></span><br><span class="line">    <span class="keyword">bool</span> empty = d1.<span class="built_in">empty</span>();</span><br><span class="line">    cout &lt;&lt; (empty ? <span class="string">"yes"</span> : <span class="string">"no"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中元素的个数</span></span><br><span class="line">    <span class="keyword">size_t</span> size = d1.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; size &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定容器的大小为 num，若容器变大，则以默认值（0）填充新位置。如果容器变小，则末尾超出容器大小的元素会被删除</span></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定容器的大小为 num，若容器变大，则以指定值填充新位置。如果容器变小，则末尾超出容器大小的元素会被删除</span></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ deque 读取操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引所指向的数据，如果索引越界，抛出 out_of_range 异常</span></span><br><span class="line">    <span class="keyword">int</span> num1 = d2.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"num1 = "</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引所指向的数据，如果索引越界，程序终止运行</span></span><br><span class="line">    <span class="keyword">int</span> num2 = d2[<span class="number">3</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">"num2 = "</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中第一个数据元素</span></span><br><span class="line">    <span class="keyword">int</span> font = d2.<span class="built_in">front</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"font = "</span> &lt;&lt; font &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中最后一个数据元素</span></span><br><span class="line">    <span class="keyword">int</span> back = d2.<span class="built_in">back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"back = "</span> &lt;&lt; back &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ deque 插入操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">3</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往迭代器指向的位置插入指定的元素</span></span><br><span class="line">    d3.<span class="built_in">insert</span>(d3.<span class="built_in">begin</span>(), <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往迭代器指向的位置插入 n 个指定的元素</span></span><br><span class="line">    d3.<span class="built_in">insert</span>(d3.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往迭代器指向的位置插入 [begin, end) 区间的数据</span></span><br><span class="line">    <span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(<span class="number">2</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line">    d3.<span class="built_in">insert</span>(d3.<span class="built_in">begin</span>(), d4.<span class="built_in">begin</span>(), d4.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器头部插入一个数据</span></span><br><span class="line">    d4.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器尾部添加一个数据</span></span><br><span class="line">    d4.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ deque 删除操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d5;</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定位置的数据，会返回下一个数据的位置</span></span><br><span class="line">    d5.<span class="built_in">erase</span>(d5.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除容器第一个数据</span></span><br><span class="line">    d5.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printDeque</span>(d5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除容器最后一个数据</span></span><br><span class="line">    d5.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printDeque</span>(d5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空容器的所有数据</span></span><br><span class="line">    d5.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">------ deque 大小操作 ------</span><br><span class="line">10 10 10 10 10 </span><br><span class="line">no</span><br><span class="line">5</span><br><span class="line">10 10 10 10 10 0 0 </span><br><span class="line">10 10 10 10 10 0 0 8 8 8 </span><br><span class="line">------ deque 读取操作 ------</span><br><span class="line">num1 = 3</span><br><span class="line">num2 = 4</span><br><span class="line">font = 1</span><br><span class="line">back = 5</span><br><span class="line">------ deque 插入操作 ------</span><br><span class="line">8 8 8 </span><br><span class="line">10 8 8 8 </span><br><span class="line">11 11 10 8 8 8 </span><br><span class="line">12 12 11 11 10 8 8 8 </span><br><span class="line">13 12 12 </span><br><span class="line">13 12 12 11 </span><br><span class="line">------ deque 删除操作 ------</span><br><span class="line">2 3 4 5 6 </span><br><span class="line">3 4 5 6 </span><br><span class="line">3 4 5 </span><br></pre></td></tr></tbody></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="容器介绍-2"><a href="#容器介绍-2" class="headerlink" title="容器介绍"></a>容器介绍</h4><p><strong>list 是一个双向链表容器，而且还是一个双向循环链表，可以高效地进行插入和删除元素。</strong>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的（如下图所示）。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。相较于 vector 的连续线性空间，list 就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list 对于空间的运用有绝对的精准，一点也不浪费。值得一提的是，对于任何位置的元素插入或元素的移除，list 永远是常数时间的耗时（效率较高）；但对于查询操作来说，list 的执行效率较低。</p><p><img data-src="../../../asset/2025/01/cplusplus-list-1.png"></p><ul><li><p>声明</p><ul><li><code>list&lt;int&gt; mylist;</code></li></ul></li><li><p>插入</p><ul><li><code>mylist.push_back(20)</code>，往尾部插入元素</li><li><code>mylist.push_front(20)</code>，往头部插入元素</li><li><code>mylist.insert(iterator, 20)</code>，往迭代器指向的位置插入元素</li></ul></li><li><p>删除</p><ul><li><code>mylist.pop_back()</code>，往尾部删除元素</li><li><code>mylist.pop_front()</code>，往头部删除元素</li><li><code>mylist.erase(it)</code>，删除迭代器指向的元素</li></ul></li><li><p>查询</p><ul><li><code>iterator</code>：迭代器遍历</li></ul></li></ul><div class="admonition note"><p class="admonition-title">链表的特性</p><ul><li>链表采用动态内存分配，不会造成内存浪费和溢出。</li><li>链表虽然灵活，但是空间和时间的额外耗费较大。</li><li>链表执行插入和删除操作都十分方便，仅修改指针即可实现，不需要移动大量元素。</li><li>链表的访问效率比数组要低，适合需要频繁插入、删除元素的场景（读少写多）。</li><li>链表不可以随机存取元素，所以不支持 <code>at.(pos)</code> 函数与 <code>[]</code> 操作符的使用。</li></ul></div><h4 id="案例代码-1"><a href="#案例代码-1" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reversePrintList</span><span class="params">(list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>{</span><br><span class="line">    <span class="comment">// 逆向遍历</span></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = L.<span class="built_in">rbegin</span>(); it != L.<span class="built_in">rend</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 插入操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; myList1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器的尾部插入元素</span></span><br><span class="line">    myList1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    myList1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    myList1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器的头部插入元素</span></span><br><span class="line">    myList1.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line">    myList1.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">    myList1.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 pos 位置插入 elem 数据的拷贝，返回新数据的位置</span></span><br><span class="line">    myList1.<span class="built_in">insert</span>(myList1.<span class="built_in">begin</span>(), <span class="number">400</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 pos 位置插入 n 个 elem 数据，无返回值</span></span><br><span class="line">    myList1.<span class="built_in">insert</span>(myList1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">500</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 pos 位置插入 [begin, end) 区间的数据，无返回值</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; myList2;</span><br><span class="line">    myList2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    myList2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    myList2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    myList1.<span class="built_in">insert</span>(myList1.<span class="built_in">begin</span>(), myList2.<span class="built_in">begin</span>(), myList2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 删除操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除容器头部的数据</span></span><br><span class="line">    myList1.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除容器尾部的数据</span></span><br><span class="line">    myList1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 pos 位置的数据，返回下一个数据的位置</span></span><br><span class="line">    myList1.<span class="built_in">erase</span>(myList1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除容器中所有与 elem 值匹配的元素</span></span><br><span class="line">    myList1.<span class="built_in">remove</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 读取操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个元素</span></span><br><span class="line">    cout &lt;&lt; myList1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最后一个元素</span></span><br><span class="line">    cout &lt;&lt; myList1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 清空操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; myList3;</span><br><span class="line">    myList3.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    myList3.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    myList3.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printList</span>(myList3);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 大小操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"size = "</span> &lt;&lt; myList1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断容器是否为空</span></span><br><span class="line">    <span class="keyword">bool</span> isEmpty = myList1.<span class="built_in">empty</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"isEmpty = "</span> &lt;&lt; (isEmpty ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定容器的长度 num，若容器变长，则以默认值填充新位置，若容器变短，则末尾超出容器长度的元素会被删除</span></span><br><span class="line">    myList1.<span class="built_in">resize</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"size = "</span> &lt;&lt; myList1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定容器的长度 num，若容器变长，则以 elem 值填充新位置，若容器变短，则末尾超出容器长度的元素会被删除</span></span><br><span class="line">    myList1.<span class="built_in">resize</span>(<span class="number">9</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line">    cout &lt;&lt; <span class="string">"size = "</span> &lt;&lt; myList1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 逆向遍历操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; myList11;</span><br><span class="line">    myList11.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    myList11.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    myList11.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">reversePrintList</span>(myList11);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">------ list 插入操作 ------</span><br><span class="line">10 20 30 </span><br><span class="line">100 200 300 10 20 30 </span><br><span class="line">400 100 200 300 10 20 30 </span><br><span class="line">500 500 400 100 200 300 10 20 30 </span><br><span class="line">1 2 3 500 500 400 100 200 300 10 20 30 </span><br><span class="line">------ list 删除操作 ------</span><br><span class="line">2 3 500 500 400 100 200 300 10 20 30 </span><br><span class="line">2 3 500 500 400 100 200 300 10 20 </span><br><span class="line">3 500 500 400 100 200 300 10 20 </span><br><span class="line">3 500 500 400 200 300 10 20 </span><br><span class="line">------ list 读取操作 ------</span><br><span class="line">3</span><br><span class="line">20</span><br><span class="line">------ list 清空操作 ------</span><br><span class="line"></span><br><span class="line">------ list 大小操作 ------</span><br><span class="line">size = 8</span><br><span class="line">isEmpty = false</span><br><span class="line">size = 6</span><br><span class="line">3 500 500 400 200 300 11 11 11 </span><br><span class="line">size = 9</span><br><span class="line">------ list 逆向遍历操作 ------</span><br><span class="line">3 2 1 </span><br></pre></td></tr></tbody></table></figure><h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><h3 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h3><p>在 C++ 中，无序关联容器的底层数据结构都是链式哈希表（也称为哈希链表），常用的无序关联容器有：</p><ul><li><code>unordered_set</code>: 一个无序容器，存储唯一键值（不允许重复），基于链式哈希表实现，提供快速的插入、删除和查找操作。  </li><li><code>unordered_multiset</code>: 一个无序容器，存储键值（允许重复），基于链式哈希表实现，提供快速的多键插入、删除和查找操作。  </li><li><code>unordered_map</code>: 一个无序的键值对容器（键不允许重复），基于链式哈希表实现，键唯一且与对应的值关联，提供高效的键查找。  </li><li><code>unordered_multimap</code>: 一个无序的键值对容器（键允许重复），基于链式哈希表实现，允许多个键相同的键值对，提供快速的键查找和多值存储。  </li></ul><p>在 C++ 中，无序关联容器有以下的常用操作：</p><ul><li><p>插入</p><ul><li><code>insert(val)</code>，往容器插入元素</li></ul></li><li><p>删除</p><ul><li><code>erase(val)</code>，删除元素</li><li><code>erase(iterator)</code>，删除迭代器指向的元素</li></ul></li><li><p>查询</p><ul><li><code>iterator</code>：迭代器遍历</li><li><code>for_each</code>，循环遍历</li><li><code>for</code>：循环遍历</li><li><code>find</code>：查找元素</li></ul></li><li><p>其他</p><ul><li><code>size()</code>：获取容器中元素数量</li><li><code>count(val)</code>：统计容器中某个元素的数量</li></ul></li></ul><h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><h5 id="案例代码-2"><a href="#案例代码-2" class="headerlink" title="案例代码"></a>案例代码</h5><p>本节将演示 <code>unordered_set</code> 容器的简单使用。值得一提的是，<code>unordered_multiset</code> 容器的使用跟 <code>unordered_set</code> 容器类似，这里不再累述。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储唯一键值（不允许重复）的无序容器</span></span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; set1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) {</span><br><span class="line">        set1.<span class="built_in">insert</span>(<span class="built_in">rand</span>() % <span class="number">20</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = set1.<span class="built_in">begin</span>(); it != set1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中的元素数量</span></span><br><span class="line">    cout &lt;&lt; set1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计容器中元素是 5 的个数</span></span><br><span class="line">    cout &lt;&lt; set1.<span class="built_in">count</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    set1.<span class="built_in">erase</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = set1.<span class="built_in">find</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">if</span> (iterator != set1.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"find item : "</span> &lt;&lt; *iterator &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not find item"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: set1) {</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16 8 12 18 20 15 13 9 2 7 19 1 10 6 17 3 14 4 5 </span><br><span class="line">19</span><br><span class="line">1</span><br><span class="line">find item : 15</span><br><span class="line">16 8 12 18 15 13 9 2 7 19 1 10 6 17 3 14 4 5 </span><br></pre></td></tr></tbody></table></figure><h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><h5 id="案例代码-3"><a href="#案例代码-3" class="headerlink" title="案例代码"></a>案例代码</h5><p>本节将演示 <code>unordered_map</code> 容器的简单使用。值得一提的是，<code>unordered_multimap</code> 容器的使用跟 <code>unordered_map</code> 容器类似，这里不再累述。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无序的键值对容器（键不允许重复）</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, string&gt; map1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1001</span>, <span class="string">"Tom"</span>));</span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1002</span>, <span class="string">"Peter"</span>));</span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1003</span>, <span class="string">"David"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定键的值，如果 key 不存在，会自动插入一个键值对 [key, string()]</span></span><br><span class="line">    cout &lt;&lt; map1[<span class="number">1002</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或者修改操作</span></span><br><span class="line">    map1[<span class="number">1004</span>] = <span class="string">"Jim"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中键值对的数量</span></span><br><span class="line">    cout &lt;&lt; map1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定的键</span></span><br><span class="line">    map1.<span class="built_in">erase</span>(<span class="number">1003</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = map1.<span class="built_in">find</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">if</span> (iterator != map1.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 获取 key 和 value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"finded, key: "</span> &lt;&lt; iterator-&gt;first &lt;&lt; <span class="string">", value: "</span> &lt;&lt; iterator-&gt;second &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not finded"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="comment">// 获取 key 和 value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"key: "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">", value: "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Peter</span><br><span class="line">4</span><br><span class="line">finded, key: 1001, value: Tom</span><br><span class="line">key: 1004, value: Jim</span><br><span class="line">key: 1002, value: Peter</span><br><span class="line">key: 1001, value: Tom</span><br></pre></td></tr></tbody></table></figure><h3 id="有序关联容器"><a href="#有序关联容器" class="headerlink" title="有序关联容器"></a>有序关联容器</h3><p>在 C++ 中，有序关联容器的底层数据结构都是红黑树（一种平衡二叉搜索树），常用的有序关联容器有：</p><ul><li><code>set</code>: 一个有序容器，存储唯一键值（不允许重复），基于红黑树实现，提供高效的元素插入、删除和有序遍历。  </li><li><code>multiset</code>: 一个有序容器，存储键值（允许重复），基于红黑树实现，支持多键插入和有序遍历。  </li><li><code>map</code>: 一个有序的键值对容器（键不允许重复），基于红黑树实现，键唯一且与对应的值关联，支持高效查找和有序遍历。  </li><li><code>multimap</code>: 一个有序的键值对容器（键允许重复），基于红黑树实现，允许键重复，支持多键查找和有序存储。  </li></ul><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>本节将演示 <code>set</code> 容器的简单使用。值得一提的是，<code>multiset</code> 容器的使用跟 <code>set</code> 容器类似，这里不再累述。</p><h5 id="案例代码一-1"><a href="#案例代码一-1" class="headerlink" title="案例代码一"></a>案例代码一</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储唯一键值（不允许重复）的有序容器</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; set1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        set1.<span class="built_in">insert</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = set1.<span class="built_in">begin</span>(); it != set1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中的元素数量</span></span><br><span class="line">    cout &lt;&lt; set1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计容器中元素是 5 的个数</span></span><br><span class="line">    cout &lt;&lt; set1.<span class="built_in">count</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    set1.<span class="built_in">erase</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = set1.<span class="built_in">find</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">if</span> (iterator != set1.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"find item : "</span> &lt;&lt; *iterator &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not find item"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: set1) {</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 21 22 26 27 36 39 41 51 55 60 67 81 89 90 91 94 96 </span><br><span class="line">18</span><br><span class="line">1</span><br><span class="line">not find item</span><br><span class="line">5 21 22 26 27 36 39 41 51 55 60 67 81 89 90 91 94 96 </span><br></pre></td></tr></tbody></table></figure><h5 id="案例代码二-1"><a href="#案例代码二-1" class="headerlink" title="案例代码二"></a>案例代码二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">long</span> id, string name) : _id(id), _name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 set 容器是有序的，因此自定义类型都需要重载小于运算符，否则 set 容器将不知道如何对自定义类型进行排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Student &amp;other) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_id &lt; other._id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;student);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">long</span> _id;</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;student) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"id: "</span> &lt;&lt; student._id &lt;&lt; <span class="string">", name: "</span> &lt;&lt; student._name;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 存储唯一键值（不允许重复）的有序容器</span></span><br><span class="line">    set&lt;Student&gt; set1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">1001</span>, <span class="string">"Tom"</span>));</span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">1002</span>, <span class="string">"Jim"</span>));</span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">1003</span>, <span class="string">"Peter"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = set1.<span class="built_in">begin</span>(); it != set1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id: 1001, name: Tom</span><br><span class="line">id: 1002, name: Jim</span><br><span class="line">id: 1003, name: Peter</span><br></pre></td></tr></tbody></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>本节将演示 <code>map</code> 容器的简单使用。值得一提的是，<code>multimap</code> 容器的使用跟 <code>map</code> 容器类似，这里不再累述。</p><h5 id="案例代码一-2"><a href="#案例代码一-2" class="headerlink" title="案例代码一"></a>案例代码一</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有序的键值对容器（键不允许重复）</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; map1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1001</span>, <span class="string">"Tom"</span>));</span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1002</span>, <span class="string">"Peter"</span>));</span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1003</span>, <span class="string">"David"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定键的值，如果 key 不存在，会自动插入一个键值对 [key, string()]</span></span><br><span class="line">    cout &lt;&lt; map1[<span class="number">1002</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或者修改操作</span></span><br><span class="line">    map1[<span class="number">1004</span>] = <span class="string">"Jim"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中键值对的数量</span></span><br><span class="line">    cout &lt;&lt; map1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定的键</span></span><br><span class="line">    map1.<span class="built_in">erase</span>(<span class="number">1003</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = map1.<span class="built_in">find</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">if</span> (iterator != map1.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 获取 key 和 value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"finded, key: "</span> &lt;&lt; iterator-&gt;first &lt;&lt; <span class="string">", value: "</span> &lt;&lt; iterator-&gt;second &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not finded"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="comment">// 获取 key 和 value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"key: "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">", value: "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Peter</span><br><span class="line">4</span><br><span class="line">finded, key: 1001, value: Tom</span><br><span class="line">key: 1001, value: Tom</span><br><span class="line">key: 1002, value: Peter</span><br><span class="line">key: 1004, value: Jim</span><br></pre></td></tr></tbody></table></figure><h5 id="案例代码二-2"><a href="#案例代码二-2" class="headerlink" title="案例代码二"></a>案例代码二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>() {</span><br><span class="line">        <span class="keyword">this</span>-&gt;_id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_name = <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">long</span> id, string name) : _id(id), _name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;student);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">long</span> _id;</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;student) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"id: "</span> &lt;&lt; student._id &lt;&lt; <span class="string">", name: "</span> &lt;&lt; student._name;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 有序的键值对容器（键不允许重复）</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, Student&gt; map1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    map1.<span class="built_in">insert</span>({<span class="number">1001</span>, <span class="built_in">Student</span>(<span class="number">1001</span>, <span class="string">"Jim"</span>)});</span><br><span class="line">    map1.<span class="built_in">insert</span>({<span class="number">1002</span>, <span class="built_in">Student</span>(<span class="number">1002</span>, <span class="string">"Peter"</span>)});</span><br><span class="line">    map1.<span class="built_in">insert</span>({<span class="number">1003</span>, <span class="built_in">Student</span>(<span class="number">1003</span>, <span class="string">"David"</span>)});</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定键的值，如果 key 不存在，会自动插入一个键值对 [key, Student()]，这需要自定义的数据类型提供默认构造函数</span></span><br><span class="line">    cout &lt;&lt; map1[<span class="number">1002</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="comment">// 获取 key 和 value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"key: "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">", value: "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: 1002, name: Peter</span><br><span class="line">key: 1001, value: id: 1001, name: Jim</span><br><span class="line">key: 1002, value: id: 1002, name: Peter</span><br><span class="line">key: 1003, value: id: 1003, name: David</span><br></pre></td></tr></tbody></table></figure><h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>在 C++ 中，常用的容器适配器有：</p><ul><li><code>stack</code>: 一个遵循后进先出（LIFO）原则的容器适配器，底层默认是基于 <code>deque</code> 实现，也可以使用 <code>vector</code> 或 <code>list</code> 替代底层容器，支持在栈顶插入、删除和访问元素的操作。</li><li><code>queue</code>: 一个遵循先进先出（FIFO）原则的容器适配器，底层默认是基于 <code>deque</code> 实现，支持在队尾插入元素和在队头移除、访问元素的操作。</li><li><code>priority_queue</code>: 一个基于堆实现的容器适配器（即优先级队列），底层默认使用 <code>vector</code> 作为容器存储，借助堆算法按优先级（默认大顶堆）访问最高优先级的元素。</li></ul><div class="admonition note"><p class="admonition-title">容器迭代器的特点</p><ul><li>容器适配器没有自己的迭代器。</li><li>容器适配器的底层没有自己的数据机构，它本质是另外一个容器的封装，它的函数全部由底层依赖的容器来实现。</li></ul></div><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h4 id="案例代码-4"><a href="#案例代码-4" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈（后进先出 - LIFO）</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        s1.<span class="built_in">push</span>(item);</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回栈的元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 获取栈顶元素</span></span><br><span class="line">        cout &lt;&lt; s1.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="comment">// 弹栈</span></span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 80 23 89 30 85 6 58 5 67 32 98 13 65 42 60 75 85 77 57 </span><br><span class="line">size: 20</span><br><span class="line">57 77 85 75 60 42 65 13 98 32 67 5 58 6 85 30 89 23 80 10 </span><br></pre></td></tr></tbody></table></figure><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h4 id="案例代码-5"><a href="#案例代码-5" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列（先进先出 - FIFO）</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        q1.<span class="built_in">push</span>(item);</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回队列的元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; q1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 获取队头元素</span></span><br><span class="line">        cout &lt;&lt; q1.<span class="built_in">front</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">14 45 87 90 95 32 66 27 9 92 96 88 93 68 72 55 42 37 35 64 </span><br><span class="line">size: 20</span><br><span class="line">14 45 87 90 95 32 66 27 9 92 96 88 93 68 72 55 42 37 35 64 </span><br></pre></td></tr></tbody></table></figure><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><h4 id="案例代码-6"><a href="#案例代码-6" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        pque.<span class="built_in">push</span>(item);</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回队列的元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; pque.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (!pque.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 获取队头元素</span></span><br><span class="line">        cout &lt;&lt; pque.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        pque.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">85 32 2 2 38 96 10 2 83 34 1 64 19 90 64 20 6 81 100 47 </span><br><span class="line">size: 20</span><br><span class="line">100 96 90 85 83 81 64 64 47 38 34 32 20 19 10 6 2 2 2 1 </span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之四</title>
    <link href="https://www.techgrow.cn/posts/4f052863.html"/>
    <id>https://www.techgrow.cn/posts/4f052863.html</id>
    <published>2024-12-13T13:55:33.000Z</published>
    <updated>2024-12-13T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><span id="more"></span><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义基类（父类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Parent</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义派生类（子类），继承方式是 public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Child</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 直接访问基类（父类）的 public 成员变量</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; <span class="string">", c="</span> &lt;&lt; <span class="keyword">this</span>-&gt;c &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Child <span class="title">child</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    child.<span class="built_in">print</span>();    <span class="comment">// 直接调用基类（父类）的 public 成员函数</span></span><br><span class="line">    child.<span class="built_in">echo</span>();     <span class="comment">// 直接调用派生类（子类）的 public 成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=1, b=2</span><br><span class="line">a=1, b=2, c=3</span><br></pre></td></tr></tbody></table></figure><h2 id="派生类的构造过程"><a href="#派生类的构造过程" class="headerlink" title="派生类的构造过程"></a>派生类的构造过程</h2><ul><li><p>派生类对象构造的过程：</p><ul><li>派生类先调用基类的构造函数，初始化从基类继承来的成员。</li><li>派生类后调用自己的构造函数，初始化派生类自己特有的成员。</li></ul></li><li><p>派生类对象析构的过程：</p><ul><li>派生类先调用自己的析构函数，释放派生类成员可能占用的外部资源（堆内存，文件等）。</li><li>派生类后调用基类的析构函数，释放派生类内存中从基类继承来的成员可能占用的外部资源（堆内存、文件等）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>在 C++ 的类继承中，先构造的后析构，即后构造的先析构。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data) : <span class="built_in">ma</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Base</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Base()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 显式调用 Base 的构造函数初始化 ma</span></span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Device</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Device()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Device <span class="title">d</span><span class="params">(<span class="number">2</span>)</span></span>;    <span class="comment">// 先构造的后析构，即后构造的先析构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base()</span><br><span class="line">Device()</span><br><span class="line">~Device()</span><br><span class="line">~Base()</span><br></pre></td></tr></tbody></table></figure><h2 id="重载、重写、隐藏"><a href="#重载、重写、隐藏" class="headerlink" title="重载、重写、隐藏"></a>重载、重写、隐藏</h2><ul><li><p>重载关系</p><ul><li>一组函数要重载，必须处在同一个作用域当中，且函数名字相同，但参数列表不同。</li></ul></li><li><p>隐藏关系</p><ul><li>在继承结构当中，派生类的同名成员会将基类的同名成员给隐藏掉，这里的隐藏是指作用域的隐藏。</li></ul></li><li><p>重写关系</p><ul><li>基类和派生类的函数，其函数名、返回值以及参数列表都相同，而且基类的方法是虚函数，那么派生类的方法就会被编译器自动处理成虚函数，它们之间成为重写（覆盖）关系。</li></ul></li></ul><h3 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : <span class="built_in">ma</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show(int)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data = <span class="number">20</span>) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Device device;</span><br><span class="line">    device.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// device.show(20);         // 错误写法，派生类的 show() 函数将基类的 show(int a) 函数隐藏了，无法正常调用基类的同名函数</span></span><br><span class="line">    device.Base::<span class="built_in">show</span>(<span class="number">20</span>);      <span class="comment">// 正确写法，派生类加上作用域可以正常调用基类的同名函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Device::show()</span><br><span class="line">Base::show()</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h3><ul><li><p>在 C++ 的继承结构中，通常会说成是从上（基类）到下（派生类）的结构</p><ul><li>从上到下，即基类对象 -&gt; 派生类对象</li><li>从下到上，即派生类对象 -&gt; 基类对象</li></ul></li><li><p> C++ 中的多态表现           </p><ul><li>基类指针（引用）-&gt; 派生类对象</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 C++ 的继承结构中进行上下的类型转换时，默认只支持从下（派生类）到上（基类）的类型的转换，不支持从上（基类）到下（派生类）的类型的转换。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : <span class="built_in">ma</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show(int)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data = <span class="number">20</span>) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"=========== test01() ==========="</span> &lt;&lt; endl;</span><br><span class="line">    Base base;</span><br><span class="line">    Device device;</span><br><span class="line">    base = device;      <span class="comment">// 正确写法，类型从下到上的转换</span></span><br><span class="line">    <span class="comment">// device = base;   // 错误写法，类型从上到下的转换</span></span><br><span class="line">    base.<span class="built_in">show</span>();</span><br><span class="line">    base.<span class="built_in">show</span>(<span class="number">30</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"=========== test02() ==========="</span> &lt;&lt; endl;</span><br><span class="line">    Base base;</span><br><span class="line">    Device device;</span><br><span class="line"></span><br><span class="line">    Base *_base = &amp;device;          <span class="comment">// 正确写法，类型从下到上的转换</span></span><br><span class="line">    <span class="comment">// Device *_device = &amp;base;     // 错误写法，类型从上到下的转换</span></span><br><span class="line">    _base-&gt;<span class="built_in">show</span>();</span><br><span class="line">    _base-&gt;<span class="built_in">show</span>(<span class="number">40</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=========== test01() ===========</span><br><span class="line">Base::show()</span><br><span class="line">Base::show(int)</span><br><span class="line">=========== test02() ===========</span><br><span class="line">Base::show()</span><br><span class="line">Base::show(int)</span><br></pre></td></tr></tbody></table></figure><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="虚函数的概念"><a href="#虚函数的概念" class="headerlink" title="虚函数的概念"></a>虚函数的概念</h3><ul><li><p>(1) 当一个类里面定义了虚函数，那么在编译阶段，编译器会给这个类的类型产生一个唯一的 <code>vtable</code> 虚函数表，虚函数表中主要存储的内容是 <code>RTTI</code> 指针和虚函数的地址（<a href="../../../asset/2025/01/cplusplus-virtual-function-1.png">如图所示</a>）。当程序运行时，每一张虚函数表都会加载到内存的 <code>.rodata</code> 区。</p></li><li><p>(2) 当一个类里面定义了虚函数，那么这个类定义的对象在其运行时，其内存中开始的部分会多存储一个 <code>vptr</code> 虚函数表指针（占 4 字节大小），它指向相应类型的虚函数表 <code>vtable</code>。一个类定义 N 个对象，它们的 <code>vptr</code> 虚函数表指针指向的都是同一张虚函数表。</p></li><li><p>(3) 如果派生类中的函数和从基类继承来的某个函数，其函数名、返回值、参数列表都相同，而且基类的函数是 <code>virtual</code> 关键字修饰的，那么派生类的这个函数会被编译器自动处理成虚函数。</p></li><li><p>(4) 一个类里面虚函数的个数，不影响类对象的内存大小（<code>vptr</code> 虚函数表指针永远只占用 4 个字节大小），影响的是虚函数表的大小。</p></li><li><p>(5) 在构造函数中调用虚函数，不会发生动态绑定。简而言之，在构造函数调用的函数，都是静态绑定。</p></li></ul><div class="admonition note"><p class="admonition-title">虚函数相关的专业术语</p><ul><li>虚函数表：通常表示为 <code>vtable</code> 或者 <code>vftable</code>，两者表达的意义都是一致的。</li><li>虚函数表指针：通常表示为 <code>vptr</code> 或者 <code>vfptr</code>，两者表达的意义都是一致的。</li></ul></div><div class="admonition warning"><p class="admonition-title">哪些函数不能实现成虚函数</p><ul><li>(1) 构造函数不能实现成虚函数。</li><li>(2) <code>static</code> 关键字修饰的函数不能实现成虚函数。</li></ul></div><h3 id="静态绑定（普通函数）"><a href="#静态绑定（普通函数）" class="headerlink" title="静态绑定（普通函数）"></a>静态绑定（普通函数）</h3><ul><li>静态（编译时期）绑定，使用的是普通函数 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : <span class="built_in">ma</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通函数（非虚函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通函数（非虚函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show(int a)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data = <span class="number">20</span>) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Device <span class="title">device</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Base *pb = &amp;device;</span><br><span class="line">    pb-&gt;<span class="built_in">show</span>();           <span class="comment">// 静态（编译时期）绑定（函数的调用）</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Base) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Device) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(pb).<span class="built_in">name</span>() &lt;&lt; endl;      <span class="comment">// class Base *</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(*pb).<span class="built_in">name</span>() &lt;&lt; endl;     <span class="comment">// class Base</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base::show()</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">class Base *</span><br><span class="line">class Base</span><br></pre></td></tr></tbody></table></figure><h3 id="动态绑定（虚函数）"><a href="#动态绑定（虚函数）" class="headerlink" title="动态绑定（虚函数）"></a>动态绑定（虚函数）</h3><ul><li>动态（运行时期）绑定，使用的是虚函数 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : <span class="built_in">ma</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show(int a)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data = <span class="number">20</span>) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Device <span class="title">device</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Base *pb = &amp;device;</span><br><span class="line">    pb-&gt;<span class="built_in">show</span>();           <span class="comment">// 动态（运行时期）绑定（函数的调用）</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Base) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Device) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(pb).<span class="built_in">name</span>() &lt;&lt; endl;      <span class="comment">// class Base *</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(*pb).<span class="built_in">name</span>() &lt;&lt; endl;     <span class="comment">// class Device</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Device::show()</span><br><span class="line">16</span><br><span class="line">16</span><br><span class="line">class Base *</span><br><span class="line">class Device</span><br></pre></td></tr></tbody></table></figure><h3 id="查看类的内存布局"><a href="#查看类的内存布局" class="headerlink" title="查看类的内存布局"></a>查看类的内存布局</h3><p>在 Visual Studio 开发人员命令提示窗口内，可以使用以下命令查看类的内存布局信息，其中 <code>YYY</code> 是类的名称，<code>xxx</code> 是 C++ 源文件的名称。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayoutYYY xxx.cpp</span><br></pre></td></tr></tbody></table></figure><ul><li>在上述动态绑定（带虚函数）的代码中，Base 类的内存布局如下：</li></ul><p><img data-src="../../../asset/2025/01/cplusplus-virtual-function-2.png"></p><ul><li>在上述动态绑定（带虚函数）的代码中，Device 类的内存布局如下：</li></ul><p><img data-src="../../../asset/2025/01/cplusplus-virtual-function-3.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p>更多关于 Visual Studio 命令的详细使用教程，请阅读 <a href="https://blog.csdn.net/weixin_44380570/article/details/120562497">《使用 VS 查看对象模型以及结构体内存对齐》</a>。</p></div><h3 id="虚函数调用深入理解"><a href="#虚函数调用深入理解" class="headerlink" title="虚函数调用深入理解"></a>虚函数调用深入理解</h3><div class="admonition warning"><p class="admonition-title">思考问题</p><p>在 C++ 中，是不是虚函数的调用一定就是动态绑定？</p></div><p>在 C++ 中，虚函数的调用不一定就是动态绑定，比如：</p><ul><li>在类的构造函数中调用虚函数，只会发生静态绑定，而不会发生动态绑定。</li><li>类对象调用自己的成员函数（虚函数），只会发生静态绑定，而不会发生动态绑定。</li><li>通过指针或者引用变量调用虚函数，都会发生动态绑定，无论调用方是基类还是派生类，且无论被调用方是基类还是派生类。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">0</span>) : <span class="built_in">ma</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data = <span class="number">0</span>) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base base;</span><br><span class="line">    Device device;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    base.<span class="built_in">show</span>();    <span class="comment">// 静态绑定</span></span><br><span class="line">    device.<span class="built_in">show</span>();  <span class="comment">// 静态绑定</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Base *bptr1 = &amp;base;</span><br><span class="line">    bptr1-&gt;<span class="built_in">show</span>();   <span class="comment">// 动态绑定（必须由指针或者引用调用虚函数）</span></span><br><span class="line"></span><br><span class="line">    Base *bptr2 = &amp;device;</span><br><span class="line">    bptr2-&gt;<span class="built_in">show</span>();   <span class="comment">// 动态绑定（必须由指针或者引用调用虚函数）</span></span><br><span class="line"></span><br><span class="line">    Base &amp;b1 = base;</span><br><span class="line">    base.<span class="built_in">show</span>();     <span class="comment">// 动态绑定（必须由指针或者引用调用虚函数）</span></span><br><span class="line"></span><br><span class="line">    Base &amp;b2 = device;</span><br><span class="line">    b2.<span class="built_in">show</span>();       <span class="comment">// 动态绑定（必须由指针或者引用调用虚函数）</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Device *dptr = &amp;device;</span><br><span class="line">    dptr-&gt;<span class="built_in">show</span>();   <span class="comment">// 动态绑定（虚函数通过指针或者引用变量调用，才会发生动态绑定）</span></span><br><span class="line"></span><br><span class="line">    Device &amp;d = device;</span><br><span class="line">    d.<span class="built_in">show</span>();       <span class="comment">// 动态绑定（虚函数通过指针或者引用变量调用，才会发生动态绑定）</span></span><br><span class="line"></span><br><span class="line">    Device *dptr2 = (Device *) &amp;base;   <span class="comment">// 强制类型转换（不安全）</span></span><br><span class="line">    dptr2-&gt;<span class="built_in">show</span>();   <span class="comment">// 动态绑定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">=====================</span><br><span class="line">Base::show()</span><br><span class="line">Device::show()</span><br><span class="line">=====================</span><br><span class="line">Base::show()</span><br><span class="line">Device::show()</span><br><span class="line">Base::show()</span><br><span class="line">Device::show()</span><br><span class="line">=====================</span><br><span class="line">Device::show()</span><br><span class="line">Device::show()</span><br><span class="line">Base::show()</span><br></pre></td></tr></tbody></table></figure><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><h3 id="虚析构函数的概念"><a href="#虚析构函数的概念" class="headerlink" title="虚析构函数的概念"></a>虚析构函数的概念</h3><ul><li>(1) 析构函数可以是虚的，虚析构函数主要用于指引 <code>delete</code> 运算符正确析构动态对象。</li><li>(2) 构造函数不能是虚函数，因为建立一个派生类对象时，必须从类层次的根开始，沿着继承路径逐个调用基类的构造函数。</li><li>(3) 虚析构函数使得在删除指向派生类对象的基类指针时，可以调用派生类的析构函数来实现释放派生类中堆内存的目的，从而防止内存泄漏。</li><li>(4) 当基类的指针（引用）指向在堆上 <code>new</code> 出来的派生类对象的时候，基类的析构函数必须实现成虚析构函数。在调用虚析构函数的时候，必定会发生动态绑定，否则会导致派生类的析构函数无法被调用。</li></ul><h3 id="虚析构函数的使用"><a href="#虚析构函数的使用" class="headerlink" title="虚析构函数的使用"></a>虚析构函数的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data) : <span class="built_in">ma</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Base()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当基类的析构函数是 virtual 虚函数，那么派生类的析构函数会自动成为虚函数</span></span><br><span class="line">    ~<span class="built_in">Device</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Device()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base *pb = <span class="keyword">new</span> <span class="built_in">Device</span>(<span class="number">10</span>);</span><br><span class="line">    pb-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base()</span><br><span class="line">Device()</span><br><span class="line">Base::show()</span><br><span class="line">~Device()</span><br><span class="line">~Base()</span><br></pre></td></tr></tbody></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h3><ul><li><p>静态（编译时期）的多态</p><ul><li>函数重载</li><li>模板（类模板与函数模板）</li></ul></li><li><p>动态（运行时期）的多态</p><ul><li>在类的继承结构中，基类指针（引用）指向派生类对象，通过该指针（引用）调用同名函数（虚函数），基类指针指向哪个派生类对象，就会调用哪个派生类对象的同名函数（虚函数）。</li><li>动态多态的底层是通过动态绑定来实现的，涉及虚函数表指针（<code>vptr</code>）和虚函数表（<code>vtable</code>）。</li></ul></li></ul><h3 id="多态的案例代码一"><a href="#多态的案例代码一" class="headerlink" title="多态的案例代码一"></a>多态的案例代码一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(string name) : _name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: miao miao"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: wang wang"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pig</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: heng heng"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">(Animal &amp;animal)</span> </span>{</span><br><span class="line">    <span class="comment">// 动态多态（底层是通过动态绑定来实现的）</span></span><br><span class="line">    animal.<span class="built_in">bark</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Cat cat = <span class="built_in">Cat</span>(<span class="string">"Cat"</span>);</span><br><span class="line">    Dog dog = <span class="built_in">Dog</span>(<span class="string">"Dog"</span>);</span><br><span class="line">    Pig pig = <span class="built_in">Pig</span>(<span class="string">"Pig"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bark</span>(cat);</span><br><span class="line">    <span class="built_in">bark</span>(dog);</span><br><span class="line">    <span class="built_in">bark</span>(pig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat bark: miao miao</span><br><span class="line">Dog bark: wang wang</span><br><span class="line">Pig bark: heng heng</span><br></pre></td></tr></tbody></table></figure><h3 id="多态的案例代码二"><a href="#多态的案例代码二" class="headerlink" title="多态的案例代码二"></a>多态的案例代码二</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(string name) : _name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: miao miao"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: wang wang"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pig</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: heng heng"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">(Animal *animal)</span> </span>{</span><br><span class="line">    <span class="comment">// 动态多态（底层是通过动态绑定来实现的）</span></span><br><span class="line">    animal-&gt;<span class="built_in">bark</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Cat cat = <span class="built_in">Cat</span>(<span class="string">"Cat"</span>);</span><br><span class="line">    Dog dog = <span class="built_in">Dog</span>(<span class="string">"Dog"</span>);</span><br><span class="line">    Pig pig = <span class="built_in">Pig</span>(<span class="string">"Pig"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bark</span>(&amp;cat);</span><br><span class="line">    <span class="built_in">bark</span>(&amp;dog);</span><br><span class="line">    <span class="built_in">bark</span>(&amp;pig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat bark: miao miao</span><br><span class="line">Dog bark: wang wang</span><br><span class="line">Pig bark: heng heng</span><br></pre></td></tr></tbody></table></figure><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><h3 id="纯虚函数和抽象类的概念"><a href="#纯虚函数和抽象类的概念" class="headerlink" title="纯虚函数和抽象类的概念"></a>纯虚函数和抽象类的概念</h3><p>基本概念：</p><ul><li>(a) 纯虚函数是一个在基类中声明的虚函数，且在基类中没有被定义，要求任何派生类都必须定义自己的版本。</li><li>(b) 纯虚函数为各派生类提供一个公共界面，可以实现接口的封装和设计、软件的模块功能划分等。</li><li>(c) 纯虚函数的声明形式： <code>virtual  类型  函数名 ( 参数表 ) = 0;</code>。</li><li>(d) <strong>一个拥有纯虚函数的基类，通常称之为 “抽象类”。</strong></li></ul><p>使用限制：</p><ul><li>(a) 可以声明抽象类的指针和引用。</li><li>(b) 抽象类不能创建对象（实例化）。</li><li>(c) 抽象类不能作为函数的参数类型和返回值类型。</li><li>(d) 如果基类中存在纯虚函数，那么派生类必须实现所有的纯虚函数，否则这个派生类也是一个抽象类。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>抽象类可以有构造函数。尽管抽象类无法被直接实例化（因为它包含至少一个纯虚函数），但它仍然可以定义构造函数，用于初始化抽象类的成员变量或执行其他构造逻辑。这样，当抽象类被继承并通过派生类构造时，抽象类的构造函数会被调用。同理，抽象类也可以有析构函数。</p></div><h3 id="纯虚函数和抽象类的案例一"><a href="#纯虚函数和抽象类的案例一" class="headerlink" title="纯虚函数和抽象类的案例一"></a>纯虚函数和抽象类的案例一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明纯虚函数，计算面积</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Circle</span>(<span class="keyword">double</span> r) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现纯虚函数，计算圆的面积</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">double</span> area = <span class="number">3.14</span> * r * r;</span><br><span class="line">        cout &lt;&lt; <span class="string">"圆的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现纯虚函数，计算三角形的面积</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">double</span> area = a * b / <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"三角形的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现纯虚函数，计算四边形的面积</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">double</span> area = a * b;</span><br><span class="line">        cout &lt;&lt; <span class="string">"四边形的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArea</span><span class="params">(Figure* base)</span> </span>{</span><br><span class="line">    base-&gt;<span class="built_in">getArea</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Figure f;    // 错误写法，抽象类不能实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Triangle <span class="title">Triangle</span><span class="params">(<span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Square <span class="title">square</span><span class="params">(<span class="number">50</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以声明抽象类的指针</span></span><br><span class="line">    Figure* pBase = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">5.3</span>);</span><br><span class="line">    pBase-&gt;<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以声明抽象类的引用</span></span><br><span class="line">    Figure&amp; base = square;</span><br><span class="line">    base.<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printArea</span>(&amp;Triangle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">圆的面积: 88.2026</span><br><span class="line">四边形的面积: 3000</span><br><span class="line">三角形的面积: 300</span><br></pre></td></tr></tbody></table></figure><h3 id="纯虚函数和抽象类的案例二"><a href="#纯虚函数和抽象类的案例二" class="headerlink" title="纯虚函数和抽象类的案例二"></a>纯虚函数和抽象类的案例二</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 抽象类可以有构造函数，用于初始化其成员变量</span></span><br><span class="line">    <span class="comment">// 当抽象类被继承并通过派生类构造时，抽象类的构造函数会被调用</span></span><br><span class="line">    <span class="built_in">Animal</span>(string name) : _name(name) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Animal()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象类可以有析构函数，用于释放资源</span></span><br><span class="line">    <span class="comment">// 当抽象类被继承并通过派生类析构时，抽象类的析构函数会被调用</span></span><br><span class="line">    ~<span class="built_in">Animal</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Animal()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: miao miao"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: wang wang"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pig</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: heng heng"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">(Animal &amp;animal)</span> </span>{</span><br><span class="line">    <span class="comment">// 动态多态（底层是通过动态绑定来实现的）</span></span><br><span class="line">    animal.<span class="built_in">bark</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 错误写法，抽象类不能实例化</span></span><br><span class="line">    <span class="comment">// Animal animal("Animal");</span></span><br><span class="line"></span><br><span class="line">    Cat cat = <span class="built_in">Cat</span>(<span class="string">"Cat"</span>);</span><br><span class="line">    Dog dog = <span class="built_in">Dog</span>(<span class="string">"Dog"</span>);</span><br><span class="line">    Pig pig = <span class="built_in">Pig</span>(<span class="string">"Pig"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bark</span>(cat);</span><br><span class="line">    <span class="built_in">bark</span>(dog);</span><br><span class="line">    <span class="built_in">bark</span>(pig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Animal()</span><br><span class="line">Animal()</span><br><span class="line">Animal()</span><br><span class="line">Cat bark: miao miao</span><br><span class="line">Dog bark: wang wang</span><br><span class="line">Pig bark: heng heng</span><br><span class="line">~Animal()</span><br><span class="line">~Animal()</span><br><span class="line">~Animal()</span><br></pre></td></tr></tbody></table></figure><h2 id="虚继承与虚基类"><a href="#虚继承与虚基类" class="headerlink" title="虚继承与虚基类"></a>虚继承与虚基类</h2><h3 id="虚继承与虚基类的概念"><a href="#虚继承与虚基类的概念" class="headerlink" title="虚继承与虚基类的概念"></a>虚继承与虚基类的概念</h3><ul><li><p>基本概念</p><ul><li>虚继承的声明需要使用关键字 <code>virtual</code>。</li><li><strong>在 C++ 中，被虚继承的类通常称作为虚基类。</strong></li><li>虚继承的底层是靠虚基类指针（<code>vbptr</code>）和虚基类表（<code>vbtable</code>）来实现。</li><li>如果一个派生类从多个基类继承，而这些基类又有一个共同的基类（公共基类），则在对该基类中声明的成员进行访问时，可能会产生二义性，需要使用虚继承来解决二义性问题。</li><li>如果在多条继承路径上有一个公共的基类，那么在继承路径的某处汇合点，这个公共基类就会在派生类的对象中产生多个基类子对象。要使这个公共基类在派生类中只产生一个子对象，必须对这个基类的继承声明为虚继承，使这个基类成为 <code>虚基类</code>。</li></ul></li><li><p>适用场景</p><ul><li>虚继承只适用于有共同基类（公共基类）的多继承场景（比如菱形继承），如下图所示：</li></ul></li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-17.png"></p><ul><li>不适用场景<ul><li>对于 <code>V</code> 字形的多继承场景，虚继承是没办法解决二义性问题的，如下图所示：</li></ul></li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-21.png"></p><h3 id="虚继承与虚基类使用案例"><a href="#虚继承与虚基类使用案例" class="headerlink" title="虚继承与虚基类使用案例"></a>虚继承与虚基类使用案例</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>(<span class="keyword">int</span> x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">cout &lt;&lt; <span class="string">"Base 类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"x = "</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>(<span class="keyword">int</span> b, <span class="keyword">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 由于父类和虚基类没有默认的无参构造函数，所以这里的派生类需要在初始化列表中，显式调用父类、虚基类的有参构造函数</span></span><br><span class="line"><span class="built_in">Base3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> x) : <span class="built_in">Base1</span>(a, x), <span class="built_in">Base2</span>(b, x), <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Base3 <span class="title">base</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;  <span class="comment">// 虚基类Base的构造函数只会被调用一次</span></span><br><span class="line">base.<span class="built_in">printA</span>();</span><br><span class="line">base.<span class="built_in">printB</span>();</span><br><span class="line">base.<span class="built_in">printC</span>();</span><br><span class="line">base.<span class="built_in">printX</span>();<span class="comment">// 当不声明虚继承的时候，此写法会产生二义性，C++编译器会出现编译错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base 类的构造函数被调用</span><br><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">c = 3</span><br><span class="line">x = 4</span><br></pre></td></tr></tbody></table></figure><h3 id="虚继承的类内存布局之一"><a href="#虚继承的类内存布局之一" class="headerlink" title="虚继承的类内存布局之一"></a>虚继承的类内存布局之一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚基类（被虚继承的基类称为虚基类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"size : "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(B) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size : 16</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 中查看上述 B 派生类的内存布局，可以得到以下结果，其中 <code>vbptr</code> 是虚基类指针（Virtual Base Ptr），而 <code>vbtable</code> 是虚基类表（Virtual Base Table）。</p><p><img data-src="../../../asset/2025/01/cplusplus-virtual-class.png"></p><h3 id="虚继承的类内存布局之二"><a href="#虚继承的类内存布局之二" class="headerlink" title="虚继承的类内存布局之二"></a>虚继承的类内存布局之二</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚基类（被虚继承的类称为虚基类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call A::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call B::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"size : "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(B) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A *a = new B();</span></span><br><span class="line">    <span class="comment">// a-&gt;show();       // 正常调用，发生动态绑定</span></span><br><span class="line">    <span class="comment">// delete a;        // 调用失败，异常终止执行，这是因为基类指针指向的是派生类中基类那部分数据的起始地址，导致无法正常释放堆上分配的内存空间</span></span><br><span class="line">    </span><br><span class="line">    B b;</span><br><span class="line">    A &amp;a = b;</span><br><span class="line">    b.<span class="built_in">show</span>();           <span class="comment">// 正常调用，发生动态绑定，且栈上分配的内存空间出了作用域之后可以正常被自动释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size : 32</span><br><span class="line">call B::show()</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 中查看上述 B 派生类的内存布局，可以得到以下结果；其中 <code>vbptr</code> 是虚基类指针（Virtual Base Ptr），而 <code>vbtable</code> 是虚基类表（Virtual Base Table）；<code>vptr</code> 是虚函数表指针（Virtual Function Ptr），<code>vtable</code> 是虚函数表（Virtual Function Table）。</p><p><img data-src="../../../asset/2025/01/cplusplus-virtual-class-2.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><p>基类指针（引用）指向派生类对象时，永远指向的是派生类中基类那部分数据的起始地址。</p></div><h2 id="菱形继承的问题"><a href="#菱形继承的问题" class="headerlink" title="菱形继承的问题"></a>菱形继承的问题</h2><h3 id="菱形继承的概念"><a href="#菱形继承的概念" class="headerlink" title="菱形继承的概念"></a>菱形继承的概念</h3><p>在 C++ 的多继承中，有一种特殊的继承结构，那就是菱形继承，如下图所示：</p><p><img data-src="../../../asset/2021/11/cplusplus-extends-17.png"></p><p>在 C++ 中，菱形继承会产生以下问题：</p><ul><li><strong>内存冗余问题</strong>：基类的内容被重复存储，占用额外内存。 </li><li><strong>成员重复问题</strong>：基类的成员在子类中会出现多份，导致访问不明确（存在二义性）。  </li><li><strong>构造与析构问题</strong>：基类的构造函数或析构函数可能被调用多次，导致不一致或意外行为。  </li><li><strong>多态冲突问题</strong>：虚函数可能产生不明确的调用，导致多态行为失效。  </li></ul><h3 id="菱形继承问题的产生"><a href="#菱形继承问题的产生" class="headerlink" title="菱形继承问题的产生"></a>菱形继承问题的产生</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> data) : <span class="built_in">ma</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> data) : <span class="built_in">A</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="keyword">int</span> data) : <span class="built_in">A</span>(data), <span class="built_in">mc</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"C()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">C</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~C()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="keyword">int</span> data) : <span class="built_in">B</span>(data), <span class="built_in">C</span>(data), <span class="built_in">md</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"D()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">D</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~D()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> md;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="comment">// d.ma;        // 错误写法，存在二义性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">A()</span><br><span class="line">C()</span><br><span class="line">D()</span><br><span class="line">~D()</span><br><span class="line">~C()</span><br><span class="line">~A()</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></tbody></table></figure><p>从上述的执行结果可以发现基类 A 被构造了两次，这执行效率是比较低的；而且派生类 D 无法正常访问基类 A 中的成员变量 <code>ma</code>，因为存在二义性。</p><h3 id="菱形继承问题的解决"><a href="#菱形继承问题的解决" class="headerlink" title="菱形继承问题的解决"></a>菱形继承问题的解决</h3><p>在 C++ 的多继承中，可以使用虚继承来解决菱形继承产生的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> data) : <span class="built_in">ma</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> data) : <span class="built_in">A</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="keyword">int</span> data) : <span class="built_in">A</span>(data), <span class="built_in">mc</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"C()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">C</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~C()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="keyword">int</span> data) : <span class="built_in">A</span>(data), <span class="built_in">B</span>(data), <span class="built_in">C</span>(data), <span class="built_in">md</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"D()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">D</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~D()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> md;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; d.ma &lt;&lt; endl;        <span class="comment">// 正确写法，不存在二义性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">C()</span><br><span class="line">D()</span><br><span class="line">20</span><br><span class="line">~D()</span><br><span class="line">~C()</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></tbody></table></figure><p>从上述的执行结果可以发现基类 A 只构造了一次，而且派生类 D 可以正常访问基类 A 中的成员变量 <code>ma</code>，因为不存在二义性。</p><h2 id="C-的四种类型转换"><a href="#C-的四种类型转换" class="headerlink" title="C++ 的四种类型转换"></a>C++ 的四种类型转换</h2><p>在 C++ 中，有以下 4 种类型转换：</p><ul><li><code>static_cast</code>：静态类型转换，如 <code>int</code> 转换成 <code>char</code></li><li><code>dynamic_cast</code>：动态类型转换，主要用在类的继承结构中，可以支持 RTTI 类型识别的上下类型转换，如父类和子类之间的多态类型转换</li><li><code>const_cast</code>：常量类型转换，用于赋予或者去除类型的 <code>const</code> 只读属性</li><li><code>reinterpreter_cast</code>：重新解释类型（强制类型转换）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device1</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device1::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device2</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device2::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device2::print()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(Base *base)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断 base 指针指向的是不是 Device2 对象</span></span><br><span class="line">    <span class="comment">// 如果是，则 dynamic_cast 转换成功，并返回 Device2 对象的地址，否则返回 nullptr</span></span><br><span class="line">    Device2 *pDevice2 = <span class="keyword">dynamic_cast</span>&lt;Device2 *&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (pDevice2 == <span class="literal">nullptr</span>) {</span><br><span class="line">        base-&gt;<span class="built_in">show</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        pDevice2-&gt;<span class="built_in">print</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const_cast：去掉常量属性的类型转换</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> * &gt; (&amp;a);</span><br><span class="line">    cout &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static_cast：提供编译器认为安全的类型转换</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">65</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(b);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reinterpret_cast：类似于 C 语言风格的类型转换</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt; (d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dynamic_cast：主要用在类的继承结构中，可以支持 RTTI 类型识别的上下类型转换</span></span><br><span class="line">    Device1 device1;</span><br><span class="line">    Device2 device2;</span><br><span class="line">    <span class="built_in">show</span>(&amp;device1);</span><br><span class="line">    <span class="built_in">show</span>(&amp;device2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">A</span><br><span class="line">call Device1::show()</span><br><span class="line">call Device2::print()</span><br></pre></td></tr></tbody></table></figure><h2 id="虚函数高频面试题"><a href="#虚函数高频面试题" class="headerlink" title="虚函数高频面试题"></a>虚函数高频面试题</h2><h3 id="虚函数高频面试题之一"><a href="#虚函数高频面试题之一" class="headerlink" title="虚函数高频面试题之一"></a>虚函数高频面试题之一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(string name) : _name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: miao miao"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: wang wang"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Animal *p1 = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">"Cat"</span>);</span><br><span class="line">    Animal *p2 = <span class="keyword">new</span> <span class="built_in">Dog</span>(<span class="string">"Dog"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p11 = (<span class="keyword">int</span> *) p1;  <span class="comment">// p11[0] 指向的是 Cat 的前 4 个字节（存放的是 vptr）</span></span><br><span class="line">    <span class="keyword">int</span> *p22 = (<span class="keyword">int</span> *) p2;  <span class="comment">// p22[0] 指向的是 Dog 的前 4 个字节（存放的是 vptr）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = p11[<span class="number">0</span>];   <span class="comment">// 交换两个对象的虚函数表指针（vptr）的地址</span></span><br><span class="line">    p11[<span class="number">0</span>] = p22[<span class="number">0</span>];</span><br><span class="line">    p22[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    p1-&gt;<span class="built_in">bark</span>();     <span class="comment">// p1 -&gt; Cat vptr -&gt; Dog vtable，输出：Cat bark: wang wang</span></span><br><span class="line">    p2-&gt;<span class="built_in">bark</span>();     <span class="comment">// p2 -&gt; Dog vptr -&gt; Cat vtable，输出：Dog bark: miao miao</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat bark: wang wang</span><br><span class="line">Dog bark: miao miao</span><br></pre></td></tr></tbody></table></figure><h3 id="虚函数高频面试题之二"><a href="#虚函数高频面试题之二" class="headerlink" title="虚函数高频面试题之二"></a>虚函数高频面试题之二</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i = <span class="number">10</span>)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Base::show i : "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i = <span class="number">20</span>)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device::show i : "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base *b = <span class="keyword">new</span> <span class="built_in">Device</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用，参数压栈是在编译时期决定的，因此这里参数压栈时使用的是基类中虚函数的默认参数值</span></span><br><span class="line">    <span class="comment">// 动态绑定，p -&gt; Device vptr -&gt; Device vtable -&gt; Device::show()，输出： call Device::show i : 10</span></span><br><span class="line">    b-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call Device::show i : 10</span><br></pre></td></tr></tbody></table></figure><h3 id="虚函数高频面试题之三"><a href="#虚函数高频面试题之三" class="headerlink" title="虚函数高频面试题之三"></a>虚函数高频面试题之三</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base *b = <span class="keyword">new</span> <span class="built_in">Device</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以正常调用，发生动态（运行时期）绑定，输出：call Device::show()</span></span><br><span class="line">    <span class="comment">// 成员函数能不能被调用，就是说函数的访问权限是不是 public，这是在编译阶段就需要确定好的，而动态绑定是发生在运行时期</span></span><br><span class="line">    b-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call Device::show()</span><br></pre></td></tr></tbody></table></figure><h3 id="虚函数高频面试题之四"><a href="#虚函数高频面试题之四" class="headerlink" title="虚函数高频面试题之四"></a>虚函数高频面试题之四</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Base()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 将当前对象的内存区域全部置为 0</span></span><br><span class="line">        <span class="comment">// 相当于当前对象内存中的 vptr 虚函数表指针被修改了，不再指向 vtable 虚函数表</span></span><br><span class="line">        <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base *bptr1 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    bptr1-&gt;<span class="built_in">show</span>();  <span class="comment">// 动态绑定，异常终止执行</span></span><br><span class="line">    <span class="keyword">delete</span> bptr1;</span><br><span class="line"></span><br><span class="line">    Base *bptr2 = <span class="keyword">new</span> <span class="built_in">Device</span>();</span><br><span class="line">    bptr2-&gt;<span class="built_in">show</span>();  <span class="comment">// 动态绑定，正常执行结束</span></span><br><span class="line">    <span class="keyword">delete</span> bptr2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之三</title>
    <link href="https://www.techgrow.cn/posts/3d7447d.html"/>
    <id>https://www.techgrow.cn/posts/3d7447d.html</id>
    <published>2024-12-05T13:55:33.000Z</published>
    <updated>2024-12-05T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><span id="more"></span><h3 id="二元运算符的重载"><a href="#二元运算符的重载" class="headerlink" title="二元运算符的重载"></a>二元运算符的重载</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CComplex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CComplex</span>(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> i = <span class="number">0</span>) : <span class="built_in">mreal</span>(r), <span class="built_in">mimage</span>(i) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在局部作用域加法运算符的重载函数</span></span><br><span class="line">    <span class="comment">// 这里不能返回引用，因为在栈上分配内存空间的对象，随着函数的运行结束，内存空间会自动释放</span></span><br><span class="line">    CComplex <span class="keyword">operator</span>+(<span class="keyword">const</span> CComplex &amp;other) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CComplex</span>(<span class="keyword">this</span>-&gt;mreal + other.mreal, <span class="keyword">this</span>-&gt;mimage + other.mimage);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用友元函数实现加法运算符的重载</span></span><br><span class="line">    <span class="keyword">friend</span> CComplex <span class="keyword">operator</span>+(<span class="keyword">const</span> CComplex &amp;left, <span class="keyword">const</span> CComplex &amp;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用友元函数实现左移运算符的重载</span></span><br><span class="line">    <span class="comment">// 左移运算符的重载只能使用友元函数来实现</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> CComplex &amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"mreal: "</span> &lt;&lt; mreal &lt;&lt; <span class="string">", mimage: "</span> &lt;&lt; mimage &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mreal;</span><br><span class="line">    <span class="keyword">int</span> mimage;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在全局作用域实现加法运算符的重载</span></span><br><span class="line">CComplex <span class="keyword">operator</span>+(<span class="keyword">const</span> CComplex &amp;left, <span class="keyword">const</span> CComplex &amp;right) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CComplex</span>(left.mreal + right.mreal, left.mimage + right.mimage);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在全局作用域实现左移运算符的重载</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> CComplex &amp;c) {</span><br><span class="line">    out &lt;&lt; <span class="string">"mreal: "</span> &lt;&lt; c.mreal &lt;&lt; <span class="string">", mimage: "</span> &lt;&lt; c.mimage &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CComplex <span class="title">c1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">CComplex <span class="title">c2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    CComplex c3 = c1 + c2;       <span class="comment">// 相当于 CComplex c3 = c1.operator+(c2);</span></span><br><span class="line">    c3.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    CComplex c4 = c1 + <span class="number">20</span>;      <span class="comment">// 默认可以正常编译运行，会自动调用 CComplex(int r = 0, int i = 0) 构造函数，然后再执行加法运算</span></span><br><span class="line">    c4.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器做对象运算的时候，会调用对象的运算符重载函数（优先调用成员方法）；如果没有成员方法，就会在全局作用域找合适的运算符重载函数。</span></span><br><span class="line">    CComplex c5 = <span class="number">30</span> + c1;      <span class="comment">// 默认不可以正常编译运行，除非是在全局作用域实现加法运算符的重载</span></span><br><span class="line">    c5.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c1 &lt;&lt; endl;     <span class="comment">// 左移运算符的重载</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mreal: 30, mimage: 30</span><br><span class="line">mreal: 30, mimage: 10</span><br><span class="line">mreal: 40, mimage: 10</span><br><span class="line">mreal: 10, mimage: 10</span><br></pre></td></tr></tbody></table></figure><h3 id="一元运算符的重载"><a href="#一元运算符的重载" class="headerlink" title="一元运算符的重载"></a>一元运算符的重载</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CComplex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CComplex</span>(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> i = <span class="number">0</span>) : <span class="built_in">mreal</span>(r), <span class="built_in">mimage</span>(i) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "前置++" 运算符的重载</span></span><br><span class="line">    CComplex &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">        <span class="keyword">this</span>-&gt;mreal++;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mimage++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "后置++" 运算符的重载</span></span><br><span class="line">    <span class="comment">// 使用占位参数进行函数重载，是为了解决与 "前置++" 类成员函数冲突的问题</span></span><br><span class="line">    CComplex <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CComplex</span>(<span class="keyword">this</span>-&gt;mreal++, <span class="keyword">this</span>-&gt;mimage++);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"mreal: "</span> &lt;&lt; mreal &lt;&lt; <span class="string">", mimage: "</span> &lt;&lt; mimage &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mreal;</span><br><span class="line">    <span class="keyword">int</span> mimage;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CComplex <span class="title">c1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置++</span></span><br><span class="line">    <span class="function">CComplex <span class="title">c2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    c2 = ++c1;</span><br><span class="line">    c1.<span class="built_in">print</span>();     <span class="comment">// 11 11</span></span><br><span class="line">    c2.<span class="built_in">print</span>();     <span class="comment">// 11 11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置++</span></span><br><span class="line">    <span class="function">CComplex <span class="title">c3</span><span class="params">(<span class="number">30</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    c3 = c1++;</span><br><span class="line">    c1.<span class="built_in">print</span>();     <span class="comment">// 12 12</span></span><br><span class="line">    c3.<span class="built_in">print</span>();     <span class="comment">// 11 11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mreal: 11, mimage: 11</span><br><span class="line">mreal: 11, mimage: 11</span><br><span class="line">mreal: 12, mimage: 12</span><br><span class="line">mreal: 11, mimage: 11</span><br></pre></td></tr></tbody></table></figure><h3 id="模拟实现字符串类"><a href="#模拟实现字符串类" class="headerlink" title="模拟实现字符串类"></a>模拟实现字符串类</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里模拟实现的字符串类，存在多次拷贝内存数据的问题，可以使用 C++ 提供的右值引用参数来解决，详细介绍请看 <a href="/posts/e302ad63.html#C-11-%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0">这里</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) &gt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) &lt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双等号运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中括号运算符重载（读写）</span></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">return</span> _pstr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中括号运算符重载（只读）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> _pstr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> length = <span class="built_in">strlen</span>(_pstr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空字符串</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 '\0' 结尾的字符串</span></span><br><span class="line">        <span class="keyword">if</span> (_pstr[length] == <span class="string">'\0'</span>) {</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不以 '\0' 结尾的字符串</span></span><br><span class="line">        <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 调用构造函数</span></span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"abcde"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用构造函数</span></span><br><span class="line">    MyString str2 = <span class="string">"fghij"</span>;</span><br><span class="line">    cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    MyString str3 = str2;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    str3 = str1;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    MyString str4 = str1 + str2;</span><br><span class="line">    cout &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> result1 = str1 &gt; str2;</span><br><span class="line">    cout &lt;&lt; (result1 ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> result2 = str1 &lt; str2;</span><br><span class="line">    cout &lt;&lt; (result2 ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双等号运算符重载</span></span><br><span class="line">    str1 = str2;</span><br><span class="line">    <span class="keyword">bool</span> result3 = str1 == str2;</span><br><span class="line">    cout &lt;&lt; (result3 ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中括号运算符重载</span></span><br><span class="line">    <span class="function">MyString <span class="title">str5</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">    str5[<span class="number">4</span>] = <span class="string">'k'</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"str5[3] = "</span> &lt;&lt; str5[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    <span class="function">MyString <span class="title">str6</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"str6.length = "</span> &lt;&lt; str6.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tmpstr = str6.<span class="built_in">c_str</span>();</span><br><span class="line">    cout &lt;&lt; tmpstr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br><span class="line">fghij</span><br><span class="line">fghij</span><br><span class="line">abcde</span><br><span class="line">abcdefghij</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">str5[3] = k</span><br><span class="line">str6.length = 5</span><br><span class="line">world</span><br></pre></td></tr></tbody></table></figure><h2 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h2><div class="admonition note"><p class="admonition-title">迭代器的介绍</p><ul><li>迭代器的功能是：提供一种统一的方式来透明地遍历容器。</li><li>泛型算法参数接收的都是选代器。</li><li>在泛型算法中，通常都有一个可以统一地遍历所有容器的元素的迭代器。</li></ul></div><h3 id="模拟实现字符串类的迭代器"><a href="#模拟实现字符串类的迭代器" class="headerlink" title="模拟实现字符串类的迭代器"></a>模拟实现字符串类的迭代器</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里模拟实现的字符串类，存在多次拷贝内存数据的问题，可以使用 C++ 提供的右值引用参数来解决，详细介绍请看 <a href="/posts/e302ad63.html#C-11-%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0">这里</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) &gt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) &lt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双等号运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中括号运算符重载（读写）</span></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">return</span> _pstr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中括号运算符重载（只读）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> _pstr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> length = <span class="built_in">strlen</span>(_pstr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空字符串</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 '\0' 结尾的字符串</span></span><br><span class="line">        <span class="keyword">if</span> (_pstr[length] == <span class="string">'\0'</span>) {</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不以 '\0' 结尾的字符串</span></span><br><span class="line">        <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">iterator</span>(<span class="keyword">char</span> *p = <span class="literal">nullptr</span>) : _p(p) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="keyword">return</span> _p != other._p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            _p++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_p++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        <span class="keyword">char</span> &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="keyword">return</span> *_p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span> *_p;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_pstr + <span class="built_in">length</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    MyString str1 = <span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span> (MyString::iterator it = str1.<span class="built_in">begin</span>(); it != str1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    MyString str2 = <span class="string">"Golang"</span>;</span><br><span class="line">    <span class="comment">// 使用 For 循环遍历字符串，会自动调用字符串类的 begin() 和 end() 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: str2) {</span><br><span class="line">        cout &lt;&lt; ch &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H e l l o   W o r l d </span><br><span class="line">G o l a n g </span><br></pre></td></tr></tbody></table></figure><h3 id="模拟实现-vector-容器的迭代器"><a href="#模拟实现-vector-容器的迭代器" class="headerlink" title="模拟实现 vector 容器的迭代器"></a>模拟实现 vector 容器的迭代器</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里模拟实现的 vector 容器，在插入数据时存在多次拷贝内存数据的问题，可以使用 C++ 提供的 <code>move</code> 移动语义或者 <code>forward</code> 类型完美转发来解决，详细介绍请看 <a href="/posts/e302ad63.html#C-11-%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">这里</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">iterator</span>(T *p = <span class="literal">nullptr</span>) : _ptr(p) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person(const Person &amp;p)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call ~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用中括号取值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"full: "</span> &lt;&lt; (v.<span class="built_in">full</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (v.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!v.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器插入元素</span></span><br><span class="line">    Vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器变遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (Vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 For 循环遍历容器，会自动调用容器类的 begin() 和 end() 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> item : v) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">99 75 54 4 58 27 46 64 65 99 85 32 85 0 27 36 56 10 59 8 </span><br><span class="line">size: 20</span><br><span class="line">full: true</span><br><span class="line">empty:  false</span><br><span class="line">8 59 10 56 36 27 0 85 32 85 99 65 64 46 27 58 4 54 75 99 </span><br><span class="line">============ test02() ============</span><br><span class="line">75 51 32 20 28 23 4 55 76 61 78 75 88 84 31 46 11 30 62 29 </span><br><span class="line">75 51 32 20 28 23 4 55 76 61 78 75 88 84 31 46 11 30 62 29 </span><br><span class="line">75 51 32 20 28 23 4 55 76 61 78 75 88 84 31 46 11 30 62 29 </span><br></pre></td></tr></tbody></table></figure><h3 id="模拟重现-vector-迭代器的失效"><a href="#模拟重现-vector-迭代器的失效" class="headerlink" title="模拟重现 vector 迭代器的失效"></a>模拟重现 vector 迭代器的失效</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里模拟实现的 vector 容器，在插入数据时存在多次拷贝内存数据的问题，可以使用 C++ 提供的 <code>move</code> 移动语义或者 <code>forward</code> 类型完美转发来解决，详细介绍请看 <a href="/posts/e302ad63.html#C-11-%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">这里</a>。</p></div><h4 id="迭代器失效问题的发生"><a href="#迭代器失效问题的发生" class="headerlink" title="迭代器失效问题的发生"></a>迭代器失效问题的发生</h4><ul><li>第一种迭代器失效的情况（容器删除元素），以下代码会异常终止运行 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的所有偶数删除掉</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 迭代器失效的问题：第一次调用 erase() 函数以后，迭代器 it 就已经失效了</span></span><br><span class="line">            <span class="comment">// 当容器调用 erase() 函数后，当前删除位置到容器尾元素的所有的选代器将全部失效，但是首元素到当前删除位置的所有的迭代器依旧是生效的</span></span><br><span class="line">            v.<span class="built_in">erase</span>(it);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第二种迭代器失效的情况（容器插入元素），以下代码会异常终止运行 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器中所有的偶数前面添加一个小于该偶数的数字</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 迭代器失效的问题：第一次调用 insert() 函数以后，迭代器 it 就已经失效了</span></span><br><span class="line">            <span class="comment">// 当容器调用 insert() 函数后，当前插入位置到容器尾元素的所有的选代器将全部失效，但是首元素到当前插入位置的所有的迭代器依旧是生效的</span></span><br><span class="line">            <span class="comment">// 一旦 insert() 函数的插入操作引起扩容，那么原来容器从首元素到尾元素的所有的选代器将全部失效</span></span><br><span class="line">            v.<span class="built_in">insert</span>(it, *it - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第三种迭代器失效的情况（容器触发扩容），当容器扩容后，原容器从首元素到尾元素的所有的选代器将全部失效。</li></ul><h4 id="迭代器失效问题的解决"><a href="#迭代器失效问题的解决" class="headerlink" title="迭代器失效问题的解决"></a>迭代器失效问题的解决</h4><h5 id="解决方案介绍"><a href="#解决方案介绍" class="headerlink" title="解决方案介绍"></a>解决方案介绍</h5><div class="admonition note"><p class="admonition-title">温馨提示</p><p>解决迭代器失效的问题，最关键是对插入点 / 删除点的迭代器执行更新操作。</p></div><ul><li>第一种迭代器失效的情况（容器删除元素），以下代码可以正常运行 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的所有偶数删除掉</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 更新迭代器</span></span><br><span class="line">            it = v.<span class="built_in">erase</span>(it);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第二种迭代器失效的情况（容器插入元素），以下代码可以正常运行 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器中所有的偶数前面添加一个小于该偶数的数字</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 更新迭代器</span></span><br><span class="line">            it = v.<span class="built_in">insert</span>(it, *it - <span class="number">1</span>);</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h5><p>为了解决迭代器失效的问题，可以在容器内部维护一个专门用于存放迭代器的单向链表数据结构，当往容器插入 / 删除元素时，对迭代器的单向链表进行维护。值得一提的是，以下代码是在 <a href="/posts/3d7447d.html#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-vector-%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">上面的案例代码</a> 的基础上改造而来，实现了 vector 容器的插入（暂时不考虑容器扩容）和删除操作。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt; *pvec = <span class="literal">nullptr</span>, T *p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base *itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt; *_pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T *p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T *p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator *cur = <span class="literal">nullptr</span>, Iterator_Base *next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator *_cur;</span><br><span class="line">        Iterator_Base *_next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T *start, T *end)</span> </span>{</span><br><span class="line">        Iterator_Base *cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base *next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person(const Person &amp;p)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call ~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器插入元素</span></span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的所有偶数删除掉</span></span><br><span class="line">    <span class="keyword">for</span> (Vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 更新迭代器</span></span><br><span class="line">            it = v.<span class="built_in">erase</span>(it);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 For 循环遍历容器，会自动调用容器类的 begin() 和 end() 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> item : v) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器插入元素</span></span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器中所有的偶数前面添加一个小于该偶数的数字</span></span><br><span class="line">    <span class="keyword">for</span> (Vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 更新迭代器</span></span><br><span class="line">            it = v.<span class="built_in">insert</span>(it, *it - <span class="number">1</span>);</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 For 循环遍历容器，会自动调用容器类的 begin() 和 end() 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> item : v) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">93 95 0 33 65 6 15 50 94 2 21 16 36 0 7 3 43 59 25 60 </span><br><span class="line">93 95 33 65 15 21 7 3 43 59 25 </span><br><span class="line">============ test02() ============</span><br><span class="line">67 86 10 44 87 27 47 53 79 60 66 24 7 67 58 24 25 73 27 19 </span><br><span class="line">67 85 86 9 10 43 44 87 27 47 53 79 59 60 65 66 23 24 7 67 57 58 23 24 25 73 27 19 </span><br></pre></td></tr></tbody></table></figure><h2 id="new-与-delete"><a href="#new-与-delete" class="headerlink" title="new 与 delete"></a>new 与 delete</h2><h3 id="malloc-与-new-的区别"><a href="#malloc-与-new-的区别" class="headerlink" title="malloc 与 new 的区别"></a>malloc 与 new 的区别</h3><p><code>malloc</code> 和 <code>new</code> 都用于在 C++ 中动态分配内存空间，但它们之间有本质的区别。</p><ul><li><strong>语法和用途</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>语法</td><td><code>void* ptr = malloc(size);</code></td><td><code>Type* ptr = new Type;</code></td></tr><tr><td>功能</td><td>仅按字节分配内存空间，不会调用构造函数。</td><td>按类型分配内存并调用对象的构造函数。</td></tr><tr><td>返回值</td><td>返回 <code>void*</code>，需要显式转换为目标类型指针。</td><td>返回指定类型的指针，无需显式转换。</td></tr></tbody></table><ul><li><strong>初始化</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>默认值</td><td>分配的内存未初始化，包含垃圾值。</td><td>基本类型未初始化，但类对象会调用构造函数进行初始化。</td></tr><tr><td>支持类型</td><td>通常适用于基本数据类型和简单内存块分配。</td><td>适用于类和复杂类型，支持构造函数调用。</td></tr></tbody></table><ul><li><strong>释放内存</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>释放方法</td><td>使用 <code>free(ptr);</code> 释放内存。</td><td>使用 <code>delete ptr;</code> 释放内存，并调用析构函数（如果有）。</td></tr><tr><td>析构函数调用</td><td>不会调用对象的析构函数。</td><td>自动调用对象的析构函数，进行清理操作。</td></tr></tbody></table><ul><li><strong>性能和类型安全</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>类型安全</td><td>无类型安全，需手动进行类型转换。</td><td>类型安全，无需手动类型转换。</td></tr><tr><td>性能</td><td>较低级，效率略高（无构造函数调用的情况下）。</td><td>高级，功能更强，但可能稍慢（有构造函数调用时）。</td></tr></tbody></table><ul><li><strong>支持数组分配</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>数组分配</td><td>手动计算所需字节数并分配：<code>int* arr = (int*) malloc(n * sizeof(int));</code></td><td>使用 <code>new[]</code>：<code>int* arr = new int[n];</code></td></tr><tr><td>释放数组</td><td>释放数组时，需用 <code>free(arr);</code></td><td>必须使用 <code>delete[] arr;</code>，否则可能导致内存泄漏或未调用析构函数。</td></tr></tbody></table><ul><li><strong>异常处理</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>失败行为</td><td>分配失败返回 <code>NULL</code>，需要手动检查返回值。</td><td>分配失败抛出 <code>std::bad_alloc</code> 异常（除非使用 <code>new (std::nothrow)</code>）。</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">适用场景</p><ul><li>使用 <code>malloc</code>：适合兼容 C 代码、分配简单内存块、不需要调用构造函数或析构函数的场景。</li><li>使用 <code>new</code>：适合 C++ 风格编程，需要调用构造和析构功能的场景，推荐在现代 C++ 中优先使用。</li></ul></div><div class="admonition note"><p class="admonition-title">温馨提示</p><ul><li>在现代 C++ 中，推荐使用智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>） 或 <code>std::vector</code> 等容器，减少手动管理内存的风险。</li></ul></div><h3 id="free-和-delete-的区别"><a href="#free-和-delete-的区别" class="headerlink" title="free 和 delete 的区别"></a>free 和 delete 的区别</h3><p><code>free</code> 和 <code>delete</code> 都用于释放动态分配的内存空间，但它们之间有本质的区别。</p><ul><li><strong>语法和用途</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>语法</td><td><code>free(ptr);</code></td><td><code>delete ptr;</code> 或 <code>delete[] ptr;</code></td></tr><tr><td>适用对象</td><td>与 <code>malloc</code> 和 <code>calloc</code> 搭配使用的内存。</td><td>与 <code>new</code> 或 <code>new[]</code> 分配的内存。</td></tr><tr><td>用途</td><td>释放动态分配的内存，不关心类型和构造函数。</td><td>释放动态分配的内存，同时调用析构函数（如果有）。</td></tr></tbody></table><ul><li><strong>析构函数调用</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>析构函数调用</td><td>不会调用析构函数，只释放内存。</td><td>自动调用对象的析构函数，完成清理操作后释放内存。</td></tr></tbody></table><ul><li><strong>数组支持</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>数组释放</td><td>没有专门的数组释放机制，需明确释放首地址。</td><td>对于数组，需要使用 <code>delete[]</code> 来正确释放并调用析构函数。</td></tr></tbody></table><ul><li><strong>异常处理</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>内存管理</td><td>手动管理，不与异常处理直接相关。</td><td>更安全，若内存释放过程中发生异常，析构函数可以处理。</td></tr></tbody></table><ul><li><strong>性能差异</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>性能开销</td><td>较低，不会进行类型检查或调用析构函数。</td><td>较高，涉及类型检查和析构函数调用。</td></tr></tbody></table><ul><li><strong>用法不当的后果</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>用法不当</td><td>释放 <code>new</code> 分配的内存可能会导致未定义行为。</td><td>释放 <code>malloc</code> 分配的内存可能会导致未定义行为。</td></tr><tr><td>未使用正确的形式</td><td>不会自动检测类型或数组。</td><td>使用 <code>delete</code> 而非 <code>delete[]</code> 释放数组，可能会导致部分内存泄漏或析构函数未调用。</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>对数组使用 <code>new[]</code> 分配内存时，必须用 <code>delete[]</code> 释放内存。</li><li><code>free</code> 和 <code>delete</code> 不能混用。<code>malloc</code> 分配的内存必须用 <code>free</code> 释放内存；<code>new</code> 分配的内存必须用 <code>delete</code> 释放内存。</li></ul></div><div class="admonition note"><p class="admonition-title">温馨提示</p><ul><li>在现代 C++ 中，推荐使用智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>） 或 <code>std::vector</code> 等容器，减少手动管理内存的风险。</li></ul></div><h3 id="重载-new-和-delete-运算符"><a href="#重载-new-和-delete-运算符" class="headerlink" title="重载 new 和 delete 运算符"></a>重载 new 和 delete 运算符</h3><p>当 C++ 内置的 <code>new</code> 和 <code>delete</code> 运算符不能满足业务需求时（比如需要实现自定义的内存池，或者需要检测内存泄漏），可以通过运算符重载来改变 <code>new</code> 和 <code>delete</code> 运算符的默认行为。示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 new 运算符，先调用 operator new 开辟内存空间，然后再调用对象的构造函数（初始化）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"operator new address: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 delete 运算符，先调用 ptr 指向对象的析构函数，然后再调用 operator delete 释放内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator delete address: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 new[] 运算符，先调用 operator new[] 开辟内存空间，然后再调用对象的构造函数（初始化）</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size) {</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"operator new[] address: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 delete[] 运算符，先调用 ptr 指向对象的析构函数，然后再调用 operator delete[] 释放内存空间</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *ptr) {</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator delete[] address: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : _data(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用重载后的 new 和 delete 运算符</span></span><br><span class="line">        <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    } <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc &amp;exception) {</span><br><span class="line">        cerr &lt;&lt; exception.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用重载后的 new[] 和 delete[] 运算符</span></span><br><span class="line">        <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    } <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc &amp;exception) {</span><br><span class="line">        cerr &lt;&lt; exception.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test03() ============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用重载后的 new 和 delete 运算符</span></span><br><span class="line">        Test *t = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">    } <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc &amp;exception) {</span><br><span class="line">        cerr &lt;&lt; exception.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test04() ============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用重载后的 new[] 和 delete[] 运算符</span></span><br><span class="line">        Test *t = <span class="keyword">new</span> Test[<span class="number">2</span>]();</span><br><span class="line">        <span class="keyword">delete</span>[] t;</span><br><span class="line">    } <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc &amp;exception) {</span><br><span class="line">        cerr &lt;&lt; exception.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">operator new address: 0x232fc20</span><br><span class="line">operator delete address: 0x232fc20</span><br><span class="line">============ test02() ============</span><br><span class="line">operator new[] address: 0x232fc40</span><br><span class="line">operator delete[] address: 0x232fc40</span><br><span class="line">============ test03() ============</span><br><span class="line">operator new address: 0x232fc20</span><br><span class="line">Test()</span><br><span class="line">~Test()</span><br><span class="line">operator delete address: 0x232fc20</span><br><span class="line">============ test04() ============</span><br><span class="line">operator new[] address: 0x232fc20</span><br><span class="line">Test()</span><br><span class="line">Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">operator delete[] address: 0x232fc20</span><br></pre></td></tr></tbody></table></figure><h3 id="通过运算符重载实现对象池"><a href="#通过运算符重载实现对象池" class="headerlink" title="通过运算符重载实现对象池"></a>通过运算符重载实现对象池</h3><p>这里将通过重载 <code>new</code> 和 <code>delete</code> 运算符来实现对象池，这样就可以避免为特定对象（如下面的 QueueItem）频繁开辟和释放内存空间，从而提高程序的运行效率。</p><div class="admonition note"><p class="admonition-title">C++ 的各种池对象</p><p>C++ 中常见的的池对象包括：内存池、对象池、进程池、线程池、连接池。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Queue()"</span> &lt;&lt; endl;</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">        _front = _rear = <span class="keyword">new</span> <span class="built_in">QueueItem</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Queue</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Queue()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span> (_front != <span class="literal">nullptr</span>) {</span><br><span class="line">            QueueItem *next = _front-&gt;_next;</span><br><span class="line">            <span class="keyword">delete</span> _front;</span><br><span class="line">            _front = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作（插入尾节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;value)</span> </span>{</span><br><span class="line">        QueueItem *item = <span class="keyword">new</span> <span class="built_in">QueueItem</span>(value);</span><br><span class="line">        _rear-&gt;_next = item;</span><br><span class="line">        _rear = item;</span><br><span class="line">        _size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作（移除头节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"Queue is empty, cannot pop"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        QueueItem *first = _front-&gt;_next;</span><br><span class="line">        _front-&gt;_next = first-&gt;_next;</span><br><span class="line">        <span class="keyword">if</span> (_front-&gt;_next == <span class="literal">nullptr</span>) {</span><br><span class="line">            _rear = _front;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">delete</span> first;</span><br><span class="line">        _size--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回头节点</span></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"Queue is empty"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _front-&gt;_next-&gt;_data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _front == _rear;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 队列元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueItem</span> {</span></span><br><span class="line">        <span class="built_in">QueueItem</span>(T data = <span class="built_in">T</span>()) : _data(data), _next(<span class="literal">nullptr</span>) {</span><br><span class="line"></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义 QueueItem 对象的内存开辟</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (_itemPool == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="comment">// 初始化对象池</span></span><br><span class="line">                _itemPool = (QueueItem *) <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in"><span class="keyword">sizeof</span></span>(QueueItem) * ITEM_POOL_SIZE];</span><br><span class="line">                QueueItem *p = _itemPool;</span><br><span class="line">                <span class="keyword">for</span> (; p &lt; _itemPool + ITEM_POOL_SIZE - <span class="number">1</span>; ++p) {</span><br><span class="line">                    p-&gt;_next = p + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 处理最后一个节点</span></span><br><span class="line">                p-&gt;_next = <span class="literal">nullptr</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            QueueItem *ptr = _itemPool;</span><br><span class="line">            _itemPool = _itemPool-&gt;_next;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义 QueueItem 对象的内存释放</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>{</span><br><span class="line">            <span class="comment">// 归还给对象池</span></span><br><span class="line">            QueueItem *p = (QueueItem *) ptr;</span><br><span class="line">            p-&gt;_next = _itemPool;</span><br><span class="line">            _itemPool = p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        T _data;                                    <span class="comment">// 当前节点的数据</span></span><br><span class="line">        QueueItem *_next;                           <span class="comment">// 下一个节点</span></span><br><span class="line">        <span class="keyword">static</span> QueueItem *_itemPool;                <span class="comment">// 指向对象池中未使用的第一节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> ITEM_POOL_SIZE = <span class="number">10000</span>;    <span class="comment">// 对象池的大小</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    QueueItem *_front;  <span class="comment">// 头结点，是一个虚拟节点，用于简化队列操作（如插入和删除）</span></span><br><span class="line">    QueueItem *_rear;   <span class="comment">// 尾节点，是一个真实节点，始终指向队列的最后一个有效节点，或者在队列为空时指向虚拟头节点</span></span><br><span class="line">    <span class="keyword">int</span> _size;          <span class="comment">// 队列的大小</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Queue&lt;T&gt;::QueueItem *Queue&lt;T&gt;::QueueItem::_itemPool = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> value = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        queue.<span class="built_in">push</span>(value);</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">"size = "</span> &lt;&lt; queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; queue.<span class="built_in">front</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">"size = "</span> &lt;&lt; queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这里不使用对象池，那么就会频繁开辟和释放对象的内存空间，导致性能消耗比较严重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> value = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        queue.<span class="built_in">push</span>(value);</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (queue.<span class="built_in">empty</span>() ? <span class="string">"empty"</span> : <span class="string">"not empty"</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">Queue()</span><br><span class="line">60 32 73 100 26 31 94 6 47 60 </span><br><span class="line">size = 10</span><br><span class="line">60 32 73 100 26 31 94 6 47 60 </span><br><span class="line">size = 0</span><br><span class="line">~Queue()</span><br><span class="line">============ test02() ============</span><br><span class="line">Queue()</span><br><span class="line">empty</span><br><span class="line">~Queue()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之二</title>
    <link href="https://www.techgrow.cn/posts/418bd270.html"/>
    <id>https://www.techgrow.cn/posts/418bd270.html</id>
    <published>2024-11-29T13:55:33.000Z</published>
    <updated>2024-11-29T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><h2 id="类、对象、指针"><a href="#类、对象、指针" class="headerlink" title="类、对象、指针"></a>类、对象、指针</h2><span id="more"></span><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NAME_LENGTH = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGoods</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CGoods</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">double</span> price, <span class="keyword">int</span> amount) {</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;_name, name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;_price = price;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_amount = amount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAmount</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_amount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>{</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;_name, name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;_price = price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAmount</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;_amount = amount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;_name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"price: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;_price &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"amount: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;_amount &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> _name[NAME_LENGTH]; <span class="comment">// 静态分配内存</span></span><br><span class="line">    <span class="keyword">double</span> _price;</span><br><span class="line">    <span class="keyword">int</span> _amount;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CGoods <span class="title">good</span><span class="params">(<span class="string">"Book"</span>, <span class="number">80</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    good.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name: Book</span><br><span class="line">price: 80</span><br><span class="line">amount: 3</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>类的成员函数一经编译，在所有函数的参数列表中，都会隐式自动添加一个 <code>this</code> 指针，用于接收调用该函数的对象的地址。这样在函数被调用时，C++ 才知道是谁调用了该函数。</p></div><h3 id="指向类成员的指针"><a href="#指向类成员的指针" class="headerlink" title="指向类成员的指针"></a>指向类成员的指针</h3><h4 id="指向类成员变量的指针"><a href="#指向类成员变量的指针" class="headerlink" title="指向类成员变量的指针"></a>指向类成员变量的指针</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类成员静态变量</span></span><br><span class="line"><span class="keyword">int</span> Test::mb = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    Test t1;    <span class="comment">// 栈上分配内存</span></span><br><span class="line">    Test *t2 = <span class="keyword">new</span> <span class="built_in">Test</span>();  <span class="comment">// 堆上分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误写法</span></span><br><span class="line">    <span class="comment">// int * p = &amp;Test::ma;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向类成员变量的指针</span></span><br><span class="line">    <span class="keyword">int</span> Test::*p = &amp;Test::ma;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问类成员变量</span></span><br><span class="line">    t1.*p = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; t1.ma &lt;&lt; <span class="string">", "</span> &lt;&lt; t1.*p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问类成员变量</span></span><br><span class="line">    t2-&gt;*p = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; t2-&gt;ma &lt;&lt; <span class="string">", "</span> &lt;&lt; t2-&gt;*p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> t2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 正确写法, 指向类成员静态变量的指针</span></span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;Test::mb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问类成员静态变量</span></span><br><span class="line">    *p1 = <span class="number">60</span>;</span><br><span class="line">    cout &lt;&lt; Test::mb &lt;&lt; <span class="string">", "</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20, 20</span><br><span class="line">30, 30</span><br><span class="line">60, 60</span><br></pre></td></tr></tbody></table></figure><h4 id="指向类成员函数的指针"><a href="#指向类成员函数的指针" class="headerlink" title="指向类成员函数的指针"></a>指向类成员函数的指针</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Test::func"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_func</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Test::static_func"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    Test t1;    <span class="comment">// 栈上分配内存</span></span><br><span class="line">    Test *t2 = <span class="keyword">new</span> <span class="built_in">Test</span>();  <span class="comment">// 堆上分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误写法</span></span><br><span class="line">    <span class="comment">// void (*pFunc)() = &amp;Test::func;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向类成员函数的指针（函数指针）</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (Test::*pFunc)() = &amp;Test::func;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用类成员函数</span></span><br><span class="line">    (t1.*pFunc)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用类成员函数</span></span><br><span class="line">    (t2-&gt;*pFunc)();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 正确写法, 指向类成员静态函数的指针（函数指针）</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*pStaticFunc)() = &amp;Test::static_func;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用类成员静态函数</span></span><br><span class="line">    (*pStaticFunc)();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call Test::func</span><br><span class="line">call Test::func</span><br><span class="line">call Test::static_func</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><ul><li>构造函数<ul><li>定义对象时，构造函数会自动调用。</li><li>构造函数是可以重载的，可以有多个构造函数。</li><li>对象构造完成后，对象就产生了。</li></ul></li><li>析构函数<ul><li>析构函数不带参数，不能重载，有且只有一个析构函数。</li><li>对象析构完成后，对象就不存在了。</li></ul></li><li>二者的共同点<ul><li>当开发者没有自定义构造函数和析构函数时，编译器会自动生成一个默认构造函数（无参构造函数）和默认析构函数。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>在栈上分配内存空间的 C++ 对象（比如 <code>SeqStack s;</code>），当该对象出了作用域之后（比如函数执行结束之后），C++ 会自动调用该对象的析构函数来释放内存空间。</li><li>在堆上分配内存空间的 C++ 对象（比如 <code>SeqStack *s = new SeqStack();</code>），那么必须在该对象出了作用域之前（比如函数执行结束之前），手动执行 <code>delete</code> 操作来释放内存空间，这样该对象的析构函数才会被调用。</li></ul></div><blockquote><p>下面将实现一个顺序栈的数据结构，并结合构造函数与析构函数一起使用。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call SeqStack()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        _pstatck = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        _top = <span class="number">-1</span>;</span><br><span class="line">        _size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SeqStack</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call ~SeqStack()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">if</span> (_pstatck != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] _pstatck;</span><br><span class="line">            _pstatck = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        _pstatck[++_top] = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        --_top;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstatck[_top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == _size - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *_pstatck; <span class="comment">// 动态开辟数组，存储顺序栈的元素</span></span><br><span class="line">    <span class="keyword">int</span> _top;   <span class="comment">// 指向栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> _size;  <span class="comment">// 数组的总大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 分配新的内存空间</span></span><br><span class="line">        <span class="keyword">int</span> *pnew = <span class="keyword">new</span> <span class="keyword">int</span>[_size * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) {</span><br><span class="line">            pnew[i] = _pstatck[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放旧的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstatck;</span><br><span class="line">        <span class="comment">// 指向新的内存空间</span></span><br><span class="line">        _pstatck = pnew;</span><br><span class="line">        _size *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"===== call test01() ====="</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">SeqStack <span class="title">s</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) {</span><br><span class="line">        s.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"===== call test02() ====="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    SeqStack *s = <span class="keyword">new</span> <span class="built_in">SeqStack</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) {</span><br><span class="line">        s-&gt;<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s-&gt;<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; s-&gt;<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        s-&gt;<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">===== call test01() =====</span><br><span class="line">call SeqStack()</span><br><span class="line">20 40 33 74 97 39 83 65 85 16 48 55 89 22 48 </span><br><span class="line">call ~SeqStack()</span><br><span class="line">===== call test02() =====</span><br><span class="line">call SeqStack()</span><br><span class="line">15 92 64 83 46 74 70 93 54 69 9 46 88 94 39 </span><br><span class="line">call ~SeqStack()</span><br></pre></td></tr></tbody></table></figure><h3 id="对象的深拷贝和浅拷贝"><a href="#对象的深拷贝和浅拷贝" class="headerlink" title="对象的深拷贝和浅拷贝"></a>对象的深拷贝和浅拷贝</h3><h4 id="使用案例一"><a href="#使用案例一" class="headerlink" title="使用案例一"></a>使用案例一</h4><p>下面将实现一个顺序栈的数据结构，并结合拷贝构造函数、深拷贝与赋值运算符重载一起使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call SeqStack()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        _pstatck = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        _top = <span class="number">-1</span>;</span><br><span class="line">        _size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SeqStack</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call ~SeqStack()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">if</span> (_pstatck != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] _pstatck;</span><br><span class="line">            _pstatck = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">const</span> SeqStack &amp;stack) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call SeqStack(const SeqStack &amp;stack)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝（重新分配内存）</span></span><br><span class="line">        _pstatck = <span class="keyword">new</span> <span class="keyword">int</span>[stack._size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack._size; i++) {</span><br><span class="line">            _pstatck[i] = stack._pstatck[i];</span><br><span class="line">        }</span><br><span class="line">        _top = stack._top;</span><br><span class="line">        _size = stack._size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运算符重载</span></span><br><span class="line">    SeqStack &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SeqStack &amp;stack) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call operator=(const SeqStack &amp;stack)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;stack) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来占用的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (_pstatck != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[]_pstatck;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝（重新分配内存）</span></span><br><span class="line">        _pstatck = <span class="keyword">new</span> <span class="keyword">int</span>[stack._size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack._size; i++) {</span><br><span class="line">            _pstatck[i] = stack._pstatck[i];</span><br><span class="line">        }</span><br><span class="line">        _top = stack._top;</span><br><span class="line">        _size = stack._size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        _pstatck[++_top] = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        --_top;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstatck[_top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == _size - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) {</span><br><span class="line">            cout &lt;&lt; _pstatck[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取元素数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *_pstatck; <span class="comment">// 动态开辟数组，存储顺序栈的元素</span></span><br><span class="line">    <span class="keyword">int</span> _top;   <span class="comment">// 指向栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> _size;  <span class="comment">// 数组的总大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 分配新的内存空间</span></span><br><span class="line">        <span class="keyword">int</span> *pnew = <span class="keyword">new</span> <span class="keyword">int</span>[_size * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) {</span><br><span class="line">            pnew[i] = _pstatck[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放旧的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstatck;</span><br><span class="line">        <span class="comment">// 指向新的内存空间</span></span><br><span class="line">        _pstatck = pnew;</span><br><span class="line">        _size *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">SeqStack <span class="title">s1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        s1.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    SeqStack s2 = s1;   <span class="comment">// 默认会调用拷贝构造函数</span></span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">SeqStack <span class="title">s3</span><span class="params">(s1)</span></span>;   <span class="comment">// 默认会调用拷贝构造函数</span></span><br><span class="line">    s3.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    s2 = s3;  <span class="comment">// 赋值运算，不会调用拷贝构造函数，默认是浅拷贝，会发生内存泄漏（内存没有被正确释放），解决办法是通过运算符重载来实现深拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call SeqStack()</span><br><span class="line">88 95 94 93 13 7 9 86 43 10 </span><br><span class="line">call SeqStack(const SeqStack &amp;stack)</span><br><span class="line">88 95 94 93 13 7 9 86 43 10 </span><br><span class="line">call SeqStack(const SeqStack &amp;stack)</span><br><span class="line">88 95 94 93 13 7 9 86 43 10 </span><br><span class="line">call operator=(const SeqStack &amp;stack)</span><br><span class="line">call ~SeqStack()</span><br><span class="line">call ~SeqStack()</span><br><span class="line">call ~SeqStack()</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例二"><a href="#使用案例二" class="headerlink" title="使用案例二"></a>使用案例二</h4><p>下面将实现一个循环队列的数据结构，并结合拷贝构造函数、深拷贝与赋值运算符重载一起使用。</p><ul><li><p>循环队列的关键特性：</p><ul><li><strong>队列特性：</strong> 循环队列仍然遵循 “先进先出”（FIFO）的原则。</li><li><strong>循环特性：</strong> 当队尾指针到达数组末尾时，如果队列未满，则可以循环到数组开头继续插入新元素。</li><li><strong>队空与队满条件：</strong> 为了区分队列是空还是满，循环队列通常会牺牲一个数组元素的存储空间：</li><li>队列为空的条件：<code>front == rear</code></li><li>队列为满的条件：<code>(rear + 1) % capacity == front</code></li></ul></li><li><p>循环队列的应用场景：</p><ul><li><strong>缓冲区</strong>：在生产者 / 消费者模型中用作环形缓冲区。</li><li><strong>流量控制</strong>：如网络数据包的接收缓冲区。</li><li><strong>任务调度</strong>：在任务管理系统中，存储循环调度任务。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>(<span class="keyword">int</span> size = <span class="number">20</span>) {</span><br><span class="line">        _pQueue = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        _front = <span class="number">0</span>;</span><br><span class="line">        _rear = <span class="number">0</span>;</span><br><span class="line">        _size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数，不让用户调用</span></span><br><span class="line">    <span class="comment">// MyQueue(const MyQueue &amp;other) = delete;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyQueue</span>(<span class="keyword">const</span> MyQueue &amp;other) {</span><br><span class="line">        _front = other._front;</span><br><span class="line">        _rear = other._rear;</span><br><span class="line">        _size = other._size;</span><br><span class="line">        _pQueue = <span class="keyword">new</span> <span class="keyword">int</span>[_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = _front; i != _rear; i = (i + <span class="number">1</span>) % _size) {</span><br><span class="line">            _pQueue[i] = other._pQueue[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符，不让用户调用</span></span><br><span class="line">    <span class="comment">// MyQueue &amp;operator=(const MyQueue &amp;other) = delete;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyQueue &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyQueue &amp;other) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_pQueue != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[]_pQueue;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        _front = other._front;</span><br><span class="line">        _rear = other._rear;</span><br><span class="line">        _size = other._size;</span><br><span class="line">        _pQueue = <span class="keyword">new</span> <span class="keyword">int</span>[_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = _front; i != _rear; i = (i + <span class="number">1</span>) % _size) {</span><br><span class="line">            _pQueue[i] = other._pQueue[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyQueue</span>() {</span><br><span class="line">        <span class="keyword">if</span> (_pQueue != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] _pQueue;</span><br><span class="line">            _pQueue = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        _pQueue[_rear] = value;</span><br><span class="line">        <span class="comment">// 循环队列</span></span><br><span class="line">        _rear = (_rear + <span class="number">1</span>) % _size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 循环队列</span></span><br><span class="line">        _front = (_front + <span class="number">1</span>) % _size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pQueue[_front];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列是否已满</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (_rear + <span class="number">1</span>) % _size == _front;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _front == _rear;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *_pQueue;   <span class="comment">// 队列的内存空间</span></span><br><span class="line">    <span class="keyword">int</span> _front;     <span class="comment">// 队头的位置</span></span><br><span class="line">    <span class="keyword">int</span> _rear;      <span class="comment">// 队尾的位置</span></span><br><span class="line">    <span class="keyword">int</span> _size;      <span class="comment">// 队列的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> *pTemp = <span class="keyword">new</span> <span class="keyword">int</span>[_size * <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = _front; i != _rear; i = (i + <span class="number">1</span>) % _size) {</span><br><span class="line">            pTemp[index++] = _pQueue[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">delete</span>[] _pQueue;</span><br><span class="line">        _pQueue = pTemp;</span><br><span class="line">        _size *= <span class="number">2</span>;</span><br><span class="line">        _front = <span class="number">0</span>;</span><br><span class="line">        _rear = index;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    MyQueue q1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="function">MyQueue <span class="title">q2</span><span class="params">(q1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyQueue q3;</span><br><span class="line">    q3 = q1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q3.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; q3.<span class="built_in">front</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        q3.<span class="built_in">poll</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">44 71 16 21 11 75 28 29 40 81 86 28 35 43 99 37 45 66 81 53</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDate</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 自定义一个构造函数，编译器不会再自动生成一个默认构造函数（无参构造函数）</span></span><br><span class="line">    <span class="built_in">CDate</span>(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day) {</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"year: "</span> &lt;&lt; _year &lt;&lt; <span class="string">", month: "</span> &lt;&lt; _month &lt;&lt; <span class="string">", day: "</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGoods</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用构造函数的初始化列表，可以指定当前对象的成员变量的初始化方式</span></span><br><span class="line">    <span class="built_in">CGoods</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> amount, <span class="keyword">double</span> price, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day) : _amount(amount), _price(price), _date(year, month, day) {</span><br><span class="line">        <span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; _name &lt;&lt; <span class="string">", amount: "</span> &lt;&lt; _amount &lt;&lt; <span class="string">", price: "</span> &lt;&lt; _price &lt;&lt; endl;</span><br><span class="line">        _date.<span class="built_in">show</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">char</span> _name[<span class="number">20</span>];  <span class="comment">// 静态分配内存</span></span><br><span class="line">    <span class="keyword">int</span> _amount;</span><br><span class="line">    <span class="keyword">double</span> _price;</span><br><span class="line">    CDate _date;    <span class="comment">// 成员对象</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CGoods <span class="title">goods</span><span class="params">(<span class="string">"Book"</span>, <span class="number">100</span>, <span class="number">59.9</span>, <span class="number">1949</span>, <span class="number">12</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line">    goods.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: Book, amount: 100, price: 59.9</span><br><span class="line">year: 1949, month: 12, day: 22</span><br></pre></td></tr></tbody></table></figure><blockquote><p>高频面试题</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : <span class="built_in">mb</span>(data), <span class="built_in">ma</span>(mb) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"ma: "</span> &lt;&lt; ma &lt;&lt; <span class="string">", mb: "</span> &lt;&lt; mb &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Test test;</span><br><span class="line">    test.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ma: -858993460, mb: 10</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>类成员变量的初始化顺序和它们定义的顺序有关，和构造函数初始化列表中定义的先后顺序无关，更多关于构造函数初始化列表的使用教程请看 <a href="/posts/beb2ebb3.html#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">这里</a>。</p></div><h2 id="类模板与函数模板"><a href="#类模板与函数模板" class="headerlink" title="类模板与函数模板"></a>类模板与函数模板</h2><h3 id="函数模板的使用"><a href="#函数模板的使用" class="headerlink" title="函数模板的使用"></a>函数模板的使用</h3><p>在 C++ 中，与函数模板相关的专业术语（知识点）有以下几个：</p><ul><li>函数模板</li><li>模板的实例化</li><li>模板函数</li><li>模板的类型参数</li><li>模板的非类型参数</li><li>模板的实参推演</li><li>模板的特例化（专用化）</li><li>非模板函数的重载关系</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>模板代码是不能在一个 <code>.cpp</code> 源文件中定义，然后在另一个 <code>.cpp</code> 源文件中使用的。</li><li>模板代码在调用之前，一定要看到模板定义的地方，这样模板才能够进行正常的实例化，产生能够被编译器编译的代码。所以，模板代码一般都是写在 <code>.h</code> 头文件中的，然后在 <code>.cpp</code> 源文件中使用 <code>#include</code> 指令将头文件包含进来。</li><li>另一种解决办法是，在调用模板函数之前，通过 <code>template bool compare&lt;int&gt;(int, int)</code> 告诉编译器，提前进行指定类型的模板实例化。</li></ul></div><h4 id="使用案例一-1"><a href="#使用案例一-1" class="headerlink" title="使用案例一"></a>使用案例一</h4><blockquote><p>函数模板的使用</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个模板参数列表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 定义一个函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"call compare(T a, T b)"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对 compare 函数模板，提供 const char* 类型的特例化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">bool</span> compare&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"call compare(const char *a, const char *b)"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数（非模板函数）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"call normal compare()"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在函数调用点，编译器会使用用户指定的类型，从原函数模板实例化一份函数代码出来（称为模板函数），如下所示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">bool compare&lt;int&gt; (int a, int b) {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">bool compare&lt;double&gt; (double a, double b) {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 函数的调用点</span></span><br><span class="line">    compare&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">    compare&lt;<span class="keyword">double</span>&gt;(<span class="number">1.3</span>, <span class="number">4.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数模板的实参推演</span></span><br><span class="line">    <span class="built_in">compare</span>(<span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器优先将 compare 处理成普通函数，如果函数不存在，才会去找 compare 模板函数</span></span><br><span class="line">    <span class="built_in">compare</span>(<span class="string">"abc"</span>, <span class="string">"efg"</span>);</span><br><span class="line">    compare&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(<span class="string">"abc"</span>, <span class="string">"efg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call compare(T a, T b)</span><br><span class="line">call compare(T a, T b)</span><br><span class="line">call compare(T a, T b)</span><br><span class="line">call normal compare()</span><br><span class="line">call compare(const char *a, const char *b)</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例二-1"><a href="#使用案例二-1" class="headerlink" title="使用案例二"></a>使用案例二</h4><blockquote><p>模板的非类型参数使用</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="comment">// 使用模板的非类型参数（必须是整数类型，整数或者地址/引用都可以），非类型参数都是常量，只能使用，不能修改</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> SIZE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T *array)</span> </span>{</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SIZE - <span class="number">1</span> - i; j++) {</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> array[] = {<span class="number">12</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">63</span>};</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(array) / <span class="built_in"><span class="keyword">sizeof</span></span>(array[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    sort&lt;<span class="keyword">int</span>, size&gt;(array);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> item: array) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 9 12 15 23 63 </span><br></pre></td></tr></tbody></table></figure><h3 id="类模板的使用"><a href="#类模板的使用" class="headerlink" title="类模板的使用"></a>类模板的使用</h3><h4 id="使用案例一-2"><a href="#使用案例一-2" class="headerlink" title="使用案例一"></a>使用案例一</h4><blockquote><p>类模板的使用</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建议构造和析构函数的名称不加 &lt;T&gt;，而且其他使用模板的地方都加上类型参数类列表，比如 &lt;T&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">int</span> size = <span class="number">10</span>) : _pstatck(<span class="keyword">new</span> T[size]), _top(<span class="number">-1</span>), _size(size) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SeqStack</span>() {</span><br><span class="line">        <span class="keyword">if</span> (_pstatck != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[]_pstatck;</span><br><span class="line">            _pstatck = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">const</span> SeqStack&lt;T&gt; &amp;stack) : _top(stack._top), _size(stack._size) {</span><br><span class="line">        <span class="comment">// 实现深拷贝</span></span><br><span class="line">        _pstatck = <span class="keyword">new</span> T[_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _top; i++) {</span><br><span class="line">            _pstatck[i] = stack._pstatck[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    SeqStack&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SeqStack&lt;T&gt; &amp;stack) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == stack) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (_pstatck != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[]_pstatck;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现深拷贝</span></span><br><span class="line">        _top = stack._top;</span><br><span class="line">        _size = stack._size;</span><br><span class="line">        _pstatck = <span class="keyword">new</span> T[_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _top; i++) {</span><br><span class="line">            _pstatck[i] = stack._pstatck[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        _pstatck[++_top] = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            --_top;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"stack is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _pstatck[_top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == _size - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    T *_pstatck; <span class="comment">// 动态开辟数组，存储顺序栈的元素</span></span><br><span class="line">    <span class="keyword">int</span> _top;    <span class="comment">// 指向栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> _size;   <span class="comment">// 数组的总大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        T *ptmp = <span class="keyword">new</span> T[_size * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _top; i++) {</span><br><span class="line">            ptmp[i] = _pstatck[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">delete</span>[]_pstatck;</span><br><span class="line">        _pstatck = ptmp;</span><br><span class="line">        _size *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类模板的选择性实例化</span></span><br><span class="line">    <span class="comment">// 实例化后的模板类 class SeqStack&lt;int&gt; { };</span></span><br><span class="line">    SeqStack&lt;<span class="keyword">int</span>&gt; stack;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        stack.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; stack.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 68 25 5 53 1 20 71 3 7 0 99 2 74 78 99 92 30 24 40</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例二-2"><a href="#使用案例二-2" class="headerlink" title="使用案例二"></a>使用案例二</h4><blockquote><p>类模板的默认类型参数使用</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类模板（使用默认类型参数）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">int</span>&gt;</span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line">class SeqStack {</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>() {</span><br><span class="line">    <span class="comment">// 使用默认类型参数</span></span><br><span class="line">    SeqStack&lt;&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例三"><a href="#使用案例三" class="headerlink" title="使用案例三"></a>使用案例三</h4><blockquote><p>使用类模板实现向量容器（Vector）</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyVector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        _first = <span class="keyword">new</span> T[size];</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyVector</span>() {</span><br><span class="line">        <span class="keyword">if</span> (_first != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] _first;</span><br><span class="line">            _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyVector</span>(<span class="keyword">const</span> MyVector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _first = <span class="keyword">new</span> T[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _first[i] = v._first[i];</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyVector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyVector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (_first != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] _first;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _first = <span class="keyword">new</span> T[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _first[i] = v._first[i];</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        *_last++ = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            --_last;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"MyVector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        T *_ptemp = <span class="keyword">new</span> T[size * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _ptemp[i] = _first[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _first;</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    MyVector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"full: "</span> &lt;&lt; (v.<span class="built_in">full</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (v.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!v.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">49 32 50 26 17 87 26 65 49 83 36 57 97 61 25 44 84 23 41 35 </span><br><span class="line">size: 20</span><br><span class="line">full: true</span><br><span class="line">empty:  false</span><br><span class="line">35 41 23 84 44 25 61 97 57 36 83 49 65 26 87 17 26 50 32 49 </span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>上述代码实现的 vector 容器，如果存放的是 Peson 类的对象，那么在容器初始化的时候，默认会调用 10 次 Peson 类的构造函数，因为在容器的构造函数中使用了 <code>new</code> 操作，比如 <code>_first = new T[size]</code>。</li><li>上述代码实现的 vector 容器，如果存放的是 Peson 类的对象，当调用 <code>pop_back()</code> 函数来删除容器尾部的元素时，Person 对象所占用的内存空间并没有被释放，这存在内存泄漏问题。</li><li>解决内存泄漏的方法可以参考 C++ STL 中的 vector 容器的实现，也就是使用空间配置器（allocator）来解决，空间配置器负责做四件事情，包括：内存开辟、内存释放、对象构造、对象析构。</li></ul></div><blockquote><p>使用空间分配器优化后的代码（重点知识）</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyAllocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span> (p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = MyAllocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class MyVector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyVector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">MyVector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyVector</span>(<span class="keyword">const</span> MyVector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyVector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyVector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"MyVector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person(const Person &amp;p)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call ~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============= test01() ============="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    MyVector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"full: "</span> &lt;&lt; (v.<span class="built_in">full</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (v.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!v.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n\n============= test02() ============="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person p1, p2, p3;</span><br><span class="line">    cout &lt;&lt; <span class="string">"------------------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    MyVector&lt;Person&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    cout &lt;&lt; <span class="string">"------------------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"------------------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">============= test01() =============</span><br><span class="line">44 60 71 5 8 44 58 52 73 97 20 21 0 10 28 44 94 81 54 82 </span><br><span class="line">size: 20</span><br><span class="line">full: true</span><br><span class="line">empty:  false</span><br><span class="line">82 54 81 94 44 28 10 0 21 20 97 73 52 58 44 8 5 71 60 44 </span><br><span class="line"></span><br><span class="line">============= test02() =============</span><br><span class="line">call Person()</span><br><span class="line">call Person()</span><br><span class="line">call Person()</span><br><span class="line">------------------------------------------</span><br><span class="line">call Person(const Person &amp;p)</span><br><span class="line">call Person(const Person &amp;p)</span><br><span class="line">call Person(const Person &amp;p)</span><br><span class="line">------------------------------------------</span><br><span class="line">call ~Person()</span><br><span class="line">------------------------------------------</span><br><span class="line">call ~Person()</span><br><span class="line">call ~Person()</span><br><span class="line">call ~Person()</span><br><span class="line">call ~Person()</span><br><span class="line">call ~Person()</span><br></pre></td></tr></tbody></table></figure><h3 id="模板特例化的使用"><a href="#模板特例化的使用" class="headerlink" title="模板特例化的使用"></a>模板特例化的使用</h3><h4 id="模板特例化的两种类型"><a href="#模板特例化的两种类型" class="headerlink" title="模板特例化的两种类型"></a>模板特例化的两种类型</h4><p>在 C++ 中，模板特例化有两种类型，包括模板完全特例化（Full Specialization）和模板部分特例化（Partial Specialization），两者都是对模板（包括函数模板和类模板）进行特定处理的方式。它们的主要区别在于对模板参数的控制程度不一样。</p><ul><li><p>模板完全特例化</p><ul><li>完全特例化是指针对某个特定的模板参数组合，提供完全定制的实现。特例化版本不会使用泛型模板的代码，而是使用特化版本的实现。</li><li>需要使用 <code>template&lt;&gt;</code> 语法，因为完全特例化没有泛型参数。</li><li>针对特定类型提供完全不同的实现，和原始模板无关。</li></ul></li><li><p>模板部分特例化</p><ul><li>部分特例化是指保留部分模板参数的泛型性，仅对某些参数的特定情况进行特化。部分特例化仍然依赖于原始模板的框架，但可以对部分参数提供不同的实现。</li><li>仍然使用 <code>template&lt;...&gt;</code> 语法，但部分参数被具体化，其他参数仍保持泛型性。</li><li>允许对部分模板参数进行特化，而不影响其他参数。</li></ul></li></ul><blockquote><p>模板完全特例化与模板部分特例化的对比总结</p></blockquote><table><thead><tr><th>比较项</th><th>模板完全特例化</th><th>模板部分特例化</th></tr></thead><tbody><tr><td>作用</td><td>针对某个特定类型组合提供完整的实现</td><td>仅对部分模板参数提供特化实现</td></tr><tr><td>泛型性</td><td>没有泛型参数，完全具体化</td><td>仍然保留部分泛型参数</td></tr><tr><td>语法</td><td><code>template&lt;&gt; class Test&lt;int&gt; {...}</code></td><td><code>template&lt;typename T2&gt; class Test&lt;int, T2&gt; {...}</code></td></tr><tr><td>影响范围</td><td>仅适用于特定类型</td><td>适用于一类特殊情况</td></tr></tbody></table><h4 id="为什么需要模板特例化"><a href="#为什么需要模板特例化" class="headerlink" title="为什么需要模板特例化"></a>为什么需要模板特例化</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"template compare"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板完全特例化（实现字符串比较）</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">bool</span> compare&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"string template compare"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(s1, s2) &gt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不使用模板特例化，这里默认只会简单比较字符串指针的地址，并不符合预期行为</span></span><br><span class="line">    <span class="built_in">compare</span>(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template compare</span><br><span class="line">string template compare</span><br></pre></td></tr></tbody></table></figure><h4 id="模板完全特例化的使用"><a href="#模板完全特例化的使用" class="headerlink" title="模板完全特例化的使用"></a>模板完全特例化的使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyVector</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyVector init"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板完全特例化</span></span><br><span class="line"><span class="comment">// 针对 char * 类型提供完全特例化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span>&lt;</span><span class="keyword">char</span> *&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyVector</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyVector&lt;char *&gt; init"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    MyVector&lt;<span class="keyword">int</span>&gt; vec1;</span><br><span class="line">    MyVector&lt;<span class="keyword">char</span> *&gt; vec2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyVector init</span><br><span class="line">MyVector&lt;char *&gt; init</span><br></pre></td></tr></tbody></table></figure><h4 id="模板部分特例化的使用"><a href="#模板部分特例化的使用" class="headerlink" title="模板部分特例化的使用"></a>模板部分特例化的使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyVector</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyVector init"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板部分特例化</span></span><br><span class="line"><span class="comment">// 针对指针类型提供部分特例化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span>&lt;</span>Ty *&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyVector</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyVector&lt;Ty *&gt; init"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板部分特例化</span></span><br><span class="line"><span class="comment">// 针对函数（有返回值，有两个参数）类型提供部分特例化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span>&lt;</span><span class="built_in">R</span>(A1, A2)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyVector</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyVector&lt;R(A1, A2)&gt; init"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板部分特例化</span></span><br><span class="line"><span class="comment">// 针对函数指针（有返回值，有两个参数）类型提供部分特例化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span>&lt;</span><span class="built_in">R</span>(*)(A1, A2)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyVector</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyVector&lt;R(*)(A1, A2) init"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    MyVector&lt;<span class="keyword">int</span>&gt; vec1;</span><br><span class="line">    MyVector&lt;<span class="keyword">int</span> *&gt; vec3;</span><br><span class="line">    MyVector&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; vec4;</span><br><span class="line">    MyVector&lt;<span class="built_in"><span class="keyword">int</span></span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; vec5;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyVector init</span><br><span class="line">MyVector&lt;Ty *&gt; init</span><br><span class="line">MyVector&lt;R(A1, A2)&gt; init</span><br><span class="line">MyVector&lt;R(*)(A1, A2) init</span><br></pre></td></tr></tbody></table></figure><h3 id="模板的实参推演"><a href="#模板的实参推演" class="headerlink" title="模板的实参推演"></a>模板的实参推演</h3><h4 id="模板实参推演的概念"><a href="#模板实参推演的概念" class="headerlink" title="模板实参推演的概念"></a>模板实参推演的概念</h4><p>C++ 模板实参推演（Template Argument Deduction）是指在使用函数模板或类模板时，编译器根据提供的实参自动推导（而非手动指定）模板参数的过程。</p><h4 id="模板实参推演的特性"><a href="#模板实参推演的特性" class="headerlink" title="模板实参推演的特性"></a>模板实参推演的特性</h4><ul><li>当调用函数模板时，编译器会根据传入的实参类型，推导出对应的模板参数。例如：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T x)</span> </span>{ }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">42</span>);      <span class="comment">// T 被推演为 int 类型，无需显式指定 func&lt;int&gt;(42)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);    <span class="comment">// T 被推演为 double 类型，无需显式指定 func&lt;double&gt;(3.14)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在 C++ 17 之前，类模板不支持类型自动推导，必须显式指定模板参数：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(T val) { }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Box&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// C++ 17 之前需要显式指定 Box&lt;int&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>从 C++ 17 开始，类模板也支持类型自动推导：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(T val) { }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Box <span class="title">b</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// C++ 17 可以自动推导为 Box&lt;int&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="模板实参推演的理解"><a href="#模板实参推演的理解" class="headerlink" title="模板实参推演的理解"></a>模板实参推演的理解</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FUNCTION_SIGNATURE __PRETTY_FUNCTION__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_WIN32)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FUNCTION_SIGNATURE __FUNCSIG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板的实参推演</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T a)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"func =&gt; "</span> &lt;&lt; FUNCTION_SIGNATURE &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(R (*)(A1, A2))</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"func2 =&gt; "</span> &lt;&lt; FUNCTION_SIGNATURE &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(R (T::*)(A1, A2))</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"func3 =&gt; "</span> &lt;&lt; FUNCTION_SIGNATURE &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">"aaa"</span>);</span><br><span class="line">    <span class="built_in">func</span>(sum);</span><br><span class="line">    <span class="built_in">func2</span>(sum);</span><br><span class="line">    <span class="built_in">func3</span>(&amp;Test::sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Linux 平台，程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func =&gt; void func(T) [with T = int]</span><br><span class="line">func =&gt; void func(T) [with T = const char*]</span><br><span class="line">func =&gt; void func(T) [with T = int (*)(int, int)]</span><br><span class="line">func2 =&gt; void func2(R (*)(A1, A2)) [with R = int; A1 = int; A2 = int]</span><br><span class="line">func3 =&gt; void func3(R (T::*)(A1, A2)) [with R = int; T = Test; A1 = int; A2 = int]</span><br></pre></td></tr></tbody></table></figure><p>在 Windows 平台，程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func =&gt; void __cdecl func&lt;int&gt;(int)</span><br><span class="line">func =&gt; void __cdecl func&lt;const char*&gt;(const char *)</span><br><span class="line">func =&gt; void __cdecl func&lt;int(__cdecl *)(int,int)&gt;(int (__cdecl *)(int,int))</span><br><span class="line">func2 =&gt; void __cdecl func2&lt;int,int,int&gt;(int (__cdecl *)(int,int))</span><br><span class="line">func3 =&gt; void __cdecl func3&lt;int,class Test,int,int&gt;(int (__cdecl Test::* )(int,int))</span><br></pre></td></tr></tbody></table></figure><h4 id="影响模板实参推演的因素"><a href="#影响模板实参推演的因素" class="headerlink" title="影响模板实参推演的因素"></a>影响模板实参推演的因素</h4><h5 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h5><ul><li>数组实参会被退化为指针 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T x)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="built_in">func</span>(arr);  <span class="comment">// T 被推演为 int*（数组退化）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>若希望保持数组类型，可以使用模板参数 <code>T&amp;</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; x)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="built_in">func</span>(arr);  <span class="comment">// T 被推演为 int[5]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="传值和传引用"><a href="#传值和传引用" class="headerlink" title="传值和传引用"></a>传值和传引用</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; x)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a);  <span class="comment">// T 被推演为 int</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>);  <span class="comment">// 错误写法：5 是右值，无法绑定到 T&amp;（左值引用）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解决方案：使用右值引用（通用引用）<code>T&amp;&amp;</code> 适配左值和右值：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; x)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);  <span class="comment">// T 推演为 int（右值）</span></span><br><span class="line"><span class="built_in">func</span>(a);   <span class="comment">// T 推演为 int&amp;（左值）</span></span><br></pre></td></tr></tbody></table></figure><h5 id="const-和-volatile-修饰符"><a href="#const-和-volatile-修饰符" class="headerlink" title="const 和 volatile 修饰符"></a>const 和 volatile 修饰符</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T x)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a);  <span class="comment">// T 推演为 int（const 被忽略）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>若希望保留 <code>const</code> 或者 <code>volatile</code> 信息，可以使用模板参数 <code>const T&amp;</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a);  <span class="comment">// T 推演为 int，参数类型保持 const int&amp;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
</feed>
